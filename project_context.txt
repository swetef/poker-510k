Project Context Generated at 2025/12/17 16:37:44


================================================================================
FILE PATH: client\eslint.config.js
================================================================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])


================================================================================
FILE PATH: client\index.html
================================================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    
    <!-- [å…³é”®ä¿®æ”¹] å¢åŠ  viewport-fit=cover è§£å†³é¡¶éƒ¨é»‘è¾¹é—®é¢˜ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    
    <link rel="manifest" href="/manifest.json">
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="510Kå¯¹æˆ˜">
    
    <title>client</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

================================================================================
FILE PATH: client\package.json
================================================================================
{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "lucide-react": "^0.559.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "socket.io-client": "^4.8.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "vite": "npm:rolldown-vite@7.2.5"
  },
  "overrides": {
    "vite": "npm:rolldown-vite@7.2.5"
  }
}


================================================================================
FILE PATH: client\src\App.css
================================================================================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}


================================================================================
FILE PATH: client\src\App.jsx
================================================================================
import React, { useState, useEffect, useRef } from 'react';
import io from 'socket.io-client';
import { Smartphone } from 'lucide-react'; 

import { sortHand } from './utils/cardLogic.js';
import SoundManager from './utils/SoundManager.js';
import { LoginScreen } from './screens/LoginScreen.jsx';
import { LobbyScreen } from './screens/LobbyScreen.jsx';
import { GameScreen } from './screens/GameScreen.jsx';

const getSocketUrl = () => {
    const { hostname, protocol } = window.location;
    const isLocal = hostname === 'localhost' || 
                    hostname === '127.0.0.1' || 
                    hostname.startsWith('192.168.') || 
                    hostname.startsWith('10.');
    if (isLocal) {
        return `${protocol}//${hostname}:3001`;
    }
    return '/';
};

const SOCKET_URL = getSocketUrl();

export default function App() {
  const [gameState, setGameState] = useState('LOGIN'); 
  const [username, setUsername] = useState('');
  const [roomId, setRoomId] = useState('');
  
  // [ä¿®æ”¹] å¢åŠ  isTeamMode: false é»˜è®¤å€¼
  const [roomConfig, setRoomConfig] = useState({ 
      deckCount: 2,          
      maxPlayers: 4,         
      targetScore: 1000,     
      turnTimeout: 60000,
      enableRankPenalty: false,    
      rankPenaltyScores: [30, 15],
      showCardCountMode: 1, // é»˜è®¤ï¼šå°‘äº3å¼ æ˜¾ç¤º
      isTeamMode: false     // [æ–°å¢] ç»„é˜Ÿæ¨¡å¼
  });
  
  const [isCreatorMode, setIsCreatorMode] = useState(false); 

  const [players, setPlayers] = useState([]);     
  const [myHand, setMyHand] = useState([]);       
  const [selectedCards, setSelectedCards] = useState([]); 
  const [lastPlayed, setLastPlayed] = useState([]); 
  const [currentTurnId, setCurrentTurnId] = useState(null); 
  const [lastPlayerName, setLastPlayerName] = useState(''); 
  const [infoMessage, setInfoMessage] = useState(''); 
  
  const [roundResult, setRoundResult] = useState(null); 
  const [grandResult, setGrandResult] = useState(null); 
  const [playerScores, setPlayerScores] = useState({});
  const [playersInfo, setPlayersInfo] = useState({});
  const [finishedRank, setFinishedRank] = useState([]); 
  
  const [pendingPoints, setPendingPoints] = useState(0);
  const [gameLogs, setGameLogs] = useState([]);

  const [sortMode, setSortMode] = useState('POINT'); 
  const [isConnected, setIsConnected] = useState(false); 
  const [mySocketId, setMySocketId] = useState(null);
  const [isLoading, setIsLoading] = useState(false);

  const [turnRemaining, setTurnRemaining] = useState(60); 

  // ç”¨äºå­˜å‚¨æ¯ä¸ªç©å®¶çš„å‰©ä½™ç‰Œæ•°
  const [handCounts, setHandCounts] = useState({});

  const socketRef = useRef(null);
  const isDragging = useRef(false); 
  const dragStartMode = useRef(true); 
  const sortModeRef = useRef('POINT');
  const usernameRef = useRef(username); 
  const mySocketIdRef = useRef(null);   

  useEffect(() => { usernameRef.current = username; }, [username]);
  useEffect(() => { mySocketIdRef.current = mySocketId; }, [mySocketId]);

  useEffect(() => {
    console.log(`æ­£åœ¨è¿æ¥æœåŠ¡å™¨: ${SOCKET_URL}`);
    
    const socket = io(SOCKET_URL, { 
        reconnectionAttempts: 10,   
        reconnectionDelay: 1000,    
        timeout: 20000,             
        transports: ['websocket', 'polling'] 
    });
    
    socketRef.current = socket;

    const initAudio = () => {
        SoundManager.init();
        window.removeEventListener('click', initAudio);
    };
    window.addEventListener('click', initAudio);

    socket.on('connect', () => {
        console.log("Socket è¿æ¥æˆåŠŸ!");
        setIsConnected(true); 
    });
    
    socket.on('disconnect', () => {
        console.log("Socket æ–­å¼€è¿æ¥");
        setIsConnected(false); 
    });
    
    socket.on('connect_error', (err) => {
        console.warn("è¿æ¥é”™è¯¯:", err);
    });

    socket.on('your_id', (id) => {
        setMySocketId(id);
        mySocketIdRef.current = id;
    });
    socket.on('error_msg', (msg) => { setIsLoading(false); alert(msg); });

    socket.on('room_info', (data) => {
        setRoomId(data.roomId);
        setRoomConfig(data.config);
        setPlayers(data.players);
        setGameState('LOBBY'); 
        setIsLoading(false);
    });

    socket.on('game_started', (data) => {
        if (data.hand) {
            setMyHand(sortHand(data.hand, sortModeRef.current));
        }
        setLastPlayed([]);
        setRoundResult(null);
        setGrandResult(null);
        setPendingPoints(0);
        setFinishedRank([]); 
        if (data.grandScores) setPlayerScores(data.grandScores);
        setGameLogs(prev => [...prev, { time: new Date().toLocaleTimeString(), text: 'ğŸ æ–°ä¸€å±€å¼€å§‹ï¼' }]); 
        setGameState('GAME');
        setTurnRemaining(60);
        setPlayersInfo({});
        // åˆå§‹ç‰Œæ•°
        if (data.handCounts) setHandCounts(data.handCounts);
        SoundManager.play('deal');
    });

    socket.on('game_state_update', (data) => {
        setCurrentTurnId(data.currentTurnId);
        
        if (data.turnRemaining !== undefined) {
             setTurnRemaining(data.turnRemaining);
        }

        if (data.lastPlayed && data.lastPlayed.length > 0) {
             SoundManager.play('play'); 
        }

        if (data.lastPlayed) setLastPlayed(sortHand(data.lastPlayed, sortModeRef.current));
        setLastPlayerName(data.lastPlayerName || '');
        
        if (data.infoText && data.infoText !== 'PASS') {
            setInfoMessage(data.infoText); setTimeout(()=>setInfoMessage(''), 2000);
            setGameLogs(prev => [...prev, { time: new Date().toLocaleTimeString(), text: data.infoText }]);
        }
        if (data.scores) setPlayerScores(data.scores);
        if (data.playersInfo) setPlayersInfo(data.playersInfo);
        
        // æ›´æ–°æ‰‹ç‰Œæ•°
        if (data.handCounts) setHandCounts(data.handCounts);

        if (data.finishedRank) setFinishedRank(data.finishedRank);

        if (data.pendingPoints !== undefined) setPendingPoints(data.pendingPoints);

        if (data.currentTurnId === mySocketIdRef.current) {
            SoundManager.play('alert');
        }
    });

    socket.on('hand_update', (newHand) => {
        setMyHand(sortHand(newHand, sortModeRef.current)); 
        setSelectedCards([]);
    });

    socket.on('play_error', (msg) => { 
        setInfoMessage(msg); 
        setTimeout(()=>setInfoMessage(''), 2000); 
        SoundManager.play('lose'); 
    }); 
    
    socket.on('round_over', (data) => {
        setRoundResult(data);
        if (data.grandScores) setPlayerScores(data.grandScores);
        const amIWinner = data.roundWinner === usernameRef.current;
        SoundManager.play(amIWinner ? 'win' : 'lose');
    });

    socket.on('grand_game_over', (data) => {
        setGrandResult(data);
        SoundManager.play('win'); 
    });

    const handleGlobalMouseUp = () => { isDragging.current = false; };
    window.addEventListener('mouseup', handleGlobalMouseUp);
    return () => { socket.disconnect(); window.removeEventListener('mouseup', handleGlobalMouseUp); };
  }, []);

  useEffect(() => {
      sortModeRef.current = sortMode;
      if (myHand.length > 0) setMyHand(prev => sortHand(prev, sortMode));
  }, [sortMode]);

  const toggleSort = () => setSortMode(prev => prev === 'POINT' ? 'SUIT' : 'POINT');
  
  const handleRoomAction = () => {
      if (!isConnected) return; 
      if (!username || !roomId) return alert("è¯·è¾“å…¥æ˜µç§°å’Œæˆ¿é—´å·");
      setIsLoading(true);
      const event = isCreatorMode ? 'create_room' : 'join_room';
      const payload = isCreatorMode ? { roomId, username, config: roomConfig } : { roomId, username };
      socketRef.current.emit(event, payload);
  };
  
  const handleStartGame = () => socketRef.current.emit('start_game', { roomId });
  const handleNextRound = () => socketRef.current.emit('next_round', { roomId });
  const handleAddBot = () => socketRef.current.emit('add_bot', { roomId });
  
  const handleToggleAutoPlay = () => socketRef.current.emit('toggle_auto_play', { roomId });

  // [æ–°å¢] å¤„ç†æ¢åº§
  const handleSwitchSeat = (index1, index2) => {
      if (!isCreatorMode && !players.find(p=>p.id===mySocketId)?.isHost) return;
      socketRef.current.emit('switch_seat', { roomId, index1, index2 });
  };

  const updateSelection = (cardVal, forceSelect = null) => {
    setSelectedCards(prev => {
        const isSelected = prev.includes(cardVal);
        if (forceSelect !== null) return forceSelect && !isSelected ? [...prev, cardVal] : (!forceSelect && isSelected ? prev.filter(c => c !== cardVal) : prev);
        return isSelected ? prev.filter(c => c !== cardVal) : [...prev, cardVal];
    });
  };

  const handleMouseDown = (cardVal) => {
    isDragging.current = true;
    dragStartMode.current = !selectedCards.includes(cardVal); 
    updateSelection(cardVal, dragStartMode.current);
    SoundManager.play('deal'); 
  };
  
  const handleMouseEnter = (cardVal) => {
    if (isDragging.current) {
        updateSelection(cardVal, dragStartMode.current);
    }
  };

  const handlePlayCards = () => {
    if (selectedCards.length === 0) return alert("è¯·å…ˆé€‰ç‰Œ");
    socketRef.current.emit('play_cards', { roomId, cards: selectedCards });
  };
  
  const handlePass = () => {
    socketRef.current.emit('pass_turn', { roomId });
    setSelectedCards([]);
  };

  // --- Render Helpers ---

  // æ¨ªå±å¼•å¯¼å±‚
  const renderLandscapeHint = () => (
      <div className="landscape-hint">
          <div className="phone-rotate-icon"></div>
          <h3 style={{marginBottom: 10, fontSize: 18}}>å»ºè®®ä½¿ç”¨æ¨ªå±æ¸¸ç©</h3>
          <p style={{fontSize: 14, opacity: 0.8, maxWidth: 250}}>
              510K éœ€è¦è¾ƒå¤§çš„å±•ç¤ºç©ºé—´ã€‚<br/>
              è¯·æ—‹è½¬æ‚¨çš„æ‰‹æœºä»¥è·å¾—æœ€ä½³ä½“éªŒã€‚
          </p>
          <button 
            style={{marginTop: 20, padding: '8px 20px', background: 'rgba(255,255,255,0.2)', color:'white', border:'1px solid white'}}
            onClick={(e) => { e.currentTarget.parentElement.style.display = 'none'; }}
          >
              æˆ‘éè¦ç«–å±ç©
          </button>
      </div>
  );

  return (
    <>
      {renderLandscapeHint()}
      
      {gameState === 'LOGIN' && <LoginScreen {...{
          username, setUsername, 
          roomId, setRoomId, 
          roomConfig, setRoomConfig, 
          isCreatorMode, setIsCreatorMode, 
          handleRoomAction, 
          isLoading,
          isConnected 
      }} />}
      
      {gameState === 'LOBBY' && <LobbyScreen {...{
          roomId, roomConfig, players, mySocketId, 
          handleStartGame, 
          handleAddBot,
          handleSwitchSeat // [æ–°å¢] ä¼ é€’ç»™å­ç»„ä»¶
      }} />}
      
      {gameState === 'GAME' && <GameScreen {...{
          roomId, players, myHand, selectedCards, lastPlayed, lastPlayerName, currentTurnId, 
          infoMessage, winner: null, playerScores, playersInfo, pendingPoints, gameLogs, sortMode, 
          mySocketId, roundResult, grandResult, roomConfig,
          turnRemaining, finishedRank, handCounts, 
          toggleSort, handleMouseDown, handleMouseEnter, handlePlayCards, handlePass, handleNextRound, handleStartGame,
          handleToggleAutoPlay 
      }} />}
    </>
  );
}

================================================================================
FILE PATH: client\src\components\BaseUI.jsx
================================================================================
import React, { useEffect, useRef, useState } from 'react'; 
import { Coins, History, Trophy, Flag, ChevronDown, ChevronUp, Shield } from 'lucide-react'; 
import { getCardDisplay } from '../utils/cardLogic.js';
import { styles } from '../styles.js';
import CountDownTimer from './CountDownTimer.jsx'; 

// [å…³é”®ä¿®æ”¹] å¯¹å±€è®°å½•é¢æ¿ï¼šæ”¯æŒæŠ˜å  + é€æ˜åº¦ä¼˜åŒ– + æ–‡å­—æè¾¹
export const GameLogPanel = ({ logs }) => {
    const [isCollapsed, setIsCollapsed] = useState(false); // é»˜è®¤å±•å¼€
    const endRef = useRef(null);

    // åªæœ‰åœ¨å±•å¼€çŠ¶æ€ä¸‹æ‰è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
    useEffect(() => {
        if (!isCollapsed) {
            endRef.current?.scrollIntoView({ behavior: 'smooth' });
        }
    }, [logs, isCollapsed]);

    return (
        <div 
            style={{
                ...styles.gameLogPanel,
                // [å…³é”®ä¿®æ”¹] å¼ºåˆ¶æé«˜å±‚çº§è‡³æœ€é«˜ï¼Œé˜²æ­¢è¢«ç©å®¶å¤´åƒæˆ–åŠ¨ç”»é®æŒ¡
                zIndex: 1000,
                // [åŠ¨æ€æ ·å¼] æ§åˆ¶é«˜åº¦
                height: isCollapsed ? 36 : 140, 
                
                // [å…³é”®ä¿®æ”¹] èƒŒæ™¯è®¾ç½®ï¼š
                // 1. background: 'transparent' è®©èƒŒæ™¯å®Œå…¨é€æ˜
                // 2. backdropFilter: 'none' å»é™¤æ¯›ç»ç’ƒæ¨¡ç³Šæ•ˆæœ
                // 3. border: æ”¶èµ·æ—¶å»é™¤è¾¹æ¡†ï¼Œå½»åº•æ¶ˆé™¤æ¡†æ¡†æ„Ÿ
                background: 'transparent', 
                backdropFilter: 'none',
                border: isCollapsed ? 'none' : '1px solid rgba(255, 255, 255, 0.1)',
                boxShadow: 'none', // å»é™¤é˜´å½±
                
                cursor: 'pointer',
                
                // [å…³é”®ä¿®æ”¹] å¼ºåŠ›æ–‡å­—æè¾¹ï¼šè®©ç™½å­—åœ¨ä»»ä½•èƒŒæ™¯ä¸Šéƒ½æ¸…æ™°å¯è§
                // æ¨¡æ‹Ÿ text-stroke æ•ˆæœï¼Œç¡®ä¿å­—æ˜¯æµ®åœ¨ç”»é¢ä¸Šçš„
                textShadow: '1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 0 2px 4px rgba(0,0,0,0.8)'
            }}
            onClick={() => setIsCollapsed(!isCollapsed)} // ç‚¹å‡»åˆ‡æ¢çŠ¶æ€
        >
            <div style={styles.logHeader}>
                <History size={14} color="#f1c40f" style={{filter: 'drop-shadow(0 1px 2px rgba(0,0,0,0.8))'}}/> 
                <span style={{color:'#fff', fontWeight:'bold', flex: 1}}>
                    å¯¹å±€è®°å½•
                </span>
                {/* å³ä¾§å°ç®­å¤´ */}
                {isCollapsed ? <ChevronDown size={14} color="#ccc" style={{filter: 'drop-shadow(0 1px 2px rgba(0,0,0,0.8))'}}/> : <ChevronUp size={14} color="#ccc" style={{filter: 'drop-shadow(0 1px 2px rgba(0,0,0,0.8))'}}/>}
            </div>
            
            {/* å†…å®¹åŒºåŸŸ */}
            <div style={{
                ...styles.logList, 
                // [åŠ¨æ€æ ·å¼] æŠ˜å æ—¶éšè—å†…å®¹ï¼Œé˜²æ­¢é‡å 
                opacity: isCollapsed ? 0 : 1,
                pointerEvents: isCollapsed ? 'none' : 'auto'
            }}>
                {logs.map((log, i) => (
                    <div key={i} style={styles.logItem}>
                        <span style={styles.logTime}>[{log.time.split(' ')[0]}]</span>
                        <span style={{color: '#eee'}}>{log.text}</span>
                    </div>
                ))}
                <div ref={endRef} />
            </div>
        </div>
    );
};

export const Card = ({ cardVal, index, isSelected, onClick, onMouseEnter, spacing }) => {
    const { suit, text, color, isScore } = getCardDisplay(cardVal);
    
    const handlePointerDown = (e) => {
        // [æ ¸å¿ƒä¿®å¤] ä¿ç•™ Code 2 çš„ä¿®å¤ï¼šå¦‚æœæ˜¯è§¦æ‘¸äº‹ä»¶ï¼Œä¸å¤„ç†ï¼Œäº¤ç»™çˆ¶å®¹å™¨
        if (e.pointerType === 'touch') return;

        if (e.button !== 0 && e.pointerType === 'mouse') return;
        e.stopPropagation();
        onClick(cardVal);
    };

    return (
        <div 
            onPointerDown={handlePointerDown}
            onMouseEnter={(e) => {
                if (e.pointerType === 'mouse') {
                     onMouseEnter(cardVal);
                }
            }}
            style={{
                ...styles.card, 
                color, 
                left: index * spacing, 
                zIndex: index,
                transform: isSelected ? 'translateY(-35px)' : 'translateY(0)',
                borderColor: isSelected ? '#3498db' : (isScore ? '#f1c40f' : '#bdc3c7'),
                boxShadow: isSelected ? '0 0 15px rgba(52, 152, 219, 0.6)' : (isScore ? '0 0 8px rgba(241, 196, 15, 0.4)' : '0 -2px 5px rgba(0,0,0,0.1)'),
                touchAction: 'none' 
            }}
        >
            <div style={{position: 'absolute', top: 0, left: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', lineHeight: 0.9}}>
                <div style={{fontSize: 16, fontWeight: '900', letterSpacing: -1}}>{text}</div>
                <div style={{fontSize: 14, marginTop: -1}}>{suit}</div>
            </div>
            {isScore && <div style={{position:'absolute', bottom:1, right:2, fontSize:10, color:'#f1c40f'}}>â˜…</div>}
        </div>
    );
};
export const MiniCard = ({ cardVal, index }) => {
    const { text, suit, color, isScore } = getCardDisplay(cardVal);
    return (
        <div style={{
            ...styles.miniCard, color,
            border: isScore ? '2px solid #f1c40f' : '1px solid #ccc',
            transform: isScore ? 'scale(1.1) translateY(-10px)' : 'scale(1)',
            zIndex: index
        }}>
            {suit}{text}
        </div>
    );
};

// [ä¿®æ”¹] æ”¯æŒ team å±æ€§æ˜¾ç¤ºé˜Ÿä¼é¢œè‰²ï¼Œè°ƒæ•´è§’æ ‡å¸ƒå±€
export const PlayerAvatar = ({ player, isTurn, score, targetScore, isMySocket, remainingSeconds, rank, timerPosition, hideTimer, cardCount, showCardCountMode, team }) => {
    const progress = Math.min((score / targetScore) * 100, 100);
    const containerOpacity = rank ? 0.75 : 1; 

    let showBadge = false;
    if (showCardCountMode === 2) showBadge = true;
    if (showCardCountMode === 1 && cardCount <= 3 && cardCount > 0) showBadge = true;
    if (rank) showBadge = false;

    // --- é˜Ÿä¼é¢œè‰²é€»è¾‘ ---
    // 0:çº¢é˜Ÿ, 1:è“é˜Ÿ
    const isTeamMode = team !== undefined && team !== null;
    const teamColor = team === 0 ? '#e74c3c' : '#3498db'; 
    const teamName = team === 0 ? 'çº¢' : 'è“';
    
    // è¾¹æ¡†é€»è¾‘ï¼šå¦‚æœæ˜¯è½®åˆ°ä»–ï¼Œæ˜¾ç¤ºé‡‘è‰²é«˜äº®ï¼›å¦åˆ™å¦‚æœå¤„äºç»„é˜Ÿæ¨¡å¼ï¼Œæ˜¾ç¤ºé˜Ÿä¼è‰²ï¼›å¦åˆ™é»˜è®¤é€æ˜
    let borderColor = 'rgba(255,255,255,0.1)';
    if (isTeamMode) borderColor = teamColor;
    if (isTurn) borderColor = '#f1c40f'; // è½®åˆ°è°ï¼Œé‡‘è‰²ä¼˜å…ˆ

    // èƒŒæ™¯é€»è¾‘ï¼šè½®åˆ°è°æ·±è‰²å¼ºè°ƒï¼Œå¦åˆ™ç»„é˜Ÿæ¨¡å¼ä¸‹å¸¦ç‚¹é˜Ÿä¼è‰²
    let bgColor = isTurn ? 'rgba(44, 62, 80, 0.9)' : 'rgba(44, 62, 80, 0.6)';
    if (isTeamMode && !isTurn) {
        bgColor = team === 0 ? 'rgba(231, 76, 60, 0.2)' : 'rgba(52, 152, 219, 0.2)';
    }

    return (
        <div style={{
            ...styles.playerBox,
            borderColor: borderColor,
            borderWidth: isTeamMode ? 2 : 1, // ç»„é˜Ÿæ¨¡å¼è¾¹æ¡†åŠ ç²—
            transform: isTurn ? 'scale(1.1)' : 'scale(1)',
            boxShadow: isTurn ? '0 0 25px rgba(241, 196, 15, 0.5)' : 'none',
            background: bgColor,
            position: 'relative',
            opacity: containerOpacity
        }}>
            {/* å·¦ä¸Šè§’ï¼šå‰©ä½™ç‰Œæ•° (Card Count) - æ ·å¼åœ¨ styles.js ä¸­å®šä¹‰ä¸º top: -8, left: -8 */}
            {showBadge && (
                <div style={styles.cardCountBadge}>
                    {cardCount}
                </div>
            )}

            {/* å³ä¸Šè§’ï¼šç»„é˜Ÿæ ‡è¯† (Team Badge) - [ä¿®æ”¹] ç§»åˆ°å³ä¸Šè§’ */}
            {isTeamMode && (
                <div style={{
                    position: 'absolute', 
                    top: -10, 
                    right: -8, // [ä¿®æ”¹] æ”¹ä¸º right: -8ï¼Œä¸å·¦è¾¹çš„ç‰Œæ•°å¾½ç« å¯¹ç§°
                    background: teamColor, color: 'white',
                    fontSize: 9, padding: '1px 4px', borderRadius: 4,
                    display: 'flex', alignItems: 'center', gap: 2,
                    boxShadow: '0 2px 4px rgba(0,0,0,0.3)',
                    zIndex: 25
                }}>
                    <Shield size={8} fill="currentColor"/> {teamName}é˜Ÿ
                </div>
            )}

            {/* æ­£ä¸Šæ–¹ï¼šæ’åå¥–æ¯ (Rank Badge) */}
            {rank && (
                <div style={{
                    position: 'absolute',
                    top: -16, // [å¾®è°ƒ] ç¨å¾®å‘ä¸Šæä¸€ç‚¹ï¼Œé¿å…è¿™ä¸‰ä¸ªå¾½ç« åœ¨è§†è§‰ä¸Šå¤ªæ‹¥æŒ¤
                    left: '50%',
                    transform: 'translateX(-50%)',
                    background: rank === 1 ? '#f1c40f' : (rank === 2 ? '#bdc3c7' : '#e67e22'), 
                    color: '#fff',
                    padding: '2px 8px',
                    borderRadius: 20,
                    fontSize: 11,
                    fontWeight: 'bold',
                    boxShadow: '0 2px 5px rgba(0,0,0,0.4)',
                    zIndex: 30, // ç¡®ä¿å±‚çº§æœ€é«˜
                    display: 'flex',
                    alignItems: 'center',
                    gap: 3,
                    whiteSpace: 'nowrap',
                    border: '1px solid white'
                }}>
                    {rank === 1 ? <Trophy size={10} fill="white" /> : <Flag size={10} fill="white"/>}
                    {rank === 1 ? 'NO.1' : `NO.${rank}`}
                </div>
            )}

            <div style={{...styles.avatar, borderColor: isTeamMode ? teamColor : 'rgba(255,255,255,0.3)'}}>
                {player.name[0]}
            </div>
            
            {/* åå­—æ˜¾ç¤ºä¼˜åŒ–ï¼šåŠ é˜Ÿä¼å‰ç¼€é¢œè‰² */}
            <div style={styles.playerName}>
                {player.name} {isMySocket && '(æˆ‘)'}
            </div>
            
            <div style={styles.scoreBarBg}>
                <div style={{...styles.scoreBarFill, width:`${progress}%`, background: progress>=100?'#e74c3c':'#2ecc71'}}></div>
            </div>
            <div style={styles.playerScore}><Coins size={10} color="#f1c40f"/> {score}</div>
            
            {isTurn && !rank && !hideTimer && (
                <CountDownTimer 
                    initialSeconds={remainingSeconds} 
                    totalSeconds={60} 
                    position={timerPosition}
                />
            )}
        </div>
    );
};

================================================================================
FILE PATH: client\src\components\CountDownTimer.jsx
================================================================================
import React, { useState, useEffect, useRef } from 'react';
import { Clock } from 'lucide-react';

const CountDownTimer = ({ initialSeconds, totalSeconds = 60, position = 'top' }) => {
    const [seconds, setSeconds] = useState(initialSeconds);
    const intervalRef = useRef(null);

    // [ä¼˜åŒ–] åªåœ¨ initialSeconds å‘ç”Ÿæ˜¾è‘—å˜åŒ–ï¼ˆä¾‹å¦‚æ–°çš„ä¸€è½®å¼€å§‹ï¼‰æ—¶é‡ç½®
    // è¿™é‡Œæˆ‘ä»¬å‡è®¾çˆ¶ç»„ä»¶ä¼šä¼ é€’æ­£ç¡®çš„ initialSeconds
    // å¦‚æœæœåŠ¡å™¨ä¸é¢‘ç¹æ¨é€ï¼Œè¿™é‡Œçš„ useEffect ä¹Ÿå°±ä¸ä¼šé¢‘ç¹è§¦å‘
    useEffect(() => {
        setSeconds(initialSeconds);
    }, [initialSeconds]);

    useEffect(() => {
        // æ¸…é™¤æ—§çš„
        if (intervalRef.current) clearInterval(intervalRef.current);

        // å¦‚æœå·²ç»ç»“æŸï¼Œä¸å¯åŠ¨
        if (seconds <= 0) return;

        // å¯åŠ¨æ–°çš„è®¡æ—¶å™¨
        intervalRef.current = setInterval(() => {
            setSeconds((prev) => {
                if (prev <= 1) {
                    clearInterval(intervalRef.current);
                    return 0;
                }
                return prev - 1;
            });
        }, 1000);

        return () => {
            if (intervalRef.current) clearInterval(intervalRef.current);
        };
    }, [initialSeconds]); // ä¾èµ–é¡¹æ”¹ä¸º initialSecondsï¼Œè€Œä¸æ˜¯ secondsï¼Œè¿™æ ·ä¸ä¼šæ¯ç§’é‡ç½® interval

    const isUrgent = seconds <= 10;
    const color = isUrgent ? '#ff4d4d' : '#ffffff';
    const bgColor = isUrgent ? 'rgba(231, 76, 60, 0.9)' : 'rgba(0, 0, 0, 0.7)';

    let posStyle = {};
    // ... (ä½ç½®æ ·å¼é€»è¾‘ä¿æŒä¸å˜) ...
    switch (position) {
        case 'bottom':
            posStyle = { top: '100%', left: '50%', transform: 'translateX(-50%)', marginTop: 5 };
            break;
        case 'left':
            posStyle = { right: '100%', top: '50%', transform: 'translateY(-50%)', marginRight: 8 };
            break;
        case 'right':
            posStyle = { left: '100%', top: '50%', transform: 'translateY(-50%)', marginLeft: 8 };
            break;
        case 'top-right': 
            posStyle = { left: '100%', top: -20, marginLeft: 5 };
            break;
        case 'inline': 
             // [æ–°å¢] å†…è”æ¨¡å¼ï¼Œç”¨äºæ“ä½œæ 
            posStyle = { position: 'static', margin: '0 10px' };
            break;
        case 'top':
        default:
            posStyle = { bottom: '100%', left: '50%', transform: 'translateX(-50%)', marginBottom: 5 };
            break;
    }

    // å†…è”æ¨¡å¼ä¸‹ç§»é™¤ absolute
    const containerStyle = position === 'inline' ? {
        ...posStyle,
        background: bgColor,
        padding: '4px 10px',
        borderRadius: 20,
        display: 'flex',
        alignItems: 'center',
        gap: 5,
        border: '1px solid rgba(255,255,255,0.2)',
        transition: 'all 0.3s'
    } : {
        position: 'absolute',
        ...posStyle,
        background: bgColor,
        padding: '2px 8px',
        borderRadius: 20,
        display: 'flex',
        alignItems: 'center',
        gap: 3,
        whiteSpace: 'nowrap',
        boxShadow: '0 4px 10px rgba(0,0,0,0.3)',
        border: '1px solid rgba(255,255,255,0.2)',
        zIndex: 30,
        transition: 'all 0.3s'
    };

    return (
        <div style={containerStyle}>
            <Clock size={12} color={color} className={isUrgent ? 'spin' : ''} />
            <span style={{ 
                color: color, 
                fontWeight: 'bold', 
                fontSize: 12,
                fontFamily: 'monospace'
            }}>
                {seconds}s
            </span>
            <style>{`.spin { animation: spin 1s linear infinite; }`}</style>
        </div>
    );
};

export default CountDownTimer;

================================================================================
FILE PATH: client\src\index.css
================================================================================
/* =========================================
   å…¨å±€åŸºç¡€æ ·å¼ (Base & Reset)
   ========================================= */
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  /* é…è‰²æ–¹æ¡ˆ */
  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  /* å­—ä½“æ¸²æŸ“ä¼˜åŒ– */
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  
  /* [ä¼˜åŒ–] ç¦æ­¢ç§»åŠ¨ç«¯ç‚¹å‡»é«˜äº® */
  -webkit-tap-highlight-color: transparent;
}

/* [å…³é”®ä¿®å¤ 0] å…¨å±€ç›’æ¨¡å‹é‡ç½® */
*, *::before, *::after {
  box-sizing: border-box;
}

/* é“¾æ¥æ ·å¼ */
a { font-weight: 500; color: #646cff; text-decoration: inherit; }
a:hover { color: #535bf2; }

/* Body åŸºç¡€è®¾ç½® */
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  /* [å…³é”®ä¿®å¤] å½»åº•ç¦æ­¢æµè§ˆå™¨çš„ä¸‹æ‹‰åˆ·æ–°å’Œå›å¼¹æ•ˆæœ */
  overscroll-behavior: none;
  overflow: hidden; /* é”æ­» Body æ»šåŠ¨ï¼Œåªå…è®¸å†…éƒ¨å…ƒç´ æ»šåŠ¨ */
  position: fixed; /* å¼ºåˆ¶å›ºå®šï¼Œé˜²æ­¢ iOS Safari åœ°å€æ å› ä¸ºé¡µé¢æ»šåŠ¨è€Œå¿½éšå¿½ç° */
}

body {
  display: flex;
  place-items: center;
  min-width: 320px;
}

/* [ä¼˜åŒ–] é’ˆå¯¹æ ¹å®¹å™¨ä¼˜åŒ–è§¦æ‘¸ä½“éªŒ */
#root, .App {
  width: 100%;
  height: 100%;
  overflow-x: hidden;
  /* å…è®¸å†…éƒ¨æ­£å¸¸çš„ç‚¹å‡»å’Œæ»šåŠ¨ */
  touch-action: manipulation;
}

h1 { font-size: 3.2em; line-height: 1.1; }

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover { border-color: #646cff; }
button:focus, button:focus-visible { outline: 4px auto -webkit-focus-ring-color; }

@media (prefers-color-scheme: light) {
  :root { color: #213547; background-color: #ffffff; }
  a:hover { color: #747bff; }
  button { background-color: #f9f9f9; }
}


/* =========================================
   ç§»åŠ¨ç«¯é€‚é…æ ¸å¿ƒåŒº (Mobile Overrides)
   ========================================= */

/* --- 1. æ¨ªå±å¼•å¯¼é®ç½© --- */
.landscape-hint {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(30, 39, 46, 0.95);
    z-index: 9999; 
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
    text-align: center;
    backdrop-filter: blur(10px);
    touch-action: none; 
}

.phone-rotate-icon {
    width: 60px;
    height: 100px; 
    border: 3px solid white; border-radius: 10px; margin-bottom: 20px;
    animation: rotate-phone 2s infinite ease-in-out;
}
@keyframes rotate-phone {
    0% { transform: rotate(0deg); }
    50% { transform: rotate(90deg); }
    100% { transform: rotate(0deg); }
}


/* --- 2. ç§»åŠ¨ç«¯ç«–å±å¸ƒå±€ä¼˜åŒ– (Portrait Core) --- */

@media (max-width: 768px) {
  
  ::-webkit-scrollbar { width: 0px; background: transparent; }

  /* é€šç”¨åˆ—å®¹å™¨ */
  .mobile-layout-column {
    display: flex !important;
    flex-direction: column !important;
    width: 95% !important;     
    max-width: none !important; 
    height: auto !important;
    
    /* ä½¿ç”¨ dvh é€‚é…åŠ¨æ€åœ°å€æ  */
    min-height: 85vh !important;
    min-height: 85dvh !important; 
    
    max-height: 95dvh !important; 
    margin: 10px auto !important; 
    overflow: hidden !important; 
    padding: 0 !important;
  }

  /* --- 2.1 ç™»å½•é¡µ (Login) --- */
  .mobile-login-left {
    flex: 0 0 auto !important;
    width: 100% !important;
    padding: 30px 20px !important; 
    border-radius: 0 0 24px 24px !important; 
    background-color: #242424; 
    min-height: auto !important;
    align-items: center !important; 
    text-align: center !important;
    padding-top: max(30px, env(safe-area-inset-top)) !important;
  }
  
  .mobile-login-left h1 { font-size: 2.5em !important; margin-bottom: 10px !important; }
  .mobile-login-left .logoCircle { width: 70px !important; height: 70px !important; margin-bottom: 15px !important; }
  .mobile-login-left .logoText { font-size: 22px !important; }

  .mobile-login-right {
    flex: 1 !important;
    width: 100% !important;
    padding: 30px 20px !important;
    background: white;
    border-radius: 24px 24px 0 0 !important; 
    margin-top: -20px; 
    position: relative;
    z-index: 2;
    overflow-y: auto !important;
    display: flex !important;
    flex-direction: column !important;
    padding-bottom: max(30px, env(safe-area-inset-bottom)) !important;
  }
  
  .hide-on-mobile { display: none !important; }


  /* --- 2.2 å¤§å…é¡µ (Lobby) --- */
  .lobbyCard.mobile-layout-column {
      height: 92dvh !important;
      position: relative;
      background: white !important;
  }

  .mobile-lobby-content {
      display: flex !important;
      flex-direction: column !important;
      height: 100% !important;
      width: 100%;
      overflow: hidden !important;
  }
  
  .lobbyHeader { 
      flex: 0 0 auto;
      padding: 15px !important;
      padding-top: calc(15px + env(safe-area-inset-top)) !important; 
      background: #f8f9fa; 
  }
  .lobbyHeader h2 { font-size: 20px !important; margin: 0 !important; }

  .mobile-lobby-grid {
      flex: 1 !important; 
      overflow-y: auto !important;
      padding: 10px !important;
      display: grid !important;
      grid-template-columns: repeat(2, 1fr) !important; 
      align-content: start !important;
      gap: 10px !important;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 10px !important;
  }
  
  .mobile-lobby-grid > div { padding: 15px !important; gap: 10px !important; }
  .mobile-lobby-grid .avatar-large { width: 50px !important; height: 50px !important; font-size: 20px !important; }

  .mobile-lobby-footer {
      flex: 0 0 auto !important;
      padding: 12px !important;
      background: white;
      border-top: 1px solid #eee;
      z-index: 10;
      padding-bottom: calc(12px + env(safe-area-inset-bottom)) !important;
      position: static !important; 
      margin-top: auto !important;
      display: flex !important;
      justify-content: space-around !important;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
  }
  
  .mobile-lobby-footer button {
      width: 45% !important;
      padding: 0 !important;
      height: 44px !important; 
      font-size: 14px !important;
      margin: 0 !important;
  }
}


/* --- 3. ç§»åŠ¨ç«¯æ¨ªå±é€‚é… (Landscape Overrides) --- */
@media (max-width: 896px) and (orientation: landscape) {
    
    /* [ç»ˆæä¿®å¤ 1] å¼ºåˆ¶é“ºæ»¡å±å¹•ï¼Œæ— è§†ä»»ä½• marginï¼Œç›´æ¥è¦†ç›– */
    /* [å…³é”® Fix] å¿…é¡»å¼ºåˆ¶é‡ç½® min-height ä¸º 0ï¼Œå¦åˆ™ JS é‡Œçš„ 600px ä¼šæ’‘ç ´å±å¹• */
    .mobile-layout-column {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        min-height: 0 !important; /* æ ¸å¿ƒä¿®å¤ï¼šè§£å†³åº•éƒ¨çœ‹ä¸è§çš„é—®é¢˜ */
        max-height: none !important;
        margin: 0 !important;
        padding: 0 !important;
        flex-direction: row !important;
        z-index: 10;
    }

    /* --- [å…³é”®ä¼˜åŒ–] ç™»å½•é¡µ (Login) --- */
    
    .mobile-login-left {
        display: none !important;
    }

    .mobile-login-right {
        width: 100% !important;
        height: 100% !important;
        flex: 1 !important;
        border-radius: 0 !important;
        margin: 0 !important;
        
        /* é¡¶éƒ¨å¯¹é½ï¼Œé˜²æ­¢è¢«åˆ‡ */
        justify-content: flex-start !important;
        padding-top: max(10px, env(safe-area-inset-top)) !important;
        
        /* [ä¿®å¤] åº•éƒ¨å¢åŠ å¤§å¹…åº¦ Paddingï¼Œç¡®ä¿æ»šåŠ¨åˆ°åº•éƒ¨æ—¶ï¼Œæœ€ä¸‹é¢çš„æŒ‰é’®èƒ½å®Œæ•´éœ²å‡º */
        padding-bottom: max(40px, env(safe-area-inset-bottom)) !important;
        padding-left: max(40px, env(safe-area-inset-left)) !important;
        padding-right: max(40px, env(safe-area-inset-right)) !important; 
        
        overflow-y: auto !important;
        display: flex !important;
        flex-direction: column !important;
    }
    
    .mobile-login-right .formContent {
        max-width: 600px;
        margin: 0 auto;
        width: 100%;
        /* ç¡®ä¿åº•éƒ¨æŒ‰é’®èƒ½å®Œæ•´éœ²å‡º */
        padding-bottom: 20px !important;
    }


    /* --- [å…³é”®ä¼˜åŒ–] å¤§å…é¡µ (Lobby) --- */

    /* [å…³é”®ä¿®å¤ 2] å½»åº•é‡æ„ Lobby å¸ƒå±€ */
    .lobbyCard.mobile-layout-column {
        background: transparent !important;
        border: none !important;
    }
    
    .mobile-lobby-content {
        background: white !important;
        border-radius: 0 !important; 
        height: 100% !important;
        width: 100% !important;
        border: none !important;
        box-shadow: none !important;
        /* ä½¿ç”¨ Flex Column å¸ƒå±€ */
        display: flex !important;
        flex-direction: column !important;
    }

    .lobbyHeader {
        flex: 0 0 auto !important; /* å¤´éƒ¨å›ºå®šé«˜åº¦ï¼Œä¸è®¸ä¼¸ç¼© */
        padding: 8px 20px !important; 
        padding-top: max(10px, env(safe-area-inset-top)) !important;
        background: #f8f9fa;
        z-index: 20;
        border-bottom: 1px solid #eee;
    }
    /* ç¼©å°æ¨ªå±ä¸‹çš„æ ‡é¢˜å­—å· */
    .lobbyHeader h2 { font-size: 18px !important; }

    /* ç©å®¶åˆ—è¡¨ Grid */
    .mobile-lobby-grid {
        /* [æ ¸å¿ƒä¿®å¤] ä¸­é—´åŒºåŸŸè‡ªé€‚åº”ï¼Œå…è®¸æ”¶ç¼©ï¼Œå…è®¸æ»šåŠ¨ */
        flex: 1 1 0% !important; /* å…³é”®ï¼è®¾ä¸º 0% å¼ºåˆ¶è®©å®ƒå»é€‚åº”å‰©ä½™ç©ºé—´ï¼Œè€Œä¸æ˜¯è¢«å†…å®¹æ’‘å¤§ */
        min-height: 0 !important; 
        
        overflow-y: auto !important;
        display: grid !important;
        grid-template-columns: repeat(4, 1fr) !important; 
        gap: 10px !important;
        padding: 10px 20px !important;
        padding-left: max(30px, env(safe-area-inset-left)) !important;
        padding-right: max(30px, env(safe-area-inset-right)) !important;
        align-content: start !important;
    }
    
    @media (max-width: 600px) {
        .mobile-lobby-grid {
            grid-template-columns: repeat(3, 1fr) !important;
        }
    }

    .mobile-lobby-grid > div {
        padding: 6px !important;
        gap: 5px !important;
    }
    
    .mobile-lobby-grid .avatar-large {
        width: 36px !important;
        height: 36px !important;
        font-size: 14px !important;
    }

    /* Footer ä¼˜åŒ– */
    .mobile-lobby-footer {
        flex: 0 0 auto !important; /* åº•éƒ¨å›ºå®šé«˜åº¦ï¼Œä¸è®¸è¢«æŒ¤å‹ */
        position: relative !important;
        z-index: 100 !important;
        
        background: #f8f9fa !important;
        border-top: 1px solid #ddd !important;
        
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        /* [æ ¸å¿ƒä¿®å¤] ç»™åº•éƒ¨ç•™å‡ºè¶³å¤Ÿçš„å®‰å…¨è·ç¦»ï¼Œé˜²æ­¢è¢«æ‰‹åŠ¿æ¡é®æŒ¡æŒ‰ä¸åˆ° */
        padding-top: 8px !important;
        padding-bottom: max(15px, env(safe-area-inset-bottom)) !important;
        padding-left: max(20px, env(safe-area-inset-left)) !important;
        padding-right: max(20px, env(safe-area-inset-right)) !important;
        margin-top: 0 !important; /* æ¸…é™¤ marginTop auto */
    }
    
    .mobile-lobby-footer button {
        height: 40px !important; /* ç¨å¾®è°ƒçŸ®æŒ‰é’® */
        font-size: 14px !important;
    }
}

================================================================================
FILE PATH: client\src\main.jsx
================================================================================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)


================================================================================
FILE PATH: client\src\screens\GameScreen.jsx
================================================================================
// æ¸¸æˆä¸»ç•Œé¢ - æ·±åº¦é€‚é…ç§»åŠ¨ç«¯å¸ƒå±€ï¼Œå¢åŠ äº†å…¨å±æŒ‰é’®
// [å®Œæ•´æ— åˆ å‡ç‰ˆ] + ç»„é˜Ÿåˆ†æ•°ç»“ç®—å±•ç¤º
import React, { useState, useRef, useEffect } from 'react';
import { Coins, Layers, Crown, Clock, Bot, Zap, Maximize, Minimize, Shield, Users } from 'lucide-react';
import { styles } from '../styles.js'; 
import { Card, MiniCard, PlayerAvatar, GameLogPanel } from '../components/BaseUI.jsx';
import TimerComponent from '../components/CountDownTimer.jsx'; 
import { calculateCardSpacing, getCardIndexFromTouch } from '../utils/cardLogic.js'; 
import SoundManager from '../utils/SoundManager.js';

export const GameScreen = ({ 
    roomId, players, myHand, selectedCards, lastPlayed, lastPlayerName, currentTurnId, 
    infoMessage: serverInfoMessage, winner, playerScores, playersInfo, pendingPoints, gameLogs, sortMode,
    mySocketId, roundResult, grandResult, roomConfig,
    turnRemaining, finishedRank = [], 
    handCounts = {}, 
    toggleSort, handleMouseDown, handleMouseEnter, handlePlayCards, handlePass, handleNextRound, handleStartGame,
    handleToggleAutoPlay 
}) => {
    const isMyTurn = currentTurnId === mySocketId;
    const amIHost = players.find(p => p.id === mySocketId)?.isHost;
    
    // --- å±å¹•å°ºå¯¸ä¸å¸ƒå±€è®¡ç®— ---
    const [dimensions, setDimensions] = useState({ width: window.innerWidth, height: window.innerHeight });
    
    useEffect(() => {
        const handleResize = () => setDimensions({ width: window.innerWidth, height: window.innerHeight });
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, []);

    const handAreaWidth = dimensions.width; 
    const cardSpacing = calculateCardSpacing(myHand.length, handAreaWidth);
    
    const myInfo = (playersInfo && playersInfo[mySocketId]) || {};
    const amIAutoPlay = myInfo.isAutoPlay;

    const isCrowded = players.length > 6;
    const avatarScale = isCrowded ? 0.85 : 1;
    const avatarStyleOverride = isCrowded ? { transform: `scale(${avatarScale})`, margin: -5 } : {};

    const [localInfo, setLocalInfo] = useState('');
    const displayMessage = localInfo || serverInfoMessage;

    const [isFullScreen, setIsFullScreen] = useState(false);

    const currentTurnPlayer = players.find(p => p.id === currentTurnId);
    const waitingText = currentTurnPlayer ? `ç­‰å¾… ${currentTurnPlayer.name}...` : 'ç­‰å¾…ä¸­...';

    // --- ç»„é˜Ÿç§¯åˆ†è®¡ç®—è¾…åŠ©å‡½æ•° ---
    const getTeamScores = () => {
        let redScore = 0;
        let blueScore = 0;
        let hasTeams = false;

        players.forEach(p => {
            const pInfo = playersInfo[p.id];
            const score = playerScores[p.id] || 0;
            if (pInfo && pInfo.team !== undefined && pInfo.team !== null) {
                hasTeams = true;
                if (pInfo.team === 0) redScore += score;
                else if (pInfo.team === 1) blueScore += score;
            }
        });

        return { hasTeams, redScore, blueScore };
    };

    // --- æ»‘åŠ¨é€‰ç‰Œé€»è¾‘ ---
    const handContainerRef = useRef(null);
    const lastTouchedIndex = useRef(null);
    const isDragging = useRef(false);
const dragStartMode = useRef(true); // true = select, false = deselect

    const handleTouchStart = (e) => {
        // [å…³é”®ä¿®æ”¹] é˜»æ­¢é»˜è®¤äº‹ä»¶ï¼Œé˜²æ­¢åç»­è§¦å‘ click/mousedown å¯¼è‡´åŒé‡æ“ä½œ
        if (e.cancelable) e.preventDefault();
        
        const touch = e.touches[0];
        const container = handContainerRef.current;
        if (!container) return;

        const rect = container.getBoundingClientRect();
        
        // 1. å…ˆç®—å‡ºæ¨ªåæ ‡å¯¹åº”çš„ç‰Œæ˜¯å“ªä¸€å¼  (ä¸ºäº†åšç²¾ç¡®çš„é«˜åº¦æ£€æµ‹ï¼Œå¿…é¡»å…ˆçŸ¥é“ç‚¹çš„æ˜¯è°)
        const index = getCardIndexFromTouch(touch.clientX, rect.left, cardSpacing, myHand.length);
        const cardVal = myHand[index];

        if (cardVal === undefined) return;

        // 2. [æ ¸å¿ƒä¼˜åŒ–] åŠ¨æ€é«˜åº¦æ£€æµ‹
        // è§£å†³é—®é¢˜ï¼šé˜²æ­¢ç‚¹å‡»â€œåç€â€çš„ç‰Œä¸Šæ–¹çš„ç©ºæ°”æ—¶è§¦å‘é€‰ä¸­
        const isSelected = selectedCards.includes(cardVal);
        const CARD_HEIGHT = 70;    // ç‰Œçš„åŸºç¡€é«˜åº¦ (styles.card.height)
        const POP_HEIGHT = 35;     // ç«™èµ·æ¥çš„ä¸Šæµ®é«˜åº¦ (transform translateY)
        const TOLERANCE = 10;      // å®¹é”™ç©ºé—´ (æ‰‹æŒ‡å¯èƒ½æ¯”ç‰Œå¤§ä¸€ç‚¹)

        // å¦‚æœç‰Œå·²ç»ç«™èµ·æ¥äº†ï¼Œæœ‰æ•ˆé«˜åº¦ = åŸºç¡€ + ä¸Šæµ® + å®¹é”™
        // å¦‚æœç‰Œæ˜¯åç€çš„ï¼Œæœ‰æ•ˆé«˜åº¦ = åŸºç¡€ + å®¹é”™
        const validVisualHeight = isSelected 
            ? CARD_HEIGHT + POP_HEIGHT + TOLERANCE 
            : CARD_HEIGHT + TOLERANCE;

        // è®¡ç®—è§¦æ‘¸ç‚¹è·ç¦»å®¹å™¨åº•éƒ¨çš„è·ç¦»
        const distanceFromBottom = rect.bottom - touch.clientY;

        // åˆ¤å®šï¼šå¦‚æœç‚¹å‡»ä½ç½®æ¯”â€œè¯¥ç‰Œå½“å‰çš„è§†è§‰é«˜åº¦â€è¿˜è¦é«˜ï¼Œè¯´æ˜ç‚¹åœ¨ç©ºæ°”ä¸Šäº†
        if (distanceFromBottom > validVisualHeight) {
            isDragging.current = false;
            return;
        }
        
        // åˆ¤å®šï¼šå¦‚æœç‚¹åˆ°å®¹å™¨å¤–é¢å¤ªä¸‹é¢å»äº†ä¹Ÿä¸è¡Œ
        if (distanceFromBottom < -10) {
            isDragging.current = false;
            return;
        }

        isDragging.current = true;
        
        // å†³å®šèµ·å§‹æ¨¡å¼
        dragStartMode.current = !selectedCards.includes(cardVal);
        lastTouchedIndex.current = index;
        
        // æ‰§è¡Œé€‰ä¸­/å–æ¶ˆ
        if (isSelected !== dragStartMode.current) {
                handleMouseDown(cardVal); // è§¦å‘ toggle
                if (navigator.vibrate) navigator.vibrate(5);
        }
    };

    const handleTouchMove = (e) => {
        if (e.cancelable) e.preventDefault(); // é˜²æ­¢æ»šåŠ¨
        if (!isDragging.current) return;

        const touch = e.touches[0];
        const container = handContainerRef.current;
        if (!container) return;

        const rect = container.getBoundingClientRect();
        // å¢åŠ ä¸€ç‚¹ Y è½´å®¹é”™ï¼Œé˜²æ­¢æ‰‹æŒ‡ç¨å¾®æ»‘å‡ºå°±æ–­è§¦
        // [è°ƒæ•´] è¿™é‡Œçš„èŒƒå›´å¯ä»¥ç¨å¾®å®½ä¸€ç‚¹ï¼Œå…è®¸æ»‘åŠ¨æ—¶æ‰‹æŒ‡ç¨å¾®è·‘å
        if (touch.clientY < rect.top - 50 || touch.clientY > rect.bottom + 50) return;

        const index = getCardIndexFromTouch(touch.clientX, rect.left, cardSpacing, myHand.length);
        
        if (lastTouchedIndex.current !== index) {
            lastTouchedIndex.current = index;
            const cardVal = myHand[index];
            if (cardVal !== undefined) {
                const isSelected = selectedCards.includes(cardVal);
                if (isSelected !== dragStartMode.current) {
                    handleMouseDown(cardVal); 
                    if (navigator.vibrate) navigator.vibrate(5);
                }
            }
        }
    };

    const handleTouchEnd = () => {
        isDragging.current = false;
        lastTouchedIndex.current = null;
    };

    const toggleFullScreen = () => {
        const doc = window.document;
        const docEl = doc.documentElement;
        const requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
        const cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;

        if (!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
            if (requestFullScreen) {
                requestFullScreen.call(docEl)
                    .then(() => setIsFullScreen(true))
                    .catch(err => {
                        console.warn("å…¨å±è¯·æ±‚è¢«æ‹’ç»:", err);
                        setLocalInfo("âš ï¸ æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒç½‘é¡µå…¨å±ï¼Œè¯·ä½¿ç”¨'æ·»åŠ åˆ°ä¸»å±å¹•'åŠŸèƒ½");
                        setTimeout(() => setLocalInfo(''), 3000);
                    });
            } else {
                setLocalInfo("âš ï¸ iOSè¯·åœ¨Safarièœå•é€‰æ‹©'æ·»åŠ åˆ°ä¸»å±å¹•'ä»¥å…¨å±æ¸¸ç©");
                setTimeout(() => setLocalInfo(''), 3000);
            }
        } else {
            if (cancelFullScreen) {
                cancelFullScreen.call(doc)
                    .then(() => setIsFullScreen(false))
                    .catch(err => console.error(err));
            }
        }
    };

    // --- ç©å®¶ä½ç½®è®¡ç®—é€»è¾‘ ---
    const renderPlayers = () => {
        const myIndex = players.findIndex(p => p.id === mySocketId);
        const safeMyIndex = myIndex === -1 ? 0 : myIndex;
        
        const otherPlayers = [];
        for (let i = 1; i < players.length; i++) {
            const idx = (safeMyIndex + i) % players.length;
            otherPlayers.push(players[idx]);
        }

        const layoutConfig = [];
        const total = otherPlayers.length;

        let countL = 0, countT = 0, countR = 0;

        if (total === 1) { countT = 1; }
        else if (total === 2) { countL = 1; countR = 1; } 
        else if (total === 3) { countL = 1; countT = 1; countR = 1; } 
        else if (total === 4) { countL = 1; countT = 2; countR = 1; } 
        else if (total === 5) { countL = 2; countT = 1; countR = 2; } 
        else {
            countL = 2;
            countR = 2;
            countT = total - 4;
        }

        const leftGroup = otherPlayers.slice(0, countL);
        const topGroup = otherPlayers.slice(countL, countL + countT);
        const rightGroup = otherPlayers.slice(countL + countT);

        leftGroup.forEach((p, i) => {
            const topPos = countL === 1 ? '40%' : (i === 0 ? '55%' : '35%'); 
            layoutConfig.push({ p, pos: { top: topPos, left: 30, transform: 'translateY(-50%)' }, timerPos: 'right' });
        });

        topGroup.forEach((p, i) => {
            let leftPos;
            if (countT === 1) {
                leftPos = '50%';
            } else {
                const start = 20; 
                const end = 80;
                const step = (end - start) / (countT - 1);
                leftPos = `${start + i * step}%`;
            }
            layoutConfig.push({ p, pos: { top: 10, left: leftPos, transform: 'translateX(-50%)' }, timerPos: 'bottom' });
        });

        rightGroup.forEach((p, i) => {
            const topPos = countR === 1 ? '40%' : (i === 0 ? '35%' : '55%');
            layoutConfig.push({ p, pos: { top: topPos, right: 10, transform: 'translateY(-50%)' }, timerPos: 'left' });
        });

        const me = players[safeMyIndex];
        const allItems = [
            { p: me, pos: { bottom: 25, left: 20, zIndex: 100 }, hideTimer: true }, 
            ...layoutConfig
        ];

        return allItems.map(({ p, pos, timerPos, hideTimer }, i) => {
            const info = (playersInfo && playersInfo[p.id]) || {};
            const isBot = info.isBot || p.isBot;
            const isAuto = info.isAutoPlay;
            const rankIndex = finishedRank ? finishedRank.indexOf(p.id) : -1;
            const finishedRankVal = rankIndex !== -1 ? rankIndex + 1 : null;
            
            // [å…³é”®] æå– Team
            const team = info.team;

            return (
                <div key={p.id} style={{...avatarStyleOverride, position: 'absolute', ...pos}}> 
                    <PlayerAvatar 
                        player={p} 
                        isTurn={p.id === currentTurnId} 
                        score={playerScores[p.id] || 0} 
                        targetScore={roomConfig.targetScore} 
                        isMySocket={p.id === mySocketId}
                        remainingSeconds={turnRemaining}
                        rank={finishedRankVal}
                        timerPosition={timerPos}
                        hideTimer={hideTimer} 
                        cardCount={handCounts[p.id] || 0}
                        showCardCountMode={roomConfig.showCardCountMode}
                        team={team} // [æ–°å¢] ä¼ é€’é˜Ÿä¼ä¿¡æ¯
                    />
                    <div style={{position: 'absolute', top: -10, right: -10, display: 'flex', gap: 5}}>
                        {isBot && <div style={styles.statusBadgeBot}><Bot size={12}/> AI</div>}
                        {isAuto && <div style={styles.statusBadgeAuto}><Zap size={12}/> æ‰˜ç®¡</div>}
                    </div>
                </div>
            );
        });
    };

    // [æ–°å¢] æ¸²æŸ“ç»“ç®—é¢æ¿çš„é˜Ÿä¼åˆ†æ•°æ 
    const renderTeamScoreBoard = () => {
        const { hasTeams, redScore, blueScore } = getTeamScores();
        if (!hasTeams) return null;

        return (
            <div style={{
                display: 'flex', justifyContent: 'center', gap: 20, marginBottom: 20, 
                padding: '10px', background: '#f0f3f5', borderRadius: 12
            }}>
                <div style={{display:'flex', flexDirection:'column', alignItems:'center', color:'#e74c3c'}}>
                    <div style={{fontSize: 12, fontWeight: 'bold'}}><Shield size={12} fill="currentColor"/> çº¢é˜Ÿæ€»åˆ†</div>
                    <div style={{fontSize: 24, fontWeight: 'bold'}}>{redScore}</div>
                </div>
                <div style={{width:1, background:'#ccc'}}></div>
                <div style={{display:'flex', flexDirection:'column', alignItems:'center', color:'#3498db'}}>
                    <div style={{fontSize: 12, fontWeight: 'bold'}}><Shield size={12} fill="currentColor"/> è“é˜Ÿæ€»åˆ†</div>
                    <div style={{fontSize: 24, fontWeight: 'bold'}}>{blueScore}</div>
                </div>
            </div>
        );
    };

    return (
        <div style={styles.gameTable} onMouseUp={() => { }}>
            <div style={styles.gameSafeArea}>
                
                <div className="gameLogPanel">
                     <GameLogPanel logs={gameLogs} />
                </div>

                <div style={styles.tableHeader}>
                    <div style={styles.roomBadgeContainer}>
                        <div style={styles.roomBadge}>Room {roomId}</div>
                        
                        <button 
                            style={{
                                pointerEvents: 'auto', 
                                background: amIAutoPlay ? '#e67e22' : 'rgba(255,255,255,0.1)', 
                                border: '1px solid rgba(255,255,255,0.3)',
                                color: '#ecf0f1',
                                borderRadius: 15, 
                                padding: '4px 8px',
                                display: 'flex', alignItems: 'center', justifyContent: 'center',
                                cursor: 'pointer',
                                fontSize: 11,
                                fontWeight: 'bold',
                                transition: 'all 0.2s',
                                whiteSpace: 'nowrap'
                            }}
                            onClick={handleToggleAutoPlay}
                            title="ç‚¹å‡»å¼€å¯/å…³é—­ç³»ç»Ÿæ‰˜ç®¡"
                        >
                            <Zap size={12} style={{marginRight: 4}} fill={amIAutoPlay ? "currentColor" : "none"}/>
                            {amIAutoPlay ? 'æ‰˜ç®¡ä¸­' : 'æ‰˜ç®¡'}
                        </button>
                    </div>

                    <div style={{display:'flex', gap: 10, marginLeft: 'auto'}}>
                        <button 
                            style={{...styles.glassButton, padding: '8px 12px', pointerEvents: 'auto'}} 
                            onClick={toggleFullScreen}
                            title={isFullScreen ? "é€€å‡ºå…¨å±" : "è¿›å…¥å…¨å±"}
                        >
                            {isFullScreen ? <Minimize size={18}/> : <Maximize size={18}/>}
                        </button>

                        <button style={styles.sortButton} onClick={toggleSort}>
                            <Layers size={16} style={{marginRight:5}}/> {sortMode === 'POINT' ? 'ç‚¹æ•°' : 'èŠ±è‰²'}
                        </button>
                    </div>
                </div>

                <div style={styles.scoreBoard}>
                    <div style={{fontSize: 10, opacity: 0.8, textTransform:'uppercase'}}>POINTS</div>
                    <div style={{fontSize: 24, fontWeight: 'bold', color: '#f1c40f', display:'flex', alignItems:'center', justifyContent:'center', gap:5}}>
                        <Coins size={20} /> {pendingPoints}
                    </div>
                </div>

                <div style={styles.infoMessage}>{displayMessage}</div>

                {/* å¼¹çª—åŒºåŸŸ */}
                {(winner || roundResult || grandResult) && (
                    <div style={styles.modalOverlay}>
                        <div className="modal-content-wrapper" style={styles.modalContent}>
                            {grandResult ? (
                                <>
                                    <Crown size={80} color="#e74c3c" style={{marginBottom: 20}} />
                                    <h2 style={{fontSize: 32, marginBottom: 10, color:'#2c3e50'}}>æœ€ç»ˆå† å†›: {grandResult.grandWinner}</h2>
                                    
                                    {/* [æ–°å¢] é˜Ÿä¼æ€»åˆ†å±•ç¤º */}
                                    {renderTeamScoreBoard()}

                                    <button style={{...styles.primaryButton, fontSize: 18}} onClick={handleStartGame}>é‡æ–°å¼€å§‹</button>
                                </>
                            ) : roundResult ? (
                                <>
                                    <Coins size={60} color="#f1c40f" style={{marginBottom: 20}} />
                                    <h2 style={{fontSize: 28}}>å°å±€ç»“æŸ</h2>
                                    <div style={{fontSize: 20}}>èƒœè€…: <span style={{color:'#27ae60'}}>{roundResult.roundWinner}</span></div>
                                    <div style={{fontSize: 32, fontWeight:'bold', color:'#f1c40f', margin:'10px 0'}}>+{roundResult.pointsEarned} åˆ†</div>
                                    
                                    {/* [æ–°å¢] é˜Ÿä¼æ€»åˆ†å±•ç¤º */}
                                    {renderTeamScoreBoard()}

                                    <div style={{
                                        color:'#666', fontSize:14, marginBottom:30, 
                                        whiteSpace: 'pre-wrap', lineHeight: '1.6', 
                                        maxHeight: 200, overflowY: 'auto', textAlign: 'left',
                                        background: '#f8f9fa', padding: 15, borderRadius: 8
                                    }}>
                                        {roundResult.detail}
                                    </div>

                                    {amIHost ? <button style={styles.primaryButton} onClick={handleNextRound}>ä¸‹ä¸€å±€</button> : <div style={{color:'#999'}}>ç­‰å¾…æˆ¿ä¸»...</div>}
                                </>
                            ) : null}
                        </div>
                    </div>
                )}

                <div style={styles.tableCenter}>
                    {lastPlayed.length > 0 && (
                        <div style={{animation: 'popIn 0.3s'}}>
                            <div style={styles.playerNameTag}>{lastPlayerName}</div>
                            <div style={styles.playedRow}> 
                                {lastPlayed.map((c, i) => <MiniCard key={i} cardVal={c} index={i} />)}
                            </div>
                        </div>
                    )}
                </div>

                {renderPlayers()}

                <div 
                    ref={handContainerRef}
                    style={{
                        ...styles.handArea, 
                        opacity: amIAutoPlay ? 0.6 : 1, 
                        filter: amIAutoPlay ? 'grayscale(0.6)' : 'none',
                        pointerEvents: amIAutoPlay ? 'none' : 'auto' 
                    }}
                    onTouchStart={!amIAutoPlay ? handleTouchStart : undefined}
                    onTouchMove={!amIAutoPlay ? handleTouchMove : undefined}
                    onTouchEnd={!amIAutoPlay ? handleTouchEnd : undefined}
                >
                    {amIAutoPlay && (
                        <div style={{
                            position: 'absolute', top: -40, left: 20,
                            background: 'rgba(230, 126, 34, 0.9)', color: 'white', padding: '5px 10px', 
                            borderRadius: 20, fontSize: 12, fontWeight: 'bold', display: 'flex', alignItems: 'center', gap: 5,
                            boxShadow: '0 4px 10px rgba(0,0,0,0.3)', zIndex: 50
                        }}>
                            <Bot size={14} /> ç³»ç»Ÿä»£æ‰“ä¸­
                        </div>
                    )}
                    
                    {myHand.map((c, i) => (
                        <Card 
                            key={`${c}-${i}`} 
                            cardVal={c} 
                            index={i} 
                            isSelected={selectedCards.includes(c)} 
                            onClick={handleMouseDown} 
                            onMouseEnter={handleMouseEnter} 
                            spacing={cardSpacing} 
                        />
                    ))}
                </div>

                <div style={styles.actionBar}>
                    {!winner && !roundResult && !grandResult && (
                        <div style={{display:'flex', alignItems: 'center', gap: 20}}>
                            {amIAutoPlay ? (
                                <button 
                                    style={{
                                        ...styles.playButton, 
                                        background: '#e74c3c', 
                                        width: 180,
                                        fontSize: 16,
                                        display: 'flex', justifyContent: 'center', alignItems: 'center'
                                    }} 
                                    onClick={handleToggleAutoPlay}
                                >
                                    <Zap size={18} style={{marginRight:8}}/> å–æ¶ˆæ‰˜ç®¡
                                </button>
                            ) : (
                                <>
                                    {isMyTurn ? (
                                        <>
                                            <button style={styles.passButton} onClick={handlePass}>ä¸è¦</button>
                                            
                                            <TimerComponent initialSeconds={turnRemaining} totalSeconds={60} position="inline" />
                                            
                                            <button style={styles.playButton} onClick={handlePlayCards}>å‡ºç‰Œ</button>
                                        </>
                                    ) : (
                                        <div style={styles.waitingBadge}><Clock size={20} className="spin" /> {waitingText}</div>
                                    )}
                                </>
                            )}
                        </div>
                    )}
                </div>
            </div>
            
            <style>{`
                .statusBadgeBot { background: #34495e; color: white; padding: 2px 6px; borderRadius: 10px; fontSize: 10px; display: flex; align-items: center; gap: 2px; border: 1px solid rgba(255,255,255,0.3); }
                .statusBadgeAuto { background: #e67e22; color: white; padding: 2px 6px; borderRadius: 10px; fontSize: 10px; display: flex; align-items: center; gap: 2px; border: 1px solid rgba(255,255,255,0.3); animation: pulse 2s infinite; }
                @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
            `}</style>
        </div>
    );
};

================================================================================
FILE PATH: client\src\screens\LobbyScreen.jsx
================================================================================
// å¤§å…é¡µ - æ”¯æŒæˆ¿ä¸»æ¢åº§ + ç»„é˜Ÿæ¨¡å¼æ˜¾ç¤º + ä¿®å¤ç§»åŠ¨ç«¯æº¢å‡º

import React from 'react';
import { Target, Layers, User, Play, Clock, Bot, Shield, ArrowUp, ArrowDown } from 'lucide-react';
import { styles } from '../styles.js';

export const LobbyScreen = ({ roomId, roomConfig, players, mySocketId, handleStartGame, handleAddBot, handleSwitchSeat }) => {
    
    // åˆ¤æ–­è‡ªå·±æ˜¯ä¸æ˜¯æˆ¿ä¸»
    const amIHost = players.find(p => p.id === mySocketId)?.isHost;
    
    // åˆ¤æ–­æ˜¯å¦å¼€å¯äº†ç»„é˜Ÿæ¨¡å¼ (å¼€å…³å¼€å¯ ä¸” äººæ•°æ˜¯å¶æ•°)
    const isTeamMode = roomConfig.isTeamMode && roomConfig.maxPlayers % 2 === 0;

    return (
    <div style={styles.container}>
      <div style={styles.lobbyCard} className="mobile-layout-column">
          
          <div className="mobile-lobby-content" style={{display:'flex', flexDirection:'column', height:'100%', width: '100%', overflow:'hidden', borderRadius: 20}}>
            
            {/* å¤´éƒ¨ä¿¡æ¯ */}
            <div style={styles.lobbyHeader}>
                <div style={{display:'flex', alignItems:'center', gap: 10}}>
                    <h2 style={{margin:0, fontSize: 24}}>æˆ¿é—´: <span style={{fontFamily:'monospace', color:'#27ae60'}}>{roomId}</span></h2>
                    {/* [æ–°å¢] ç»„é˜Ÿæ¨¡å¼æ ‡ç­¾ */}
                    {isTeamMode && (
                        <span style={{background:'#27ae60', color:'white', fontSize:12, padding:'2px 8px', borderRadius:10, display:'flex', alignItems:'center', gap:4}}>
                            <Shield size={12}/> ç»„é˜Ÿæ¨¡å¼
                        </span>
                    )}
                </div>
                <div style={{display:'flex', gap:15}}>
                    <span style={styles.tag}><Target size={14}/> ç›®æ ‡ {roomConfig.targetScore}</span>
                    <span style={styles.tag}><Layers size={14}/> {roomConfig.deckCount}å‰¯</span>
                    <span style={styles.tag}><User size={14}/> {roomConfig.maxPlayers}äºº</span>
                </div>
            </div>

            {/* ç©å®¶åˆ—è¡¨åŒºåŸŸ */}
            <div style={styles.playerGrid} className="mobile-lobby-grid">
                {players.map((p, i) => {
                    // --- [æ–°å¢] ç»„é˜Ÿæ¨¡å¼è§†è§‰é€»è¾‘ ---
                    let teamColor = '#eee'; // é»˜è®¤è¾¹æ¡†
                    let teamBg = 'white';   // é»˜è®¤èƒŒæ™¯
                    let teamName = null;
                    
                    if (isTeamMode) {
                        const isRedTeam = i % 2 === 0; // 0, 2, 4... çº¢é˜Ÿ
                        teamColor = isRedTeam ? '#e74c3c' : '#3498db';
                        teamBg = isRedTeam ? '#fdedec' : '#eaf2f8';
                        teamName = isRedTeam ? 'çº¢é˜Ÿ' : 'è“é˜Ÿ';
                    }

                    // è‡ªå·±çš„é«˜äº®å¤„ç† (åœ¨ç»„é˜Ÿæ¨¡å¼ä¸‹å åŠ ï¼Œæ™®é€šæ¨¡å¼ä¸‹å•ç‹¬æ˜¾ç¤º)
                    const isMe = p.id === mySocketId;
                    if (isMe && !isTeamMode) {
                        teamBg = '#f0fbf4';
                        teamColor = '#27ae60';
                    }
                    const borderWidth = isMe ? 3 : 2;

                    return (
                        <div key={p.id} style={{
                            ...styles.lobbyPlayer, 
                            borderColor: isMe ? '#2ecc71' : teamColor, 
                            background: teamBg,
                            borderWidth: borderWidth,
                            position: 'relative'
                        }}>
                            {/* [æ–°å¢] ç»„é˜Ÿè§’æ ‡ */}
                            {teamName && (
                                <div style={{
                                    position: 'absolute', top: 0, left: 0, 
                                    background: teamColor, color: 'white', 
                                    fontSize: 10, padding: '2px 8px', 
                                    borderBottomRightRadius: 8, borderTopLeftRadius: 8
                                }}>
                                    {teamName}
                                </div>
                            )}

                            {/* --- [æ–°å¢] æˆ¿ä¸»è°ƒä½æŒ‰é’® (æ‰€æœ‰æ¨¡å¼é€šç”¨) --- */}
                            {amIHost && players.length > 1 && (
                                <div style={{
                                    position: 'absolute', right: 5, top: '50%', transform: 'translateY(-50%)',
                                    display:'flex', flexDirection:'column', gap:4
                                }}>
                                    {/* ä¸Šç§»æŒ‰é’® (éç¬¬ä¸€ä½æ˜¾ç¤º) */}
                                    {i > 0 && (
                                        <button 
                                            onClick={(e) => { e.stopPropagation(); handleSwitchSeat(i, i - 1); }}
                                            style={{
                                                padding:4, borderRadius:4, border:'1px solid #ccc', 
                                                background:'white', cursor:'pointer', lineHeight:0
                                            }}
                                            title="ä¸Šç§»"
                                        >
                                            <ArrowUp size={14} color="#666"/>
                                        </button>
                                    )}
                                    {/* ä¸‹ç§»æŒ‰é’® (éæœ€åä¸€ä½æ˜¾ç¤º) */}
                                    {i < players.length - 1 && (
                                        <button 
                                            onClick={(e) => { e.stopPropagation(); handleSwitchSeat(i, i + 1); }}
                                            style={{
                                                padding:4, borderRadius:4, border:'1px solid #ccc', 
                                                background:'white', cursor:'pointer', lineHeight:0
                                            }}
                                            title="ä¸‹ç§»"
                                        >
                                            <ArrowDown size={14} color="#666"/>
                                        </button>
                                    )}
                                </div>
                            )}

                            <div style={styles.avatarLarge}>
                                {p.isBot ? <Bot size={40} /> : p.name[0]}
                            </div>
                            <div style={{fontWeight: 'bold', display:'flex', alignItems:'center', gap:5}}>
                                {p.name}
                                {p.isBot && <span style={{fontSize:10, background:'#eee', padding:'2px 5px', borderRadius:4}}>AI</span>}
                            </div>
                            {p.isHost && <span style={styles.hostBadge}>æˆ¿ä¸»</span>}
                        </div>
                    );
                })}
                
                {/* è™šæ‹Ÿç©ºä½ */}
                {Array.from({length: roomConfig.maxPlayers - players.length}).map((_, i) => (
                    <div key={`empty-${i}`} style={{...styles.lobbyPlayer, borderStyle: 'dashed', opacity: 0.5}}>
                        <div style={{...styles.avatarLarge, background:'#f0f0f0', color:'#ccc'}}>?</div>
                        <div style={{color:'#999'}}>ç­‰å¾…åŠ å…¥</div>
                    </div>
                ))}
            </div>

            {/* åº•éƒ¨æŒ‰é’® */}
            <div style={styles.lobbyFooter} className="mobile-lobby-footer">
                {players.find(p=>p.id===mySocketId)?.isHost ? (
                    <div style={{display:'flex', gap: 15, justifyContent: 'center'}}>
                        <button 
                            style={{...styles.primaryButton, background: '#7f8c8d', width:'auto', padding:'0 20px', fontSize: 16, marginTop:0}} 
                            onClick={handleAddBot}
                            disabled={players.length >= roomConfig.maxPlayers}
                        >
                            <Bot size={18} style={{marginRight:5}}/> +Bot
                        </button>

                        <button style={{...styles.primaryButton, width:'auto', padding:'0 30px', marginTop:0}} onClick={handleStartGame} disabled={players.length < 2}>
                            <Play size={18} style={{marginRight:5}}/> å¼€å§‹å¯¹æˆ˜
                        </button>
                    </div>
                ) : (
                    <div style={{color:'#999', fontSize: 14, display:'flex', alignItems:'center', gap:5}}><Clock size={16}/> ç­‰å¾…æˆ¿ä¸»å¼€å§‹...</div>
                )}
            </div>
          </div>
      </div>
    </div>
    );
};

================================================================================
FILE PATH: client\src\screens\LoginScreen.jsx
================================================================================
// ç™»å½•é¡µ - é€‚é…ç§»åŠ¨ç«¯ï¼ŒåŒ…å«è‡ªåŠ¨å…¨å±é€»è¾‘ + æ‰‹åŠ¨å…¨å±æŒ‰é’® + å‰©ä½™ç‰Œæ•°é…ç½® + [æ–°å¢]ç»„é˜Ÿå¼€å…³
import React, { useState } from 'react'; 
import { User, Monitor, RefreshCw, Plus, LogIn, Clock, Layers, Users, Target, Wifi, WifiOff, Award, Maximize, Minimize, Eye, Shield } from 'lucide-react'; 
import { styles } from '../styles.js';

export const LoginScreen = ({ 
    username, setUsername, 
    roomId, setRoomId, 
    roomConfig, setRoomConfig, 
    isCreatorMode, setIsCreatorMode, 
    handleRoomAction, 
    isLoading,
    isConnected 
}) => {
    
    // å…¨å±çŠ¶æ€ç®¡ç†
    const [isFullScreen, setIsFullScreen] = useState(false);

    // æ‰‹åŠ¨åˆ‡æ¢å…¨å±
    const toggleFullScreen = () => {
        if (!document.fullscreenElement) {
            const docEl = document.documentElement;
            const requestFull = docEl.requestFullscreen || docEl.webkitRequestFullscreen || docEl.mozRequestFullScreen || docEl.msRequestFullscreen;
            if (requestFull) {
                requestFull.call(docEl)
                    .then(() => setIsFullScreen(true))
                    .catch(err => console.log("å…¨å±è¯·æ±‚è¢«æ‹¦æˆª:", err));
            }
        } else {
            const exitFull = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen;
            if (exitFull) {
                exitFull.call(document)
                    .then(() => setIsFullScreen(false));
            }
        }
    };

    // å°è¯•è¯·æ±‚å…¨å±çš„è¾…åŠ©å‡½æ•°
    const tryEnterFullScreen = () => {
        try {
            if (!document.fullscreenElement) {
                const docEl = document.documentElement;
                const requestFull = docEl.requestFullscreen || docEl.webkitRequestFullscreen || docEl.mozRequestFullScreen || docEl.msRequestFullscreen;
                
                if (requestFull) {
                    requestFull.call(docEl)
                        .then(() => setIsFullScreen(true))
                        .catch(err => console.log("å…¨å±è‡ªåŠ¨è§¦å‘è¢«æ‹¦æˆª (æ­£å¸¸):", err));
                }
            }
        } catch (e) {
            console.log("å…¨å±é”™è¯¯:", e);
        }
    };

    const onActionClick = () => {
        tryEnterFullScreen(); 
        handleRoomAction();   
    };

    const renderConfigSlider = (icon, label, value, min, max, step, onChange, suffix = '') => (
        <div style={styles.configItem}>
            <div style={styles.configLabel}>
                <span style={{display:'flex', alignItems:'center', gap:6}}>{icon} {label}</span>
                <span style={styles.configValue}>{value}{suffix}</span>
            </div>
            <input 
                type="range" 
                style={styles.rangeInput}
                min={min} 
                max={max} 
                step={step || 1}
                value={value} 
                onChange={(e) => onChange(parseInt(e.target.value))}
            />
        </div>
    );

    return (
        <div style={styles.container}>
            <div style={styles.loginCard} className="mobile-layout-column">
                {/* å·¦ä¾§ï¼šå“ç‰Œå±•ç¤ºåŒº */}
                <div style={styles.loginLeft} className="mobile-login-left">
                    <div style={styles.logoCircle}>
                        <div style={styles.logoText}>510K</div>
                    </div>
                    <h1 style={styles.brandTitle}>æ‰‘å…‹å¯¹æˆ˜</h1>
                    <div style={styles.brandSubtitle}>å¤šäººåœ¨çº¿ Â· è‡ªç”±è§„åˆ™ Â· æé€Ÿç•…ç©</div>
                    
                    <div style={styles.featureList} className="hide-on-mobile">
                        <div style={styles.featureItem}>âœ¨ æ”¯æŒ 2-12 äººåŒå°ç«æŠ€</div>
                        <div style={styles.featureItem}>ğŸš€ åªæœ‰ 1 å‰¯ç‰Œ? ä¸ï¼Œç°åœ¨æ”¯æŒ 8 å‰¯!</div>
                        <div style={styles.featureItem}>â±ï¸ è‡ªå®šä¹‰æ€è€ƒæ—¶é—´ä¸è·èƒœç›®æ ‡</div>
                    </div>
                </div>

                {/* å³ä¾§ï¼šæ“ä½œåŒº */}
                <div style={styles.loginRight} className="mobile-login-right">
                    {/* é¡¶éƒ¨çŠ¶æ€æ  */}
                    <div style={{
                        display: 'flex', 
                        justifyContent: 'space-between', 
                        alignItems: 'center',
                        marginBottom: 20
                    }}>
                        <button 
                            onClick={toggleFullScreen}
                            style={{
                                background: '#f8f9fa', border: '1px solid #e1e4e8', borderRadius: 20, padding: '6px 12px',
                                cursor: 'pointer', color: '#7f8c8d', display: 'flex', alignItems: 'center', gap: 6,
                                fontSize: 12, fontWeight: 'bold', transition: 'all 0.2s'
                            }}
                        >
                            {isFullScreen ? <Minimize size={14}/> : <Maximize size={14}/>}
                            <span>{isFullScreen ? 'é€€å‡ºå…¨å±' : 'å…¨å±æ¨¡å¼'}</span>
                        </button>

                        <div style={{
                            display: 'flex', alignItems: 'center', gap: 6, fontSize: 12, padding: '6px 12px', borderRadius: 20,
                            background: isConnected ? '#eafaf1' : '#fdedec', color: isConnected ? '#27ae60' : '#e74c3c',
                            fontWeight: 'bold', border: `1px solid ${isConnected ? '#abebc6' : '#fadbd8'}`
                        }}>
                            {isConnected ? <Wifi size={14}/> : <WifiOff size={14}/>}
                            {isConnected ? 'å·²è¿æ¥' : 'è¿æ¥ä¸­...'}
                        </div>
                    </div>

                    {/* é¡¶éƒ¨ Tab åˆ‡æ¢ */}
                    <div style={styles.tabs}>
                        <button style={!isCreatorMode ? styles.tabBtnActive : styles.tabBtn} onClick={()=>setIsCreatorMode(false)}>åŠ å…¥æˆ¿é—´</button>
                        <button style={isCreatorMode ? styles.tabBtnActive : styles.tabBtn} onClick={()=>setIsCreatorMode(true)}>åˆ›å»ºæˆ¿é—´</button>
                    </div>

                    <div style={styles.formContent}>
                        <div style={styles.inputGroup}>
                            <User size={18} color="#7f8c8d" />
                            <input style={styles.input} value={username} onChange={e=>setUsername(e.target.value)} placeholder="è¯·è¾“å…¥ä½ çš„æ˜µç§°" maxLength={10}/>
                        </div>
                        <div style={styles.inputGroup}>
                            <Monitor size={18} color="#7f8c8d" />
                            <input style={styles.input} value={roomId} onChange={e=>setRoomId(e.target.value)} placeholder="è¯·è¾“å…¥æˆ¿é—´å· (å¦‚: 888)" maxLength={6}/>
                        </div>

                        {/* åˆ›å»ºæ¨¡å¼ä¸‹çš„é«˜çº§é…ç½®åŒº */}
                        {isCreatorMode && (
                            <div style={styles.advancedConfigPanel}>
                                <div style={styles.configGrid}>
                                    {renderConfigSlider(<Users size={14}/>, "ç©å®¶äººæ•°", roomConfig.maxPlayers, 2, 12, 1, v=>setRoomConfig({...roomConfig, maxPlayers:v}), 'äºº')}
                                    {renderConfigSlider(<Layers size={14}/>, "ç‰Œåº“æ•°é‡", roomConfig.deckCount, 1, 8, 1, v=>setRoomConfig({...roomConfig, deckCount:v}), 'å‰¯')}
                                    {renderConfigSlider(<Target size={14}/>, "è·èƒœç›®æ ‡", roomConfig.targetScore, 500, 5000, 500, v=>setRoomConfig({...roomConfig, targetScore:v}), 'åˆ†')}
                                    
                                    {/* [æ–°å¢] ç»„é˜Ÿå¯¹æŠ—å¼€å…³ */}
                                    <div style={{...styles.configItem, marginTop: 10, padding: '10px', background: roomConfig.maxPlayers % 2 !== 0 ? '#f0f0f0' : '#e8f8f5', borderRadius: 8, opacity: roomConfig.maxPlayers % 2 !== 0 ? 0.6 : 1, gridColumn: '1 / -1'}}>
                                        <div style={{display:'flex', justifyContent:'space-between', alignItems:'center'}}>
                                            <div style={{display:'flex', alignItems:'center', gap:6, fontWeight:'600', color: roomConfig.maxPlayers % 2 !== 0 ? '#999' : '#27ae60'}}>
                                                <Shield size={16} /> ç»„é˜Ÿå¯¹æŠ—æ¨¡å¼ (2v2, 3v3...)
                                            </div>
                                            <label style={{position:'relative', display:'inline-block', width:40, height:20}}>
                                                <input 
                                                    type="checkbox" 
                                                    style={{opacity:0, width:0, height:0}}
                                                    checked={roomConfig.isTeamMode && roomConfig.maxPlayers % 2 === 0}
                                                    disabled={roomConfig.maxPlayers % 2 !== 0}
                                                    onChange={(e) => setRoomConfig({...roomConfig, isTeamMode: e.target.checked})}
                                                />
                                                <span style={{
                                                    position:'absolute', cursor: roomConfig.maxPlayers % 2 !== 0 ? 'not-allowed' : 'pointer', top:0, left:0, right:0, bottom:0, 
                                                    backgroundColor: (roomConfig.isTeamMode && roomConfig.maxPlayers % 2 === 0) ? '#27ae60' : '#ccc', 
                                                    transition:'.4s', borderRadius: 20
                                                }}>
                                                    <span style={{
                                                        position:'absolute', content:"", height:16, width:16, left:2, bottom:2, 
                                                        backgroundColor:'white', transition:'.4s', borderRadius:'50%',
                                                        transform: (roomConfig.isTeamMode && roomConfig.maxPlayers % 2 === 0) ? 'translateX(20px)' : 'translateX(0)'
                                                    }}></span>
                                                </span>
                                            </label>
                                        </div>
                                        <div style={{fontSize: 11, color: '#7f8c8d', marginTop: 4}}>
                                            {roomConfig.maxPlayers % 2 !== 0 ? "âš ï¸ éœ€è¦å¶æ•°äººæ•° (4, 6...) æ‰èƒ½å¼€å¯" : "å¼€å¯åï¼Œé—´éš”å…¥åº§ä¸ºé˜Ÿå‹ (1å’Œ3é˜Ÿå‹ï¼Œ2å’Œ4é˜Ÿå‹)"}
                                        </div>
                                    </div>

                                    {/* å€’è®¡æ—¶é€‰æ‹© */}
                                    <div style={styles.configItem}>
                                        <div style={styles.configLabel}>
                                            <span style={{display:'flex', alignItems:'center', gap:6}}><Clock size={14}/> å‡ºç‰Œæ—¶é™</span>
                                            <span style={styles.configValue}>{roomConfig.turnTimeout / 1000}ç§’</span>
                                        </div>
                                        <div style={styles.radioGroup}>
                                            {[30, 60, 90, 120].map(sec => (
                                                <button 
                                                    key={sec}
                                                    style={roomConfig.turnTimeout === sec * 1000 ? styles.radioBtnActive : styles.radioBtn}
                                                    onClick={() => setRoomConfig({...roomConfig, turnTimeout: sec * 1000})}
                                                >
                                                    {sec}s
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                </div>

                                {/* å‰©ä½™ç‰Œæ•°æ˜¾ç¤ºé…ç½® */}
                                <div style={{marginTop: 20, paddingTop: 15, borderTop: '1px solid #f0f0f0'}}>
                                    <div style={{display:'flex', alignItems:'center', gap:6, color:'#7f8c8d', fontSize:14, marginBottom:10, fontWeight:600}}>
                                        <Eye size={14}/> å‰©ä½™ç‰Œæ•°æ˜¾ç¤ºè§„åˆ™
                                    </div>
                                    <div style={styles.radioGroup}>
                                        <button 
                                            style={roomConfig.showCardCountMode === 0 ? styles.radioBtnActive : styles.radioBtn}
                                            onClick={() => setRoomConfig({...roomConfig, showCardCountMode: 0})}
                                        >
                                            ä¸æ˜¾ç¤º
                                        </button>
                                        <button 
                                            style={roomConfig.showCardCountMode === 1 ? styles.radioBtnActive : styles.radioBtn}
                                            onClick={() => setRoomConfig({...roomConfig, showCardCountMode: 1})}
                                        >
                                            â‰¤3å¼ æ˜¾ç¤º
                                        </button>
                                        <button 
                                            style={roomConfig.showCardCountMode === 2 ? styles.radioBtnActive : styles.radioBtn}
                                            onClick={() => setRoomConfig({...roomConfig, showCardCountMode: 2})}
                                        >
                                            ä¸€ç›´æ˜¾ç¤º
                                        </button>
                                    </div>
                                </div>

                                {/* æ’åèµç½šè®¾ç½®åŒºåŸŸ */}
                                <div style={{marginTop: 20, paddingTop: 20, borderTop: '1px solid #f0f0f0'}}>
                                    <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom: 15}}>
                                        <div style={{display:'flex', alignItems:'center', gap:8, fontWeight:'600', color:'#555', fontSize:14}}>
                                            <Award size={16} /> å¯ç”¨æ’åèµç½š (è¿›è´¡/æŠ“åˆ†)
                                        </div>
                                        <label style={{position:'relative', display:'inline-block', width:40, height:20}}>
                                            <input 
                                                type="checkbox" 
                                                style={{opacity:0, width:0, height:0}}
                                                checked={roomConfig.enableRankPenalty}
                                                onChange={(e) => setRoomConfig({...roomConfig, enableRankPenalty: e.target.checked})}
                                            />
                                            <span style={{
                                                position:'absolute', cursor:'pointer', top:0, left:0, right:0, bottom:0, 
                                                backgroundColor: roomConfig.enableRankPenalty ? '#27ae60' : '#ccc', 
                                                transition:'.4s', borderRadius: 20
                                            }}>
                                                <span style={{
                                                    position:'absolute', content:"", height:16, width:16, left:2, bottom:2, 
                                                    backgroundColor:'white', transition:'.4s', borderRadius:'50%',
                                                    transform: roomConfig.enableRankPenalty ? 'translateX(20px)' : 'translateX(0)'
                                                }}></span>
                                            </span>
                                        </label>
                                    </div>

                                    {/* å¦‚æœå¼€å¯ï¼Œæ˜¾ç¤ºè¯¦ç»†åˆ†å€¼è®¾ç½® */}
                                    {roomConfig.enableRankPenalty && (
                                        <div style={{background:'#f9f9f9', padding: 15, borderRadius: 8, display:'flex', gap: 20, fontSize: 13}}>
                                            <div style={{flex:1}}>
                                                <div style={{marginBottom:5, color:'#7f8c8d'}}>å¤´å°¾èµç½š (ç¬¬1å vs å€’1)</div>
                                                <input 
                                                    type="number" style={{...styles.input, background:'white', height: 35, padding: '0 10px'}} 
                                                    value={roomConfig.rankPenaltyScores[0]}
                                                    onChange={e => {
                                                        const val = Math.max(0, parseInt(e.target.value) || 0);
                                                        setRoomConfig({...roomConfig, rankPenaltyScores: [val, roomConfig.rankPenaltyScores[1]]});
                                                    }}
                                                />
                                            </div>
                                            <div style={{flex:1}}>
                                                <div style={{marginBottom:5, color:'#7f8c8d'}}>æ¬¡çº§èµç½š (ç¬¬2å vs å€’2)</div>
                                                <input 
                                                    type="number" style={{...styles.input, background:'white', height: 35, padding: '0 10px'}} 
                                                    value={roomConfig.rankPenaltyScores[1]}
                                                    onChange={e => {
                                                        const val = Math.max(0, parseInt(e.target.value) || 0);
                                                        setRoomConfig({...roomConfig, rankPenaltyScores: [roomConfig.rankPenaltyScores[0], val]});
                                                    }}
                                                />
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}

                        <div style={{flex: 1}}></div>

                        <button 
                            style={{
                                ...styles.primaryButton,
                                opacity: (!isConnected || isLoading) ? 0.7 : 1,
                                cursor: (!isConnected || isLoading) ? 'not-allowed' : 'pointer',
                                background: (!isConnected) ? '#95a5a6' : '#2c3e50'
                            }} 
                            onClick={onActionClick} 
                            disabled={isLoading || !isConnected}
                        >
                            {(isLoading || !isConnected) ? <RefreshCw className="spin" size={20}/> : (isCreatorMode ? <Plus size={20}/> : <LogIn size={20}/>)}
                            <span style={{marginLeft:10}}>
                                {!isConnected ? "æ­£åœ¨è¿æ¥æœåŠ¡å™¨..." : (isLoading ? "å¤„ç†ä¸­..." : (isCreatorMode ? "ç«‹å³åˆ›å»ºæˆ¿é—´" : "è¿›å…¥æ¸¸æˆæˆ¿é—´"))}
                            </span>
                        </button>
                        
                        {!isConnected && (
                            <div style={{textAlign:'center', marginTop: 15, fontSize: 13, color:'#e74c3c', background:'#fdedec', padding:'8px', borderRadius:8}}>
                                âš ï¸ é¦–æ¬¡è®¿é—®å¯èƒ½éœ€è¦ 30-50ç§’ å”¤é†’æœåŠ¡å™¨ï¼Œè¯·è€å¿ƒç­‰å¾…å³ä¸Šè§’å˜ä¸ºç»¿è‰²ã€‚
                            </div>
                        )}
                    </div>
                </div>
            </div>
            <style>{`.spin { animation: spin 1s linear infinite; } @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }`}</style>
        </div>
    );
};

================================================================================
FILE PATH: client\src\styles.js
================================================================================
// ç»Ÿä¸€æ ·å¼æ–‡ä»¶ - ç§»åŠ¨ç«¯é€‚é…ç‰ˆ
// [å®Œæ•´ç‰ˆ] åŒ…å«æ‰€æœ‰åŸæœ‰å¸ƒå±€ã€æ‹‡æŒ‡çƒ­åŒºã€ä»¥åŠæ–°å¢çš„æ»‘åŠ¨é€‰ç‰Œæ”¯æŒå’Œå‰©ä½™ç‰Œæ•°å¾½ç« 

export const styles = {
  // ============================
  // å…¨å±€å®¹å™¨
  // ============================
  container: { 
      height: '100dvh', // ä½¿ç”¨ 100dvh è‡ªåŠ¨é€‚é…åŠ¨æ€åœ°å€æ 
      width: '100vw', 
      display: 'flex', 
      justifyContent: 'center', 
      alignItems: 'center', 
      background: '#1e272e', 
      fontFamily: '"Segoe UI", Roboto, Helvetica, Arial, sans-serif', 
      backgroundImage: 'radial-gradient(circle at top right, #34495e 0%, #000000 100%)',
      overflow: 'hidden' 
  },
  
  // ============================
  // ç™»å½•é¡µ (Login Screen)
  // ============================
  loginCard: { 
      background: 'white', 
      borderRadius: 24, 
      width: '95%', 
      maxWidth: '1100px', 
      minHeight: '600px', 
      maxHeight: '90vh',
      display: 'flex', 
      boxShadow: '0 50px 100px -20px rgba(0,0,0,0.7)',
      overflow: 'hidden',
      animation: 'popIn 0.5s ease-out'
  },

  // å·¦ä¾§å“ç‰ŒåŒº
  loginLeft: { 
      flex: 0.8, 
      background: 'linear-gradient(135deg, #27ae60 0%, #2ecc71 100%)', 
      padding: '60px 50px', 
      display:'flex', 
      flexDirection:'column', 
      justifyContent:'center', 
      alignItems: 'flex-start',
      color: 'white',
      position: 'relative',
      overflow: 'hidden'
  },
  logoCircle: { width: 90, height: 90, background: 'rgba(255,255,255,0.2)', borderRadius: 24, display:'flex', alignItems:'center', justifyContent:'center', marginBottom: 25, backdropFilter: 'blur(10px)' },
  logoText: { fontSize: 28, fontWeight: '900', color: 'white' },
  brandTitle: { fontSize: 48, fontWeight: '800', margin: '0 0 15px 0', letterSpacing: -1.5 },
  brandSubtitle: { fontSize: 18, opacity: 0.9, marginBottom: 50, fontWeight: '500' },
  featureList: { marginTop: 'auto', display: 'flex', flexDirection: 'column', gap: 15 },
  featureItem: { fontSize: 15, opacity: 0.95, display:'flex', alignItems:'center', fontWeight: '500' },

  // å³ä¾§è¡¨å•åŒº
  loginRight: { 
      flex: 1.2, 
      padding: '50px 60px', 
      display: 'flex',
      flexDirection: 'column',
      background: '#ffffff',
      overflowY: 'auto' 
  },
  
  tabs: { display: 'flex', gap: 35, marginBottom: 35, borderBottom: '2px solid #f1f2f6' },
  tabBtn: { padding: '12px 0', fontSize: 18, fontWeight: 'bold', color: '#95a5a6', background: 'none', border: 'none', cursor: 'pointer', transition: 'all 0.3s', borderBottom: '3px solid transparent', marginBottom: -3 },
  tabBtnActive: { padding: '12px 0', fontSize: 18, fontWeight: 'bold', color: '#2c3e50', background: 'none', border: 'none', cursor: 'pointer', transition: 'all 0.3s', borderBottom: '3px solid #27ae60', marginBottom: -3 },
  
  formContent: { flex: 1, display: 'flex', flexDirection: 'column' },

  inputGroup: { display: 'flex', alignItems: 'center', background: '#f8f9fa', borderRadius: 14, padding: '0 20px', marginBottom: 20, border: '1px solid #e1e4e8', height: 60, transition: 'all 0.2s' },
  input: { padding: '10px', border: 'none', background: 'transparent', flex: 1, outline:'none', fontSize: 17, color: '#2c3e50', fontWeight: '500' },

  // é«˜çº§é…ç½®é¢æ¿
  advancedConfigPanel: { 
      marginTop: 15, 
      background: '#fff', 
      borderRadius: 12,
      animation: 'fadeIn 0.4s ease'
  },
  configGrid: {
      display: 'grid',
      gridTemplateColumns: '1fr 1fr', 
      gap: '25px 35px'
  },
  configItem: { display: 'flex', flexDirection: 'column', gap: 10 },
  configLabel: { display: 'flex', justifyContent: 'space-between', fontSize: 14, color: '#7f8c8d', fontWeight: '600' },
  configValue: { color: '#27ae60', fontWeight: 'bold' },
  
  rangeInput: { width: '100%', cursor: 'pointer', accentColor: '#27ae60', height: 6 },

  radioGroup: { display: 'flex', gap: 10 },
  radioBtn: { flex: 1, padding: '8px 0', borderRadius: 8, border: '1px solid #e1e4e8', background: 'white', color: '#7f8c8d', fontSize: 13, cursor: 'pointer', transition: 'all 0.2s' },
  radioBtnActive: { flex: 1, padding: '8px 0', borderRadius: 8, border: '1px solid #27ae60', background: '#eafaf1', color: '#27ae60', fontSize: 13, fontWeight: 'bold', cursor: 'pointer' },

  primaryButton: { 
      marginTop: 25, 
      width: '100%', 
      height: 65, 
      background: '#2c3e50', 
      color: 'white', 
      border: 'none', 
      borderRadius: 14, 
      fontWeight: 'bold', 
      cursor: 'pointer', 
      display: 'flex', 
      justifyContent: 'center', 
      alignItems: 'center', 
      fontSize: 19, 
      transition: 'all 0.2s', 
      boxShadow: '0 10px 25px rgba(44, 62, 80, 0.25)' 
  },

  // ============================
  // æ¸¸æˆç•Œé¢ (Game Screen)
  // ============================

  gameTable: { 
      height: '100dvh', // ä½¿ç”¨ 100dvh
      width: '100vw', 
      background: '#1e3c29', 
      backgroundImage: 'radial-gradient(circle at center, #2d7a54 0%, #173b25 100%)', 
      position: 'relative', 
      overflow: 'hidden', 
      display: 'flex', 
      flexDirection: 'column', 
      userSelect: 'none',
      
      // [å…³é”®] å¿…é¡»åŠ ä¸Š border-boxï¼Œé˜²æ­¢å®½åº¦æº¢å‡º
      boxSizing: 'border-box',

      paddingTop: 'env(safe-area-inset-top)',
      paddingLeft: 'max(15px, env(safe-area-inset-left))',
      paddingRight: 'max(15px, env(safe-area-inset-right))',
      paddingBottom: 'env(safe-area-inset-bottom)'
  },
  
  // å®‰å…¨åŒºåŸŸåŒ…è£…å±‚
  gameSafeArea: {
      position: 'absolute',
      top: 0, left: 0, right: 0, bottom: 0,
      width: '100%',
      height: '100%',
      boxSizing: 'border-box',
      paddingTop: 'env(safe-area-inset-top)',
      paddingLeft: 'max(15px, env(safe-area-inset-left))',
      paddingRight: 'max(15px, env(safe-area-inset-right))',
      paddingBottom: 'env(safe-area-inset-bottom)',
      display: 'flex',
      flexDirection: 'column',
      pointerEvents: 'none' 
  },

  playersArea: { 
      position: 'absolute',
      top: 0, left: 0, right: 0, bottom: 0,
      pointerEvents: 'none',
      zIndex: 10
  },
  
  playerBox: { 
      pointerEvents: 'auto',
      padding: '2px 4px',   
      borderRadius: 8, 
      textAlign: 'center', 
      minWidth: 45,           
      color:'white', 
      border: '1px solid transparent', 
      transition: 'all 0.3s', 
      position: 'relative',
      backdropFilter: 'blur(3px)',
      boxShadow: '0 2px 10px rgba(0,0,0,0.3)'
  },

  // [æ–°å¢] å‰©ä½™ç‰Œæ•°å°å¾½ç« æ ·å¼
  cardCountBadge: {
      position: 'absolute',
      top: -8,
      left: -8,
      background: '#e74c3c',
      color: 'white',
      borderRadius: '50%',
      width: 20,
      height: 20,
      fontSize: 12,
      fontWeight: 'bold',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      border: '2px solid #fff',
      boxShadow: '0 2px 5px rgba(0,0,0,0.3)',
      zIndex: 25
  },

  avatar: { 
      width: 30, 
      height: 30, 
      background: '#ecf0f1', 
      borderRadius: '50%', 
      margin: '0 auto 2px', 
      lineHeight: '30px', 
      color:'#333', 
      fontWeight:'bold', 
      fontSize: 14, 
      border: '1px solid rgba(255,255,255,0.3)', 
      boxShadow: '0 2px 5px rgba(0,0,0,0.2)' 
  },

  playerName: { 
      fontSize: 10, 
      fontWeight: 'bold', 
      marginBottom: 1, 
      whiteSpace: 'nowrap', 
      overflow: 'hidden', 
      textOverflow: 'ellipsis', 
      maxWidth: 50 
  },
  
  // [ä¿®æ”¹] å·¦ä¸Šè§’æ—¥å¿—é¢æ¿ (GameLogPanel) - æ”¯æŒæŠ˜å åŠ¨ç”»
  gameLogPanel: { 
      position: 'absolute', 
      top: 50, 
      left: 10, 
      width: 200, 
      // é«˜åº¦åœ¨ JSX ä¸­åŠ¨æ€æ§åˆ¶ï¼Œè¿™é‡Œè®¾é»˜è®¤å€¼
      // height: 140, 
      
      // [å…³é”®ä¿®æ”¹] èƒŒæ™¯é»˜è®¤æ”¹ä¸ºæ›´é€æ˜ (0.35)ï¼Œç»„ä»¶å†…åŠ¨æ€æ§åˆ¶
      background: 'rgba(0, 0, 0, 0.35)', 
      
      borderRadius: 10, 
      padding: '8px 12px', 
      border: '1px solid rgba(255,255,255,0.1)',
      backdropFilter: 'blur(5px)',
      
      display: 'flex', 
      flexDirection: 'column', 
      zIndex: 5, 
      pointerEvents: 'auto', 
      boxShadow: '0 4px 10px rgba(0,0,0,0.3)',
      
      // [å…³é”®ä¿®æ”¹] å¢åŠ è¿‡æ¸¡åŠ¨ç”»ï¼Œè®©æŠ˜å æ›´ä¸æ»‘
      transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
      overflow: 'hidden' // é˜²æ­¢æŠ˜å æ—¶å†…å®¹æº¢å‡º
  },
  
  logHeader: { 
      display: 'flex', 
      alignItems: 'center', 
      gap: 5, 
      fontSize: 12, 
      borderBottom: '1px solid rgba(255,255,255,0.2)', 
      paddingBottom: 4, 
      marginBottom: 4 
  }, 
  
  logList: { 
      flex: 1, 
      overflowY: 'auto', 
      display: 'flex', 
      flexDirection: 'column', 
      gap: 4, 
      fontSize: 12,
      // å¢åŠ é€æ˜åº¦è¿‡æ¸¡
      transition: 'opacity 0.2s ease-in-out',
      maskImage: 'linear-gradient(to bottom, transparent, black 10%)',
      WebkitMaskImage: 'linear-gradient(to bottom, transparent, black 10%)'
  },
  
  logItem: { 
      lineHeight: 1.4, 
      display: 'flex', 
      alignItems: 'flex-start', 
      color: '#ecf0f1',
      fontSize: 12,
      textShadow: '0 1px 1px rgba(0,0,0,0.8)'
  },
  
  logTime: { display: 'none' },
  
  tableHeader: { 
      padding: '4px 10px', 
      display: 'flex', 
      justifyContent: 'space-between', 
      alignItems:'flex-start', 
      zIndex: 20,
      width: '100%',
      pointerEvents: 'none',
      boxSizing: 'border-box' 
  },
  
  roomBadgeContainer: {
    display: 'flex',
    alignItems: 'center',
    gap: 8, 
    pointerEvents: 'auto'
  },

  roomBadge: { 
    background: 'rgba(0,0,0,0.3)', 
    color:'white', 
    padding: '4px 8px', 
    borderRadius: 15, 
    fontSize: 11, 
    border: '1px solid rgba(255,255,255,0.1)', 
    fontWeight: 'bold',
    whiteSpace: 'nowrap'
  },
  
  scoreBoard: { 
      position: 'absolute', 
      top: '40%', 
      left: '50%', 
      transform: 'translate(-50%, -100%) scale(0.8)', 
      background: 'rgba(0,0,0,0.6)', 
      padding: '5px 20px', 
      borderRadius: 20, 
      textAlign: 'center', 
      color: 'white', 
      border: '1px solid rgba(255,255,255,0.2)', 
      backdropFilter: 'blur(5px)', 
      boxShadow: '0 5px 15px rgba(0,0,0,0.3)',
      zIndex: 5 
  },
  
  glassButton: { pointerEvents: 'auto', background: 'rgba(255,255,255,0.1)', color: 'white', border: '1px solid rgba(255,255,255,0.2)', padding: '8px 20px', borderRadius: 20, cursor: 'pointer', display: 'flex', alignItems: 'center', fontSize: 14, transition: 'background 0.2s' },
  sortButton: { pointerEvents: 'auto', background: 'rgba(255,255,255,0.1)', color: 'white', border: '1px solid rgba(255,255,255,0.2)', padding: '8px 20px', borderRadius: 20, cursor: 'pointer', display: 'flex', alignItems: 'center', fontSize: 14, transition: 'background 0.2s' },
  
  infoMessage: { position: 'absolute', top: '25%', width: '100%', textAlign: 'center', color: '#f1c40f', fontSize: 40, fontWeight: 'bold', textShadow: '0 5px 15px rgba(0,0,0,0.5)', pointerEvents: 'none', zIndex: 50, letterSpacing: 2 },
  
  tableCenter: { 
      position: 'absolute',
      top: '50%',
      left: '50%',
      transform: 'translate(-50%, -50%)',
      display: 'flex', 
      alignItems: 'center', 
      justifyContent: 'center', 
      zIndex: 1
  },
  
  playerNameTag: { color: 'white', textAlign: 'center', marginBottom: 5, textShadow: '0 2px 4px rgba(0,0,0,0.5)', fontSize: 14, fontWeight: 'bold', background: 'rgba(0,0,0,0.3)', padding: '2px 10px', borderRadius: 20, display: 'inline-block' },
  playedRow: { display: 'flex', gap: -10, filter: 'drop-shadow(0 10px 20px rgba(0,0,0,0.3))' }, 
  miniCard: { background: 'white', padding: '10px 15px', borderRadius: 8, fontWeight: 'bold', fontSize: 24, minWidth: 40, textAlign:'center' },
  
  scoreBarBg: { width:'100%', height:4, background:'rgba(0,0,0,0.5)', borderRadius:2, marginTop:2, overflow:'hidden' },
  scoreBarFill: { height:'100%', transition:'width 0.5s' },
  playerScore: { fontSize: 9, color: '#f1c40f', fontWeight: 'bold', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 3, marginTop: 1 },
  turnProgress: { position: 'absolute', bottom: 0, left: 0, height: 4, background: '#f1c40f', width: '100%', animation: 'progress 15s linear forwards' },
  
  // HandArea
  handArea: { 
      position: 'absolute', 
      // [å…³é”®ä¿®æ”¹] æŠ¬é«˜åº•éƒ¨è·ç¦»ï¼Œä» 5px æ”¹ä¸º max(25px, env...) 
      // é¿å… iOS åº•éƒ¨å°é»‘æ¡é®æŒ¡ï¼Œè§£å†³â€œç‚¹å‡»åº•éƒ¨æ— ååº”â€çš„é—®é¢˜
      bottom: 'max(25px, env(safe-area-inset-bottom))',              
      left: 65,
      right: 10, 
      height: 160,            
      display: 'flex', 
      justifyContent:'flex-start', 
      alignItems: 'flex-end', 
      zIndex: 20,
      touchAction: 'none', 
      pointerEvents: 'auto',
      paddingBottom: 10       
  },
  
  card: { 
      background: 'white', 
      borderRadius: 6,      
      border: '1px solid #999', 
      position: 'absolute', 
      cursor: 'pointer', 
      display: 'flex', 
      flexDirection: 'column', 
      padding: 4,            
      transition: 'transform 0.1s cubic-bezier(0.2, 0.8, 0.2, 1)', 
      width: 55,         
      height: 70 
  },
  
  actionBar: { position: 'absolute', bottom: 100, width: '100%', height: 60, display: 'flex', justifyContent: 'center', alignItems: 'center', pointerEvents: 'none', zIndex: 30 }, 
  playButton: { pointerEvents: 'auto', padding: '8px 30px', background: 'linear-gradient(to bottom, #f1c40f, #f39c12)', border: 'none', borderRadius: 40, fontWeight: 'bold', cursor: 'pointer', marginLeft: 20, fontSize: 16, boxShadow: '0 8px 20px rgba(243, 156, 18, 0.4)', color: '#fff', textShadow: '0 1px 2px rgba(0,0,0,0.2)', transition: 'transform 0.1s' },
  passButton: { pointerEvents: 'auto', padding: '8px 25px', background: '#7f8c8d', border: 'none', borderRadius: 40, fontWeight: 'bold', cursor: 'pointer', fontSize: 14, color: 'white', boxShadow: '0 5px 15px rgba(0,0,0,0.3)' },
  waitingBadge: { color: 'rgba(255,255,255,0.7)', fontSize: 16, display: 'flex', alignItems: 'center', gap: 10, background: 'rgba(0,0,0,0.3)', padding: '10px 20px', borderRadius: 30 },
  modalOverlay: { position: 'fixed', top:0, left:0, right:0, bottom:0, background: 'rgba(0,0,0,0.85)', display:'flex', justifyContent:'center', alignItems:'center', zIndex: 99, backdropFilter: 'blur(8px)' },
  modalContent: { background: 'white', padding: 60, borderRadius: 30, textAlign: 'center', boxShadow: '0 30px 80px rgba(0,0,0,0.6)', animation: 'popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275)' },
  
  // å¤§å…é¡µ (Lobby)
  lobbyCard: { background: 'white', padding: 40, borderRadius: 20, width: '1000px', maxWidth: '95vw', minHeight: '600px', display: 'flex', flexDirection: 'column', boxShadow: '0 30px 60px rgba(0,0,0,0.5)' },
  lobbyHeader: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 30, paddingBottom: 20, borderBottom: '1px solid #eee' },
  tag: { background: '#f0f9f4', color: '#27ae60', padding: '5px 10px', borderRadius: 20, fontSize: 14, display: 'flex', alignItems: 'center', gap: 5 },
  playerGrid: { display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(180px, 1fr))', gap: 20, flex: 1, alignContent: 'start' },
  lobbyPlayer: { border: '2px solid #eee', borderRadius: 12, padding: 25, display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 15, position: 'relative', transition: 'all 0.2s' },
  avatarLarge: { width: 80, height: 80, borderRadius: '50%', background: '#34495e', color: 'white', fontSize: 32, display: 'flex', alignItems: 'center', justifyContent: 'center', fontWeight: 'bold' },
  hostBadge: { position: 'absolute', top: 10, right: 10, background: '#f1c40f', color: '#333', fontSize: 12, padding: '4px 8px', borderRadius: 4, fontWeight: 'bold' },
  lobbyFooter: { marginTop: 'auto', borderTop: '1px solid #eee', paddingTop: 20, display: 'flex', justifyContent: 'center' },
};

================================================================================
FILE PATH: client\src\utils\cardLogic.js
================================================================================
// çº¯é€»è¾‘å·¥å…·

// æ’åºæƒé‡ï¼š2(15) > A(14) > K(13)...
export const getSortValue = (cardVal) => {
    const normalized = cardVal % 54;
    if (normalized === 52) return 16;
    if (normalized === 53) return 17;
    const base = normalized % 13;
    if (base === 0) return 14; 
    if (base === 1) return 15; 
    return base + 1;
};

// èŠ±è‰²æ’åºæƒé‡
export const getSuitSortValue = (cardVal) => {
    if (cardVal >= 52) return cardVal * 100;
    const suit = Math.floor(cardVal / 13) % 4; 
    const val = cardVal % 13;
    return suit * 100 + val; 
};

// è·å–å•å¼ ç‰Œçš„æ˜¾ç¤ºä¿¡æ¯
export const getCardDisplay = (cardVal) => {
    const normalizedValue = cardVal % 54; 
    if (normalizedValue === 52) return { suit: 'Joker', text: 'å°ç‹', color: '#000', isScore: false };
    if (normalizedValue === 53) return { suit: 'Joker', text: 'å¤§ç‹', color: '#d00', isScore: false };
    
    const suits = ['â™ ', 'â™¥', 'â™£', 'â™¦'];
    const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
    const valueIndex = normalizedValue % 13;
    const suit = suits[Math.floor(normalizedValue / 13)];
    const color = (suit === 'â™¥' || suit === 'â™¦') ? '#d00' : '#000';
    const text = values[valueIndex];
    const isScore = (text === '5' || text === '10' || text === 'K');
    
    return { suit, text, color, isScore };
};

// æ‰‹ç‰Œæ’åº
export const sortHand = (cards, mode = 'POINT') => {
    if (mode === 'SUIT') {
        return [...cards].sort((a, b) => getSuitSortValue(b) - getSuitSortValue(a));
    }
    return [...cards].sort((a, b) => getSortValue(b) - getSortValue(a));
};

// è®¡ç®—æ‰‹ç‰Œé—´è·
export const calculateCardSpacing = (count, screenWidth) => {
    if (count <= 1) return 0;
    
    // é€‚é…æ‰‹æœºé€»è¾‘ï¼šç•™å‡ºå·¦å³å®‰å…¨è·ç¦»
    const isMobile = screenWidth < 768;
    const padding = isMobile ? 20 : 100; // å‡å°‘ä¸¤ä¾§ç•™ç™½
    
    const w = Math.min(screenWidth - padding, 1200); 
    
    // å¡ç‰Œå®é™…å®½åº¦
    const cardWidth = 55; // ä¸ styles.js ä¸­çš„ card width ä¸€è‡´
    
    // æœ€å¤§é—´è·ï¼šç‰Œå°‘çš„æ—¶å€™ä¸è¦åˆ†å¤ªå¼€
    const maxGap = isMobile ? 35 : 45; 
    
    const neededWidth = (count - 1) * maxGap + cardWidth;
    
    // å¦‚æœéœ€è¦çš„å®½åº¦å°äºå±å¹•å®½ï¼Œå°±ç”¨æœ€å¤§é—´è·
    if (neededWidth <= w) return maxGap;
    
    // å¦åˆ™ï¼ŒæŒ¤å‹ç‰Œçš„é—´è·
    return (w - cardWidth) / (count - 1);
};

// [æ–°å¢] è¾…åŠ©å‡½æ•°ï¼šæ ¹æ®è§¦æ‘¸Xåæ ‡è®¡ç®—æ˜¯ç¬¬å‡ å¼ ç‰Œ
export const getCardIndexFromTouch = (touchX, containerLeft, spacing, count) => {
    // ç›¸å¯¹å®¹å™¨å·¦ä¾§çš„è·ç¦»
    const relativeX = touchX - containerLeft;
    
    // ä¼°ç®—ç´¢å¼•
    let index = Math.floor(relativeX / spacing);
    
    // è¾¹ç•Œæ£€æŸ¥
    if (index < 0) index = 0;
    if (index >= count) index = count - 1; // è§¦æ‘¸åœ¨æœ€åä¸€å¼ ç‰Œä¹‹åï¼Œä¹Ÿç®—æœ€åä¸€å¼ 
    
    return index;
};

================================================================================
FILE PATH: client\src\utils\SoundManager.js
================================================================================
/**
 * ç®€æ˜“ Web Audio API éŸ³æ•ˆç®¡ç†å™¨
 * ä¸éœ€è¦å¤–éƒ¨ MP3 æ–‡ä»¶ï¼Œç›´æ¥ç”¨ä»£ç ç”Ÿæˆå£°éŸ³
 */
const SoundManager = {
    ctx: null,

    init: () => {
        if (!SoundManager.ctx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            SoundManager.ctx = new AudioContext();
        }
    },

    // æ’­æ”¾æŒ‡å®šç±»å‹çš„éŸ³æ•ˆ
    play: (type) => {
        try {
            // æŸäº›æµè§ˆå™¨éœ€è¦ç”¨æˆ·äº¤äº’åæ‰èƒ½æ¢å¤ Context
            if (SoundManager.ctx && SoundManager.ctx.state === 'suspended') {
                SoundManager.ctx.resume();
            }
            if (!SoundManager.ctx) SoundManager.init();

            switch (type) {
                case 'deal': // å‘ç‰Œ/ç‚¹å‡»ç‰Œ (çŸ­ä¿ƒçš„é«˜é¢‘éŸ³)
                    SoundManager.beep(800, 0.05, 'sine');
                    break;
                case 'play': // å‡ºç‰Œ (æœ‰æ‰“å‡»æ„Ÿ)
                    SoundManager.noise(0.1); 
                    break;
                case 'win': // èƒœåˆ© (è¿ç»­çš„ç¶éŸ³)
                    SoundManager.arpeggio([523.25, 659.25, 783.99, 1046.50], 0.1);
                    break;
                case 'lose': // å¤±è´¥/è¢«å‹ (ä½æ²‰)
                    SoundManager.beep(150, 0.3, 'sawtooth');
                    break;
                case 'alert': // è½®åˆ°ä½ äº†
                    SoundManager.beep(880, 0.1, 'square');
                    setTimeout(() => SoundManager.beep(880, 0.1, 'square'), 150);
                    break;
                default:
                    break;
            }
        } catch (e) {
            console.warn('Audio play failed:', e);
        }
    },

    // --- åˆæˆå™¨åº•å±‚å‡½æ•° ---

    // å‘å‡ºå•éŸ³
    beep: (freq, duration, type = 'sine') => {
        const ctx = SoundManager.ctx;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();

        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        
        gain.gain.setValueAtTime(0.1, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(ctx.destination);

        osc.start();
        osc.stop(ctx.currentTime + duration);
    },

    // æ¨¡æ‹Ÿæ‰“å‡»å£° (ç™½å™ªéŸ³)
    noise: (duration) => {
        const ctx = SoundManager.ctx;
        const bufferSize = ctx.sampleRate * duration;
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }

        const noise = ctx.createBufferSource();
        noise.buffer = buffer;
        
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.2, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);

        noise.connect(gain);
        gain.connect(ctx.destination);
        noise.start();
    },

    // ç¶éŸ³ (èƒœåˆ©éŸ³æ•ˆ)
    arpeggio: (freqs, interval) => {
        freqs.forEach((f, i) => {
            setTimeout(() => SoundManager.beep(f, 0.2, 'triangle'), i * interval * 1000);
        });
    }
};

export default SoundManager;

================================================================================
FILE PATH: client\vite.config.js
================================================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})


================================================================================
FILE PATH: server\game\BotLogic.js
================================================================================
const CardRules = require('./CardRules');

const BotLogic = {
    // ç®€å•çš„å†³ç­–å‡½æ•°
    decideMove: (hand, lastPlayedCards, deckCount) => {
        try {
            // 1. å¦‚æœå½“å‰æ²¡æœ‰è¢«å‹ç‰Œï¼ˆè‡ªå·±é¢†å‡ºï¼‰ï¼Œå‡ºæœ€å°çš„ä¸€å¼ ç‰Œ
            if (!lastPlayedCards || lastPlayedCards.length === 0) {
                if (hand.length === 0) return null;
                // ç®€å•ç­–ç•¥ï¼šæ€»æ˜¯å‡ºæ‰‹ä¸­æœ€å°çš„ä¸€å¼ ç‰Œ
                return [hand[0]]; 
            }

            // 2. å¦‚æœæœ‰äººå‡ºç‰Œäº†ï¼Œå°è¯•ç®¡ä¸Š
            const lastHandState = CardRules.analyze(lastPlayedCards, deckCount);
            if (lastHandState.type === 'INVALID') return null; 

            // æ•´ç†æ‰‹ç‰Œï¼šæŒ‰ç‚¹æ•°åˆ†ç»„
            const grouped = {};
            hand.forEach(c => {
                const p = CardRules.getPoint(c);
                if (!grouped[p]) grouped[p] = [];
                grouped[p].push(c);
            });
            
            const uniquePoints = Object.keys(grouped).map(Number).sort((a,b) => a-b);

            // ç­–ç•¥ Aï¼šå°è¯•ç”¨åŒç±»å‹çš„ç‰Œç®¡ï¼ˆä¸å«ç‚¸å¼¹ï¼‰
            if (['SINGLE', 'PAIR', 'TRIPLE'].includes(lastHandState.type)) {
                const countNeeded = lastHandState.type === 'SINGLE' ? 1 : 
                                    lastHandState.type === 'PAIR' ? 2 : 3;
                
                for (let p of uniquePoints) {
                    if (p > lastHandState.val && grouped[p].length >= countNeeded) {
                        return grouped[p].slice(0, countNeeded);
                    }
                }
            }
            
            // ç®€å•çš„è¿å¯¹/é£æœºç®¡ç‰Œå°è¯• (åªç®¡é•¿åº¦ä¸€è‡´çš„)
            if (lastHandState.type === 'LIANDUI' || lastHandState.type === 'AIRPLANE') {
                 // è¿™æ˜¯ä¸€ä¸ªå¤æ‚çš„æœç´¢ï¼Œè¿™é‡Œç®€åŒ–ï¼šBotæš‚ä¸å¤„ç†å¤æ‚ç‰Œå‹çš„è·Ÿç‰Œï¼Œç›´æ¥å°è¯•ç”¨ç‚¸å¼¹ç‚¸
            }

            // ç­–ç•¥ Bï¼šå°è¯•ç”¨ç‚¸å¼¹ç‚¸
            const currentLevel = lastHandState.level || 0;
            
            // æ‰¾æ™®é€šç‚¸å¼¹ (4å¼ åŠä»¥ä¸Š)
            for (let p of uniquePoints) {
                if (grouped[p].length >= 4) {
                    const bombCards = grouped[p];
                    const bombState = CardRules.analyze(bombCards, deckCount);
                    
                    // çº§åˆ«é«˜ï¼Œæˆ–åŒçº§åˆ«ç‚¹æ•°å¤§
                    if (bombState.level > currentLevel) return bombCards;
                    if (bombState.level === currentLevel && bombState.val > lastHandState.val) return bombCards;
                }
            }

            // 3. å®åœ¨ç®¡ä¸ä¸Šï¼Œè¿‡
            return null;
        } catch (e) {
            console.error("BotLogic error:", e);
            return null; // æŠ¥é”™æ—¶é»˜è®¤è¿‡ç‰Œ
        }
    }
};

module.exports = BotLogic;

================================================================================
FILE PATH: server\game\CardRules.js
================================================================================
// çº¯è§„åˆ™è®¡ç®— (510K é€»è¾‘ã€æ¯”å¤§å°)

const CardRules = {
    // 1. åŸºç¡€æ˜ å°„
    // 3=3 ... K=13, A=14, 2=15, å°ç‹=16, å¤§ç‹=17
    getPoint: (cardVal) => {
        const normalized = cardVal % 54;
        if (normalized === 52) return 16;
        if (normalized === 53) return 17;
        const base = normalized % 13;
        if (base === 0) return 14; // A
        if (base === 1) return 15; // 2
        return base + 1; // 3 => 3
    },
    
    // [æ–°å¢] è¾…åŠ©ï¼šç‚¹æ•°è½¬æ˜¾ç¤ºæ–‡æœ¬
    getPointText: (point) => {
        if (point <= 10) return point.toString();
        if (point === 11) return 'J';
        if (point === 12) return 'Q';
        if (point === 13) return 'K';
        if (point === 14) return 'A';
        if (point === 15) return '2';
        if (point === 16) return 'å°ç‹';
        if (point === 17) return 'å¤§ç‹';
        return '?';
    },
    
    // [æ–°å¢] è¾…åŠ©ï¼šå°†åˆ†æç»“æœè½¬ä¸ºäººç±»å¯è¯»æ–‡æœ¬
    getAnalysisText: (analysisResult) => {
        if (!analysisResult || analysisResult.type === 'INVALID') return 'æœªçŸ¥ç‰Œå‹';
        
        const pt = CardRules.getPointText(analysisResult.val);
        
        switch (analysisResult.type) {
            case 'SINGLE': return `å•å¼  ${pt}`;
            case 'PAIR': return `å¯¹ ${pt}`;
            case 'TRIPLE': return `ä¸‰å¼  ${pt}`;
            case 'LIANDUI': return `${analysisResult.len/2}è¿å¯¹ (${pt}èµ·)`;
            case 'AIRPLANE': return `é£æœº (${pt}èµ·)`;
            // case '510K_MIXED': return 'æ‚ 510K'; // æ‚è‰²å·²åºŸå¼ƒ
            case '510K_PURE': 
                const suitNames = ['é»‘æ¡ƒ', 'çº¢æ¡ƒ', 'æ¢…èŠ±', 'æ–¹ç‰‡'];
                // val æ˜ å°„å›ç´¢å¼•ï¼š4->0, 3->1, 2->2, 1->3
                const suitIndex = 4 - analysisResult.val; 
                const sName = suitNames[suitIndex] || 'çº¯';
                return `${sName} 510K`;
            case 'BOMB_STD': return `${analysisResult.len}ç‚¸ (${pt})`;
            case 'BOMB_MAX': return `è‡³å°Š ${analysisResult.len}ç‚¸ (${pt})`;
            case 'BOMB_KING': return 'å¤©ç‹ç‚¸!';
            default: return 'æœªçŸ¥';
        }
    },

    // è·å–ç‰Œçš„åˆ†æ•° (5=5, 10=10, K=10)
    getCardScore: (cardVal) => {
        const p = CardRules.getPoint(cardVal);
        if (p === 5) return 5;
        if (p === 10) return 10;
        if (p === 13) return 10; // K
        return 0;
    },

    // è®¡ç®—ä¸€ç»„ç‰Œçš„æ€»åˆ†
    calculateTotalScore: (cards) => {
        return cards.reduce((sum, c) => sum + CardRules.getCardScore(c), 0);
    },

    // è·å–ç‰Œçš„èŠ±è‰² (0-3)
    // 0:é»‘æ¡ƒ, 1:çº¢æ¡ƒ, 2:æ¢…èŠ±, 3:æ–¹ç‰‡
    getSuit: (cardVal) => {
        const normalized = cardVal % 54;
        if (normalized >= 52) return -1; // ç‹æ²¡æœ‰èŠ±è‰²
        return Math.floor(normalized / 13);
    },

    // 2. æ ¸å¿ƒï¼šç‰Œå‹åˆ†æ
    analyze: (cards, deckCount = 1) => {
        const len = cards.length;
        if (len === 0) return { type: 'EMPTY' };

        // æ’åºï¼šç‚¹æ•°ä»å°åˆ°å¤§
        const points = cards.map(CardRules.getPoint).sort((a, b) => a - b);
        
        // ç»Ÿè®¡ç‚¹æ•°é¢‘ç‡ { point: count }
        const counts = {};
        points.forEach(p => { counts[p] = (counts[p] || 0) + 1; });
        const uniquePoints = Object.keys(counts).map(Number).sort((a,b)=>a-b);
        
        // --- éç‚¸å¼¹ç‰Œå‹ ---

        // å•å¼ 
        if (len === 1) return { type: 'SINGLE', val: points[0], level: 0 };

        // å¯¹å­
        if (len === 2 && points[0] === points[1]) {
            return { type: 'PAIR', val: points[0], level: 0 };
        }

        // ä¸‰å¼  (ä¸å¸¦)
        if (len === 3 && uniquePoints.length === 1) {
            return { type: 'TRIPLE', val: points[0], level: 0 };
        }

        // è¿å¯¹ (Liandui)
        if (len >= 4 && len % 2 === 0) {
            // ç®€å•æ ¡éªŒï¼šä¸å«2å’Œç‹
            if (!points.some(p => p >= 15)) {
                let isLiandui = true;
                if (uniquePoints.length === len / 2) {
                     for (let p of uniquePoints) {
                         if (counts[p] !== 2) isLiandui = false;
                     }
                     for(let i=0; i<uniquePoints.length-1; i++) {
                         if(uniquePoints[i+1] !== uniquePoints[i]+1) isLiandui = false;
                     }
                     if (isLiandui) return { type: 'LIANDUI', val: points[0], len: len, level: 0 };
                }
            }
        }

        // é£æœº (Airplane) - è¿ç»­çš„ä¸‰ä¸å¸¦
        if (len >= 6 && len % 3 === 0) {
            if (!points.some(p => p >= 15)) {
                let isAirplane = true;
                if (uniquePoints.length === len / 3) {
                    for (let p of uniquePoints) {
                        if (counts[p] !== 3) isAirplane = false;
                    }
                    for(let i=0; i<uniquePoints.length-1; i++) {
                        if(uniquePoints[i+1] !== uniquePoints[i]+1) isAirplane = false;
                    }
                    if (isAirplane) return { type: 'AIRPLANE', val: points[0], len: len, level: 0 };
                }
            }
        }

        // --- ç‚¸å¼¹ç‰Œå‹ (Level 1-5) ---

        // Level 1: 510K (çº¯è‰²) - æ‚è‰²å·²åºŸå¼ƒ
        if (len === 3) {
            const has5 = points.includes(5);
            const has10 = points.includes(10);
            const hasK = points.includes(13);
            if (has5 && has10 && hasK) {
                // æ£€æŸ¥èŠ±è‰²
                const suits = cards.map(CardRules.getSuit);
                const isPure = (suits[0] === suits[1] && suits[1] === suits[2]);
                
                if (isPure) {
                    // çº¯510K (Level 2ï¼Œæ³¨ï¼šè™½ç„¶ç°åœ¨åªæœ‰çº¯è‰²ï¼Œä½†ä¾ç„¶ç®—ä½œ Level 2 ä»¥åŒºåˆ«äºæ‚è‰²å†å²é€»è¾‘ï¼Œæˆ–è€…ç»Ÿç§°ä¸º510Kç‚¸å¼¹)
                    // è§„åˆ™ï¼šé»‘(0)>çº¢(1)>æ¢…(2)>æ–¹(3)
                    // ä¸ºäº†æ–¹ä¾¿æ¯”è¾ƒå¤§å°ï¼Œæˆ‘ä»¬å°† val è®¾ä¸ºèŠ±è‰²çš„åå‘æƒé‡ï¼š
                    // é»‘æ¡ƒ(0) -> 4
                    // çº¢æ¡ƒ(1) -> 3
                    // æ¢…èŠ±(2) -> 2
                    // æ–¹ç‰‡(3) -> 1
                    const suit = suits[0];
                    let suitVal = 0;
                    if (suit === 0) suitVal = 4;
                    else if (suit === 1) suitVal = 3;
                    else if (suit === 2) suitVal = 2;
                    else if (suit === 3) suitVal = 1;

                    return { type: '510K_PURE', val: suitVal, level: 2 }; 
                } 
                // æ‚è‰² 510K ä¸å†è¿”å› INVALIDï¼Œè€Œæ˜¯ä½œä¸ºæ™®é€šæ•£ç‰Œå¤„ç†ï¼ˆä¹Ÿå°±æ˜¯æ— æ³•ä¸€æ¬¡æ€§æ‰“å‡ºï¼Œé™¤éå½“å•å¼ /å¯¹å­æ‰“ï¼‰
                // ç”±äºä»£ç é€»è¾‘èµ°åˆ°è¿™é‡Œå·²ç»ä¸æ˜¯å•/å¯¹/ä¸‰/è¿/é£æœºï¼Œæ‰€ä»¥æœ€ç»ˆä¼šè¿”å› INVALIDï¼Œç¬¦åˆâ€œæ‚è‰²ä¸è¡Œâ€çš„è¦æ±‚ã€‚
            }
        }

        // Level 3: æ™®é€šç‚¸å¼¹ (>=4å¼ )
        if (uniquePoints.length === 1 && len >= 4) {
            // Level 5: è‡³å°Šæ»¡ç‚¸ (Rankæ•°é‡ == DECK_COUNT * 4)
            if (len === deckCount * 4) {
                 return { type: 'BOMB_MAX', val: points[0], level: 5 };
            }
            // æ™®é€šç‚¸å¼¹ (åŒ…æ‹¬ 4ä¸ªå°ç‹ è¿™ç§)
            return { type: 'BOMB_STD', val: points[0], len: len, level: 3 };
        }

        // Level 4: å¤©ç‹ç‚¸ (æ‰€æœ‰ç‹)
        const isAllJokers = points.every(p => p >= 16);
        // è§„åˆ™ï¼šå¿…é¡»é›†é½æ‰€æœ‰ç‹
        if (isAllJokers && len === deckCount * 2) {
            return { type: 'BOMB_KING', val: 999, level: 4 };
        }
        // å¦‚æœæ˜¯ 3ä¸ªç‹ã€2ä¸ªç‹ï¼Œå› ä¸º uniquePoints é•¿åº¦ä¸ä¸º 1 (16å’Œ17ä¸åŒ)ï¼Œ
        // ä¸” len ä¸æ»¡è¶³ deckCount*2ï¼Œæ‰€ä»¥ä¼šä½œä¸º INVALID å¤„ç†ï¼ˆæ— æ³•ä½œä¸ºç‚¸å¼¹ä¸€æ¬¡æ‰“å‡ºï¼‰ã€‚
        // ä½†å¦‚æœæ˜¯ 2ä¸ªå°ç‹ (len=2, points=[16,16])ï¼Œä¸Šé¢å·²ç»åŒ¹é…äº† PAIRã€‚
        // å¦‚æœæ˜¯ 3ä¸ªå°ç‹ (len=3, points=[16,16,16])ï¼Œä¸Šé¢å·²ç»åŒ¹é…äº† TRIPLEã€‚
        // å¦‚æœæ˜¯ 4ä¸ªå°ç‹ (len=4, points=[16,16,16,16])ï¼Œä¸Šé¢åŒ¹é…äº† BOMB_STDã€‚
        // å®Œå…¨ç¬¦åˆâ€œä¸é½çš„è¯ï¼Œå°±æ˜¯æŒ‰ç…§æ­£å¸¸çš„å¤§å°ç‹çš„å¤§å°ç®—â€çš„è§„åˆ™ã€‚

        return { type: 'INVALID' };
    },

    // 3. æ ¡éªŒèƒ½å¦ç®¡ç‰Œ
    canPlay: (newCards, lastCards, deckCount) => {
        const newHand = CardRules.analyze(newCards, deckCount);
        if (newHand.type === 'INVALID') return false;

        // è‡ªç”±å‡ºç‰Œ
        if (!lastCards || lastCards.length === 0) return true;

        const lastHand = CardRules.analyze(lastCards, deckCount);

        // A. ç‚¸å¼¹ vs éç‚¸å¼¹
        if (newHand.level > 0 && lastHand.level === 0) return true;
        if (newHand.level === 0 && lastHand.level > 0) return false;

        // B. ç‚¸å¼¹ä¹‹é—´ (Level æ¯”è¾ƒ)
        if (newHand.level > 0 && lastHand.level > 0) {
            if (newHand.level > lastHand.level) return true;
            if (newHand.level < lastHand.level) return false;

            // åŒçº§åˆ«æ¯”è¾ƒ
            if (newHand.type === '510K_PURE') {
                // çº¯510K æ¯”è¾ƒèŠ±è‰²æƒé‡ (é»‘4 > çº¢3 > æ¢…2 > æ–¹1)
                return newHand.val > lastHand.val;
            }

            if (newHand.type === 'BOMB_STD') {
                if (newHand.len > lastHand.len) return true;
                if (newHand.len < lastHand.len) return false;
                return newHand.val > lastHand.val;
            }
            
            if (newHand.type === 'BOMB_MAX') return newHand.val > lastHand.val;
            return false;
        }

        // C. éç‚¸å¼¹ä¹‹é—´ (åŒç‰Œå‹æ¯”è¾ƒ)
        if (newHand.type === lastHand.type) {
            // è¿å¯¹å’Œé£æœºå¿…é¡»å¼ æ•°ä¸€è‡´æ‰èƒ½æ¯”è¾ƒ
            if ((newHand.type === 'LIANDUI' || newHand.type === 'AIRPLANE') && newHand.len !== lastHand.len) return false;
            
            // å¿…é¡»å¼ æ•°ä¸€è‡´
            if (newCards.length !== lastCards.length) return false;
            
            // [è§„åˆ™] è¿å¯¹ï¼šä¸¥ä¸åˆç¼ (å¿…é¡»å¤§1ç‚¹)
            if (newHand.type === 'LIANDUI') {
                return newHand.val === lastHand.val + 1;
            }

            // [è§„åˆ™] é£æœºï¼šåªè¦ç‚¹æ•°å¤§å³å¯ (val > val)
            // [è§„åˆ™] æ™®é€šç‰Œå‹ (å•/å¯¹/ä¸‰)ï¼šåªè¦ç‚¹æ•°å¤§å³å¯
            return newHand.val > lastHand.val;
        }

        return false;
    }
};

module.exports = CardRules;

================================================================================
FILE PATH: server\game\Deck.js
================================================================================
// ç‰Œåº“ç”Ÿæˆä¸æ´—ç‰Œ


class Deck {
    constructor(deckCount = 1) {
        this.deck = [];
        // ç”Ÿæˆå¤šå‰¯ç‰Œã€‚æ¯å‰¯ç‰Œæ˜¯ 0-53ã€‚
        // æˆ‘ä»¬ä½¿ç”¨ i + d * 54 æ¥ä¿è¯æ¯å¼ ç‰Œæœ‰å”¯ä¸€IDï¼Œæ–¹ä¾¿å‰ç«¯æ¸²æŸ“ Key å€¼
        for (let d = 0; d < deckCount; d++) {
             for (let i = 0; i < 54; i++) {
                this.deck.push(i + d * 54); 
            }
        }
    }

    shuffle() {
        // Fisher-Yates æ´—ç‰Œç®—æ³•
        for (let i = this.deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
        }
    }

    deal(playerCount) {
        this.shuffle();
        const hands = {};
        const totalCards = this.deck.length;
        const cardsPerPlayer = Math.floor(totalCards / playerCount); 
        
        for (let i = 0; i < playerCount; i++) {
            hands[i] = this.deck.slice(i * cardsPerPlayer, (i + 1) * cardsPerPlayer);
            // å°†å¤šä½™çš„ç‰Œå‘ç»™æœ€åä¸€ä¸ªäººï¼ˆç®€åŒ–å¤„ç†ï¼‰
            if (i === playerCount - 1) {
                 hands[i] = this.deck.slice(i * cardsPerPlayer);
            }
        }
        return hands;
    }
}

module.exports = Deck;

================================================================================
FILE PATH: server\game\GameManager.js
================================================================================
const CardRules = require('./CardRules');
const Deck = require('./Deck');
const BotLogic = require('./BotLogic');

class GameManager {
    constructor(roomConfig, players, io, roomId) {
        this.config = roomConfig;
        this.players = players; 
        this.io = io; 
        this.roomId = roomId;

        this.grandScores = {};
        this.players.forEach(p => this.grandScores[p.id] = 0);
        this.lastWinnerId = null;
        this.gameState = null; 
        
        this.timer = null;
        this.botTimer = null;
        this.turnStartTime = 0; 
    }

    // åˆ‡æ¢æ‰˜ç®¡çŠ¶æ€
    toggleAutoPlay(playerId) {
        const player = this.players.find(p => p.id === playerId);
        if (!player || player.isBot) return; 

        player.isAutoPlay = !player.isAutoPlay;
        
        // å¦‚æœå½“å‰æ­£å¥½æ˜¯è¯¥ç©å®¶çš„å›åˆ
        if (this.gameState && this.players[this.gameState.currentTurnIndex].id === playerId) {
            if (player.isAutoPlay) {
                // å¼€å¯æ‰˜ç®¡ï¼šç«‹å³å°è¯•è¿è¡Œ Bot
                this._checkAndRunBot();
            } else {
                // å–æ¶ˆæ‰˜ç®¡ï¼šæ¸…é™¤ Bot è®¡æ—¶å™¨ï¼Œé‡ç½®è¶…æ—¶è®¡æ—¶å™¨ç»™ç©å®¶æ€è€ƒæ—¶é—´
                if (this.botTimer) {
                    clearTimeout(this.botTimer);
                    this.botTimer = null;
                }
                this._resetTimer();
            }
        }
    }

    startRound(isNextRound = false) {
        if (!isNextRound) {
            this.players.forEach(p => this.grandScores[p.id] = 0);
            this.lastWinnerId = null;
        }

        const deck = new Deck(this.config.deckCount);
        const hands = deck.deal(this.players.length);

        let startIndex = 0;
        if (this.lastWinnerId) {
            const winnerIdx = this.players.findIndex(p => p.id === this.lastWinnerId);
            if (winnerIdx !== -1) startIndex = winnerIdx;
        }

        // [æ–°å¢] ç»„é˜Ÿåˆ†é…é€»è¾‘ï¼šé—´éš”å…¥åº§ (0,2ä¸ºä¸€é˜Ÿ; 1,3ä¸ºä¸€é˜Ÿ)
        const isTeamMode = this.config.isTeamMode && (this.players.length % 2 === 0);
        this.players.forEach((p, index) => {
            if (isTeamMode) {
                p.team = index % 2; // 0 æˆ– 1
            } else {
                p.team = null; // ä¸ªäººæˆ˜
            }
        });

        this.gameState = {
            hands: {},
            currentTurnIndex: startIndex,
            lastPlayedCards: [],    
            consecutivePasses: 0,   
            roundPoints: {},        
            pendingTablePoints: 0,  
            roundWinnerId: null, 
            finishedRank: [],    
        };

        this.players.forEach((p, index) => {
            this.gameState.hands[p.id] = hands[index];
            this.gameState.roundPoints[p.id] = 0;
        });

        this._resetTimer();
        this._checkAndRunBot();

        return {
            startPlayerIndex: startIndex,
            startPlayerId: this.players[startIndex].id,
            hands: this.gameState.hands
        };
    }

    _checkAndRunBot() {
        if (!this.gameState) return;
        
        if (this.botTimer) {
            clearTimeout(this.botTimer);
            this.botTimer = null;
        }

        if (this._getActivePlayerCount() <= 1 && this.gameState.lastPlayedCards.length === 0) return;

        const currPlayer = this.players[this.gameState.currentTurnIndex];
        const isAI = currPlayer.isBot || currPlayer.isAutoPlay;

        if (isAI && this.gameState.hands[currPlayer.id].length > 0) {
            const delay = 1000 + Math.random() * 1000;
            this.botTimer = setTimeout(() => {
                this._executeBotTurn(currPlayer);
            }, delay);
        }
    }

    _executeBotTurn(botPlayer) {
        if (!this.gameState) return;
        // åŒé‡æ£€æŸ¥ï¼šç¡®ä¿å½“å‰å›åˆç¡®å®å±äºè¯¥ Botï¼Œé˜²æ­¢ Timer è§¦å‘æ—¶å›åˆå·²å˜
        if (this.players[this.gameState.currentTurnIndex].id !== botPlayer.id) return;

        try {
            const hand = this.gameState.hands[botPlayer.id];
            // æ²¡ç‰Œäº†ï¼Œç›´æ¥è·³è¿‡
            if (!hand || hand.length === 0) {
                 this._advanceTurn(); 
                 this._broadcastUpdate(); // å¹¿æ’­çŠ¶æ€
                 return;
            }

            const isNewRound = this.gameState.lastPlayedCards.length === 0;
            const cardsToBeat = isNewRound ? [] : this.gameState.lastPlayedCards;

            const sortedHand = [...hand].sort((a,b) => CardRules.getPoint(a) - CardRules.getPoint(b));
            
            // å°è¯•è·å–å‡ºç‰Œç­–ç•¥
            let cardsToPlay = null;
            try {
                cardsToPlay = BotLogic.decideMove(sortedHand, cardsToBeat, this.config.deckCount);
            } catch (err) {
                console.error("[Bot Error] Logic crashed:", err);
            }

            if (cardsToPlay) {
                console.log(`[Bot/Auto] ${botPlayer.name} plays ${cardsToPlay.length} cards.`);
                const result = this.playCards(botPlayer.id, cardsToPlay);
                
                if (result.success) {
                    if (!botPlayer.isBot) {
                        this.io.to(botPlayer.id).emit('hand_update', this.gameState.hands[botPlayer.id]);
                    }

                    if (result.isRoundOver) {
                        this._handleWin(result, botPlayer.id);
                    } else {
                        const analysis = CardRules.analyze(cardsToPlay, this.config.deckCount);
                        const desc = CardRules.getAnalysisText(analysis);
                        this._broadcastUpdate(`${botPlayer.name}: ${desc}`);
                    }
                } else {
                    console.error(`[Bot Error] Play failed: ${result.error}`);
                    if (!isNewRound) {
                        this._forcePass(botPlayer);
                    } else {
                        this._playMinCard(botPlayer, sortedHand);
                    }
                }
            } else {
                if (isNewRound) {
                    console.warn(`[Bot Fix] AI tried to pass on new round. Forcing min card.`);
                    this._playMinCard(botPlayer, sortedHand);
                } else {
                    console.log(`[Bot/Auto] ${botPlayer.name} passes.`);
                    this._forcePass(botPlayer);
                }
            }
        } catch (error) {
            console.error(`[Bot Error] Critical Exception in _executeBotTurn:`, error);
            
            this._advanceTurn();
            this._resetTimer();
            
            const publicState = this.getPublicState();
            publicState.infoText = `${botPlayer.name} å‘ç”Ÿé”™è¯¯ï¼Œè·³è¿‡`;
            this.io.to(this.roomId).emit('game_state_update', publicState);

            this._checkAndRunBot();
        }
    }
    
    // è¾…åŠ©ï¼šå‡ºæœ€å°çš„ä¸€å¼ ç‰Œ (ç”¨äºå…œåº•)
    _playMinCard(botPlayer, sortedHand) {
        const minCard = [sortedHand[0]];
        const result = this.playCards(botPlayer.id, minCard);
        if (result.success) {
            if (!botPlayer.isBot) this.io.to(botPlayer.id).emit('hand_update', this.gameState.hands[botPlayer.id]);
            
            const analysis = CardRules.analyze(minCard, this.config.deckCount);
            const desc = CardRules.getAnalysisText(analysis);
            this._broadcastUpdate(`${botPlayer.name}: ${desc} (ç³»ç»Ÿ)`);
        } else {
             this._forcePass(botPlayer); 
        }
    }

    // ç»Ÿä¸€å¹¿æ’­å‡½æ•°
    _broadcastUpdate(infoText = null) {
        const publicState = this.getPublicState();
        if (infoText) publicState.infoText = infoText;
        this.io.to(this.roomId).emit('game_state_update', publicState);
    }
    
    // å¼ºåˆ¶è¿‡ç‰Œè¾…åŠ©å‡½æ•°
    _forcePass(botPlayer) {
        const result = this.passTurn(botPlayer.id);
        if (result.success) {
            this._broadcastUpdate(`${botPlayer.name}: ä¸è¦`);
        } else {
            console.error("[Bot Critical] Failed to pass turn:", result.error);
            this._advanceTurn();
            this._broadcastUpdate();
            this._resetTimer();
            this._checkAndRunBot();
        }
    }

    _handleWin(result, winnerId) {
        const rInfo = result.roundResult;
        if (rInfo.isGrandOver) {
            this.io.to(this.roomId).emit('grand_game_over', { 
                grandWinner: rInfo.roundWinnerName, 
                grandScores: rInfo.grandScores 
            });
            this.gameState = null; 
            this._clearTimer(); 
        } else {
            this.io.to(this.roomId).emit('round_over', {
                roundWinner: rInfo.roundWinnerName,
                pointsEarned: rInfo.pointsEarned,
                detail: rInfo.detail,
                grandScores: rInfo.grandScores
            });
            this._clearTimer();
        }
    }

    playCards(playerId, cards) {
        if (!this.gameState) return { success: false, error: 'æ¸¸æˆæœªå¼€å§‹' };

        const currPlayer = this.players[this.gameState.currentTurnIndex];
        if (currPlayer.id !== playerId) return { success: false, error: 'è¿˜æ²¡è½®åˆ°ä½ ' };

        const playerHand = this.gameState.hands[playerId];
        if (!this._handContainsCards(playerHand, cards)) {
            return { success: false, error: 'æ‰‹ç‰Œä¸è¶³æˆ–æ•°æ®ä¸åŒæ­¥' };
        }

        const isNewRound = this.gameState.lastPlayedCards.length === 0;
        const cardsToBeat = isNewRound ? [] : this.gameState.lastPlayedCards;

        if (!CardRules.canPlay(cards, cardsToBeat, this.config.deckCount)) {
            return { success: false, error: 'ç‰Œå‹ä¸ç¬¦æˆ–ç®¡ä¸ä¸Š' };
        }

        this._removeCardsFromHand(playerId, cards);
        this.gameState.pendingTablePoints += CardRules.calculateTotalScore(cards);
        this.gameState.lastPlayedCards = cards;
        this.gameState.consecutivePasses = 0;
        this.gameState.roundWinnerId = playerId;

        const isFinished = this.gameState.hands[playerId].length === 0;
        if (isFinished) {
            if (!this.gameState.finishedRank.includes(playerId)) {
                this.gameState.finishedRank.push(playerId);
            }
        }
        
        const analysis = CardRules.analyze(cards, this.config.deckCount);
        const cardDesc = CardRules.getAnalysisText(analysis);
        const logText = `${currPlayer.name}: ${cardDesc}`;

        const activeCount = this._getActivePlayerCount();
        
        if (activeCount <= 1) {
            this._clearTimer();
            const roundResult = this._concludeRound();
            return { 
                success: true, 
                isRoundOver: true,
                roundResult,
                cardsPlayed: cards,
                pendingPoints: this.gameState.pendingTablePoints,
                logText // è¿”å›æ—¥å¿—ç»™è°ƒç”¨è€…
            };
        }

        this._advanceTurn();
        this._resetTimer();
        this._checkAndRunBot();

        return { 
            success: true, 
            isRoundOver: false,
            cardsPlayed: cards,
            pendingPoints: this.gameState.pendingTablePoints,
            logText // è¿”å›æ—¥å¿—ç»™è°ƒç”¨è€…
        };
    }

    passTurn(playerId) {
        if (!this.gameState) return { success: false, error: 'æ¸¸æˆæœªå¼€å§‹' };

        const currPlayer = this.players[this.gameState.currentTurnIndex];
        if (currPlayer.id !== playerId) return { success: false, error: 'è¿˜æ²¡è½®åˆ°ä½ ' };

        if (this.gameState.lastPlayedCards.length === 0) {
            return { success: false, error: 'å¿…é¡»å‡ºç‰Œ' };
        }

        this.gameState.consecutivePasses++;
        this._advanceTurn(); 

        const winnerHand = this.gameState.hands[this.gameState.roundWinnerId];
        const winnerIsActive = winnerHand && winnerHand.length > 0;
        const activeCount = this._getActivePlayerCount();
        
        const passesNeeded = winnerIsActive ? (activeCount - 1) : activeCount;

        let turnCleared = false;
        if (this.gameState.consecutivePasses >= passesNeeded) {
            const wId = this.gameState.roundWinnerId;
            if (wId) {
                this.gameState.roundPoints[wId] = (this.gameState.roundPoints[wId] || 0) + this.gameState.pendingTablePoints;
                this.gameState.pendingTablePoints = 0;
                
                if (this.gameState.hands[wId].length > 0) {
                     const wIdx = this.players.findIndex(p => p.id === wId);
                     this.gameState.currentTurnIndex = wIdx;
                }
            }
            
            this.gameState.lastPlayedCards = [];
            this.gameState.consecutivePasses = 0;
            turnCleared = true;
        }

        this._resetTimer(); 
        this._checkAndRunBot();

        return { 
            success: true, 
            turnCleared,
            logText: `${currPlayer.name}: ä¸è¦`
        };
    }

    _clearTimer() {
        if (this.timer) clearTimeout(this.timer);
        if (this.botTimer) clearTimeout(this.botTimer);
        this.timer = null;
        this.botTimer = null;
    }

    _resetTimer() {
        this._clearTimer();
        if (this.gameState && this._getActivePlayerCount() > 1) {
            this.turnStartTime = Date.now();
            const timeLimit = this.config.turnTimeout || 60000;
            this.timer = setTimeout(() => {
                this._handleTimeout();
            }, timeLimit);
        }
    }

    _handleTimeout() {
        if (!this.gameState) return;
        const currIdx = this.gameState.currentTurnIndex;
        const currPlayer = this.players[currIdx];
        
        console.log(`[Timeout] Player ${currPlayer.name} (${currPlayer.id}) timed out.`);
        const isNewRound = this.gameState.lastPlayedCards.length === 0;

        if (isNewRound) {
            const hand = this.gameState.hands[currPlayer.id];
            if (!hand || hand.length === 0) { this._advanceTurn(); return; }

            const sorted = hand.map(c => ({ id: c, val: CardRules.getPoint(c) })).sort((a, b) => a.val - b.val);
            const cardToPlay = [sorted[0].id]; 
            
            const result = this.playCards(currPlayer.id, cardToPlay);
            if (result.success) {
                this.io.to(currPlayer.id).emit('hand_update', this.gameState.hands[currPlayer.id]);
                
                const logText = result.logText || `${currPlayer.name} è¶…æ—¶å‡ºç‰Œ`;
                
                if (result.isRoundOver) {
                     this._handleWin(result, currPlayer.id);
                } else {
                     this._broadcastUpdate(logText);
                }
            }
        } else {
            const result = this.passTurn(currPlayer.id);
            if (result.success) {
                this._broadcastUpdate(`${currPlayer.name}: è¶…æ—¶è¿‡ç‰Œ`);
            }
        }
    }

    _getActivePlayerCount() {
        if (!this.gameState) return 0;
        let count = 0;
        for (const p of this.players) {
            if (this.gameState.hands[p.id] && this.gameState.hands[p.id].length > 0) {
                count++;
            }
        }
        return count;
    }

    _advanceTurn() {
        const playerCount = this.players.length;
        let nextIndex = this.gameState.currentTurnIndex;
        let attempts = 0;
        
        do {
            nextIndex = (nextIndex - 1 + playerCount) % playerCount;
            attempts++;
        } while (
            this.gameState.hands[this.players[nextIndex].id].length === 0 && 
            attempts < playerCount 
        );
        
        this.gameState.currentTurnIndex = nextIndex;
    }

    getPublicState() {
        if (!this.gameState) return null;
        
        const currentScoresDisplay = {};
        const playersInfo = {};
        
        const handCounts = {};

        this.players.forEach(p => {
            currentScoresDisplay[p.id] = (this.grandScores[p.id] || 0) + (this.gameState.roundPoints[p.id] || 0);
            // [å…³é”®ä¿®æ”¹] å°† team ä¿¡æ¯æš´éœ²ç»™å‰ç«¯
            playersInfo[p.id] = { 
                isBot: p.isBot, 
                isAutoPlay: p.isAutoPlay,
                team: p.team 
            };
            handCounts[p.id] = this.gameState.hands[p.id] ? this.gameState.hands[p.id].length : 0;
        });

        const winnerObj = this.players.find(p => p.id === this.gameState.roundWinnerId);

        let remainingSeconds = 0;
        if (this.turnStartTime) {
            const timeLimit = this.config.turnTimeout || 60000;
            const elapsed = Date.now() - this.turnStartTime;
            remainingSeconds = Math.max(0, Math.ceil((timeLimit - elapsed) / 1000));
        }
        
        return {
            turnIndex: this.gameState.currentTurnIndex,
            currentTurnId: this.players[this.gameState.currentTurnIndex].id,
            turnRemaining: remainingSeconds, 
            lastPlayed: this.gameState.lastPlayedCards,
            lastPlayerName: winnerObj ? winnerObj.name : '',
            scores: currentScoresDisplay,
            pendingPoints: this.gameState.pendingTablePoints,
            finishedRank: this.gameState.finishedRank,
            playersInfo: playersInfo,
            handCounts: handCounts 
        };
    }

    reconnectPlayer(oldId, newId) {
        if (this.grandScores[oldId] !== undefined) {
            this.grandScores[newId] = this.grandScores[oldId];
            delete this.grandScores[oldId];
        }
        if (this.lastWinnerId === oldId) this.lastWinnerId = newId;

        const player = this.players.find(p => p.id === newId);
        if (player) player.isAutoPlay = false;

        if (this.gameState) {
            if (this.gameState.hands[oldId]) {
                this.gameState.hands[newId] = this.gameState.hands[oldId];
                delete this.gameState.hands[oldId];
            }
            if (this.gameState.roundPoints[oldId] !== undefined) {
                this.gameState.roundPoints[newId] = this.gameState.roundPoints[oldId];
                delete this.gameState.roundPoints[oldId];
            }
            if (this.gameState.roundWinnerId === oldId) this.gameState.roundWinnerId = newId;
            
            const rankIdx = this.gameState.finishedRank.indexOf(oldId);
            if (rankIdx !== -1) {
                this.gameState.finishedRank[rankIdx] = newId;
            }
        }
        return true;
    }

    _handContainsCards(hand, cardsToPlay) {
        const tempHand = [...hand];
        for (let c of cardsToPlay) {
            const idx = tempHand.indexOf(c);
            if (idx === -1) return false;
            tempHand.splice(idx, 1);
        }
        return true;
    }

    _removeCardsFromHand(playerId, cards) {
        const newHand = [...this.gameState.hands[playerId]];
        for (let c of cards) {
            const idx = newHand.indexOf(c);
            if (idx !== -1) newHand.splice(idx, 1);
        }
        this.gameState.hands[playerId] = newHand;
    }

    _concludeRound() {
        const lastPlayer = this.players.find(p => this.gameState.hands[p.id].length > 0);
        if (lastPlayer) {
            this.gameState.finishedRank.push(lastPlayer.id);
        }
        
        const wId = this.gameState.roundWinnerId;
        if (wId) {
             this.gameState.roundPoints[wId] = (this.gameState.roundPoints[wId] || 0) + this.gameState.pendingTablePoints;
             this.gameState.pendingTablePoints = 0;
        }

        const fullRankIds = [...this.gameState.finishedRank];
        this.players.forEach(p => {
            if (!fullRankIds.includes(p.id)) fullRankIds.push(p.id);
        });

        const firstWinnerId = fullRankIds[0];
        this.lastWinnerId = firstWinnerId;

        let logLines = [];

        let totalCardPenalty = 0;
        let cardPenaltyDetail = "";

        this.players.forEach(p => {
            const handPts = CardRules.calculateTotalScore(this.gameState.hands[p.id]);
            if (handPts > 0) {
                totalCardPenalty += handPts;
                cardPenaltyDetail += `${p.name}-${handPts} `;
            }
            this.grandScores[p.id] += (this.gameState.roundPoints[p.id] || 0);
        });

        // å¤´æ¸¸æ”¶åˆ†é€»è¾‘
        if (firstWinnerId && totalCardPenalty > 0) {
            this.grandScores[firstWinnerId] += totalCardPenalty;
            logLines.push(`[æ‰‹ç‰Œç½šåˆ†] è¾“å®¶å…±è®¡ ${totalCardPenalty} åˆ†ï¼Œå½’ç¬¬ä¸€å ${this.players.find(p=>p.id===firstWinnerId)?.name}ã€‚`);
        }

        // æ’åèµç½š + [æ–°å¢] é˜Ÿå‹ä¿æŠ¤é€»è¾‘
        if (this.config.enableRankPenalty && this.config.rankPenaltyScores && this.config.rankPenaltyScores.length > 0) {
            const penaltyConfig = this.config.rankPenaltyScores;
            const playerCount = fullRankIds.length;
            
            penaltyConfig.forEach((score, index) => {
                const winnerIndex = index; 
                const loserIndex = playerCount - 1 - index; 

                if (winnerIndex < loserIndex) {
                    const winnerId = fullRankIds[winnerIndex];
                    const loserId = fullRankIds[loserIndex];
                    
                    if (winnerId && loserId) {
                        const winner = this.players.find(p=>p.id===winnerId);
                        const loser = this.players.find(p=>p.id===loserId);
                        
                        // [æ–°å¢] é˜Ÿå‹ä¿æŠ¤åˆ¤æ–­
                        // é€»è¾‘ï¼šå¦‚æœä¸¤äººéƒ½æœ‰ team å±æ€§ï¼Œä¸” team ç›¸ç­‰ï¼Œåˆ™å…ç½š
                        if (winner.team !== null && winner.team !== undefined && winner.team === loser.team) {
                             logLines.push(`[ğŸ›¡ï¸é˜Ÿå‹ä¿æŠ¤] ç¬¬${winnerIndex+1}å(${winner.name}) ä¸ å€’æ•°ç¬¬${index+1}å(${loser.name}) æ˜¯é˜Ÿå‹ï¼Œ${score}åˆ† å…ç½šï¼`);
                        } else {
                            // æ­£å¸¸ç½šåˆ†
                            this.grandScores[winnerId] += score;
                            this.grandScores[loserId] -= score;
                            logLines.push(`[æ’åèµç½š] ç¬¬${winnerIndex+1}å ${winner.name} æ”¶å– å€’æ•°ç¬¬${index+1}å ${loser.name} ${score} åˆ†ã€‚`);
                        }
                    }
                }
            });
        }

        const firstWinnerName = this.players.find(p => p.id === firstWinnerId)?.name || 'æœªçŸ¥';
        const isGrandOver = this.grandScores[firstWinnerId] >= this.config.targetScore;
        const totalPointsEarned = (this.gameState.roundPoints[firstWinnerId] || 0) + totalCardPenalty;

        return {
            roundWinnerName: firstWinnerName,
            pointsEarned: totalPointsEarned, 
            detail: logLines.join('\n') || 'å®Œç¾ç»“æŸï¼Œæœªè®¾ç½®é¢å¤–ç½šåˆ†', 
            grandScores: this.grandScores,
            isGrandOver
        };
    }
    
    getPlayerHand(playerId) {
        if (!this.gameState || !this.gameState.hands) return [];
        return this.gameState.hands[playerId] || [];
    }
}

module.exports = GameManager;

================================================================================
FILE PATH: server\index.js
================================================================================
// ç¨‹åºå…¥å£ï¼Œåªè´Ÿè´£å¯åŠ¨æœåŠ¡å’Œ Socket ç›‘å¬
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const cors = require('cors');
const path = require('path');

// å¼•å…¥æ¨¡å—
const GameManager = require('./game/GameManager');

const app = express();
app.use(cors());

const server = http.createServer(app);
const io = new Server(server, {
    cors: { origin: "*", methods: ["GET", "POST"] }
});

// å†…å­˜æ•°æ®åº“
const rooms = {}; 

/**
 * è¾…åŠ©å‡½æ•°ï¼šå‘æˆ¿é—´å†…æ‰€æœ‰äººå¹¿æ’­æœ€æ–°çŠ¶æ€
 */
function broadcastGameState(io, roomId, room, infoText = null) {
    if (!room.gameManager) return;
    
    // ä» GameManager è·å–çº¯å‡€çš„ UI å±•ç¤ºæ•°æ®
    const publicState = room.gameManager.getPublicState();
    if (!publicState) return;

    if (infoText) publicState.infoText = infoText;

    io.to(roomId).emit('game_state_update', publicState);
}

io.on('connection', (socket) => {
    console.log(`[Connect] ${socket.id}`);
    socket.emit('your_id', socket.id);

    // --- åˆ›å»ºæˆ¿é—´ ---
    socket.on('create_room', ({ roomId, username, config }) => {
        if (rooms[roomId]) return socket.emit('error_msg', 'æˆ¿é—´å·²å­˜åœ¨');
        
        const cleanName = String(username || '').trim();
        if (!cleanName) return socket.emit('error_msg', 'ç”¨æˆ·åä¸èƒ½ä¸ºç©º');

        const roomConfig = { deckCount: 1, maxPlayers: 3, targetScore: 500, ...config };
        
        rooms[roomId] = {
            config: roomConfig,
            players: [],
            gameManager: null,
            destroyTimer: null 
        };
        
        socket.join(roomId);
        rooms[roomId].players.push({ id: socket.id, name: cleanName, isHost: true, online: true });
        
        const initialScores = {};
        rooms[roomId].players.forEach(p => initialScores[p.id] = 0);

        const data = { roomId, config: roomConfig, players: rooms[roomId].players, grandScores: initialScores };
        socket.emit('room_info', data); 
        io.to(roomId).emit('room_info', data);
    });

    // --- åŠ å…¥æˆ¿é—´ ---
    socket.on('join_room', ({ roomId, username }) => {
        const room = rooms[roomId];
        if (!room) return socket.emit('error_msg', 'æˆ¿é—´ä¸å­˜åœ¨');

        const cleanName = String(username || '').trim();
        if (!cleanName) return socket.emit('error_msg', 'ç”¨æˆ·åä¸èƒ½ä¸ºç©º');

        const existingPlayerIndex = room.players.findIndex(p => p.name === cleanName);
        let isReconnect = false;
        let oldSocketId = null;

        if (existingPlayerIndex !== -1) {
            const existingPlayer = room.players[existingPlayerIndex];
            
            if (existingPlayer.online) {
                return socket.emit('error_msg', `åå­— "${cleanName}" å·²è¢«ä½¿ç”¨ä¸”ç©å®¶åœ¨çº¿`);
            }

            isReconnect = true;
            oldSocketId = existingPlayer.id;
            console.log(`[Reconnect] Success! ${cleanName} (${oldSocketId} -> ${socket.id})`);

            existingPlayer.id = socket.id;
            existingPlayer.online = true; 

            if (room.destroyTimer) {
                clearTimeout(room.destroyTimer);
                room.destroyTimer = null;
                console.log(`[Room] Destruction cancelled for ${roomId} (player returned)`);
            }

            if (room.gameManager) {
                room.gameManager.reconnectPlayer(oldSocketId, socket.id);
            }
        } else {
            if (room.players.length >= room.config.maxPlayers) {
                return socket.emit('error_msg', 'æˆ¿é—´å·²æ»¡');
            }
            
            socket.join(roomId);
            if (!room.players.find(u => u.id === socket.id)) {
                room.players.push({ id: socket.id, name: cleanName, isHost: false, online: true });
            }
        }

        socket.join(roomId);
        
        let currentGrandScores = {};
        if (room.gameManager) {
            currentGrandScores = room.gameManager.grandScores;
        } else {
            room.players.forEach(p => currentGrandScores[p.id] = 0);
        }
        
        const data = { roomId, config: room.config, players: room.players, grandScores: currentGrandScores };
        
        socket.emit('room_info', data);

        const isGameRunning = room.gameManager && room.gameManager.gameState;
        if (!isGameRunning) {
            socket.to(roomId).emit('room_info', data);
        }

        if (isGameRunning) {
            if (isReconnect) {
                const hand = room.gameManager.getPlayerHand(socket.id);
                socket.emit('game_started', { 
                    hand: hand, 
                    grandScores: room.gameManager.grandScores 
                });
            }
            broadcastGameState(io, roomId, room);
        }
    });
    
    // æ·»åŠ æœºå™¨äºº
    socket.on('add_bot', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room) return;
        
        if (room.players.length >= room.config.maxPlayers) return socket.emit('error_msg', 'æˆ¿é—´å·²æ»¡');
        
        const botId = `bot_${Date.now()}_${Math.floor(Math.random()*1000)}`;
        const botName = `Robot ${Math.floor(Math.random()*100)}`;
        
        room.players.push({ 
            id: botId, 
            name: botName, 
            isHost: false, 
            online: true,
            isBot: true 
        });
        
        const currentGrandScores = room.gameManager ? room.gameManager.grandScores : {};
        currentGrandScores[botId] = 0;

        const data = { roomId, config: room.config, players: room.players, grandScores: currentGrandScores };
        io.to(roomId).emit('room_info', data);
    });

    // åˆ‡æ¢æ‰˜ç®¡
    socket.on('toggle_auto_play', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room || !room.gameManager) return;

        room.gameManager.toggleAutoPlay(socket.id);
        broadcastGameState(io, roomId, room);
    });

    // [æ–°å¢] åº§ä½è°ƒæ•´
    socket.on('switch_seat', ({ roomId, index1, index2 }) => {
        const room = rooms[roomId];
        if (!room) return;

        // 1. æƒé™æ£€æŸ¥ï¼šå¿…é¡»æ˜¯æˆ¿ä¸»
        const requestPlayer = room.players.find(p => p.id === socket.id);
        if (!requestPlayer || !requestPlayer.isHost) {
            return socket.emit('error_msg', 'åªæœ‰æˆ¿ä¸»å¯ä»¥è°ƒæ•´åº§ä½');
        }

        // 2. è¾¹ç•Œæ£€æŸ¥
        if (index1 < 0 || index1 >= room.players.length || index2 < 0 || index2 >= room.players.length) {
            return;
        }

        // 3. æ¸¸æˆè¿›è¡Œä¸­ç¦æ­¢è°ƒæ•´
        if (room.gameManager && room.gameManager.gameState) {
             return socket.emit('error_msg', 'æ¸¸æˆä¸­æ— æ³•è°ƒæ•´åº§ä½');
        }

        // 4. äº¤æ¢ä½ç½®
        const temp = room.players[index1];
        room.players[index1] = room.players[index2];
        room.players[index2] = temp;

        // 5. å¹¿æ’­æ›´æ–°
        const currentGrandScores = room.gameManager ? room.gameManager.grandScores : {};
        if (Object.keys(currentGrandScores).length === 0) {
            room.players.forEach(p => currentGrandScores[p.id] = 0);
        }

        const data = { 
            roomId, 
            config: room.config, 
            players: room.players, 
            grandScores: currentGrandScores 
        };
        io.to(roomId).emit('room_info', data);
    });

    // --- æ¸¸æˆæµç¨‹ ---
    const handleGameStart = (roomId, isNextRound) => {
        const room = rooms[roomId];
        if (!room) return;

        if (!isNextRound || !room.gameManager) {
            room.gameManager = new GameManager(room.config, room.players, io, roomId);
        }

        const startInfo = room.gameManager.startRound(isNextRound);

        room.players.forEach((p) => {
            if (!p.isBot) { 
                const hand = startInfo.hands[p.id];
                io.to(p.id).emit('game_started', { 
                    hand: hand, 
                    grandScores: room.gameManager.grandScores,
                    // [æ³¨æ„] è¿™é‡Œè¦å¸¦ä¸Šç‰Œæ•°
                    handCounts: room.gameManager.getPublicState().handCounts
                });
            }
        });

        const startPlayerName = room.players[startInfo.startPlayerIndex].name;
        const msg = isNextRound 
            ? `æ–°ä¸€è½®å¼€å§‹ï¼ç”± ${startPlayerName} å…ˆå‡º` 
            : `æ¸¸æˆå¼€å§‹ï¼ç›®æ ‡ ${room.config.targetScore} åˆ†`;
        
        broadcastGameState(io, roomId, room, msg);
    };

    socket.on('start_game', ({ roomId }) => handleGameStart(roomId, false));
    socket.on('next_round', ({ roomId }) => handleGameStart(roomId, true));

// --- å‡ºç‰Œ ---
    socket.on('play_cards', ({ roomId, cards }) => {
        const room = rooms[roomId];
        if (!room || !room.gameManager) return;
        
        const result = room.gameManager.playCards(socket.id, cards);

        if (!result.success) {
            return socket.emit('play_error', result.error);
        }

        const currentHand = room.gameManager.gameState.hands[socket.id];
        io.to(socket.id).emit('hand_update', currentHand);

        if (result.isRoundOver) { 
            const rInfo = result.roundResult;
            if (rInfo.isGrandOver) {
                io.to(roomId).emit('grand_game_over', { 
                    grandWinner: rInfo.roundWinnerName, 
                    grandScores: rInfo.grandScores 
                });
                room.gameManager = null; 
            } else {
                io.to(roomId).emit('round_over', {
                    roundWinner: rInfo.roundWinnerName,
                    pointsEarned: rInfo.pointsEarned,
                    detail: rInfo.detail,
                    grandScores: rInfo.grandScores
                });
            }
        } else {
            // å¹¿æ’­çŠ¶æ€æ—¶ï¼Œé™„å¸¦å‡ºç‰Œçš„æ—¥å¿—æ–‡æœ¬
            broadcastGameState(io, roomId, room, result.logText);
        }
    });

    // --- è¿‡ç‰Œ ---
    socket.on('pass_turn', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room || !room.gameManager) return;

        const result = room.gameManager.passTurn(socket.id);
        
        if (!result.success) return socket.emit('play_error', result.error);

        broadcastGameState(io, roomId, room, result.logText || "PASS");
    });

    // --- æ–­å¼€è¿æ¥ ---
    socket.on('disconnect', () => {
        Object.keys(rooms).forEach(rId => {
            const r = rooms[rId];
            
            const idx = r.players.findIndex(p => p.id === socket.id);
            if (idx === -1) return; 

            const player = r.players[idx];
            const isGameRunning = r.gameManager && r.gameManager.gameState;

            if (!isGameRunning) {
                r.players.splice(idx, 1);
                console.log(`[Disconnect] Lobby user ${player.name} removed from ${rId}`);
                
                if (r.players.length === 0) {
                    if (r.destroyTimer) clearTimeout(r.destroyTimer);
                    delete rooms[rId];
                    console.log(`[Room] Room ${rId} deleted (empty lobby).`);
                } else {
                    io.to(rId).emit('room_info', { 
                        roomId: rId, 
                        config: r.config, 
                        players: r.players, 
                        grandScores: r.gameManager ? r.gameManager.grandScores : {} 
                    });
                }
            } else {
                player.online = false;
                console.log(`[Disconnect] Game user ${player.name} (${socket.id}) dropped.`);

                const allHumansOffline = r.players.filter(p => !p.isBot).every(p => !p.online);
                
                if (allHumansOffline) {
                    console.log(`[Room] Room ${rId} is empty. Scheduling destruction in 60s...`);
                    
                    if (r.destroyTimer) clearTimeout(r.destroyTimer);
                    
                    r.destroyTimer = setTimeout(() => {
                        if (rooms[rId] && rooms[rId].players.filter(p => !p.isBot).every(p => !p.online)) {
                            delete rooms[rId];
                            console.log(`[Room] Room ${rId} destroyed due to inactivity (game running).`);
                        }
                    }, 60000); 
                }
            }
        });
    });
});



// è¿™ä¸€æ®µçš„æ„æ€æ˜¯ï¼šå¦‚æœæ˜¯åœ¨çº¿ä¸Šç¯å¢ƒï¼Œå°±æŠŠ React æ‰“åŒ…å¥½çš„æ–‡ä»¶(build)å‘ç»™æµè§ˆå™¨
if (process.env.NODE_ENV === 'production') {
    // 1. æŒ‡å®šé™æ€æ–‡ä»¶ç›®å½•
    const buildPath = path.join(__dirname, '../client/dist');
    app.use(express.static(buildPath));
    // 2. ä»»ä½•å…¶ä»–è¯·æ±‚ï¼Œéƒ½è¿”å› index.html
    app.get(/(.*)/, (req, res) => {
        res.sendFile(path.join(__dirname, '../client/dist', 'index.html'));
    });
}

// å¯åŠ¨æœåŠ¡å™¨
const PORT = process.env.PORT || 3001;
server.listen(PORT, () => {
    console.log(`>>> Server Running on port ${PORT}`);
});

================================================================================
FILE PATH: server\package.json
================================================================================
{
  "name": "server",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^5.2.1",
    "nodemon": "^3.1.11",
    "socket.io": "^4.8.1"
  }
}


================================================================================
FILE PATH: server\utils\socketAuth.js
================================================================================
// (å¯é€‰) èº«ä»½éªŒè¯å·¥å…·
