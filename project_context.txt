Project Context Generated at 2025/12/15 12:26:10


================================================================================
FILE PATH: server\game\CardRules.js
================================================================================
// 纯规则计算 (510K 逻辑、比大小)

const CardRules = {
    // 1. 基础映射
    // 3=3 ... K=13, A=14, 2=15, 小王=16, 大王=17
    getPoint: (cardVal) => {
        const normalized = cardVal % 54;
        if (normalized === 52) return 16;
        if (normalized === 53) return 17;
        const base = normalized % 13;
        if (base === 0) return 14; // A
        if (base === 1) return 15; // 2
        return base + 1; // 3 => 3
    },

    // 获取牌的分数 (5=5, 10=10, K=10)
    getCardScore: (cardVal) => {
        const p = CardRules.getPoint(cardVal);
        if (p === 5) return 5;
        if (p === 10) return 10;
        if (p === 13) return 10; // K
        return 0;
    },

    // 计算一组牌的总分
    calculateTotalScore: (cards) => {
        return cards.reduce((sum, c) => sum + CardRules.getCardScore(c), 0);
    },

    // 获取牌的花色 (0-3)
    getSuit: (cardVal) => {
        const normalized = cardVal % 54;
        if (normalized >= 52) return -1; // 王没有花色
        return Math.floor(normalized / 13);
    },

    // 2. 核心：牌型分析
    analyze: (cards, deckCount = 1) => {
        const len = cards.length;
        if (len === 0) return { type: 'EMPTY' };

        // 排序：点数从小到大
        const points = cards.map(CardRules.getPoint).sort((a, b) => a - b);
        
        // 统计点数频率 { point: count }
        const counts = {};
        points.forEach(p => { counts[p] = (counts[p] || 0) + 1; });
        const uniquePoints = Object.keys(counts).map(Number).sort((a,b)=>a-b);
        
        // --- 非炸弹牌型 ---

        // 单张
        if (len === 1) return { type: 'SINGLE', val: points[0], level: 0 };

        // 对子
        if (len === 2 && points[0] === points[1]) {
            return { type: 'PAIR', val: points[0], level: 0 };
        }

        // 三张 (不带)
        if (len === 3 && uniquePoints.length === 1) {
            return { type: 'TRIPLE', val: points[0], level: 0 };
        }

        // 连对 (简化版，核心是偶数张且连续)
        if (len >= 4 && len % 2 === 0) {
            // 简单校验：不含2和王，且点数连续
            if (!points.some(p => p >= 15)) {
                let isLiandui = true;
                // 检查是否是连续的对子 (3344, 334455)
                // 这里简化处理，实际项目可加更严格校验
                if (uniquePoints.length === len / 2) {
                     // 检查 uniquePoints 是否连续
                     for(let i=0; i<uniquePoints.length-1; i++) {
                         if(uniquePoints[i+1] !== uniquePoints[i]+1) isLiandui = false;
                     }
                     if (isLiandui) return { type: 'LIANDUI', val: points[0], len: len, level: 0 };
                }
            }
        }

        // --- 炸弹牌型 (Level 1-5) ---

        // Level 1 & 2: 510K
        if (len === 3) {
            const has5 = points.includes(5);
            const has10 = points.includes(10);
            const hasK = points.includes(13);
            if (has5 && has10 && hasK) {
                // 检查花色
                const suits = cards.map(CardRules.getSuit);
                const isPure = (suits[0] === suits[1] && suits[1] === suits[2]);
                if (isPure) {
                    return { type: '510K_PURE', val: suits[0], level: 2 }; // 纯510K (Level 2)
                } else {
                    return { type: '510K_MIXED', val: 0, level: 1 }; // 杂510K (Level 1)
                }
            }
        }

        // Level 3: 普通炸弹 (>=4张)
        if (uniquePoints.length === 1 && len >= 4) {
            // Level 5: 至尊满炸 (Rank数量 == DECK_COUNT * 4)
            if (len === deckCount * 4) {
                 return { type: 'BOMB_MAX', val: points[0], level: 5 };
            }
            // 普通炸弹
            return { type: 'BOMB_STD', val: points[0], len: len, level: 3 };
        }

        // Level 4: 天王炸 (所有王)
        const isAllJokers = points.every(p => p >= 16);
        if (isAllJokers && len === deckCount * 2) {
            return { type: 'BOMB_KING', val: 999, level: 4 };
        }

        return { type: 'INVALID' };
    },

    // 3. 校验能否管牌
    canPlay: (newCards, lastCards, deckCount) => {
        const newHand = CardRules.analyze(newCards, deckCount);
        if (newHand.type === 'INVALID') return false;

        // 自由出牌
        if (!lastCards || lastCards.length === 0) return true;

        const lastHand = CardRules.analyze(lastCards, deckCount);

        // A. 炸弹 vs 非炸弹
        if (newHand.level > 0 && lastHand.level === 0) return true;
        if (newHand.level === 0 && lastHand.level > 0) return false;

        // B. 炸弹之间 (Level 比较)
        if (newHand.level > 0 && lastHand.level > 0) {
            if (newHand.level > lastHand.level) return true;
            if (newHand.level < lastHand.level) return false;

            // 同级别比较
            if (newHand.type === '510K_MIXED') return false; // 互不管
            if (newHand.type === '510K_PURE') return false; 

            if (newHand.type === 'BOMB_STD') {
                if (newHand.len > lastHand.len) return true;
                if (newHand.len < lastHand.len) return false;
                return newHand.val > lastHand.val;
            }
            
            if (newHand.type === 'BOMB_MAX') return newHand.val > lastHand.val;
            return false;
        }

        // C. 非炸弹之间 (同牌型比较)
        if (newHand.type === lastHand.type) {
            if (newHand.type === 'LIANDUI' && newHand.len !== lastHand.len) return false;
            // 必须张数一致
            if (newCards.length !== lastCards.length) return false;
            return newHand.val > lastHand.val;
        }

        return false;
    }
};

module.exports = CardRules;

================================================================================
FILE PATH: server\game\Deck.js
================================================================================
// 牌库生成与洗牌


class Deck {
    constructor(deckCount = 1) {
        this.deck = [];
        // 生成多副牌。每副牌是 0-53。
        // 我们使用 i + d * 54 来保证每张牌有唯一ID，方便前端渲染 Key 值
        for (let d = 0; d < deckCount; d++) {
             for (let i = 0; i < 54; i++) {
                this.deck.push(i + d * 54); 
            }
        }
    }

    shuffle() {
        // Fisher-Yates 洗牌算法
        for (let i = this.deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
        }
    }

    deal(playerCount) {
        this.shuffle();
        const hands = {};
        const totalCards = this.deck.length;
        const cardsPerPlayer = Math.floor(totalCards / playerCount); 
        
        for (let i = 0; i < playerCount; i++) {
            hands[i] = this.deck.slice(i * cardsPerPlayer, (i + 1) * cardsPerPlayer);
            // 将多余的牌发给最后一个人（简化处理）
            if (i === playerCount - 1) {
                 hands[i] = this.deck.slice(i * cardsPerPlayer);
            }
        }
        return hands;
    }
}

module.exports = Deck;

================================================================================
FILE PATH: server\game\GameManager.js
================================================================================
// 房间管理、游戏流程控制 (Deal, Play, Pass)

================================================================================
FILE PATH: server\index.js
================================================================================
// (原 server.js) 程序入口，只负责启动服务和 Socket 监听
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const cors = require('cors');

// 引入模块
const CardRules = require('./game/CardRules');
const Deck = require('./game/Deck');

const app = express();
app.use(cors());

const server = http.createServer(app);
const io = new Server(server, {
    cors: { origin: "*", methods: ["GET", "POST"] }
});

const rooms = {}; 

function broadcastGameState(io, roomId, room, infoText = null) {
    const game = room.game;
    if (!game) return;
    const players = room.players;
    
    const currentScoresDisplay = {};
    players.forEach(p => {
        currentScoresDisplay[p.id] = (room.grandScores[p.id] || 0) + (game.roundPoints[p.id] || 0);
    });

    io.to(roomId).emit('game_state_update', {
        turnIndex: game.currentTurnIndex,
        currentTurnId: players[game.currentTurnIndex].id,
        lastPlayed: game.lastPlayedCards,
        lastPlayerName: players.find(p => p.id === game.roundWinnerId)?.name || '',
        infoText: infoText,
        scores: currentScoresDisplay,
        pendingPoints: game.pendingTablePoints
    });
}

io.on('connection', (socket) => {
    console.log(`[Connect] ${socket.id}`);
    socket.emit('your_id', socket.id);

    // --- 创建房间 ---
    socket.on('create_room', ({ roomId, username, config }) => {
        if (rooms[roomId]) return socket.emit('error_msg', '房间已存在');
        
        const roomConfig = { deckCount: 1, maxPlayers: 3, targetScore: 500, ...config };
        
        rooms[roomId] = {
            config: roomConfig,
            players: [],
            grandScores: {}, 
            lastWinnerId: null, // 新增：记录上一局赢家
            game: null
        };
        
        socket.join(roomId);
        rooms[roomId].players.push({ id: socket.id, name: username, isHost: true });
        rooms[roomId].grandScores[socket.id] = 0;

        const data = { roomId, config: roomConfig, players: rooms[roomId].players, grandScores: rooms[roomId].grandScores };
        socket.emit('room_info', data); 
        io.to(roomId).emit('room_info', data);
    });

    // --- 加入房间 ---
    socket.on('join_room', ({ roomId, username }) => {
        const room = rooms[roomId];
        if (!room) return socket.emit('error_msg', '房间不存在');
        if (room.players.length >= room.config.maxPlayers) return socket.emit('error_msg', '房间已满');

        socket.join(roomId);
        if (!room.players.find(u=>u.id===socket.id)) {
            room.players.push({ id: socket.id, name: username, isHost: false });
            if (room.grandScores[socket.id] === undefined) room.grandScores[socket.id] = 0;
        }
        
        const data = { roomId, config: room.config, players: room.players, grandScores: room.grandScores };
        socket.emit('room_info', data);
        io.to(roomId).emit('room_info', data);
    });

    // --- 游戏流程控制 ---
    const startGameLogic = (roomId, isNextRound = false) => {
        const room = rooms[roomId];
        if (!room) return;

        // 如果是全新开始，重置大分和赢家记录
        if (!isNextRound) {
            room.players.forEach(p => room.grandScores[p.id] = 0);
            room.lastWinnerId = null;
        }

        const deck = new Deck(room.config.deckCount);
        const hands = deck.deal(room.players.length);

        // 确定谁先出牌：如果有上一局赢家，他先出；否则房主(0)先出
        let startIndex = 0;
        if (room.lastWinnerId) {
            const winnerIdx = room.players.findIndex(p => p.id === room.lastWinnerId);
            if (winnerIdx !== -1) startIndex = winnerIdx;
        }

        room.game = {
            hands: {}, 
            currentTurnIndex: startIndex, // 设定初始出牌人
            lastPlayedCards: [], 
            consecutivePasses: 0, 
            winner: null,
            roundPoints: {},      
            pendingTablePoints: 0,
            roundWinnerId: null,  
        };

        room.players.forEach((p, index) => {
            room.game.hands[p.id] = hands[index];
            room.game.roundPoints[p.id] = 0;
            io.to(p.id).emit('game_started', { hand: hands[index], grandScores: room.grandScores });
        });

        const startPlayerName = room.players[startIndex].name;
        broadcastGameState(io, roomId, room, isNextRound ? `新一轮开始！由 ${startPlayerName} 先出` : `游戏开始！目标 ${room.config.targetScore} 分`);
    };

    socket.on('start_game', ({ roomId }) => startGameLogic(roomId, false));
    socket.on('next_round', ({ roomId }) => startGameLogic(roomId, true));

    // --- 出牌 ---
    socket.on('play_cards', ({ roomId, cards }) => {
        const room = rooms[roomId];
        if (!room || !room.game) return;
        const gameState = room.game;
        
        const isNewRound = gameState.lastPlayedCards.length === 0 || gameState.consecutivePasses >= room.players.length - 1;
        const cardsToBeat = isNewRound ? [] : gameState.lastPlayedCards;
        
        if (!CardRules.canPlay(cards, cardsToBeat, room.config.deckCount)) {
            return socket.emit('play_error', '管不上！');
        }

        const playerHand = gameState.hands[socket.id];
        let newHand = [...playerHand];
        for (let c of cards) {
            const idx = newHand.indexOf(c);
            if (idx !== -1) newHand.splice(idx, 1);
        }
        gameState.hands[socket.id] = newHand;
        
        gameState.pendingTablePoints += CardRules.calculateTotalScore(cards);
        
        gameState.lastPlayedCards = cards;
        gameState.consecutivePasses = 0;
        gameState.roundWinnerId = socket.id;

        const currIdx = room.players.findIndex(p => p.id === socket.id);
        gameState.currentTurnIndex = (currIdx + 1) % room.players.length;

        // 判定小局结束
        if (newHand.length === 0) {
            const winnerId = socket.id;
            const winnerName = room.players[currIdx].name;
            
            // 记录本局赢家，用于下一局先手
            room.lastWinnerId = winnerId;

            let totalRoundScore = gameState.pendingTablePoints; 
            
            let penaltyLog = "";
            room.players.forEach(p => {
                if (p.id !== winnerId) {
                    const handPts = CardRules.calculateTotalScore(gameState.hands[p.id]);
                    if (handPts > 0) {
                        totalRoundScore += handPts;
                        penaltyLog += `${p.name}剩${handPts}分 `;
                    }
                }
            });

            totalRoundScore += (gameState.roundPoints[winnerId] || 0);
            room.grandScores[winnerId] += totalRoundScore;

            if (room.grandScores[winnerId] >= room.config.targetScore) {
                io.to(roomId).emit('grand_game_over', { grandWinner: winnerName, grandScores: room.grandScores });
                room.game = null;
            } else {
                io.to(roomId).emit('round_over', {
                    roundWinner: winnerName,
                    pointsEarned: totalRoundScore,
                    detail: penaltyLog ? `罚分: ${penaltyLog}` : '无罚分',
                    grandScores: room.grandScores
                });
            }
        } else {
            broadcastGameState(io, roomId, room);
            io.to(socket.id).emit('hand_update', newHand);
        }
    });

    // --- 过牌 ---
    socket.on('pass_turn', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room || !room.game) return;
        const gameState = room.game;
        
        if (gameState.lastPlayedCards.length === 0 || gameState.consecutivePasses >= room.players.length - 1) {
            return socket.emit('play_error', '必须出牌');
        }

        gameState.consecutivePasses++;
        const currIdx = room.players.findIndex(p => p.id === socket.id);
        gameState.currentTurnIndex = (currIdx + 1) % room.players.length;

        if (gameState.consecutivePasses >= room.players.length - 1) {
            const wId = gameState.roundWinnerId;
            if (wId) {
                gameState.roundPoints[wId] = (gameState.roundPoints[wId] || 0) + gameState.pendingTablePoints;
                gameState.pendingTablePoints = 0;
            }
            gameState.lastPlayedCards = [];
            gameState.currentTurnIndex = room.players.findIndex(p => p.id === wId);
        }

        broadcastGameState(io, roomId, room, "PASS");
    });

    socket.on('disconnect', () => {
        for (const rId in rooms) {
            const r = rooms[rId];
            if (!r.game) {
                const idx = r.players.findIndex(p => p.id === socket.id);
                if (idx !== -1) {
                    r.players.splice(idx, 1);
                    io.to(rId).emit('room_info', { roomId: rId, config: r.config, players: r.players, grandScores: r.grandScores });
                }
            }
        }
    });
});
const path = require('path');

// --- 生产环境部署配置 (关键代码) ---
// 这一段的意思是：如果是在线上环境，就把 React 打包好的文件(build)发给浏览器
if (process.env.NODE_ENV === 'production') {
    // 1. 指定静态文件目录
    app.use(express.static(path.join(__dirname, '../build')));

    // 2. 任何其他请求，都返回 index.html
    app.get(/(.*)/, (req, res) => {
        res.sendFile(path.join(__dirname, '../build', 'index.html'));
    });
}

// 启动服务器
const PORT = process.env.PORT || 3001;
server.listen(PORT, () => {
    console.log(`>>> Server Running on port ${PORT}`);
});





================================================================================
FILE PATH: server\package.json
================================================================================
{
  "name": "server",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^5.2.1",
    "nodemon": "^3.1.11",
    "socket.io": "^4.8.1"
  }
}


================================================================================
FILE PATH: server\utils\socketAuth.js
================================================================================
// (可选) 身份验证工具
