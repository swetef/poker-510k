Project Context Generated at 2025/12/23 18:37:34


================================================================================
FILE PATH: client\eslint.config.js
================================================================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])


================================================================================
FILE PATH: client\index.html
================================================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    
    <!-- [å…³é”®ä¿®æ”¹] å¢åŠ  viewport-fit=cover è§£å†³é¡¶éƒ¨é»‘è¾¹é—®é¢˜ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    
    <link rel="manifest" href="/manifest.json">
    
    <!-- [ä¿®å¤] æ›¿æ¢è¿‡æ—¶çš„ apple-mobile-web-app-capable -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="510Kå¯¹æˆ˜">
    
    <title>client</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

================================================================================
FILE PATH: client\package.json
================================================================================
{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "lucide-react": "^0.559.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "socket.io-client": "^4.8.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "vite": "npm:rolldown-vite@7.2.5"
  },
  "overrides": {
    "vite": "npm:rolldown-vite@7.2.5"
  }
}


================================================================================
FILE PATH: client\src\App.css
================================================================================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}


================================================================================
FILE PATH: client\src\App.jsx
================================================================================
import React from 'react';
import { RefreshCw, AlertCircle } from 'lucide-react'; 
// [ä¿®æ”¹] å¼•å…¥ useGame
import { useGame } from './context/GameContext.jsx';

import { LoginScreen } from './screens/LoginScreen.jsx';
import { LobbyScreen } from './screens/LobbyScreen.jsx';
import { GameScreen } from './screens/GameScreen.jsx';
import { DrawSeatScreen } from './screens/DrawSeatScreen.jsx';

export default function App() {
  // [ä¿®æ”¹] ç›´æ¥ä» Context è·å–éœ€è¦çš„çŠ¶æ€
  const { gameState, isConnected } = useGame();

  const renderLandscapeHint = () => (
      <div className="landscape-hint">
          <div className="phone-rotate-icon"></div>
          <h3 style={{marginBottom: 10, fontSize: 18}}>å»ºè®®ä½¿ç”¨æ¨ªå±æ¸¸ç©</h3>
          <p style={{fontSize: 14, opacity: 0.8, maxWidth: 250}}>
              510K éœ€è¦è¾ƒå¤§çš„å±•ç¤ºç©ºé—´ã€‚<br/>
              è¯·æ—‹è½¬æ‚¨çš„æ‰‹æœºä»¥è·å¾—æœ€ä½³ä½“éªŒã€‚
          </p>
          <button 
            style={{marginTop: 20, padding: '8px 20px', background: 'rgba(255,255,255,0.2)', color:'white', border:'1px solid white'}}
            onClick={(e) => { e.currentTarget.parentElement.style.display = 'none'; }}
          >
              æˆ‘éè¦ç«–å±ç©
          </button>
      </div>
  );

  const renderDisconnectAlert = () => (
      !isConnected && (
          <div style={{
              position: 'fixed', top: 0, left: 0, right: 0, zIndex: 9999,
              background: '#e74c3c', color: 'white', padding: '10px',
              display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 10,
              boxShadow: '0 2px 10px rgba(0,0,0,0.2)'
          }}>
              <AlertCircle size={20} />
              <span style={{fontWeight: 'bold'}}>è¿æ¥å·²æ–­å¼€ï¼Œæ­£åœ¨å°è¯•é‡è¿...</span>
              <button 
                onClick={() => window.location.reload()} 
                style={{
                    background: 'white', color: '#e74c3c', border: 'none', 
                    borderRadius: 20, padding: '4px 12px', fontSize: 12, fontWeight: 'bold',
                    cursor: 'pointer', display: 'flex', alignItems: 'center', gap: 4
                }}
              >
                  <RefreshCw size={12} /> åˆ·æ–°é‡è¿
              </button>
          </div>
      )
  );

  return (
    <>
      {renderDisconnectAlert()}
      {renderLandscapeHint()}
      
      {/* [ä¿®æ”¹] å­ç»„ä»¶ä¸å†éœ€è¦ä¼ å‚ï¼Œå®ƒä»¬ä¼šè‡ªå·±å» Context é‡Œæ‹¿æ•°æ® */}
      {gameState === 'LOGIN' && <LoginScreen />}
      
      {gameState === 'LOBBY' && <LobbyScreen />}
      
      {gameState === 'DRAW_SEATS' && <DrawSeatScreen />}
      
      {gameState === 'GAME' && <GameScreen />}
    </>
  );
}

================================================================================
FILE PATH: client\src\components\BaseUI.jsx
================================================================================
// BaseUI.jsx ç°åœ¨ä¸»è¦ä½œä¸ºç»„ä»¶å¯¼å‡ºå…¥å£
// å…·ä½“çš„ç»„ä»¶é€»è¾‘å·²ç»æ‹†åˆ†åˆ° ui/ ç›®å½•ä¸‹
// è¿™æ ·å¯ä»¥å¤§å¹…å‡å°‘å•ä¸ªæ–‡ä»¶çš„é•¿åº¦ï¼Œä¾¿äº AI é˜…è¯»å’Œç»´æŠ¤

export { Card, MiniCard } from './ui/Card.jsx';
export { GameLogPanel } from './ui/GameLogPanel.jsx';
export { PlayerAvatar } from './ui/PlayerAvatar.jsx';

================================================================================
FILE PATH: client\src\components\CountDownTimer.jsx
================================================================================
import React, { useState, useEffect, useRef } from 'react';
import { Clock } from 'lucide-react';
import SoundManager from '../utils/SoundManager.js';

const CountDownTimer = ({ initialSeconds, totalSeconds = 60, position = 'top' }) => {
    const [seconds, setSeconds] = useState(initialSeconds);
    const intervalRef = useRef(null);

    useEffect(() => {
        setSeconds(initialSeconds);
    }, [initialSeconds]);

    useEffect(() => {
        if (intervalRef.current) clearInterval(intervalRef.current);
        if (seconds <= 0) return;

        intervalRef.current = setInterval(() => {
            setSeconds((prev) => {
                if (prev <= 1) {
                    clearInterval(intervalRef.current);
                    return 0;
                }
                
                if (prev <= 6 && prev > 1) {
                     SoundManager.play('tick');
                }
                
                return prev - 1;
            });
        }, 1000);

        return () => {
            if (intervalRef.current) clearInterval(intervalRef.current);
        };
    }, [initialSeconds]);

    const isUrgent = seconds <= 10;
    const isCritical = seconds <= 5; 
    
    const color = isUrgent ? '#ff4d4d' : '#ffffff';
    const bgColor = isUrgent ? 'rgba(231, 76, 60, 0.9)' : 'rgba(0, 0, 0, 0.7)';

    let posStyle = {};
    switch (position) {
        case 'bottom':
            posStyle = { top: '100%', left: '50%', transform: 'translateX(-50%)', marginTop: 5 };
            break;
        case 'left':
            posStyle = { right: '100%', top: '50%', transform: 'translateY(-50%)', marginRight: 8 };
            break;
        case 'right':
            posStyle = { left: '100%', top: '50%', transform: 'translateY(-50%)', marginLeft: 8 };
            break;
        case 'top-right': 
            posStyle = { left: '100%', top: -20, marginLeft: 5 };
            break;
        case 'inline': 
            posStyle = { position: 'static', margin: '0 10px' };
            break;
        case 'top':
        default:
            posStyle = { bottom: '100%', left: '50%', transform: 'translateX(-50%)', marginBottom: 5 };
            break;
    }

    const containerStyle = position === 'inline' ? {
        ...posStyle,
        background: bgColor,
        padding: '4px 10px',
        borderRadius: 20,
        display: 'flex',
        alignItems: 'center',
        gap: 5,
        border: '1px solid rgba(255,255,255,0.2)',
        transition: 'all 0.3s'
    } : {
        position: 'absolute',
        ...posStyle,
        background: bgColor,
        padding: '2px 8px',
        borderRadius: 20,
        display: 'flex',
        alignItems: 'center',
        gap: 3,
        whiteSpace: 'nowrap',
        boxShadow: '0 4px 10px rgba(0,0,0,0.3)',
        border: '1px solid rgba(255,255,255,0.2)',
        zIndex: 30,
        transition: 'all 0.3s'
    };

    return (
        <div style={containerStyle} className={isCritical ? "critical-pulse" : ""}>
            <Clock size={12} color={color} className={isUrgent ? 'spin' : ''} />
            <span style={{ 
                color: color, 
                fontWeight: 'bold', 
                fontSize: 12,
                fontFamily: 'monospace'
            }}>
                {seconds}s
            </span>
            <style>{`.spin { animation: spin 1s linear infinite; }`}</style>
        </div>
    );
};

export default CountDownTimer;

================================================================================
FILE PATH: client\src\components\game\GameActionBar.jsx
================================================================================
import React, { useState, useEffect } from 'react';
import { RotateCcw, Zap, Lightbulb, Clock, Loader2, AlertTriangle, Repeat, Shield, Coins, Coffee, Eye } from 'lucide-react';
import css from './GameActionBar.module.css';
import { useGame } from '../../context/GameContext.jsx';
import TimerComponent from '../CountDownTimer.jsx';
import { isBomb } from '../../utils/cardLogic.js';

export const GameActionBar = () => {
    const { 
        winner, roundResult, grandResult, selectedCards, 
        playersInfo, mySocketId, currentTurnId, players, turnRemaining,
        handleClearSelection, handleToggleAutoPlay, handleSwitchAutoPlayMode,
        handlePass, handleRequestHint, handlePlayCards,
        isSubmitting, lastPlayerName,
        isSpectator, observedHands // [æ–°å¢]
    } = useGame();

    const [confirmState, setConfirmState] = useState(false);

    useEffect(() => {
        setConfirmState(false);
    }, [selectedCards, currentTurnId]);

    if (winner || roundResult || grandResult) return null;

    // [æ–°å¢] å¦‚æœæ˜¯è§‚ä¼—ï¼Œæ˜¾ç¤ºç®€å•çš„çŠ¶æ€æ 
    if (isSpectator) {
        return (
             <div className={css.actionBar}>
                <div className={css.waitingBadge}>
                    <Eye size={20} /> æ­£åœ¨è§‚æˆ˜ä¸­...
                </div>
            </div>
        );
    }

    const myInfo = playersInfo[mySocketId] || {};
    const amIAutoPlay = myInfo.isAutoPlay;
    const currentMode = myInfo.autoPlayMode || 'SMART';
    
    // [æ–°å¢] å¦‚æœå·²ç»æ‰“å®Œç‰Œäº† (èµ¢äº†)ï¼Œæ˜¾ç¤ºè§‚çœ‹çŠ¶æ€
    // é€šè¿‡åˆ¤æ–­æ‰‹ç‰Œæ•° (myHand åœ¨ Context é‡Œï¼Œä½†è¿™é‡Œæ²¡è§£æ„ï¼Œå¯ä»¥ç”¨ observedHands ä¾§é¢åˆ¤æ–­)
    // æ›´ç®€å•çš„åˆ¤æ–­ï¼šå¦‚æœåœ¨ observedHands é‡Œæœ‰æ•°æ®ï¼Œè¯´æ˜æˆ‘å·²ç» finished å¹¶ä¸”æ”¶åˆ°äº†æ¨é€
    const isFinishedAndWatching = Object.keys(observedHands).length > 0;
    
    if (isFinishedAndWatching) {
        return (
            <div className={css.actionBar}>
                <div className={css.waitingBadge} style={{background: 'rgba(52, 152, 219, 0.4)'}}>
                    <Eye size={20} /> å·²å®Œèµ›ï¼Œè§‚çœ‹é˜Ÿå‹ä¸­
                </div>
            </div>
        );
    }
    
    const myTurn = currentTurnId === mySocketId;
    const currentTurnPlayer = players.find(p => p.id === currentTurnId);
    const waitingText = currentTurnPlayer ? `ç­‰å¾… ${currentTurnPlayer.name}...` : 'ç­‰å¾…ä¸­...';

    const handlePlayClick = () => {
        if (isSubmitting) return;
        
        if (selectedCards.length === 0) {
            handlePlayCards();
            return;
        }

        const lastPlayer = players.find(p => p.name === lastPlayerName);
        const isTeammate = 
            myInfo.team !== undefined && myInfo.team !== null && 
            lastPlayer && lastPlayer.id !== mySocketId && 
            playersInfo[lastPlayer.id]?.team === myInfo.team;

        const playingBomb = isBomb(selectedCards);

        if (isTeammate && playingBomb && !confirmState) {
            setConfirmState(true);
            setTimeout(() => setConfirmState(false), 3000);
            return;
        }

        handlePlayCards();
        setConfirmState(false);
    };

    const cycleMode = () => {
        const modes = ['SMART', 'THRIFTY', 'AFK'];
        const currentIdx = modes.indexOf(currentMode);
        const nextMode = modes[(currentIdx + 1) % modes.length];
        handleSwitchAutoPlayMode(nextMode);
    };

    const getModeLabel = (mode) => {
        switch(mode) {
            case 'SMART': return { text: 'æ™ºèƒ½(ä¿é˜Ÿå‹)', icon: <Shield size={14} />, color: '#2ecc71' };
            case 'THRIFTY': return { text: 'çœé’±(æ— åˆ†ä¸ç‚¸)', icon: <Coins size={14} />, color: '#f1c40f' };
            case 'AFK': return { text: 'èººå¹³(å…¨ä¸è¦)', icon: <Coffee size={14} />, color: '#95a5a6' };
            default: return { text: 'æ™ºèƒ½', icon: <Shield size={14} />, color: '#2ecc71' };
        }
    };

    const modeInfo = getModeLabel(currentMode);

    return (
        <div className={css.actionBar}>
            <div className={css.buttonGroup}>
                {selectedCards.length > 0 && (
                    <button 
                        className={css.btnReset}
                        onClick={handleClearSelection}
                        disabled={isSubmitting}
                    >
                        <RotateCcw size={16} /> é‡é€‰
                    </button>
                )}
                
                {amIAutoPlay ? (
                    <div className={css.autoPlayGroup}>
                        <button 
                            className={css.btnModeSwitch}
                            onClick={cycleMode}
                            style={{borderColor: modeInfo.color, color: modeInfo.color}}
                        >
                            {modeInfo.icon} {modeInfo.text} <Repeat size={12} style={{opacity:0.6}}/>
                        </button>

                        <button 
                            className={css.btnCancelAuto}
                            onClick={handleToggleAutoPlay}
                        >
                            <Zap size={18} /> å–æ¶ˆæ‰˜ç®¡
                        </button>
                    </div>
                ) : (
                    <>
                        {myTurn ? (
                            <>
                                <button 
                                    className={css.btnSecondary}
                                    onClick={handlePass}
                                    disabled={isSubmitting}
                                >
                                    ä¸è¦
                                </button>
                                
                                <button 
                                    className={css.btnHint}
                                    onClick={handleRequestHint}
                                    disabled={isSubmitting}
                                >
                                    <Lightbulb size={16} /> æç¤º
                                </button>

                                <TimerComponent initialSeconds={turnRemaining} totalSeconds={60} position="inline" />
                                
                                <button 
                                    className={confirmState ? css.btnWarning : css.btnPlay} 
                                    onClick={handlePlayClick}
                                    disabled={isSubmitting}
                                >
                                    {isSubmitting ? (
                                        <Loader2 size={18} className="spin"/>
                                    ) : (
                                        confirmState ? (
                                            <>
                                                <AlertTriangle size={18} /> ç¡®è®¤ç‚¸é˜Ÿå‹?
                                            </>
                                        ) : 'å‡ºç‰Œ'
                                    )}
                                </button>
                            </>
                        ) : (
                            <div className={css.waitingBadge}>
                                <Clock size={20} className="spin" /> {waitingText}
                            </div>
                        )}
                    </>
                )}
            </div>
        </div>
    );
};

================================================================================
FILE PATH: client\src\components\game\GameActionBar.module.css
================================================================================
.actionBar {
    position: absolute;
    bottom: 100px;
    width: 100%;
    height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
    pointer-events: none; /* å®¹å™¨ç©¿é€ */
    /* [ä¿®æ”¹] æå‡å±‚çº§è‡³ 100ï¼Œç¡®ä¿é«˜äºæ‰‹ç‰ŒåŒºåŸŸ (z-index: 20) å’Œå…¶ä»–ç‰¹æ•ˆå±‚ */
    z-index: 100;
}

.buttonGroup {
    display: flex;
    align-items: center;
    gap: 20px;
    pointer-events: auto; /* æŒ‰é’®å¯ç‚¹ */
}

/* æ‰˜ç®¡æ¨¡å¼ç»„åˆå®¹å™¨ */
.autoPlayGroup {
    display: flex;
    gap: 10px;
    background: rgba(0,0,0,0.6);
    padding: 10px;
    border-radius: 40px;
    border: 1px solid rgba(255,255,255,0.2);
}

/* æ¨¡å¼åˆ‡æ¢æŒ‰é’® */
.btnModeSwitch {
    background: rgba(255,255,255,0.1);
    border: 1px solid #ccc;
    color: white;
    padding: 8px 15px;
    border-radius: 30px;
    font-size: 13px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 5px;
    transition: all 0.2s;
}

.btnModeSwitch:active {
    transform: scale(0.95);
}

/* åŸºç¡€æŒ‰é’®æ ·å¼ */
.btn {
    border: none;
    border-radius: 40px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 5px;
    transition: all 0.2s;
    color: white;
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.btn:active {
    transform: scale(0.95);
}

/* ç°è‰²åŠŸèƒ½æŒ‰é’® (é‡é€‰ã€ä¸è¦ã€æç¤º) */
.btnSecondary {
    composes: btn;
    padding: 8px 15px;
    background: #7f8c8d;
    font-size: 14px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

.btnHint {
    composes: btnSecondary;
    background: #8e44ad;
}

.btnReset {
    composes: btnSecondary;
    background: #95a5a6;
}

/* å‡ºç‰ŒæŒ‰é’® (é«˜äº®) */
.btnPlay {
    composes: btn;
    padding: 8px 30px;
    background: linear-gradient(to bottom, #f1c40f, #f39c12);
    font-size: 16px;
    box-shadow: 0 8px 20px rgba(243, 156, 18, 0.4);
    text-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

.btnCancelAuto {
    composes: btnPlay;
    background: #e74c3c;
    width: auto;
    padding: 8px 20px;
    box-shadow: 0 8px 20px rgba(231, 76, 60, 0.4);
    font-size: 14px;
}

/* ç­‰å¾…æç¤º */
.waitingBadge {
    color: rgba(255,255,255,0.7);
    font-size: 16px;
    display: flex;
    align-items: center;
    gap: 10px;
    background: rgba(0,0,0,0.3);
    padding: 10px 20px;
    border-radius: 30px;
}

.btnWarning {
    composes: btnPlay;
    background: linear-gradient(to bottom, #e74c3c, #c0392b);
    box-shadow: 0 8px 20px rgba(231, 76, 60, 0.4);
    animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
}

@keyframes shake {
    10%, 90% { transform: translate3d(-1px, 0, 0); }
    20%, 80% { transform: translate3d(2px, 0, 0); }
    30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
    40%, 60% { transform: translate3d(4px, 0, 0); }
}

================================================================================
FILE PATH: client\src\components\game\GameHeader.jsx
================================================================================
import React, { useState } from 'react';
// [ä¿®æ”¹] å¼•å…¥ Info å›¾æ ‡
import { Zap, Minimize, Maximize, Layers, Shield, ChevronDown, ChevronUp, Wifi, WifiOff, LogOut, Info } from 'lucide-react';
import css from './GameHeader.module.css'; 
import { useGame } from '../../context/GameContext.jsx';

/**
 * [æ¯”åˆ†æ¿ç»„ä»¶] çº¢è“é˜Ÿåˆ†æ•° (å†…éƒ¨ä½¿ç”¨)
 */
const TeamScoreBoard = () => {
    // ... (ä¿æŒ TeamScoreBoard ä»£ç ä¸å˜ï¼Œçœç•¥ä»¥èŠ‚çœç©ºé—´) ...
    const { players, playersInfo, playerScores, roomConfig } = useGame();
    const [isCollapsed, setIsCollapsed] = useState(true);

    let redScore = 0, blueScore = 0, hasTeams = false;
    players.forEach(p => {
        const pInfo = playersInfo[p.id];
        const score = playerScores[p.id] || 0;
        if (pInfo && pInfo.team !== undefined && pInfo.team !== null) {
            hasTeams = true;
            if (pInfo.team === 0) redScore += score;
            else if (pInfo.team === 1) blueScore += score;
        }
    });

    if (!hasTeams) return null;

    return (
        <div className={css.teamScoreContainer}>
            <div className={css.teamScoreBar} onClick={() => setIsCollapsed(!isCollapsed)}>
                <div className={css.scoreItem} style={{color:'#e74c3c'}}>
                    <Shield size={12} fill="currentColor"/> {redScore}
                </div>
                <div className={css.divider}></div>
                <div className={css.scoreItem} style={{color:'#3498db'}}>
                    <Shield size={12} fill="currentColor"/> {blueScore}
                </div>
                {isCollapsed ? <ChevronDown size={14} color="#ccc"/> : <ChevronUp size={14} color="#ccc"/>}
            </div>

            {!isCollapsed && (
                <div className={css.scoreDropdown}>
                    <div style={{marginBottom: 5, color: '#f1c40f', fontWeight: 'bold'}}>å½“å‰æ¯”åˆ†è¯¦æƒ…</div>
                    <div style={{display:'flex', justifyContent:'space-between', marginBottom:2}}>
                        <span style={{color:'#e74c3c'}}>çº¢é˜Ÿ</span> <span>{redScore}</span>
                    </div>
                    <div style={{display:'flex', justifyContent:'space-between', marginBottom:6}}>
                        <span style={{color:'#3498db'}}>è“é˜Ÿ</span> <span>{blueScore}</span>
                    </div>
                    <div style={{height:1, background:'rgba(255,255,255,0.1)', marginBottom:6}}></div>
                    <div>ç›®æ ‡åˆ†æ•°: {roomConfig.targetScore}</div>
                </div>
            )}
        </div>
    );
};

/**
 * [Headerç»„ä»¶]
 */
export const GameHeader = () => {
    // [ä¿®æ”¹] è§£æ„ roomConfig
    const { roomId, playersInfo, mySocketId, toggleSort, sortMode, handleToggleAutoPlay, ping, isConnected, handleLeaveRoom, roomConfig } = useGame();
    const [isFullScreen, setIsFullScreen] = useState(false);
    // [æ–°å¢] æ§åˆ¶æˆ¿é—´è¯¦æƒ…æ˜¾ç¤º
    const [showRoomInfo, setShowRoomInfo] = useState(false);
    
    const myInfo = playersInfo[mySocketId] || {};
    const amIAutoPlay = myInfo.isAutoPlay;

    const toggleFullScreen = () => {
        const doc = window.document;
        const docEl = doc.documentElement;
        const requestFullScreen = docEl.requestFullscreen || docEl.webkitRequestFullScreen;
        const cancelFullScreen = doc.exitFullscreen || doc.webkitExitFullscreen;
        if (!doc.fullscreenElement && !doc.webkitFullscreenElement) {
            if (requestFullScreen) requestFullScreen.call(docEl).then(()=>setIsFullScreen(true)).catch(e=>console.log(e));
        } else {
            if (cancelFullScreen) cancelFullScreen.call(doc).then(()=>setIsFullScreen(false));
        }
    };

    const getPingColor = (p) => {
        if (!isConnected) return '#e74c3c';
        if (p < 100) return '#2ecc71';
        if (p < 200) return '#f1c40f';
        return '#e74c3c';
    };

    const getSortButtonText = () => {
        if (sortMode === 'POINT') return 'ç‚¹æ•°';
        if (sortMode === 'ARRANGE') return 'ç†ç‰Œ(æ)'; 
        if (sortMode === 'ARRANGE_MERGED') return 'ç†ç‰Œ(åˆ)'; 
        return 'æœªçŸ¥';
    };

    // [æ–°å¢] ç­–ç•¥åç§°è½¬æ¢ helper
    const getStrategyName = () => {
        if (!roomConfig) return 'åŠ è½½ä¸­';
        const s = roomConfig.shuffleStrategy;
        const p = roomConfig.preciseMode;
        if (s === 'NO_SHUFFLE') return 'å‡è´«å¯Œ(ä¸æ´—ç‰Œ)';
        if (s === 'SIMULATION') return 'æ¨¡æ‹Ÿæ‰‹æ´—';
        if (s === 'PRECISE') {
            const modes = { normal: 'å¸¸è§„', stimulating: 'åˆºæ¿€', thrilling: 'æƒŠé™©', exciting: 'çˆ½å±€' };
            return `æ™ºèƒ½æ§ç‰Œ(${modes[p] || 'åˆºæ¿€'})`;
        }
        return 'éšæœºæ´—ç‰Œ';
    };

    return (
        <div className={css.header}>
            <div className={css.roomBadgeContainer}>
                <button 
                    className={css.iconBtn} 
                    onClick={handleLeaveRoom}
                    style={{padding: '4px 8px', border:'none', background:'transparent'}}
                    title="é€€å‡ºæˆ¿é—´"
                >
                    <LogOut size={16} />
                </button>

                {/* [ä¿®æ”¹] æˆ¿é—´å·åŒºåŸŸï¼ŒåŒ…è£¹ä¸€ä¸ªç›¸å¯¹å®šä½çš„ div ä»¥ä¾¿å®šä½å¼¹çª— */}
                <div style={{position: 'relative'}}>
                    <div className={css.roomBadgeGroup}>
                        <div className={css.roomBadge}>Room {roomId}</div>
                        {/* [æ–°å¢] è¯¦æƒ…ç¼©æ”¾æŒ‰é’® */}
                        <button 
                            className={css.infoBtn} 
                            onClick={() => setShowRoomInfo(!showRoomInfo)}
                        >
                            <Info size={12} />
                        </button>
                    </div>

                    {/* [æ–°å¢] æˆ¿é—´è¯¦æƒ…å¼¹çª— */}
                    {showRoomInfo && roomConfig && (
                        <div className={css.roomInfoDropdown}>
                            <div className={css.infoTitle}>æˆ¿é—´è§„åˆ™</div>
                            <div className={css.infoRow}>
                                <span>æ´—ç‰Œç­–ç•¥:</span>
                                <span className={css.infoVal}>{getStrategyName()}</span>
                            </div>
                            <div className={css.infoRow}>
                                <span>ç›®æ ‡åˆ†æ•°:</span>
                                <span className={css.infoVal}>{roomConfig.targetScore}</span>
                            </div>
                            <div className={css.infoRow}>
                                <span>æ’åèµç½š:</span>
                                <span className={css.infoVal}>
                                    {roomConfig.enableRankPenalty 
                                        ? `${roomConfig.rankPenaltyScores[0]} / ${roomConfig.rankPenaltyScores[1]}` 
                                        : 'å…³é—­'}
                                </span>
                            </div>
                            <div className={css.infoRow}>
                                <span>ç‰Œåº“/äººæ•°:</span>
                                <span className={css.infoVal}>{roomConfig.deckCount}å‰¯ / {roomConfig.maxPlayers}äºº</span>
                            </div>
                        </div>
                    )}
                </div>
                
                <div className={css.pingBadge} style={{ color: getPingColor(ping) }}>
                    {isConnected ? <Wifi size={10}/> : <WifiOff size={10}/>}
                    {isConnected ? `${ping}ms` : 'æ–­çº¿'}
                </div>

                <button 
                    className={amIAutoPlay ? css.autoPlayBtnActive : css.autoPlayBtn}
                    onClick={handleToggleAutoPlay}
                >
                    <Zap size={12} style={{marginRight: 4}} fill={amIAutoPlay ? "currentColor" : "none"}/>
                    {amIAutoPlay ? 'æ‰˜ç®¡ä¸­' : 'æ‰˜ç®¡'}
                </button>
            </div>

            <div className={css.rightSection}>
                <TeamScoreBoard />
                <div className={css.buttonGroup}>
                    <button className={css.iconBtn} onClick={toggleFullScreen}>
                        {isFullScreen ? <Minimize size={18}/> : <Maximize size={18}/>}
                    </button>
                    <button className={css.iconBtn} onClick={toggleSort}>
                        <Layers size={16} style={{marginRight:5}}/> 
                        {getSortButtonText()}
                    </button>
                </div>
            </div>
        </div>
    );
};

================================================================================
FILE PATH: client\src\components\game\GameHeader.module.css
================================================================================
/* é¡¶éƒ¨æ å®¹å™¨ */
.header {
    padding: 4px 10px;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    z-index: 20;
    width: 100%;
    pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€ï¼ŒæŒ‰é’®å•ç‹¬å¼€å¯ auto */
    box-sizing: border-box;
}

/* å·¦ä¾§ï¼šæˆ¿é—´ä¿¡æ¯å— */
.roomBadgeContainer {
    display: flex;
    align-items: center;
    gap: 8px;
    pointer-events: auto;
}

/* [æ–°å¢] æˆ¿é—´å·ä¸æŒ‰é’®çš„ç»„åˆå®¹å™¨ */
.roomBadgeGroup {
    display: flex;
    align-items: center;
    background: rgba(0,0,0,0.3);
    border-radius: 15px;
    border: 1px solid rgba(255,255,255,0.1);
    overflow: hidden;
}

/* [ä¿®æ”¹] Room Badge æ ·å¼å¾®è°ƒï¼Œç§»é™¤ç‹¬ç«‹è¾¹æ¡† */
.roomBadge {
    color: white;
    padding: 4px 8px;
    font-size: 11px;
    font-weight: bold;
    white-space: nowrap;
}

/* [æ–°å¢] ä¿¡æ¯æŒ‰é’®æ ·å¼ */
.infoBtn {
    background: rgba(255,255,255,0.1);
    border: none;
    border-left: 1px solid rgba(255,255,255,0.1);
    color: #ecf0f1;
    cursor: pointer;
    padding: 4px 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
    height: 100%;
}

.infoBtn:hover {
    background: rgba(255,255,255,0.2);
}

/* [æ–°å¢] æˆ¿é—´è¯¦æƒ…ä¸‹æ‹‰æ¡† */
.roomInfoDropdown {
    position: absolute;
    top: 115%;
    left: 0;
    width: 160px;
    background: rgba(30, 40, 50, 0.95);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    padding: 10px;
    color: white;
    font-size: 11px;
    backdrop-filter: blur(5px);
    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    /* [ä¿®æ”¹] æå‡å±‚çº§ï¼Œç¡®ä¿é«˜äºå·¦ä¾§çš„ GameLogPanel (z-index: 1000) */
    z-index: 2000;
    animation: fadeIn 0.2s ease;
    text-align: left;
}


.infoTitle {
    font-weight: bold;
    color: #f1c40f;
    margin-bottom: 6px;
    border-bottom: 1px solid rgba(255,255,255,0.1);
    padding-bottom: 4px;
    text-align: center;
}

.infoRow {
    display: flex;
    justify-content: space-between;
    margin-bottom: 4px;
    color: #bdc3c7;
}

.infoVal {
    color: white;
    font-weight: bold;
}

/* Ping å€¼å¾½ç«  */
.pingBadge {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 10px;
    padding: 2px 8px;
    border-radius: 12px;
    background: rgba(0,0,0,0.3);
    border: 1px solid rgba(255,255,255,0.1);
    font-weight: bold;
    transition: color 0.5s;
}

/* æ‰˜ç®¡æŒ‰é’® */
.autoPlayBtn {
    pointer-events: auto;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.3);
    color: #ecf0f1;
    border-radius: 15px;
    padding: 4px 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 11px;
    font-weight: bold;
    transition: all 0.2s;
}

.autoPlayBtnActive {
    composes: autoPlayBtn;
    background: #e67e22;
}

/* å³ä¾§ï¼šæ¯”åˆ†ä¸åŠŸèƒ½æŒ‰é’® */
.rightSection {
    display: flex;
    align-items: center;
    margin-left: auto;
}

.buttonGroup {
    display: flex;
    gap: 10px;
}

.iconBtn {
    pointer-events: auto;
    background: rgba(255,255,255,0.1);
    color: white;
    border: 1px solid rgba(255,255,255,0.2);
    padding: 8px 12px;
    border-radius: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    font-size: 14px;
    transition: background 0.2s;
}

.iconBtn:hover {
    background: rgba(255,255,255,0.2);
}

/* --- å†…éƒ¨ç»„ä»¶ï¼šé˜Ÿä¼æ¯”åˆ†æ¿ --- */
.teamScoreContainer {
    position: relative;
    margin-right: 10px;
    z-index: 50;
    pointer-events: auto;
}

.teamScoreBar {
    background: rgba(0,0,0,0.3);
    padding: 4px 10px;
    border-radius: 20px;
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    border: 1px solid rgba(255,255,255,0.1);
    transition: background 0.2s;
}

.scoreItem {
    font-weight: bold;
    display: flex;
    align-items: center;
    gap: 3px;
    font-size: 13px;
}

.divider {
    width: 1px;
    height: 12px;
    background: rgba(255,255,255,0.2);
}

.scoreDropdown {
    position: absolute;
    top: 120%;
    right: 0;
    background: rgba(30, 40, 50, 0.95);
    border-radius: 8px;
    padding: 10px;
    color: white;
    font-size: 12px;
    text-align: center;
    width: 140px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    border: 1px solid rgba(255,255,255,0.1);
    backdrop-filter: blur(5px);
    animation: fadeIn 0.2s ease;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-5px); }
    to { opacity: 1; transform: translateY(0); }
}

================================================================================
FILE PATH: client\src\components\game\HandArea.jsx
================================================================================
import React, { useState, useEffect } from 'react';
import { Bot, Eye } from 'lucide-react';
import css from './HandArea.module.css'; 
import { Card } from '../BaseUI.jsx';
import { calculateCardSpacing, sortHand } from '../../utils/cardLogic.js';
import { useGame } from '../../context/GameContext.jsx';
import { useHandGesture } from '../../hooks/useHandGesture.js';

export const HandArea = () => {
    const { 
        myHand, selectedCards, handleMouseDown, handleMouseEnter, 
        playersInfo, mySocketId,
        observedHands, isSpectator // [æ–°å¢]
    } = useGame();
    
    const myInfo = playersInfo[mySocketId] || {};
    const amIAutoPlay = myInfo.isAutoPlay;

    const [dimensions, setDimensions] = useState({ width: window.innerWidth });
    
    useEffect(() => {
        const handleResize = () => setDimensions({ width: window.innerWidth });
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, []);

    // [æ–°å¢] å†³å®šæ˜¾ç¤ºè°çš„æ‰‹ç‰Œ
    let displayHand = myHand;
    let isWatching = false;
    let watchingName = '';

    // å¦‚æœæˆ‘è‡ªå·±æ²¡ç‰Œäº† (æˆ–è€…æˆ‘æ˜¯è§‚ä¼—)ï¼Œä¸”æœ‰è§‚å¯Ÿåˆ°çš„æ‰‹ç‰Œ
    if ((myHand.length === 0 || isSpectator) && Object.keys(observedHands).length > 0) {
        // ç®€å•ç­–ç•¥ï¼šæ˜¾ç¤ºç¬¬ä¸€ä¸ªè§‚å¯Ÿåˆ°çš„éç©ºæ‰‹ç‰Œ
        const targetId = Object.keys(observedHands).find(id => observedHands[id] && observedHands[id].length > 0);
        if (targetId) {
            // å¯¹è§‚å¯Ÿçš„æ‰‹ç‰Œè¿›è¡Œæ’åºï¼Œç¡®ä¿æ˜¾ç¤ºæ•´é½
            displayHand = sortHand(observedHands[targetId], 'POINT'); 
            isWatching = true;
            // å°è¯•è·å–åå­—ï¼Œéœ€ä» playersInfo æˆ– players ä¸­æ‰¾ (Contexté‡Œ playerså¯èƒ½æ²¡ä¼ è¿›æ¥)
            // è¿™é‡Œç®€å•ç”¨IDï¼Œæˆ–è€…ç¨å¾®ä¿®æ”¹ Context ä¼ å…¥ players
            // å‡è®¾æˆ‘ä»¬åªèƒ½æ‹¿åˆ° IDï¼ŒUI æ˜¾ç¤º "æ­£åœ¨è§‚çœ‹é˜Ÿå‹" å³å¯
        }
    }

    const cardSpacing = calculateCardSpacing(displayHand.length, dimensions.width);

    // åªæœ‰æ“ä½œè‡ªå·±çš„æ‰‹ç‰Œæ‰å¯ç”¨æ‰‹åŠ¿
    const handContainerRef = useHandGesture({
        myHand: isWatching ? [] : displayHand, // è§‚çœ‹æ¨¡å¼ä¸‹ç¦ç”¨äº¤äº’
        selectedCards: isWatching ? [] : selectedCards, 
        cardSpacing, 
        handleMouseDown, 
        amIAutoPlay
    });

    const containerClass = [
        css.handArea,
        amIAutoPlay ? css.autoPlayMode : ''
    ].join(' ');

    return (
        <div ref={handContainerRef} className={containerClass}>
            {amIAutoPlay && !isWatching && (
                <div className={css.autoPlayBadge}>
                    <Bot size={14} /> ç³»ç»Ÿä»£æ‰“ä¸­
                </div>
            )}

            {/* [æ–°å¢] è§‚çœ‹æ¨¡å¼æç¤º */}
            {isWatching && (
                <div className={css.autoPlayBadge} style={{background: '#3498db'}}>
                    <Eye size={14} /> æ­£åœ¨è§‚çœ‹é˜Ÿå‹è§†è§’
                </div>
            )}
            
            {displayHand.map((c, i) => (
                <Card 
                    key={`${c}-${i}`} 
                    cardVal={c} 
                    index={i} 
                    isSelected={!isWatching && selectedCards.includes(c)} 
                    onClick={isWatching ? ()=>{} : handleMouseDown} 
                    onMouseEnter={isWatching ? ()=>{} : handleMouseEnter} 
                    spacing={cardSpacing} 
                />
            ))}
        </div>
    );
};

================================================================================
FILE PATH: client\src\components\game\HandArea.module.css
================================================================================
.handArea {
    position: absolute;
    /* é€‚é… iPhone åº•éƒ¨é»‘æ¡ */
    bottom: max(25px, env(safe-area-inset-bottom));
    /* å·¦ä¾§é¿å¼€å¤´åƒåŒºåŸŸ */
    left: 90px;
    right: 10px;
    height: 160px;
    display: flex;
    justify-content: flex-start;
    align-items: flex-end;
    z-index: 20;
    touch-action: none;
    pointer-events: auto;
    padding-bottom: 10px;
    transition: all 0.3s;
}

/* æ‰˜ç®¡æ¨¡å¼ä¸‹çš„é®ç½©æ•ˆæœ */
.autoPlayMode {
    opacity: 0.6;
    filter: grayscale(0.6);
    pointer-events: none;
}

.autoPlayBadge {
    position: absolute;
    top: -40px;
    left: 20px;
    background: rgba(230, 126, 34, 0.9);
    color: white;
    padding: 5px 10px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: bold;
    display: flex;
    align-items: center;
    gap: 5px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    z-index: 50;
    animation: floatBadge 2s infinite ease-in-out;
}

@keyframes floatBadge {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-5px); }
}

================================================================================
FILE PATH: client\src\components\game\PlayerLayout.jsx
================================================================================
import React from 'react';
import { Bot, Zap } from 'lucide-react';
import { PlayerAvatar } from '../BaseUI'; // ç§»é™¤ .jsx åç¼€ä»¥å¢å¼ºå…¼å®¹æ€§
import { useGame } from '../../context/GameContext'; // ç§»é™¤ .jsx åç¼€

const calculateLayout = (otherPlayersCount) => {
    if (otherPlayersCount === 0) return { countT: 0, countR: 0, countL: 0 }; 
    if (otherPlayersCount === 1) return { countT: 1, countR: 0, countL: 0 }; 
    if (otherPlayersCount === 2) return { countT: 0, countR: 1, countL: 1 }; 
    if (otherPlayersCount === 3) return { countT: 1, countR: 1, countL: 1 }; 
    if (otherPlayersCount === 4) return { countT: 2, countR: 1, countL: 1 }; 
    if (otherPlayersCount === 5) return { countT: 2, countR: 2, countL: 1 }; 

    const sideCount = Math.ceil(otherPlayersCount / 3);
    const topCount = otherPlayersCount - (sideCount * 2);
    
    return {
        countR: sideCount,
        countL: sideCount,
        countT: Math.max(0, topCount) 
    };
};

export const PlayerLayout = () => {
    const { 
        players, mySocketId, currentTurnId, playersInfo, playerScores, 
        roundPoints, roomConfig, turnRemaining, finishedRank, handCounts,
        isSpectator 
    } = useGame();

    // [å®‰å…¨æ£€æŸ¥] é˜²æ­¢ players ä¸º undefined å¯¼è‡´å´©æºƒ
    if (!players) return null;

    const totalP = players.length;
    let avatarScale = 1;
    if (totalP > 10) avatarScale = 0.70;      
    else if (totalP > 8) avatarScale = 0.80;  
    else if (totalP > 6) avatarScale = 0.90;  
    
    const avatarStyleOverride = totalP > 6 ? { transform: `scale(${avatarScale})`, margin: -5 } : {};

    let myIndex = players.findIndex(p => p.id === mySocketId);
    
    // [ä¿®æ”¹] å¦‚æœæ˜¯è§‚ä¼—ï¼Œæˆ–è€…æ‰¾ä¸åˆ°è‡ªå·±ï¼Œé»˜è®¤ä»¥ç¬¬ä¸€ä¸ªç©å®¶ä¸ºè§†è§’ä¸­å¿ƒ (index 0)
    if (myIndex === -1) {
        myIndex = 0; 
    }

    // é‡æ–°æ’åˆ—æ•°ç»„ï¼Œè®©è§†è§’ä¸­å¿ƒåœ¨ç¬¬ä¸€ä¸ª
    const otherPlayers = [];
    if (players.length > 0) {
        for (let i = 1; i < players.length; i++) {
            // å®‰å…¨å–æ¨¡
            const idx = (myIndex + i) % players.length;
            if (players[idx]) {
                otherPlayers.push(players[idx]);
            }
        }
    }

    const { countT, countR, countL } = calculateLayout(otherPlayers.length);
    const rightGroup = otherPlayers.slice(0, countR);
    const topGroup = otherPlayers.slice(countR, countR + countT);
    const leftGroup = otherPlayers.slice(countR + countT);

    const layoutItems = [];

    rightGroup.forEach((p, i) => {
        let topPos;
        if (countR === 1) {
            topPos = '45%'; 
        } else {
            const start = 65; 
            const end = 25;   
            const step = (start - end) / (countR - 1 || 1);
            topPos = `${start - i * step}%`;
        }
        layoutItems.push({ p, pos: { top: topPos, right: 10, transform: 'translateY(-50%)' }, timerPos: 'left' });
    });

    topGroup.forEach((p, i) => {
        let leftPos;
        if (countT === 1) {
            leftPos = '50%';
        } else {
            const start = 85; 
            const end = 15;   
            const step = (start - end) / (countT - 1 || 1);
            leftPos = `${start - i * step}%`; 
        }
        layoutItems.push({ p, pos: { top: '12%', left: leftPos, transform: 'translateX(-50%)' }, timerPos: 'bottom' });
    });

    leftGroup.forEach((p, i) => {
        let topPos;
        if (countL === 1) {
            topPos = '45%';
        } else {
            const start = 25; 
            const end = 65;   
            const step = (end - start) / (countL - 1 || 1);
            topPos = `${start + i * step}%`;
        }
        layoutItems.push({ p, pos: { top: topPos, left: 30, transform: 'translateY(-50%)' }, timerPos: 'right' });
    });

    // åŠ å…¥â€œè‡ªå·±â€æˆ–â€œä¸»è§†è§’ç©å®¶â€
    const me = players[myIndex];
    if (me) {
        const isActuallyMe = me.id === mySocketId;
        
        if (!isSpectator || isActuallyMe) {
            // æ­£å¸¸ç©å®¶æ¨¡å¼ï¼šè‡ªå·±ä¸æ˜¾ç¤ºTimerï¼ˆæˆ–è€…æ˜¾ç¤ºåœ¨ç‰¹å®šä½ç½®ï¼‰ï¼Œä½ç½®å›ºå®šåœ¨å·¦ä¸‹
            layoutItems.unshift({ p: me, pos: { bottom: 35, left: 20, zIndex: 100 }, hideTimer: true });
        } else {
            // è§‚ä¼—æ¨¡å¼ï¼šä¸»è§†è§’ç©å®¶éœ€è¦æ˜¾ç¤ºTimerï¼ŒTimeråœ¨ä¸Šæ–¹
            layoutItems.unshift({ p: me, pos: { bottom: 35, left: 20, zIndex: 100 }, hideTimer: false, timerPos: 'top' });
        }
    }

    return (
        <>
            {layoutItems.map(({ p, pos, timerPos, hideTimer }) => {
                if (!p) return null; // å®‰å…¨æ£€æŸ¥

                const info = playersInfo[p.id] || {};
                const isBot = info.isBot || p.isBot;
                const isAuto = info.isAutoPlay;
                const rankIndex = finishedRank ? finishedRank.indexOf(p.id) : -1;
                const finishedRankVal = rankIndex !== -1 ? rankIndex + 1 : null;
                
                return (
                    <div key={p.id} style={{...avatarStyleOverride, position: 'absolute', ...pos, transition: 'all 0.5s ease'}}> 
                        <PlayerAvatar 
                            player={p} 
                            isTurn={p.id === currentTurnId} 
                            score={playerScores[p.id] || 0} 
                            roundScore={roundPoints[p.id] || 0} 
                            targetScore={roomConfig ? roomConfig.targetScore : 500} // å®‰å…¨è®¿é—®
                            isMySocket={p.id === mySocketId}
                            remainingSeconds={turnRemaining}
                            rank={finishedRankVal}
                            timerPosition={timerPos}
                            hideTimer={hideTimer} 
                            cardCount={handCounts[p.id] || 0}
                            showCardCountMode={roomConfig ? roomConfig.showCardCountMode : false} // å®‰å…¨è®¿é—®
                            team={info.team} 
                        />
                        <div style={{position: 'absolute', top: -10, right: -10, display: 'flex', gap: 5}}>
                            {isBot && <div className="statusBadgeBot"><Bot size={12}/> AI</div>}
                            {isAuto && <div className="statusBadgeAuto"><Zap size={12}/> æ‰˜ç®¡</div>}
                        </div>
                    </div>
                );
            })}
        </>
    );
};

================================================================================
FILE PATH: client\src\components\game\RoomSettingsForm.jsx
================================================================================
import React from 'react';
import { Users, Layers, Target, Clock, Shuffle, Sparkles, Shield, Eye, Award, Sliders } from 'lucide-react'; 
import css from './RoomSettingsForm.module.css';

/**
 * é€šç”¨æˆ¿é—´é…ç½®ç»„ä»¶
 */
export const RoomSettingsForm = ({ config, onChange, readOnly = false }) => {
    
    const update = (key, val) => {
        if (!readOnly && onChange) onChange(key, val);
    };

    // æ¸²æŸ“æ»‘å— (ä¿æŒä¸å˜)
    const renderSlider = (icon, label, field, min, max, step, suffix = '') => (
        <div className={css.configItem}>
            <div className={css.configLabel}>
                <span style={{display:'flex', alignItems:'center', gap:6}}>{icon} {label}</span>
                <span className={css.configValue}>{config[field]}{suffix}</span>
            </div>
            <input 
                type="range" 
                className={css.rangeInput}
                min={min} 
                max={max} 
                step={step}
                value={config[field]} 
                onChange={(e) => update(field, parseInt(e.target.value))}
                disabled={readOnly}
                style={{opacity: readOnly ? 0.6 : 1, cursor: readOnly ? 'not-allowed' : 'pointer'}}
            />
        </div>
    );

    return (
        <div className={css.configContainer}>
            <div className={css.configGrid}>
                {renderSlider(<Users size={14}/>, "ç©å®¶äººæ•°", 'maxPlayers', 2, 12, 1, 'äºº')}
                {renderSlider(<Layers size={14}/>, "ç‰Œåº“æ•°é‡", 'deckCount', 1, 8, 1, 'å‰¯')}
                {renderSlider(<Target size={14}/>, "è·èƒœç›®æ ‡", 'targetScore', 500, 5000, 500, 'åˆ†')}

                {/* --- [ä¿®æ”¹] æ´—ç‰Œç­–ç•¥åŒºåŸŸ --- */}
                <div className={css.configItem} style={{gridColumn: '1 / -1', marginTop: 5}}>
                    <div className={css.configLabel} style={{marginBottom: 8}}>
                        <span style={{display:'flex', alignItems:'center', gap:6}}><Shuffle size={14}/> æ´—ç‰Œç­–ç•¥</span>
                    </div>
                    
                    {/* ä¸€çº§ç­–ç•¥é€‰æ‹© */}
                    <div className={css.radioGroup} style={{marginBottom: 10}}>
                        <button 
                            className={css.strategyBtn}
                            style={(!config.shuffleStrategy || config.shuffleStrategy === 'CLASSIC') ? {borderColor: '#2ecc71', background: '#eafaf1', color: '#2ecc71'} : {}}
                            onClick={() => update('shuffleStrategy', 'CLASSIC')}
                            disabled={readOnly}
                        >
                            ğŸ² éšæœº
                        </button>
                        <button 
                            className={css.strategyBtn}
                            style={config.shuffleStrategy === 'NO_SHUFFLE' ? {borderColor: '#e67e22', background: '#fdf2e9', color: '#e67e22'} : {}}
                            onClick={() => update('shuffleStrategy', 'NO_SHUFFLE')}
                            disabled={readOnly}
                        >
                            <Sparkles size={14}/> å‡è´«å¯Œ
                        </button>
                        <button 
                            className={css.strategyBtn}
                            style={config.shuffleStrategy === 'SIMULATION' ? {borderColor: '#9b59b6', background: '#f5eef8', color: '#9b59b6'} : {}}
                            onClick={() => update('shuffleStrategy', 'SIMULATION')}
                            disabled={readOnly}
                        >
                            <Layers size={14}/> æ¨¡æ‹Ÿæ‰‹æ´—
                        </button>
                        <button 
                            className={css.strategyBtn}
                            style={config.shuffleStrategy === 'PRECISE' ? {borderColor: '#e74c3c', background: '#fdedec', color: '#e74c3c'} : {}}
                            onClick={() => update('shuffleStrategy', 'PRECISE')}
                            disabled={readOnly}
                        >
                            <Sliders size={14}/> æ™ºèƒ½æ§ç‰Œ
                        </button>
                    </div>

                    {/* [æ–°å¢] äºŒçº§é€‰é¡¹ï¼šä»…å½“é€‰æ‹©äº†â€œæ™ºèƒ½æ§ç‰Œâ€æ—¶æ˜¾ç¤º */}
                    {config.shuffleStrategy === 'PRECISE' && (
                        <div style={{
                            background: '#fdedec', padding: 10, borderRadius: 8, marginBottom: 5,
                            border: '1px dashed #e74c3c', animation: 'fadeIn 0.3s'
                        }}>
                            <div style={{fontSize: 12, color: '#c0392b', marginBottom: 6, fontWeight:'bold'}}>é€‰æ‹©åˆºæ¿€ç¨‹åº¦:</div>
                            <div className={css.radioGroup}>
                                {['normal', 'stimulating', 'thrilling', 'exciting'].map(mode => {
                                    const labels = { normal: 'å¸¸è§„', stimulating: 'åˆºæ¿€', thrilling: 'æƒŠé™©', exciting: 'çˆ½å±€' };
                                    const isActive = (config.preciseMode || 'stimulating') === mode;
                                    return (
                                        <button 
                                            key={mode}
                                            onClick={() => update('preciseMode', mode)}
                                            disabled={readOnly}
                                            style={{
                                                flex: 1, padding: '4px 0', fontSize: 12, borderRadius: 4, cursor: readOnly ? 'not-allowed' : 'pointer', border: 'none',
                                                background: isActive ? '#e74c3c' : 'rgba(255,255,255,0.5)',
                                                color: isActive ? 'white' : '#c0392b',
                                                fontWeight: isActive ? 'bold' : 'normal',
                                                transition: 'all 0.2s'
                                            }}
                                        >
                                            {labels[mode]}
                                        </button>
                                    );
                                })}
                            </div>
                        </div>
                    )}

                    <div style={{fontSize: 11, color: '#999', marginTop: 4, lineHeight: '1.4'}}>
                        {(!config.shuffleStrategy || config.shuffleStrategy === 'CLASSIC') && "å®Œå…¨éšæœºï¼Œè¿æ°”è‡³ä¸Šã€‚"}
                        {config.shuffleStrategy === 'NO_SHUFFLE' && "ç³»ç»Ÿå¹³å‡åˆ†é…ç‚¸å¼¹ï¼Œæ‹’ç»ä¸€é¢å€’ã€‚"}
                        {config.shuffleStrategy === 'SIMULATION' && "è¿˜åŸçº¿ä¸‹å ç‰Œåˆ‡ç‰Œï¼Œä¿ç•™è¿å¯¹é•¿é¾™ã€‚"}
                        {config.shuffleStrategy === 'PRECISE' && (
                            <span style={{color: '#c0392b'}}>
                                {config.preciseMode === 'normal' && "æ™®é€šæ¦‚ç‡ï¼Œå¤§ç‚¸å¼¹è¾ƒå°‘ã€‚"}
                                {(!config.preciseMode || config.preciseMode === 'stimulating') && "ç‚¸å¼¹å¢å¤šï¼ŒèŠ‚å¥åŠ å¿«ã€‚"}
                                {config.preciseMode === 'thrilling' && "å¤§ç‚¸é¢‘å‡ºï¼Œå¯¹æŠ—æ¿€çƒˆã€‚"}
                                {config.preciseMode === 'exciting' && "æ»¡å±ç‚¸å¼¹ï¼Œè¶…å¤§ç‰Œå‹ï¼"}
                            </span>
                        )}
                    </div>
                </div>

                {/* ç»„é˜Ÿæ¨¡å¼ (ä¿æŒä¸å˜) */}
                <div className={config.maxPlayers % 2 !== 0 ? css.toggleContainerDisabled : css.toggleContainer}>
                     <div style={{display:'flex', justifyContent:'space-between', alignItems:'center'}}>
                        <div style={{display:'flex', alignItems:'center', gap:6, fontWeight:'600', color: config.maxPlayers % 2 !== 0 ? '#999' : '#27ae60', fontSize: 14}}>
                            <Shield size={14} /> ç»„é˜Ÿå¯¹æŠ— (2v2, 3v3...)
                        </div>
                        <label style={{position:'relative', display:'inline-block', width:40, height:20}}>
                            <input 
                                type="checkbox" 
                                style={{opacity:0, width:0, height:0}}
                                checked={config.isTeamMode && config.maxPlayers % 2 === 0}
                                disabled={readOnly || config.maxPlayers % 2 !== 0}
                                onChange={(e) => update('isTeamMode', e.target.checked)}
                            />
                            <span style={{
                                position:'absolute', cursor: (readOnly || config.maxPlayers % 2 !== 0) ? 'not-allowed' : 'pointer', 
                                top:0, left:0, right:0, bottom:0, 
                                backgroundColor: (config.isTeamMode && config.maxPlayers % 2 === 0) ? '#27ae60' : '#ccc', 
                                transition:'.4s', borderRadius: 20
                            }}>
                                <span style={{
                                    position:'absolute', content:"", height:16, width:16, left:2, bottom:2, 
                                    backgroundColor:'white', transition:'.4s', borderRadius:'50%',
                                    transform: (config.isTeamMode && config.maxPlayers % 2 === 0) ? 'translateX(20px)' : 'translateX(0)'
                                }}></span>
                            </span>
                        </label>
                    </div>
                    <div style={{fontSize: 11, color: '#7f8c8d'}}>
                        {config.maxPlayers % 2 !== 0 ? "âš ï¸ éœ€å¶æ•°äººæ•°æ‰èƒ½å¼€å¯" : "é—´éš”å…¥åº§ä¸ºé˜Ÿå‹ (1,3 vs 2,4)"}
                    </div>
                </div>

                {/* å‡ºç‰Œæ—¶é™ (ä¿æŒä¸å˜) */}
                <div className={css.configItem}>
                    <div className={css.configLabel}>
                        <span style={{display:'flex', alignItems:'center', gap:6}}><Clock size={14}/> å‡ºç‰Œæ—¶é™</span>
                        <span className={css.configValue}>{config.turnTimeout / 1000}s</span>
                    </div>
                    <div className={css.radioGroup}>
                        {[30, 60, 90, 120].map(sec => (
                            <button 
                                key={sec}
                                className={config.turnTimeout === sec * 1000 ? css.radioBtnActive : css.radioBtn}
                                onClick={() => update('turnTimeout', sec * 1000)}
                                disabled={readOnly}
                            >
                                {sec}s
                            </button>
                        ))}
                    </div>
                </div>
            </div>

            <div className={css.divider}></div>

            {/* å‰©ä½™ç‰Œæ•°æ˜¾ç¤º (ä¿®æ”¹ UI ä¸º â‰¤3å¼ ) */}
            <div>
                <div className={css.configLabel} style={{marginBottom: 8}}>
                    <span style={{display:'flex', alignItems:'center', gap:6}}><Eye size={14}/> å‰©ä½™ç‰Œæ•°æ˜¾ç¤º</span>
                </div>
                <div className={css.radioGroup}>
                    <button className={config.showCardCountMode === 0 ? css.radioBtnActive : css.radioBtn} onClick={() => update('showCardCountMode', 0)} disabled={readOnly}>ä¸æ˜¾ç¤º</button>
                    {/* [ä¿®æ”¹] 2 æ”¹ä¸º 3 */}
                    <button className={config.showCardCountMode === 1 ? css.radioBtnActive : css.radioBtn} onClick={() => update('showCardCountMode', 1)} disabled={readOnly}>â‰¤3å¼ </button>
                    <button className={config.showCardCountMode === 2 ? css.radioBtnActive : css.radioBtn} onClick={() => update('showCardCountMode', 2)} disabled={readOnly}>ä¸€ç›´æ˜¾ç¤º</button>
                </div>
            </div>

            <div className={css.divider}></div>

            {/* æ’åèµç½š (ä¿æŒä¸å˜) */}
            <div>
                <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom: 10}}>
                    <div style={{display:'flex', alignItems:'center', gap:6, fontWeight:'600', color:'#555', fontSize:14}}>
                        <Award size={14} /> å¯ç”¨æ’åèµç½š (æŠ“åˆ†)
                    </div>
                    <label style={{position:'relative', display:'inline-block', width:40, height:20}}>
                        <input 
                            type="checkbox" 
                            style={{opacity:0, width:0, height:0}}
                            checked={config.enableRankPenalty}
                            onChange={(e) => update('enableRankPenalty', e.target.checked)}
                            disabled={readOnly}
                        />
                        <span style={{
                            position:'absolute', cursor: readOnly ? 'not-allowed' : 'pointer', top:0, left:0, right:0, bottom:0, 
                            backgroundColor: config.enableRankPenalty ? '#27ae60' : '#ccc', 
                            transition:'.4s', borderRadius: 20
                        }}>
                            <span style={{
                                position:'absolute', content:"", height:16, width:16, left:2, bottom:2, 
                                backgroundColor:'white', transition:'.4s', borderRadius:'50%',
                                transform: config.enableRankPenalty ? 'translateX(20px)' : 'translateX(0)'
                            }}></span>
                        </span>
                    </label>
                </div>
                
                {config.enableRankPenalty && (
                    <div className={css.rankPenaltyContainer}>
                        <div style={{flex:1}}>
                            <div style={{marginBottom:5, color:'#7f8c8d', fontSize:12}}>å¤´å°¾èµç½š</div>
                            <input 
                                type="number" className={css.input}
                                value={config.rankPenaltyScores[0]}
                                onChange={e => {
                                    const val = Math.max(0, parseInt(e.target.value) || 0);
                                    update('rankPenaltyScores', [val, config.rankPenaltyScores[1]]);
                                }}
                                disabled={readOnly}
                            />
                        </div>
                        <div style={{flex:1}}>
                            <div style={{marginBottom:5, color:'#7f8c8d', fontSize:12}}>æ¬¡çº§èµç½š</div>
                            <input 
                                type="number" className={css.input}
                                value={config.rankPenaltyScores[1]}
                                onChange={e => {
                                    const val = Math.max(0, parseInt(e.target.value) || 0);
                                    update('rankPenaltyScores', [config.rankPenaltyScores[0], val]);
                                }}
                                disabled={readOnly}
                            />
                        </div>
                    </div>
                )}
            </div>
            
            <style>{`@keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }`}</style>
        </div>
    );
};

================================================================================
FILE PATH: client\src\components\game\RoomSettingsForm.module.css
================================================================================
.configContainer {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.configGrid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px 30px;
    width: 100%;
}

/* ç§»åŠ¨ç«¯å•åˆ— */
@media (max-width: 600px) {
    .configGrid {
        grid-template-columns: 1fr;
        gap: 15px;
    }
}

.configItem {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.configLabel {
    display: flex;
    justify-content: space-between;
    font-size: 14px;
    color: #7f8c8d;
    font-weight: 600;
}

.configValue {
    color: #27ae60;
    font-weight: bold;
}

.rangeInput {
    width: 100%;
    cursor: pointer;
    accent-color: #27ae60;
    height: 6px;
    border-radius: 3px;
    background: #e0e0e0;
    outline: none;
}

/* Radio Group */
.radioGroup {
    display: flex;
    gap: 8px;
}

.radioBtn {
    flex: 1;
    padding: 8px 0;
    border-radius: 6px;
    border: 1px solid #e1e4e8;
    background: white;
    color: #7f8c8d;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s;
    font-weight: 500;
}

.radioBtnActive {
    flex: 1;
    padding: 8px 0;
    border-radius: 6px;
    border: 1px solid #27ae60;
    background: #eafaf1;
    color: #27ae60;
    font-size: 12px;
    font-weight: bold;
    cursor: pointer;
}

/* ç‰¹æ®Šç­–ç•¥æŒ‰é’® */
.strategyBtn {
    flex: 1;
    padding: 8px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: bold;
    cursor: pointer;
    border: 1px solid #ddd;
    background: white;
    color: #7f8c8d;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
}

.input {
    padding: 0 10px;
    height: 35px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
    color: #2c3e50;
    outline: none;
    width: 100%;
    background: white;
}

/* åˆ†å‰²çº¿ */
.divider {
    height: 1px;
    background: #f0f0f0;
    margin: 5px 0;
    width: 100%;
}

/* ç»„é˜Ÿå¼€å…³å®¹å™¨ */
.toggleContainer {
    padding: 10px;
    background: #e8f8f5;
    border-radius: 8px;
    grid-column: 1 / -1;
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.toggleContainerDisabled {
    composes: toggleContainer;
    background: #f5f5f5;
    opacity: 0.7;
}

.rankPenaltyContainer {
    background: #f9f9f9;
    padding: 12px;
    border-radius: 8px;
    display: flex;
    gap: 15px;
    margin-top: 5px;
}

================================================================================
FILE PATH: client\src\components\game\SettlementModal.jsx
================================================================================
import React, { useState } from 'react';
import { Crown, Coins, List, History } from 'lucide-react';
import css from './SettlementModal.module.css';
import { ScoreTable } from '../ScoreTable.jsx';
import { useGame } from '../../context/GameContext.jsx';

/**
 * [æœ¬å±€è¯¦æƒ…è¡¨æ ¼]
 * å±•ç¤ºï¼šæ’åã€ç©å®¶ã€åœºå†…æŠ“åˆ†ã€å¥–ç½š(å«å‰©ç‰Œ)ã€æœ¬å±€æ€»åˆ†
 */
const RoundDetailTable = ({ scoreBreakdown, players }) => {
    if (!scoreBreakdown) return <div style={{padding:20}}>æš‚æ— è¯¦æƒ…æ•°æ®</div>;

    // å°†å¯¹è±¡è½¬ä¸ºæ•°ç»„å¹¶æŒ‰å¾—åˆ†æ’åï¼ˆæˆ–æŒ‰ç»“æŸæ’åï¼Ÿï¼‰
    // éœ€æ±‚è¯´ï¼šè¿˜æœ‰ä¸€æ æ˜¯â€œè¿™ä¸€å±€æ€»å¾—åˆ†çš„æ’åâ€
    // æˆ‘ä»¬è¿™é‡Œé»˜è®¤æŒ‰â€œæœ¬å±€æ€»åˆ†â€é™åºæ’åˆ—
    const rows = Object.values(scoreBreakdown).sort((a, b) => b.final - a.final);

    return (
        <div className={css.detailTableContainer}>
            <div className={css.detailHeaderRow}>
                <div style={{flex:0.8}}>èµ°ä½</div>
                <div style={{flex:2, textAlign:'left'}}>ç©å®¶</div>
                <div style={{flex:1.2}}>æŠ“åˆ†</div>
                <div style={{flex:2}}>å¥–ç½š(å‰©ç‰Œ)</div>
                <div style={{flex:1.2, color:'#f1c40f'}}>å¾—åˆ†</div>
                <div style={{flex:0.8}}>æ’å</div>
            </div>
            
            <div className={css.detailBody}>
                {rows.map((row, index) => {
                    const isWin = row.final > 0;
                    const isLose = row.final < 0;
                    const scoreColor = isWin ? '#e74c3c' : (isLose ? '#2ecc71' : '#ccc');
                    
                    // æ ¼å¼åŒ–å¥–ç½šæ ï¼šä¾‹å¦‚ "+50 (å‰©0)" æˆ– "-30 (å‰©25)"
                    const penaltyText = row.penalty > 0 ? `+${row.penalty}` : row.penalty;
                    const handText = row.handScore > 0 ? `å‰©${row.handScore}` : 'å‰©0';
                    
                    return (
                        <div key={row.id} className={css.detailRow}>
                            <div style={{flex:0.8, color:'#999', fontSize:12}}>
                                {row.finishRank}
                            </div>
                            <div style={{flex:2, textAlign:'left', fontWeight:'bold', overflow:'hidden', textOverflow:'ellipsis', whiteSpace:'nowrap'}}>
                                {row.team !== undefined && row.team !== null && (
                                    <span style={{color: row.team===0?'#e74c3c':'#3498db', marginRight:4}}>
                                        {row.team===0?'[çº¢]':'[è“]'}
                                    </span>
                                )}
                                {row.name}
                            </div>
                            <div style={{flex:1.2, fontWeight:'bold'}}>{row.tablePoints}</div>
                            <div style={{flex:2, fontSize:12, color:'#7f8c8d'}}>
                                <span style={{color: row.penalty!==0 ? (row.penalty>0?'#e67e22':'#2ecc71') : '#999', fontWeight:'bold'}}>
                                    {penaltyText}
                                </span>
                                <span style={{marginLeft:4, opacity:0.8}}>({handText})</span>
                            </div>
                            <div style={{flex:1.2, fontWeight:'900', color: scoreColor, fontSize:16}}>
                                {row.final > 0 ? `+${row.final}` : row.final}
                            </div>
                            <div style={{flex:0.8, fontSize:12, fontWeight:'bold', color:'#ccc'}}>
                                {index + 1}
                            </div>
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

/**
 * [ç»“ç®—å¼¹çª—ç»„ä»¶]
 */
export const SettlementModal = () => {
    const { 
        winner, roundResult, grandResult, players, playersInfo, roomConfig, 
        handleStartGame, handleNextRound, mySocketId 
    } = useGame();

    // é»˜è®¤æ˜¾ç¤º 'round' (æœ¬å±€è¯¦æƒ…), ä¹Ÿå¯ä»¥åˆ‡åˆ° 'grand' (æ€»æˆ˜ç»©)
    const [activeTab, setActiveTab] = useState('round');

    if (!winner && !roundResult && !grandResult) return null;

    const amIHost = players.find(p => p.id === mySocketId)?.isHost;
    
    // å¦‚æœæ˜¯ç»ˆå±€ç»“ç®— (Grand Over)ï¼Œé»˜è®¤å¯èƒ½æƒ³çœ‹æ€»è¡¨ï¼Œè¿™é‡Œè¿˜æ˜¯æŒ‰éœ€æ±‚é»˜è®¤ç»™ Round
    // æˆ–è€…ä½ å¯ä»¥æ ¹æ® grandResult æ˜¯å¦å­˜åœ¨æ¥å†³å®šé»˜è®¤ Tab
    const data = grandResult || roundResult;
    if (!data) return null;

    const playersWithTeamInfo = players.map(p => ({
        ...p, team: (playersInfo[p.id] && playersInfo[p.id].team !== undefined) ? playersInfo[p.id].team : p.team
    }));

    return (
        <div className={css.modalOverlay}>
            <div className={css.modalContent}>
                
                {/* é¡¶éƒ¨æ ‡é¢˜åŒº */}
                <div className={css.headerSection}>
                    {grandResult ? (
                        <>
                            <Crown size={40} color="#e74c3c" />
                            <h2 className={css.title}>{grandResult.grandWinner} å¤ºå† !</h2>
                        </>
                    ) : (
                        <>
                            <Coins size={32} color="#f1c40f" />
                            <h2 className={css.title}>å°å±€ç»“ç®—</h2>
                        </>
                    )}
                </div>

                {/* Tab åˆ‡æ¢åŒº */}
                <div className={css.tabContainer}>
                    <button 
                        className={activeTab === 'round' ? css.tabActive : css.tab}
                        onClick={() => setActiveTab('round')}
                    >
                        <List size={14}/> æœ¬å±€è¯¦æƒ…
                    </button>
                    <button 
                        className={activeTab === 'grand' ? css.tabActive : css.tab}
                        onClick={() => setActiveTab('grand')}
                    >
                        <History size={14}/> æ€»æˆ˜ç»©è¡¨
                    </button>
                </div>

                {/* å†…å®¹å±•ç¤ºåŒº */}
                <div className={css.contentBody}>
                    {activeTab === 'round' ? (
                        <div className={css.tabContent}>
                            {/* å¦‚æœæœ‰ scoreBreakdown å°±æ˜¾ç¤ºæ–°è¡¨æ ¼ï¼Œå¦åˆ™(æ—§ç‰ˆå…¼å®¹)æ˜¾ç¤ºæç¤º */}
                            {data.scoreBreakdown ? (
                                <RoundDetailTable 
                                    scoreBreakdown={data.scoreBreakdown} 
                                    players={playersWithTeamInfo}
                                />
                            ) : (
                                <div style={{padding:20, color:'#999'}}>æœåŠ¡ç«¯æœªè¿”å›è¯¦æƒ…æ•°æ®</div>
                            )}
                            
                            {/* ä¸‹æ–¹ä¿ç•™ç®€ç•¥æ—¥å¿—ï¼Œæ–¹ä¾¿æŸ¥é˜… */}
                            <div className={css.logBox}>
                                <div style={{fontWeight:'bold', marginBottom:5, fontSize:12, color:'#ccc'}}>ç»“ç®—æ—¥å¿—:</div>
                                {data.detail}
                            </div>
                        </div>
                    ) : (
                        <div className={css.tabContent}>
                            <ScoreTable 
                                players={playersWithTeamInfo} 
                                matchHistory={data.matchHistory} 
                                currentScores={data.grandScores} 
                                roomConfig={roomConfig} 
                            />
                        </div>
                    )}
                </div>

                {/* åº•éƒ¨æŒ‰é’®åŒº */}
                <div className={css.footerSection}>
                    {grandResult ? (
                        <button className={css.primaryButton} onClick={handleStartGame}>é‡æ–°å¼€å§‹</button>
                    ) : (
                        amIHost ? (
                            <button className={css.primaryButton} onClick={handleNextRound}>ä¸‹ä¸€å±€</button>
                        ) : (
                            <div className={css.waitingText}>ç­‰å¾…æˆ¿ä¸»...</div>
                        )
                    )}
                </div>

            </div>
        </div>
    );
};

================================================================================
FILE PATH: client\src\components\game\SettlementModal.module.css
================================================================================
.modalOverlay {
    position: fixed; 
    top: 0; left: 0; right: 0; bottom: 0; 
    background: rgba(0,0,0,0.85); 
    display: flex; 
    justify-content: center; 
    align-items: center; 
    z-index: 99; 
    backdrop-filter: blur(8px);
    pointer-events: auto;
}

.modalContent {
    background: white; 
    border-radius: 24px; 
    text-align: center; 
    box-shadow: 0 30px 80px rgba(0,0,0,0.6); 
    animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    width: 95%;        
    max-width: 650px;
    
    /* [ä¿®æ”¹] é™åˆ¶æœ€å¤§é«˜åº¦ï¼Œç•™å‡ºè¾¹è·ï¼Œé€‚é…æ¨ªå± */
    max-height: 92dvh;
    
    display: flex;
    flex-direction: column;
    overflow: hidden; /* é˜²æ­¢åœ†è§’è¢«å­å…ƒç´ ç ´å */
}

@keyframes popIn {
    0% { transform: scale(0.8); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
}

/* é¡¶éƒ¨æ ‡é¢˜ */
.headerSection {
    /* [ä¿®æ”¹] é˜²æ­¢è¢«å‹ç¼© */
    flex-shrink: 0;
    padding: 20px 20px 10px 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    background: #f8f9fa;
    border-bottom: 1px solid #eee;
}

/* æ¨ªå±ä¸‹ç¨å¾®å‡å° Header çš„ paddingï¼Œè…¾å‡ºç©ºé—´ */
@media (max-height: 500px) {
    .headerSection {
        padding: 10px 20px 5px 20px;
    }
}

.title {
    margin: 0;
    font-size: 22px;
    font-weight: bold;
    color: #2c3e50;
}

/* Tab åˆ‡æ¢æ  */
.tabContainer {
    /* [ä¿®æ”¹] é˜²æ­¢è¢«å‹ç¼© */
    flex-shrink: 0;
    display: flex;
    background: #eee;
    padding: 4px;
    margin: 15px 20px 5px 20px;
    border-radius: 12px;
}

.tab {
    flex: 1;
    padding: 8px;
    border: none;
    background: transparent;
    color: #7f8c8d;
    font-weight: bold;
    font-size: 14px;
    cursor: pointer;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    transition: all 0.2s;
}

.tabActive {
    composes: tab;
    background: white;
    color: #2c3e50;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

/* å†…å®¹åŒºåŸŸ */
.contentBody {
    /* [ä¿®æ”¹] æ ¸å¿ƒï¼šå æ®å‰©ä½™ç©ºé—´ï¼Œä¸”å…è®¸æ»šåŠ¨ */
    flex: 1;
    overflow-y: auto; 
    min-height: 0; /* Flexbox æ»šåŠ¨ä¿®å¤ trick */
    padding: 10px 0;
    background: #fff;
    
    /* ä¼˜åŒ–ç§»åŠ¨ç«¯æ»šåŠ¨ä½“éªŒ */
    -webkit-overflow-scrolling: touch; 
    overscroll-behavior: contain;
}

.tabContent {
    width: 100%;
    animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(5px); }
    to { opacity: 1; transform: translateY(0); }
}

/* --- æœ¬å±€è¯¦æƒ…è¡¨æ ¼æ ·å¼ --- */
.detailTableContainer {
    margin: 0 15px;
    border: 1px solid #eee;
    border-radius: 8px;
    overflow: hidden;
}

.detailHeaderRow {
    display: flex;
    background: #2c3e50;
    color: white;
    padding: 10px 5px;
    font-size: 12px;
    font-weight: bold;
    align-items: center;
}

.detailBody {
    background: white;
}

.detailRow {
    display: flex;
    padding: 12px 5px;
    border-bottom: 1px solid #f0f0f0;
    align-items: center;
    font-size: 13px;
    color: #34495e;
}

.detailRow:last-child {
    border-bottom: none;
}

/* ç®€ç•¥æ—¥å¿—æ¡† */
.logBox {
    margin: 15px 20px 0 20px;
    background: #2c3e50;
    padding: 10px;
    border-radius: 8px;
    color: #ecf0f1;
    font-size: 12px;
    text-align: left;
    line-height: 1.5;
    white-space: pre-wrap;
    /* [ä¿®æ”¹] ç§»é™¤ max-heightï¼Œè®©å…¶åœ¨ contentBody é‡Œè‡ªç„¶æ»šåŠ¨ï¼Œæˆ–è€…ä¿ç•™é™åˆ¶ä½†å…è®¸å†…éƒ¨æ»š */
    /* è¿™é‡Œå»ºè®®ç§»é™¤é™åˆ¶ï¼Œè®©ç”¨æˆ·åœ¨ contentBody è¿™ä¸ªå¤§å®¹å™¨é‡Œæ»‘æ¯”è¾ƒé¡ºæ‰‹ */
    max-height: none; 
}

/* åº•éƒ¨æŒ‰é’®åŒº */
.footerSection {
    /* [ä¿®æ”¹] å¼ºåˆ¶ä¸æ”¶ç¼©ï¼Œå¹¶å¢åŠ åº•éƒ¨å®‰å…¨è·ç¦» */
    flex-shrink: 0;
    padding: 15px 20px 20px 20px;
    
    /* é€‚é… iPhone æ¨ªæ¡ */
    padding-bottom: max(20px, env(safe-area-inset-bottom));
    
    border-top: 1px solid #eee;
    background: white;
    z-index: 10;
}

.primaryButton {
    width: 100%;
    height: 50px;
    background: #2c3e50;
    color: white;
    border: none;
    border-radius: 12px;
    font-weight: bold;
    cursor: pointer;
    font-size: 16px;
    transition: all 0.2s;
    box-shadow: 0 5px 15px rgba(44, 62, 80, 0.2);
}

.primaryButton:hover {
    background: #34495e;
}

.waitingText {
    color: #999;
    font-size: 14px;
    padding: 10px;
}

================================================================================
FILE PATH: client\src\components\game\TableCenterArea.jsx
================================================================================
import React from 'react';
import { useGame } from '../../context/GameContext.jsx';
import { Coins } from 'lucide-react';
// [ä¿®å¤] ä¿®æ­£ Card å¯¼å…¥è·¯å¾„
import { Card } from '../ui/Card.jsx';
import css from './TableCenterArea.module.css';

export const TableCenterArea = () => {
    const { 
        lastPlayed, 
        lastPlayerName, 
        infoMessage, 
        pendingPoints
    } = useGame();

    return (
        <>
            {/* åº•åˆ†é¢æ¿ - æç®€çº¯å‡€ç‰ˆ */}
            {pendingPoints > 0 && (
                <div className={css.scoreBoard}>
                    <div className={css.scoreValue}>
                        <Coins size={24} fill="#f1c40f" stroke="#e67e22" strokeWidth={2} />
                        <span style={{marginLeft: 6}}>{pendingPoints}</span>
                    </div>
                </div>
            )}

            {/* ç³»ç»Ÿæ¶ˆæ¯ (å…¨å±å¤§å­—) */}
            {infoMessage && (
                <div className={css.infoMessage}>
                    {infoMessage}
                </div>
            )}

            {/* æ¡Œé¢å‡ºç‰Œå±•ç¤ºåŒº */}
            {lastPlayed && lastPlayed.length > 0 && (
                <div className={css.tableCenter}>
                    <div className={css.playedContainer}>
                        <div className={css.playerNameTag}>{lastPlayerName}</div>
                        
                        <div className={css.playedRow}>
                            {lastPlayed.map((c, i) => (
                                <div key={`${c}-${i}`} className={css.miniCardWrapper}>
                                    {/* [ä¿®å¤] ä½¿ç”¨æ­£ç¡®çš„ Card å±æ€§: cardVal */}
                                    {/* index=0 spacing=0 ç¡®ä¿å®ƒåœ¨ wrapper å†…éƒ¨å±…ä¸­/é å·¦ï¼Œç”± wrapper è´Ÿè´£å¸ƒå±€ */}
                                    <Card 
                                        cardVal={c} 
                                        index={0} 
                                        isSelected={false} 
                                        onClick={()=>{}} 
                                        onMouseEnter={()=>{}} 
                                        spacing={0} 
                                    />
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            )}
        </>
    );
};

================================================================================
FILE PATH: client\src\components\game\TableCenterArea.module.css
================================================================================
/* åº•åˆ†é¢æ¿ - æç®€çº¯å‡€ç‰ˆ */
.scoreBoard {
    position: absolute;
    /* [ä¿®æ”¹] ä» 42% ä¸Šç§»è‡³ 30%ï¼Œé¿å¼€ä¸‹æ–¹çš„å‡ºç‰ŒåŒºäººå */
    top: 30%;
    left: 50%;
    transform: translate(-50%, -50%);
    
    background: transparent;
    border: none;
    box-shadow: none;
    backdrop-filter: none;
    
    padding: 0;
    z-index: 5;
    pointer-events: none;
    
    animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translate(-50%, -40%); }
    to { opacity: 1; transform: translate(-50%, -50%); }
}

.scoreValue {
    font-size: 28px;
    font-weight: 900;
    color: #f1c40f;
    display: flex;
    align-items: center;
    justify-content: center;
    
    text-shadow: 
        0 2px 0 #b9770e,
        0 4px 4px rgba(0,0,0,0.5),
        -1px -1px 0 #000,  
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    
    filter: drop-shadow(0 2px 3px rgba(0,0,0,0.5));
}

/* ç³»ç»Ÿæ¶ˆæ¯ */
.infoMessage {
    position: absolute;
    top: 25%;
    width: 100%;
    text-align: center;
    color: #f1c40f;
    font-size: 40px;
    font-weight: bold;
    text-shadow: 0 5px 15px rgba(0,0,0,0.5);
    pointer-events: none;
    z-index: 50;
    letter-spacing: 2px;
    animation: fadeInOut 3.5s forwards;
}

@keyframes fadeInOut {
    0% { opacity: 0; transform: translateY(10px); }
    10% { opacity: 1; transform: translateY(0); }
    80% { opacity: 1; transform: translateY(0); }
    100% { opacity: 0; transform: translateY(-10px); }
}

/* æ¡Œé¢å‡ºç‰Œå±•ç¤ºåŒº */
.tableCenter {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1;
}

.playedContainer {
    animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    display: flex;
    flex-direction: column;
    align-items: center;
}

@keyframes popIn {
    0% { transform: scale(0.5); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
}

.playerNameTag {
    color: white;
    text-align: center;
    margin-bottom: 5px;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    font-size: 14px;
    font-weight: bold;
    background: rgba(0,0,0,0.3);
    padding: 2px 10px;
    border-radius: 20px;
    display: inline-block;
}

/* ç‰Œå‹è¡Œ */
.playedRow {
    display: flex;
    justify-content: center;
    /* [ä¿®å¤] gap ä¸æ”¯æŒè´Ÿå€¼ï¼Œæ”¹ç”¨ margin å®ç°å ç‰Œ */
    filter: drop-shadow(0 10px 20px rgba(0,0,0,0.3));
    /* æ•´ä½“ç¼©å°ä¸€ç‚¹ç‚¹ï¼Œçœ‹èµ·æ¥æ›´ç²¾è‡´ */
    transform: scale(0.9);
}

/* * [é‡è¦] Cardç»„ä»¶å†…éƒ¨æ˜¯ absolute å®šä½
 * è¿™é‡Œ wrapper éœ€è¦ç›¸å¯¹å®šä½å¹¶æŒ‡å®šå®½é«˜ï¼Œæ‰èƒ½æ’‘å¼€ flex å¸ƒå±€ 
 * 55px x 70px æ˜¯ Card.module.css å®šä¹‰çš„å°ºå¯¸
 */
.miniCardWrapper {
    width: 55px;
    height: 70px;
    position: relative;
    /* è´Ÿ margin å®ç°å ç‰Œæ•ˆæœ */
    margin-right: -25px; 
}

.miniCardWrapper:last-child {
    margin-right: 0;
}

================================================================================
FILE PATH: client\src\components\ScoreTable.jsx
================================================================================
import React from 'react';
import { Trophy, Shield, Medal, ScrollText } from 'lucide-react';

export const ScoreTable = ({ 
    players, 
    matchHistory = [], 
    currentScores,     
    roomConfig,
    grandResult
}) => {
    const isTeamMode = roomConfig.isTeamMode && (players.length % 2 === 0);

    const sortedPlayers = [...players].sort((a, b) => {
        const scoreA = currentScores[a.id] || 0;
        const scoreB = currentScores[b.id] || 0;
        return scoreB - scoreA; 
    });

    let redTeamHistory = [];
    let blueTeamHistory = [];
    let redTotal = 0;
    let blueTotal = 0;

    if (isTeamMode) {
        matchHistory.forEach((match, idx) => {
            let r = 0, b = 0;
            players.forEach(p => {
                const s = match.scores[p.id] || 0;
                if (p.team === 0) r += s;
                else if (p.team === 1) b += s;
            });
            redTeamHistory[idx] = r;
            blueTeamHistory[idx] = b;
        });
        
        players.forEach(p => {
            const s = currentScores[p.id] || 0;
            if (p.team === 0) redTotal += s;
            else if (p.team === 1) blueTotal += s;
        });
    }

    // [æ–°å¢] å®šä¹‰åˆ—çš„æœ€å°å®½åº¦ï¼Œé˜²æ­¢åœ¨æ‰‹æœºä¸Šè¢«æŒ¤å‹
    const minColWidth = 50; 

    const renderHeader = () => (
        <div style={{display: 'flex', background: '#2c3e50', color: 'white', padding: '10px', borderRadius: '8px 8px 0 0', fontWeight: 'bold', fontSize: 13, minWidth: '100%'}}>
            <div style={{flex: 2, textAlign: 'left', paddingLeft: 10, minWidth: 80, position: 'sticky', left: 0, background: '#2c3e50', zIndex: 1}}>ç©å®¶/é˜Ÿä¼</div>
            {matchHistory.map((_, i) => (
                <div key={i} style={{flex: 1, textAlign: 'center', minWidth: minColWidth}}>R{i + 1}</div>
            ))}
            <div style={{flex: 1.2, textAlign: 'center', color: '#f1c40f', minWidth: 60}}>æ€»åˆ†</div>
            <div style={{flex: 0.8, textAlign: 'center', minWidth: 40}}>æ’å</div>
        </div>
    );

    const renderTeamRow = (teamIndex, totalScore, historyScores) => {
        const color = teamIndex === 0 ? '#e74c3c' : '#3498db';
        const bg = teamIndex === 0 ? 'rgba(231, 76, 60, 0.1)' : 'rgba(52, 152, 219, 0.1)';
        const name = teamIndex === 0 ? 'çº¢é˜Ÿ' : 'è“é˜Ÿ';
        
        return (
            <div style={{display: 'flex', background: bg, padding: '8px 10px', borderBottom: '1px solid rgba(0,0,0,0.05)', alignItems:'center', fontSize: 13, minWidth: '100%'}}>
                <div style={{flex: 2, textAlign: 'left', color: color, fontWeight: 'bold', display:'flex', alignItems:'center', gap:5, minWidth: 80, position: 'sticky', left: 0, background: teamIndex === 0 ? '#fceceb' : '#ebf5fb', zIndex: 1}}>
                    <Shield size={14} fill={color} /> {name}
                </div>
                {matchHistory.map((_, i) => (
                    <div key={i} style={{flex: 1, textAlign: 'center', color: historyScores[i] > 0 ? color : '#999', fontWeight:'bold', minWidth: minColWidth}}>
                        {historyScores[i] > 0 ? `+${historyScores[i]}` : historyScores[i]}
                    </div>
                ))}
                <div style={{flex: 1.2, textAlign: 'center', color: color, fontWeight: '900', fontSize: 14, minWidth: 60}}>{totalScore}</div>
                <div style={{flex: 0.8, minWidth: 40}}></div>
            </div>
        );
    };

    const renderPlayerRow = (player, rank) => {
        const score = currentScores[player.id] || 0;
        
        let rankIcon = null;
        if (rank === 1) rankIcon = <Trophy size={16} color="#f1c40f" fill="#f1c40f"/>;
        else if (rank === 2) rankIcon = <Medal size={16} color="#bdc3c7" fill="#bdc3c7"/>;
        else if (rank === 3) rankIcon = <Medal size={16} color="#e67e22" fill="#e67e22"/>;
        else rankIcon = <span style={{color:'#999', fontSize:12}}>{rank}</span>;

        return (
            <div key={player.id} style={{
                display: 'flex', 
                padding: '10px', 
                background: 'white', 
                borderBottom: '1px solid #eee',
                alignItems: 'center',
                fontSize: 13,
                minWidth: '100%'
            }}>
                {/* ç©å®¶åå­—å›ºå®šåœ¨å·¦ä¾§ï¼Œæ–¹ä¾¿æ¨ªå‘æ»šåŠ¨æŸ¥çœ‹åˆ†æ•° */}
                <div style={{flex: 2, textAlign: 'left', display: 'flex', alignItems: 'center', gap: 8, overflow:'hidden', minWidth: 80, position: 'sticky', left: 0, background: 'white', zIndex: 1, borderRight: '1px solid #f0f0f0'}}>
                    <div style={{
                        width: 24, height: 24, borderRadius: '50%', background: '#ecf0f1', 
                        display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: 12, fontWeight: 'bold',
                        border: player.team !== undefined && player.team !== null ? `2px solid ${player.team===0?'#e74c3c':'#3498db'}` : 'none',
                        flexShrink: 0
                    }}>
                        {player.name[0]}
                    </div>
                    <span style={{fontWeight: 'bold', color: '#2c3e50', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis'}}>
                        {player.name}
                    </span>
                </div>

                {matchHistory.map((match, i) => {
                    const s = match.scores[player.id] || 0;
                    return (
                        <div key={i} style={{flex: 1, textAlign: 'center', color: s > 0 ? '#e67e22' : (s < 0 ? '#7f8c8d' : '#bdc3c7'), fontWeight: s!==0?'bold':'normal', minWidth: minColWidth}}>
                            {s > 0 ? `+${s}` : s}
                        </div>
                    );
                })}

                <div style={{flex: 1.2, textAlign: 'center', fontWeight: 'bold', color: score >= 0 ? '#27ae60' : '#c0392b', fontSize: 14, minWidth: 60}}>
                    {score}
                </div>

                <div style={{flex: 0.8, textAlign: 'center', display:'flex', justifyContent:'center', minWidth: 40}}>
                    {rankIcon}
                </div>
            </div>
        );
    };

    return (
        <div style={{width: '100%', display: 'flex', flexDirection: 'column', gap: 0, borderRadius: 8, overflow: 'hidden', border: '1px solid #ddd'}}>
            {/* [å…³é”®ä¿®æ”¹] å¤–å±‚å¢åŠ  overflowX: autoï¼Œå®ç°æ¨ªå‘æ»šåŠ¨ */}
            <div style={{overflowX: 'auto', width: '100%'}}>
                {renderHeader()}
                
                {isTeamMode && renderTeamRow(0, redTotal, redTeamHistory)}
                {isTeamMode && renderTeamRow(1, blueTotal, blueTeamHistory)}
                
                {/* [å…³é”®ä¿®æ”¹] maxHeight ä½¿ç”¨ min(300px, 40vh) é€‚é…å°å±å¹• */}
                <div style={{maxHeight: 'min(300px, 40vh)', overflowY: 'auto'}}>
                    {sortedPlayers.map((p, i) => renderPlayerRow(p, i + 1))}
                </div>
            </div>

            <div style={{background: '#f8f9fa', padding: 10, borderTop: '1px solid #ddd'}}>
                <div style={{display:'flex', alignItems:'center', gap:5, fontSize: 12, color: '#7f8c8d', marginBottom: 5, fontWeight:'bold'}}>
                    <ScrollText size={12}/> èµç½šæ—¥å¿—è¯¦æƒ…
                </div>
                {/* [å…³é”®ä¿®æ”¹] maxHeight ä½¿ç”¨ min(100px, 15vh) */}
                <div style={{fontSize: 11, color: '#666', lineHeight: '1.6', maxHeight: 'min(100px, 15vh)', overflowY: 'auto', textAlign:'left'}}>
                    {matchHistory.length > 0 ? (
                        matchHistory.slice().reverse().map((match, i) => (
                            <div key={i} style={{marginBottom: 4}}>
                                <span style={{fontWeight:'bold', color:'#333'}}>R{matchHistory.length - i}: </span>
                                {match.details && match.details.length > 0 ? match.details.join('; ') : 'æ— ç‰¹æ®Šèµç½š'}
                            </div>
                        ))
                    ) : (
                        <div>æš‚æ— è®°å½•</div>
                    )}
                </div>
            </div>
        </div>
    );
};

================================================================================
FILE PATH: client\src\components\ui\Card.jsx
================================================================================
import React from 'react';
import { getCardDisplay } from '../../utils/cardLogic.js';
import css from './Card.module.css';

export const Card = ({ cardVal, index, isSelected, onClick, onMouseEnter, spacing }) => {
    const { suit, text, color, isScore } = getCardDisplay(cardVal);
    
    const handlePointerDown = (e) => {
        if (e.pointerType === 'touch') return;
        
        // [ä¿®æ”¹] PC ç«¯é¼ æ ‡ç‚¹å‡»ä¹Ÿäº¤ç”±çˆ¶ç»„ä»¶æ‰‹åŠ¿ Hook ç»Ÿä¸€å¤„ç†
        // å±è”½æ­¤å¤„çš„ onClickï¼Œé¿å…ä¸ useHandGesture çš„ mousedown é€»è¾‘å†²çªï¼ˆå¯¼è‡´ç‚¹ä¸€æ¬¡è§¦å‘ä¸¤æ¬¡ï¼‰
        
        /* if (e.button !== 0 && e.pointerType === 'mouse') return;
        e.stopPropagation();
        onClick(cardVal); 
        */
    };

    const containerClasses = [
        css.card,
        isSelected ? css.cardSelected : '',
        isScore ? css.cardScore : css.cardNormal
    ].join(' ');

    return (
        <div 
            className={containerClasses}
            onPointerDown={handlePointerDown}
            onMouseEnter={(e) => {
                // è¿™ä¸ªäº‹ä»¶ä¸»è¦ä¿ç•™ç»™æ—§é€»è¾‘ï¼Œä½†æœ‰äº† useHandGesture åå…¶å®ä¸å†ä¾èµ–å®ƒ
                if (e.pointerType === 'mouse') {
                     onMouseEnter(cardVal);
                }
            }}
            style={{
                color: color, 
                left: index * spacing, 
                zIndex: index
            }}
        >
            <div className={css.cardContent}>
                <div className={css.cardText}>{text}</div>
                <div className={css.cardSuit}>{suit}</div>
            </div>
            {isScore && <div className={css.starBadge}>â˜…</div>}
        </div>
    );
};

export const MiniCard = ({ cardVal, index }) => {
    const { text, suit, color, isScore } = getCardDisplay(cardVal);
    
    const miniClasses = [
        css.miniCard,
        isScore ? css.miniCardScore : ''
    ].join(' ');

    return (
        <div 
            className={miniClasses}
            style={{ 
                color,
                zIndex: index 
            }}
        >
            {suit}{text}
        </div>
    );
};

================================================================================
FILE PATH: client\src\components\ui\Card.module.css
================================================================================
/* åŸºç¡€å¡ç‰Œå®¹å™¨ */
.card {
    background: white;
    border-radius: 6px;
    border: 1px solid #999;
    position: absolute;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    padding: 4px;
    transition: transform 0.1s cubic-bezier(0.2, 0.8, 0.2, 1);
    width: 55px;
    height: 70px;
    box-sizing: border-box;
    /* ç¦æ­¢è§¦æ‘¸æ—¶çš„é»˜è®¤åŠ¨ä½œï¼Œäº¤ç”± JS å¤„ç† */
    touch-action: none; 
    box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
}

/* é€‰ä¸­çŠ¶æ€ */
.cardSelected {
    transform: translateY(-35px);
    border-color: #3498db !important;
    box-shadow: 0 0 15px rgba(52, 152, 219, 0.6) !important;
}

/* åˆ†ç‰Œé«˜äº® */
.cardScore {
    border-color: #f1c40f;
    box-shadow: 0 0 8px rgba(241, 196, 15, 0.4);
}

/* æ™®é€šç‰Œ */
.cardNormal {
    border-color: #bdc3c7;
}

/* å¡é¢å†…å®¹å¸ƒå±€ */
.cardContent {
    position: absolute;
    top: 0;
    left: 1px;
    display: flex;
    flex-direction: column;
    align-items: center;
    line-height: 0.9;
}

.cardText {
    font-size: 16px;
    font-weight: 900;
    letter-spacing: -1px;
}

.cardSuit {
    font-size: 14px;
    margin-top: -1px;
}

/* å³ä¸‹è§’æ˜Ÿæ˜Ÿ */
.starBadge {
    position: absolute;
    bottom: 1px;
    right: 2px;
    font-size: 10px;
    color: #f1c40f;
}

/* --- å°å¡ç‰Œ (ç”¨äºå†å²è®°å½•/æ¡Œé¢å±•ç¤º) --- */
.miniCard {
    background: white;
    padding: 10px 15px;
    border-radius: 8px;
    font-weight: bold;
    font-size: 24px;
    min-width: 40px;
    text-align: center;
    border: 1px solid #ccc;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    position: relative;
}

.miniCardScore {
    border: 2px solid #f1c40f;
    transform: scale(1.1) translateY(-10px);
    z-index: 10;
}

================================================================================
FILE PATH: client\src\components\ui\GameLogPanel.jsx
================================================================================
import React, { useEffect, useRef, useState } from 'react'; 
import { History, ChevronDown, ChevronUp } from 'lucide-react'; 
import css from './GameLogPanel.module.css';

export const GameLogPanel = ({ logs }) => {
    const [isCollapsed, setIsCollapsed] = useState(false); 
    const endRef = useRef(null);

    useEffect(() => {
        if (!isCollapsed) {
            endRef.current?.scrollIntoView({ behavior: 'smooth' });
        }
    }, [logs, isCollapsed]);

    const panelClasses = [
        css.panel,
        isCollapsed ? css.panelCollapsed : css.panelExpanded
    ].join(' ');

    return (
        <div 
            className={panelClasses}
            onClick={() => setIsCollapsed(!isCollapsed)} 
        >
            <div className={css.header}>
                <History size={14} color="#f1c40f" /> 
                <span style={{color:'#fff', fontWeight:'bold', flex: 1}}>
                    å¯¹å±€è®°å½•
                </span>
                {isCollapsed ? <ChevronDown size={14} color="#ccc"/> : <ChevronUp size={14} color="#ccc"/>}
            </div>
            
            <div className={isCollapsed ? css.listHidden : css.list}>
                {logs.map((log, i) => (
                    <div key={i} className={css.logItem}>
                        <span className={css.logTime}>[{log.time.split(' ')[0]}]</span>
                        <span style={{color: '#eee'}}>{log.text}</span>
                    </div>
                ))}
                <div ref={endRef} />
            </div>
        </div>
    );
};

================================================================================
FILE PATH: client\src\components\ui\GameLogPanel.module.css
================================================================================
.panel {
    position: absolute;
    top: 60px;
    left: 10px;
    width: 200px;
    background: rgba(0, 0, 0, 0.4);
    border-radius: 8px;
    padding: 8px;
    color: white;
    font-size: 12px;
    z-index: 1000;
    backdrop-filter: blur(2px);
    transition: all 0.3s ease;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    cursor: pointer;
    overflow: hidden;
    /* [ä¿®å¤] ç¡®ä¿åœ¨ä»»ä½•çŠ¶æ€ä¸‹éƒ½æ¥æ”¶é¼ æ ‡äº‹ä»¶ï¼Œé˜²æ­¢æ— æ³•ç‚¹å‡»å±•å¼€ */
    pointer-events: auto; 
}

.panelCollapsed {
    height: 36px;
    background: rgba(0, 0, 0, 0.2);
    border-color: transparent;
}

.panelExpanded {
    height: 140px;
}

.header {
    display: flex;
    align-items: center;
    gap: 5px;
    margin-bottom: 5px;
    font-weight: bold;
    color: #f1c40f;
    text-shadow: 0 1px 2px rgba(0,0,0,0.8);
}

.list {
    height: 100px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 4px;
    opacity: 1;
    transition: opacity 0.2s;
    /* éšè—æ»šåŠ¨æ¡ä½†ä¿ç•™åŠŸèƒ½ */
    scrollbar-width: none; 
}

.listHidden {
    opacity: 0;
    pointer-events: none;
}

.logItem {
    display: flex;
    gap: 6px;
    line-height: 1.3;
    text-shadow: 0 1px 1px rgba(0,0,0,0.8);
}

.logTime {
    color: #95a5a6;
    font-family: monospace;
    flex-shrink: 0;
}

================================================================================
FILE PATH: client\src\components\ui\PlayerAvatar.jsx
================================================================================
import React from 'react';
import { Trophy, Flag, Shield, Coins } from 'lucide-react';
import css from './PlayerAvatar.module.css';
import CountDownTimer from '../CountDownTimer.jsx';

export const PlayerAvatar = ({ player, isTurn, score, roundScore = 0, targetScore, isMySocket, remainingSeconds, rank, timerPosition, hideTimer, cardCount, showCardCountMode, team }) => {
    const progress = Math.min((score / targetScore) * 100, 100);
    
    // æ’åçŠ¶æ€ä¸‹çš„é€æ˜åº¦
    const containerStyle = rank ? { opacity: 0.75 } : {};

    let showBadge = false;
    if (showCardCountMode === 2) showBadge = true;
    // [ä¿®æ”¹] 2 æ”¹ä¸º 3
    if (showCardCountMode === 1 && cardCount <= 3 && cardCount > 0) showBadge = true;
    if (rank) showBadge = false;

    const isTeamMode = team !== undefined && team !== null;
    const teamName = team === 0 ? 'çº¢' : 'è“';
    
    const boxClasses = [
        css.playerBox,
        isTurn ? css.activeTurn : '',
        isTeamMode ? (team === 0 ? css.teamRed : css.teamBlue) : ''
    ].join(' ');

    return (
        <div className={boxClasses} style={containerStyle}>
            {showBadge && (
                <div className={css.cardCountBadge}>
                    {cardCount}
                </div>
            )}

            {isTeamMode && (
                <div className={css.teamBadge} style={{backgroundColor: team === 0 ? '#e74c3c' : '#3498db'}}>
                    <Shield size={8} fill="currentColor"/> {teamName}é˜Ÿ
                </div>
            )}

            {rank && (
                <div className={css.rankBadge} style={{
                    background: rank === 1 ? '#f1c40f' : (rank === 2 ? '#bdc3c7' : '#e67e22')
                }}>
                    {rank === 1 ? <Trophy size={10} fill="white" /> : <Flag size={10} fill="white"/>}
                    {rank === 1 ? 'NO.1' : `NO.${rank}`}
                </div>
            )}

            <div className={css.avatar} style={{borderColor: isTeamMode ? (team === 0 ? '#e74c3c' : '#3498db') : 'rgba(255,255,255,0.3)'}}>
                {player.name[0]}
            </div>
            
            <div className={css.playerName}>
                {player.name} {isMySocket && '(æˆ‘)'}
            </div>
            
            <div className={css.scoreBarBg}>
                <div className={css.scoreBarFill} style={{width:`${progress}%`, background: progress>=100?'#e74c3c':'#2ecc71'}}></div>
            </div>
            
            <div className={css.playerScore}>
                <Coins size={10} color="#f1c40f"/> 
                {score}
                {roundScore > 0 && (
                    <span style={{color: '#f1c40f', fontSize: 9, marginLeft: 2, fontWeight: 900}}>(+{roundScore})</span>
                )}
            </div>
            
            {isTurn && !rank && !hideTimer && (
                <CountDownTimer 
                    initialSeconds={remainingSeconds} 
                    totalSeconds={60} 
                    position={timerPosition}
                />
            )}
        </div>
    );
};

================================================================================
FILE PATH: client\src\components\ui\PlayerAvatar.module.css
================================================================================
/* å¤´åƒå®¹å™¨ */
.playerBox {
    pointer-events: auto;
    padding: 2px 4px;
    border-radius: 8px;
    text-align: center;
    min-width: 45px;
    color: white;
    border: 1px solid transparent;
    transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
    position: relative;
    backdrop-filter: blur(3px);
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    background: rgba(44, 62, 80, 0.6);
}

/* è½®åˆ°è¯¥ç©å®¶æ—¶çš„æ¿€æ´»çŠ¶æ€ */
.activeTurn {
    transform: scale(1.1);
    box-shadow: 0 0 25px rgba(241, 196, 15, 0.5);
    background: rgba(44, 62, 80, 0.9);
    border-color: #f1c40f !important; /* å¼ºåˆ¶è¦†ç›–é˜Ÿä¼è‰² */
    z-index: 20;
}

/* é˜Ÿä¼èƒŒæ™¯è‰² */
.teamRed { background: rgba(231, 76, 60, 0.2); }
.teamBlue { background: rgba(52, 152, 219, 0.2); }

/* å‰©ä½™æ‰‹ç‰Œæ•°å¾½ç«  */
.cardCountBadge {
    position: absolute;
    top: -8px;
    left: -8px;
    background: #e74c3c;
    color: white;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    font-size: 12px;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 2px solid #fff;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    z-index: 25;
}

/* ç»„é˜Ÿæ ‡ç­¾ */
.teamBadge {
    position: absolute; 
    top: -10px; 
    right: -8px; 
    color: white;
    font-size: 9px; 
    padding: 1px 4px; 
    border-radius: 4px;
    display: flex; 
    align-items: center; 
    gap: 2px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    z-index: 25;
}

/* æ’åæ ‡ç­¾ (NO.1 etc) */
.rankBadge {
    position: absolute;
    top: -16px;
    left: 50%;
    transform: translateX(-50%);
    color: #fff;
    padding: 2px 8px;
    border-radius: 20px;
    font-size: 11px;
    font-weight: bold;
    box-shadow: 0 2px 5px rgba(0,0,0,0.4);
    z-index: 30;
    display: flex;
    align-items: center;
    gap: 3px;
    white-space: nowrap;
    border: 1px solid white;
}

/* åœ†å½¢å¤´åƒ */
.avatar {
    width: 30px;
    height: 30px;
    background: #ecf0f1;
    border-radius: 50%;
    margin: 0 auto 2px;
    line-height: 30px;
    color: #333;
    font-weight: bold;
    font-size: 14px;
    border: 1px solid rgba(255,255,255,0.3);
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    display: flex;
    align-items: center;
    justify-content: center;
}

.playerName {
    font-size: 10px;
    font-weight: bold;
    margin-bottom: 1px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 50px;
    margin-left: auto;
    margin-right: auto;
}

/* åˆ†æ•°æ¡ */
.scoreBarBg {
    width: 100%;
    height: 4px;
    background: rgba(0,0,0,0.5);
    border-radius: 2px;
    margin-top: 2px;
    overflow: hidden;
}

.scoreBarFill {
    height: 100%;
    transition: width 0.5s;
}

.playerScore {
    font-size: 9px;
    color: #f1c40f;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 3px;
    margin-top: 1px;
}

================================================================================
FILE PATH: client\src\context\GameContext.jsx
================================================================================
import React, { createContext, useContext, useEffect, useRef, useState } from 'react';

import { useSocketConnection } from '../hooks/useSocketConnection.js';
import { useRoomLogic } from '../hooks/game/useRoomLogic.js';
import { useGameData } from '../hooks/game/useGameData.js';
import { useBattleLogic } from '../hooks/game/useBattleLogic.js';

const GameContext = createContext(null);

export const GameProvider = ({ children }) => {
  const { socket, isConnected, mySocketId, ping } = useSocketConnection();

  // [æ–°å¢] è§‚ä¼—çŠ¶æ€
  const [isSpectator, setIsSpectator] = useState(false);
  // [æ–°å¢] è§‚å¯Ÿåˆ°çš„å…¶ä»–äººæ‰‹ç‰Œ { playerId: [cards] }
  const [observedHands, setObservedHands] = useState({});

  const roomLogic = useRoomLogic(socket, isConnected);
  const { 
      username, roomId, inputConfig, isLoading, setIsLoading,
      handleRoomAction, handleUpdateConfig
  } = roomLogic;

  const gameData = useGameData(socket, setIsLoading);
  const { 
      gameState, players, syncedConfig, 
      handleStartGame, handleNextRound,
      handleAddBot, handleSwitchSeat, handleDrawCard, handleKickPlayer
  } = gameData;

  const activeRoomConfig = (gameState === 'LOGIN') ? inputConfig : (syncedConfig || inputConfig);

  const deckCount = activeRoomConfig ? activeRoomConfig.deckCount : 2;
  const battleLogic = useBattleLogic(socket, username, mySocketId, roomId, deckCount);

  // [æ–°å¢] ç›‘å¬è§‚ä¼—äº‹ä»¶å’Œæ‰‹ç‰Œè§‚å¯Ÿäº‹ä»¶
  useEffect(() => {
    if (!socket) return;

    const onSpectatorJoin = (data) => {
        setIsSpectator(true);
        // å¦‚æœè¿›å…¥æ—¶æ¸¸æˆå·²ç»æ˜¯ GAME çŠ¶æ€ï¼Œæ‰‹åŠ¨è§£é™¤ loading (é˜²æ­¢ useGameData é€»è¾‘è¦†ç›–)
        setIsLoading(false); 
        alert(data.message);
    };

    const onObservationUpdate = (data) => {
        // data: { targetId, hand, targetName }
        setObservedHands(prev => ({
            ...prev,
            [data.targetId]: data.hand
        }));
    };

    // æ¯æ¬¡æ–°å±€å¼€å§‹ï¼Œæ¸…ç©ºè§‚å¯Ÿçš„æ‰‹ç‰Œ
    const onGameStarted = (data) => {
        setObservedHands({});
        // å¦‚æœæœåŠ¡å™¨æ˜ç¡®æ ‡è®°ä½ æ˜¯è§‚ä¼—
        if (data.isSpectator) {
            setIsSpectator(true);
        } else {
            // å¦‚æœæˆ‘æ˜¯ç©å®¶ï¼ˆæœ‰æ‰‹ç‰Œï¼‰ï¼Œç¡®ä¿ isSpectator ä¸º false
            if (data.hand && data.hand.length > 0) setIsSpectator(false);
        }
    };

    socket.on('spectator_join', onSpectatorJoin);
    socket.on('observation_update', onObservationUpdate);
    socket.on('game_started', onGameStarted);

    return () => {
        socket.off('spectator_join', onSpectatorJoin);
        socket.off('observation_update', onObservationUpdate);
        socket.off('game_started', onGameStarted);
    };
  }, [socket, setIsLoading]);


  const wrappedActions = {
      handleRoomAction,
      handleUpdateConfig: (cfg) => handleUpdateConfig(roomId, cfg),
      handleStartGame: () => handleStartGame(roomId),
      handleNextRound: () => handleNextRound(roomId),
      handleAddBot: () => handleAddBot(roomId),
      handleSwitchSeat: (i1, i2) => handleSwitchSeat(roomId, i1, i2),
      handleDrawCard: (idx) => handleDrawCard(roomId, idx),
      handleKickPlayer: (tid) => handleKickPlayer(roomId, tid),
      
      handleToggleAutoPlay: () => battleLogic.handleToggleAutoPlay(roomId),
      handlePass: () => battleLogic.handlePass(roomId),
      handlePlayCards: () => battleLogic.handlePlayCards(roomId),
      handleRequestHint: () => battleLogic.handleRequestHint(roomId),

      handleQuickReconnect: () => {
          const lastRid = localStorage.getItem('poker_roomid');
          const lastName = localStorage.getItem('poker_username');
          
          if (!lastRid || !lastName) {
              return alert("æ²¡æœ‰æ‰¾åˆ°æœ€è¿‘çš„æˆ¿é—´è®°å½•ï¼Œæ— æ³•é‡è¿");
          }
          if (!isConnected) return alert("ç½‘ç»œè¿æ¥æœªå°±ç»ªï¼Œè¯·ç¨å€™");

          roomLogic.setRoomId(lastRid);
          roomLogic.setUsername(lastName);
          roomLogic.setIsCreatorMode(false);
          
          if (setIsLoading) setIsLoading(true);
          console.log(`[QuickReconnect] å°è¯•é‡å›æˆ¿é—´: ${lastRid} as ${lastName}`);
          
          if (socket && socket.connected) {
              socket.emit('join_room', { roomId: lastRid, username: lastName });
          } else {
              setIsLoading(false);
              alert("è¿æ¥æ–­å¼€ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•");
          }
      },

      handleLeaveRoom: () => {
          if (window.confirm("ç¡®å®šè¦é€€å‡ºæˆ¿é—´è¿”å›é¦–é¡µå—ï¼Ÿ")) {
              window.location.reload();
          }
      }
  };

  const contextValue = {
      socket, isConnected, mySocketId, ping,
      
      username, setUsername: roomLogic.setUsername,
      roomId, setRoomId: roomLogic.setRoomId,
      isCreatorMode: roomLogic.isCreatorMode, setIsCreatorMode: roomLogic.setIsCreatorMode,
      isLoading,
      
      roomConfig: activeRoomConfig, 
      setRoomConfig: roomLogic.setInputConfig, 
      gameState, 
      players, 
      
      ...gameData, 
      ...battleLogic, 
      
      ...wrappedActions,
      
      handleMouseDown: battleLogic.handleMouseDown,
      handleMouseEnter: battleLogic.handleMouseEnter,
      handleClearSelection: battleLogic.handleClearSelection,
      toggleSort: battleLogic.toggleSort,

      // [æ–°å¢] æš´éœ²ç»™ UI çš„æ–°çŠ¶æ€
      isSpectator,
      observedHands 
  };

  return (
    <GameContext.Provider value={contextValue}>
      {children}
    </GameContext.Provider>
  );
};

export const useGame = () => {
  const context = useContext(GameContext);
  if (!context) {
    throw new Error('useGame must be used within a GameProvider');
  }
  return context;
};

================================================================================
FILE PATH: client\src\hooks\game\useBattleLogic.js
================================================================================
import { useState, useEffect, useRef } from 'react';
import { sortHand } from '../../utils/cardLogic.js';
import SoundManager from '../../utils/SoundManager.js';
import SmartHint from '../../utils/smartHint.js'; // å¼•å…¥æœ¬åœ°æ™ºèƒ½æç¤º

export const useBattleLogic = (socket, username, mySocketId, roomId, deckCount = 2) => {
    // --- å±€å†…çŠ¶æ€ ---
    const [myHand, setMyHand] = useState([]);       
    const [selectedCards, setSelectedCards] = useState([]); 
    const [lastPlayed, setLastPlayed] = useState([]); 
    const [currentTurnId, setCurrentTurnId] = useState(null); 
    const [lastPlayerName, setLastPlayerName] = useState(''); 
    const [infoMessage, setInfoMessage] = useState(''); 
    
    // ç§¯åˆ†ä¸ç»“ç®—
    const [roundResult, setRoundResult] = useState(null); 
    const [grandResult, setGrandResult] = useState(null); 
    const [playerScores, setPlayerScores] = useState({});
    const [roundPoints, setRoundPoints] = useState({});
    const [playersInfo, setPlayersInfo] = useState({}); 
    const [finishedRank, setFinishedRank] = useState([]); 
    const [pendingPoints, setPendingPoints] = useState(0);
    
    // æ‚é¡¹
    const [gameLogs, setGameLogs] = useState([]);
    const [sortMode, setSortMode] = useState('POINT'); 
    const [turnRemaining, setTurnRemaining] = useState(60); 
    const [handCounts, setHandCounts] = useState({});

    // æç¤ºåŠŸèƒ½çŠ¶æ€
    const [availableHints, setAvailableHints] = useState([]); 
    const [hintIndex, setHintIndex] = useState(0);            
    
    // [æ–°å¢] æäº¤é˜²æŠ–çŠ¶æ€
    const [isSubmitting, setIsSubmitting] = useState(false);

    // äº¤äº’ Ref
    const isDragging = useRef(false); 
    const dragStartMode = useRef(true); 
    const sortModeRef = useRef('POINT');
    const backupHandRef = useRef([]);

    // ä¿æŒ Ref åŒæ­¥
    useEffect(() => { sortModeRef.current = sortMode; }, [sortMode]);
    // å½“æ’åºæ¨¡å¼æ”¹å˜æ—¶ï¼Œé‡æ’æ‰‹ç‰Œ
    useEffect(() => {
        if (myHand.length > 0) setMyHand(prev => sortHand(prev, sortMode));
    }, [sortMode]);

    // åˆå§‹åŒ–éŸ³æ•ˆ & å…¨å±€äº‹ä»¶
    useEffect(() => {
        const initAudio = () => {
            SoundManager.init();
            window.removeEventListener('click', initAudio);
        };
        window.addEventListener('click', initAudio);

        const handleGlobalMouseUp = () => { isDragging.current = false; };
        window.addEventListener('mouseup', handleGlobalMouseUp);
        return () => window.removeEventListener('mouseup', handleGlobalMouseUp);
    }, []);

    // --- è‡ªåŠ¨è®¡ç®—æç¤º (å½“è½®åˆ°æˆ‘å‡ºç‰Œæ—¶) ---
    useEffect(() => {
        if (currentTurnId === mySocketId && myHand.length > 0) {
            // æœ¬åœ°è®¡ç®—ï¼Œå®æ—¶æ€§æ›´é«˜
            // æ³¨æ„ï¼šlastPlayed éœ€è¦æ˜¯æœ€æ–°çš„
            const hints = SmartHint.getSortedHints(myHand, lastPlayed, deckCount);
            setAvailableHints(hints);
            setHintIndex(0);
        } else {
            setAvailableHints([]);
            setHintIndex(0);
        }
    }, [currentTurnId, mySocketId, myHand, lastPlayed, deckCount]);


    // --- Socket ç›‘å¬ ---
    useEffect(() => {
        if (!socket) return;

        const onGameStarted = (data) => {
            if (data.hand) {
                setMyHand(sortHand(data.hand, sortModeRef.current));
            }
            setLastPlayed([]);
            setRoundResult(null);
            setGrandResult(null);
            setPendingPoints(0);
            setFinishedRank([]); 
            if (data.grandScores) setPlayerScores(data.grandScores);
            setRoundPoints({});

            setGameLogs([{ time: new Date().toLocaleTimeString(), text: 'ğŸ æ–°ä¸€å±€å¼€å§‹ï¼' }]); 
            setTurnRemaining(60);
            setPlayersInfo({});
            if (data.handCounts) setHandCounts(data.handCounts);
            
            backupHandRef.current = []; 
        };

        const onGameStateUpdate = (data) => {
            setCurrentTurnId(data.currentTurnId);
            
            if (data.turnRemaining !== undefined) setTurnRemaining(data.turnRemaining);

            if (data.lastPlayed && data.lastPlayed.length > 0) {
                if (data.lastPlayerName !== username) {
                    SoundManager.play('play'); 
                }
            }
            if (data.currentTurnId === mySocketId) {
                SoundManager.play('alert');
            }

            if (data.lastPlayerName === username) {
                 setIsSubmitting(false); 
            }

            if (data.lastPlayed) setLastPlayed(sortHand(data.lastPlayed, sortModeRef.current));
            setLastPlayerName(data.lastPlayerName || '');
            
            if (data.infoText) {
                if (data.infoText.includes('ä¸è¦')) {
                    SoundManager.play('pass');
                }
                
                if (data.infoText !== 'PASS') {
                    // [ä¿®æ”¹] å»¶é•¿åœç•™æ—¶é—´è‡³ 3.5sï¼Œé…åˆ CSS åŠ¨ç”»
                    setInfoMessage(data.infoText); 
                    setTimeout(() => setInfoMessage(''), 3500);
                    
                    setGameLogs(prev => [...prev, { time: new Date().toLocaleTimeString(), text: data.infoText }]);
                }
            }
            
            if (data.scores) setPlayerScores(data.scores);
            if (data.roundPoints) setRoundPoints(data.roundPoints);
            if (data.playersInfo) setPlayersInfo(data.playersInfo);
            if (data.handCounts) setHandCounts(data.handCounts);
            if (data.finishedRank) setFinishedRank(data.finishedRank);
            if (data.pendingPoints !== undefined) setPendingPoints(data.pendingPoints);
        };

        const onHandUpdate = (newHand) => {
            setMyHand(sortHand(newHand, sortModeRef.current)); 
            setSelectedCards([]);
            backupHandRef.current = [];
        };

        const onPlayError = (msg) => { 
            setIsSubmitting(false); 
            setInfoMessage(msg); 
            setTimeout(()=>setInfoMessage(''), 3500); 
            SoundManager.play('lose'); 
            
            if (backupHandRef.current.length > 0) {
                setMyHand(backupHandRef.current);
                backupHandRef.current = [];
                setInfoMessage("å‡ºç‰Œæ— æ•ˆï¼Œæ‰‹ç‰Œå·²å›æ»š");
            }
        }; 
        
        const onRoundOver = (data) => {
            setTimeout(() => {
                setRoundResult(data);
                if (data.grandScores) setPlayerScores(data.grandScores);
                const amIWinner = data.roundWinner === username;
                SoundManager.play(amIWinner ? 'win' : 'lose');
            }, 1000); 
        };

        const onGrandGameOver = (data) => {
             setTimeout(() => {
                setGrandResult(data);
                SoundManager.play('win'); 
             }, 1000);
        };

        socket.on('game_started', onGameStarted);
        socket.on('game_state_update', onGameStateUpdate);
        socket.on('hand_update', onHandUpdate);
        socket.on('play_error', onPlayError);
        socket.on('round_over', onRoundOver);
        socket.on('grand_game_over', onGrandGameOver);

        return () => {
            socket.off('game_started', onGameStarted);
            socket.off('game_state_update', onGameStateUpdate);
            socket.off('hand_update', onHandUpdate);
            socket.off('play_error', onPlayError);
            socket.off('round_over', onRoundOver);
            socket.off('grand_game_over', onGrandGameOver);
        };
    }, [socket, username, mySocketId]); 

    // --- äº¤äº’ Actions ---

    const toggleSort = () => setSortMode(prev => {
        if (prev === 'POINT') return 'ARRANGE';
        if (prev === 'ARRANGE') return 'ARRANGE_MERGED';
        return 'POINT';
    });
    
    const handleToggleAutoPlay = (roomId) => socket.emit('toggle_auto_play', { roomId });

    // [æ–°å¢] åˆ‡æ¢æ‰˜ç®¡æ¨¡å¼
    const handleSwitchAutoPlayMode = (roomId, mode) => socket.emit('switch_autoplay_mode', { roomId, mode });

    const handlePass = (roomId) => {
        if (isSubmitting) return; 
        setIsSubmitting(true);    

        socket.emit('pass_turn', { roomId });
        setSelectedCards([]);

        setTimeout(() => setIsSubmitting(false), 500); 
    };
    
    const updateSelection = (cardVal, forceSelect = null) => {
        setSelectedCards(prev => {
            const isSelected = prev.includes(cardVal);
            if (forceSelect !== null) return forceSelect && !isSelected ? [...prev, cardVal] : (!forceSelect && isSelected ? prev.filter(c => c !== cardVal) : prev);
            return isSelected ? prev.filter(c => c !== cardVal) : [...prev, cardVal];
        });
    };

    const handleClearSelection = () => setSelectedCards([]);

    const handleMouseDown = (cardVal) => {
        isDragging.current = true;
        dragStartMode.current = !selectedCards.includes(cardVal); 
        updateSelection(cardVal, dragStartMode.current);
        SoundManager.play('deal'); 
    };
    
    const handleMouseEnter = (cardVal) => {
        if (isDragging.current) {
            updateSelection(cardVal, dragStartMode.current);
        }
    };

    const handlePlayCards = (roomId) => {
        if (isSubmitting) return; 
        if (selectedCards.length === 0) return alert("è¯·å…ˆé€‰ç‰Œ");
        
        setIsSubmitting(true); 
        
        const cardsToPlay = [...selectedCards];
        
        backupHandRef.current = [...myHand];
        const nextHand = myHand.filter(c => !cardsToPlay.includes(c));
        setMyHand(nextHand);
        
        setLastPlayed(sortHand(cardsToPlay, sortModeRef.current));
        setLastPlayerName(username); 
        setSelectedCards([]); 
        
        SoundManager.play('play');
        socket.emit('play_cards', { roomId, cards: cardsToPlay });

        setTimeout(() => setIsSubmitting(false), 3000);
    };

    // [ä¿®æ”¹] æç¤ºæŒ‰é’®ç‚¹å‡»é€»è¾‘ï¼šå¾ªç¯åˆ‡æ¢å€™é€‰ç‰Œå‹
    const handleRequestHint = (roomId) => {
        if (availableHints.length > 0) {
            // å½“å‰é€‰ä¸­çš„æç¤ºç´¢å¼•
            const targetHint = availableHints[hintIndex]; 
            setSelectedCards(targetHint);
            
            // ç§»åŠ¨æŒ‡é’ˆåˆ°ä¸‹ä¸€ä¸ªï¼Œä¸ºä¸‹æ¬¡ç‚¹å‡»åšå‡†å¤‡
            setHintIndex((hintIndex + 1) % availableHints.length);
        } else {
            setInfoMessage('æ²¡æœ‰æ‰“å¾—è¿‡çš„ç‰Œ');
            setTimeout(()=>setInfoMessage(''), 1000);
            SoundManager.play('pass'); 
        }
    };

    return {
        // State
        myHand, selectedCards, lastPlayed,
        currentTurnId, lastPlayerName, infoMessage,
        roundResult, grandResult, playerScores, roundPoints,
        playersInfo, finishedRank, pendingPoints, gameLogs,
        sortMode, turnRemaining, handCounts,
        isSubmitting, 

        // Actions
        toggleSort, 
        handleToggleAutoPlay,
        handleSwitchAutoPlayMode, // [æ–°å¢] å¯¼å‡ºè¯¥æ–¹æ³•
        handlePass, 
        handlePlayCards,
        handleRequestHint,
        handleMouseDown, 
        handleMouseEnter,
        handleClearSelection
    };
};

================================================================================
FILE PATH: client\src\hooks\game\useGameData.js
================================================================================
import { useState, useEffect } from 'react';
import SoundManager from '../../utils/SoundManager.js';

export const useGameData = (socket, setIsLoading) => {
    const [gameState, setGameState] = useState('LOGIN'); 
    const [players, setPlayers] = useState([]);
    
    // ä»æœåŠ¡å™¨åŒæ­¥å›æ¥çš„é…ç½® (ç”¨äºå¤§å…å±•ç¤ºå’Œæ¸¸æˆå†…é€»è¾‘)
    const [syncedConfig, setSyncedConfig] = useState(null);

    // æŠ½ç­¾é˜¶æ®µç‰¹æœ‰æ•°æ®
    const [drawState, setDrawState] = useState(null); 
    // { totalCards: number, history: Array<{playerId, index, val, name}> }

    useEffect(() => {
        if (!socket) return;

        // --- ç›‘å¬å¤§å…ä¸å…¨å±€çŠ¶æ€ ---

        const onRoomInfo = (data) => {
            setSyncedConfig(data.config);
            setPlayers(data.players);
            
            // è‡ªåŠ¨æµè½¬çŠ¶æ€
            if (gameState !== 'GAME' && gameState !== 'DRAW_SEATS') {
                setGameState('LOBBY'); 
            }
            if (setIsLoading) setIsLoading(false);
        };

        const onEnterDrawPhase = (data) => {
            setDrawState({ totalCards: data.totalCards, history: [] });
            setGameState('DRAW_SEATS');
            SoundManager.play('deal');
        };

        const onSeatDrawUpdate = (data) => {
            setDrawState(prev => ({ ...prev, history: [...prev.history, data] }));
            SoundManager.play('deal'); 
        };

        const onSeatDrawFinished = (data) => {
            setPlayers(data.players); 
            // æ¸¸æˆå¼€å§‹äº‹ä»¶ä¼šç´§æ¥ç€è§¦å‘ï¼Œä¸ç”¨è¿™é‡Œåˆ‡çŠ¶æ€
        };

        const onGameStarted = (data) => {
            setGameState('GAME');
            SoundManager.play('deal');
        };
        
        const onErrorMsg = (msg) => {
            if (setIsLoading) setIsLoading(false);
            alert(msg);
        };
        
        const onKicked = (msg) => {
             alert(msg);
             window.location.reload();
        };

        socket.on('room_info', onRoomInfo);
        socket.on('enter_draw_phase', onEnterDrawPhase);
        socket.on('seat_draw_update', onSeatDrawUpdate);
        socket.on('seat_draw_finished', onSeatDrawFinished);
        socket.on('game_started', onGameStarted);
        socket.on('error_msg', onErrorMsg);
        socket.on('kicked', onKicked);

        return () => {
            socket.off('room_info', onRoomInfo);
            socket.off('enter_draw_phase', onEnterDrawPhase);
            socket.off('seat_draw_update', onSeatDrawUpdate);
            socket.off('seat_draw_finished', onSeatDrawFinished);
            socket.off('game_started', onGameStarted);
            socket.off('error_msg', onErrorMsg);
            socket.off('kicked', onKicked);
        };
    }, [socket, gameState, setIsLoading]);

    // --- å¤§å…æ“ä½œ Actions ---
    const handleStartGame = (roomId) => socket.emit('start_game', { roomId });
    // [ä¿®å¤] å¢åŠ  handleNextRound
    const handleNextRound = (roomId) => socket.emit('next_round', { roomId });
    
    const handleAddBot = (roomId) => socket.emit('add_bot', { roomId });
    const handleKickPlayer = (roomId, targetId) => socket.emit('kick_player', { roomId, targetId });
    const handleSwitchSeat = (roomId, index1, index2) => socket.emit('switch_seat', { roomId, index1, index2 });
    const handleDrawCard = (roomId, index) => socket.emit('draw_seat_card', { roomId, cardIndex: index });

    return {
        gameState, setGameState,
        players, setPlayers,
        syncedConfig, setSyncedConfig,
        drawState,
        
        // Actions
        handleStartGame, 
        handleNextRound, // å¯¼å‡º
        handleAddBot, 
        handleKickPlayer, 
        handleSwitchSeat, 
        handleDrawCard
    };
};

================================================================================
FILE PATH: client\src\hooks\game\useRoomLogic.js
================================================================================
import { useState, useEffect } from 'react';

export const useRoomLogic = (socket, isConnected) => {
    // åŸºç¡€è¡¨å•çŠ¶æ€
    // [ä¿®æ”¹] åˆå§‹å€¼ä¼˜å…ˆä» localStorage è¯»å–ï¼Œé˜²æ­¢åˆ·æ–°ä¸¢å¤±
    const [username, setUsername] = useState(localStorage.getItem('poker_username') || '');
    const [roomId, setRoomId] = useState(localStorage.getItem('poker_roomid') || '');
    
    const [isCreatorMode, setIsCreatorMode] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    
    // æˆ¿é—´é…ç½®è¡¨å•çŠ¶æ€ (é»˜è®¤å€¼)
    const [inputConfig, setInputConfig] = useState({ 
        deckCount: 2,          
        maxPlayers: 4,         
        targetScore: 1000,     
        turnTimeout: 60000,
        enableRankPenalty: true, 
        rankPenaltyScores: [30, 15],
        showCardCountMode: 1, 
        isTeamMode: false,
        shuffleStrategy: 'CLASSIC'
    });

    // [æ–°å¢] ç›‘å¬ username å˜åŒ–å¹¶è‡ªåŠ¨ä¿å­˜åˆ° localStorage
    useEffect(() => {
        if (username) {
            localStorage.setItem('poker_username', username);
        }
    }, [username]);

    // [æ–°å¢] ç›‘å¬ roomId å˜åŒ–å¹¶è‡ªåŠ¨ä¿å­˜åˆ° localStorage
    useEffect(() => {
        if (roomId) {
            localStorage.setItem('poker_roomid', roomId);
        }
    }, [roomId]);

    // åŠ¨ä½œï¼šåˆ›å»ºæˆ–åŠ å…¥æˆ¿é—´
    const handleRoomAction = () => {
        if (!isConnected) return; 
        if (!username || !roomId) return alert("è¯·è¾“å…¥æ˜µç§°å’Œæˆ¿é—´å·");
        
        setIsLoading(true);
        
        const event = isCreatorMode ? 'create_room' : 'join_room';
        const payload = isCreatorMode 
            ? { roomId, username, config: inputConfig } 
            : { roomId, username };
            
        socket.emit(event, payload);
    };

    // åŠ¨ä½œï¼šæ›´æ–°é…ç½® (æˆ¿ä¸»)
    const handleUpdateConfig = (roomId, newConfig) => {
        if (socket) socket.emit('update_room_config', { roomId, config: newConfig });
    };

    return {
        username, setUsername,
        roomId, setRoomId,
        isCreatorMode, setIsCreatorMode,
        isLoading, setIsLoading,
        inputConfig, setInputConfig, // æš´éœ²ç»™ LoginScreen ä½¿ç”¨
        
        // Actions
        handleRoomAction,
        handleUpdateConfig
    };
};

================================================================================
FILE PATH: client\src\hooks\useHandGesture.js
================================================================================
import { useEffect, useRef } from 'react';
import { getCardIndexFromTouch } from '../utils/cardLogic.js';

/**
 * ä¸“é—¨å¤„ç†æ‰‹ç‰ŒåŒºåŸŸçš„è§¦æ‘¸æ»‘åŠ¨ & é¼ æ ‡æ‹–æ‹½é€‰æ‹©é€»è¾‘
 * [ä¿®æ”¹] å¢åŠ äº† Mouse äº‹ä»¶æ”¯æŒï¼Œé€‚é… PC ç«¯æ»‘åŠ¨é€‰ç‰Œ
 */
export const useHandGesture = ({ 
    myHand, 
    selectedCards, 
    cardSpacing, 
    handleMouseDown, // è¿™é‡Œå¤ç”¨åŸæœ¬çš„ç‚¹å‡»/é€‰ç‰Œå¤„ç†å‡½æ•°
    amIAutoPlay 
}) => {
    const handContainerRef = useRef(null);
    const lastTouchedIndex = useRef(null);
    const isDragging = useRef(false);
    const dragStartMode = useRef(true); // true=é€‰ä¸­æ¨¡å¼, false=å–æ¶ˆæ¨¡å¼

    // ä½¿ç”¨ Ref ä¿å­˜æœ€æ–°çŠ¶æ€ï¼Œé¿å…åœ¨ EventListener ä¸­äº§ç”Ÿé—­åŒ…é™·é˜±
    const stateRef = useRef({ myHand, selectedCards, cardSpacing, handleMouseDown });

    useEffect(() => {
        stateRef.current = { myHand, selectedCards, cardSpacing, handleMouseDown };
    }, [myHand, selectedCards, cardSpacing, handleMouseDown]);

    // --- æ ¸å¿ƒæ‰‹åŠ¿é€»è¾‘ (å¤ç”¨äº Touch å’Œ Mouse) ---
    const handleGestureStart = (clientX, clientY) => {
        const container = handContainerRef.current;
        if (!container) return;
        
        const rect = container.getBoundingClientRect();
        const { myHand: currHand, selectedCards: currSelection, cardSpacing: currSpacing, handleMouseDown: currToggle } = stateRef.current;
        
        const index = getCardIndexFromTouch(clientX, rect.left, currSpacing, currHand.length);
        const cardVal = currHand[index];
        if (cardVal === undefined) return;

        const isSelected = currSelection.includes(cardVal);
        // åˆ¤å®šæœ‰æ•ˆé«˜åº¦ (æ¨¡æ‹Ÿ visually å¼¹èµ·çš„ç‰Œ)
        const CARD_HEIGHT = 70;    
        const POP_HEIGHT = 35;     
        const TOLERANCE = 10;      
        const validVisualHeight = isSelected ? CARD_HEIGHT + POP_HEIGHT + TOLERANCE : CARD_HEIGHT + TOLERANCE;
        const distanceFromBottom = rect.bottom - clientY;

        // è¶…å‡ºåˆ¤å®šåŒºåŸŸåˆ™å¿½ç•¥ (é˜²æ­¢ç‚¹åˆ°å¡ç‰Œä¸Šæ–¹ç©ºç™½å¤„è¯¯è§¦)
        if (distanceFromBottom > validVisualHeight || distanceFromBottom < -10) {
            isDragging.current = false;
            return;
        }

        isDragging.current = true;
        dragStartMode.current = !currSelection.includes(cardVal);
        lastTouchedIndex.current = index;
        
        // ç«‹å³è§¦å‘å½“å‰ç‚¹å‡»
        if (isSelected !== dragStartMode.current) {
            currToggle(cardVal); 
            if (navigator.vibrate) navigator.vibrate(5);
        }
    };

    const handleGestureMove = (clientX, clientY) => {
        if (!isDragging.current) return;
        
        const container = handContainerRef.current;
        if (!container) return;
        
        const rect = container.getBoundingClientRect();
        // å¢åŠ å‚ç›´å®¹é”™ï¼Œé˜²æ­¢é¼ æ ‡/æ‰‹æŒ‡ç¨å¾®åˆ’å‡ºåŒºåŸŸå°±æ–­è§¦
        if (clientY < rect.top - 50 || clientY > rect.bottom + 50) return;
        
        const { myHand: currHand, selectedCards: currSelection, cardSpacing: currSpacing, handleMouseDown: currToggle } = stateRef.current;
        const index = getCardIndexFromTouch(clientX, rect.left, currSpacing, currHand.length);
        
        // åªæœ‰æ»‘åˆ°äº†æ–°çš„ç‰Œä¸Šæ‰è§¦å‘
        if (lastTouchedIndex.current !== index) {
            lastTouchedIndex.current = index;
            const cardVal = currHand[index];
            if (cardVal !== undefined) {
                const isSelected = currSelection.includes(cardVal);
                // ä¿æŒå’Œèµ·å§‹åŠ¨ä½œä¸€è‡´ï¼ˆå¦‚æœæ˜¯â€œé€‰ä¸­â€æ¨¡å¼ï¼Œåˆ’è¿‡çš„éƒ½é€‰ä¸­ï¼›å¦‚æœæ˜¯â€œå–æ¶ˆâ€æ¨¡å¼ï¼Œåˆ’è¿‡çš„éƒ½å–æ¶ˆï¼‰
                if (isSelected !== dragStartMode.current) {
                    currToggle(cardVal); 
                    if (navigator.vibrate) navigator.vibrate(5);
                }
            }
        }
    };

    const handleGestureEnd = () => {
        isDragging.current = false;
        lastTouchedIndex.current = null;
    };

    // --- äº‹ä»¶ç»‘å®š ---
    useEffect(() => {
        const container = handContainerRef.current;
        if (!container || amIAutoPlay) return;
        
        // 1. Touch Events (ç§»åŠ¨ç«¯)
        const onTouchStart = (e) => {
            if (e.cancelable) e.preventDefault();
            if (e.touches.length > 0) {
                handleGestureStart(e.touches[0].clientX, e.touches[0].clientY);
            }
        };
        const onTouchMove = (e) => {
            if (e.cancelable) e.preventDefault();
            if (e.touches.length > 0) {
                handleGestureMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        };
        const onTouchEnd = () => handleGestureEnd();

        // 2. Mouse Events (PCç«¯é€‚é…)
        const onMouseDown = (e) => {
            if (e.button !== 0) return; // åªå“åº”å·¦é”®
            handleGestureStart(e.clientX, e.clientY);
        };
        const onMouseMove = (e) => {
            handleGestureMove(e.clientX, e.clientY);
        };
        const onMouseUp = () => handleGestureEnd();

        
        // ç»‘å®š Touch (ä½¿ç”¨ passive: false ä»¥ä¾¿èƒ½ preventDefault é˜»æ­¢æ»šåŠ¨)
        container.addEventListener('touchstart', onTouchStart, { passive: false });
        container.addEventListener('touchmove', onTouchMove, { passive: false });
        container.addEventListener('touchend', onTouchEnd);
        
        // ç»‘å®š Mouse
        container.addEventListener('mousedown', onMouseDown);
        // å°† Move å’Œ Up ç»‘å®šåˆ° windowï¼Œé˜²æ­¢é¼ æ ‡æ‹–å‡ºå®¹å™¨åå¤±æ•ˆ
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
        
        return () => {
            container.removeEventListener('touchstart', onTouchStart);
            container.removeEventListener('touchmove', onTouchMove);
            container.removeEventListener('touchend', onTouchEnd);

            container.removeEventListener('mousedown', onMouseDown);
            window.removeEventListener('mousemove', onMouseMove);
            window.removeEventListener('mouseup', onMouseUp);
        };
    }, [amIAutoPlay]);

    return handContainerRef;
};

================================================================================
FILE PATH: client\src\hooks\useSocketConnection.js
================================================================================
import { useState, useEffect } from 'react';
import io from 'socket.io-client';

const getSocketUrl = () => {
    const { hostname, port, protocol } = window.location;
    
    if (port === '' || port === '80' || port === '443') {
        return '/';
    }

    // æœ¬åœ°å¼€å‘å›é€€é€»è¾‘
    if (hostname === 'localhost' || hostname === '127.0.0.1') {
        if (port !== '3001') { return `${protocol}//${hostname}:3001`; }
    }
    if (hostname.startsWith('192.168.') || hostname.startsWith('10.')) {
        if (port !== '3001') { return `${protocol}//${hostname}:3001`; }
    }
    
    return '/';
};

const SOCKET_URL = getSocketUrl();

export const useSocketConnection = () => {
    const [socket, setSocket] = useState(null);
    const [isConnected, setIsConnected] = useState(false);
    const [mySocketId, setMySocketId] = useState(null);
    
    const [ping, setPing] = useState(0);

    useEffect(() => {
        console.log(`æ­£åœ¨è¿æ¥æœåŠ¡å™¨: ${SOCKET_URL}`);
        
        const newSocket = io(SOCKET_URL, { 
            reconnectionAttempts: 20,   
            reconnectionDelay: 2000,    
            timeout: 20000,
            autoConnect: true,
            // [æ–°å¢] æ˜¾å¼æŒ‡å®š transportï¼Œé˜²æ­¢ Nginx ä»£ç†æ—¶è½®è¯¢å¤±è´¥
            transports: ['websocket', 'polling'] 
        });
        
        setSocket(newSocket);

        let pingInterval;

        const onConnect = () => {
            console.log("Socket è¿æ¥æˆåŠŸ!");
            setIsConnected(true);
            
            // [æ ¸å¿ƒä¿®å¤] è¿æ¥æˆåŠŸæ—¶ï¼Œç«‹å³è·å– socket.id ä½œä¸ºæˆ‘çš„ ID
            // è¿™æ ·ä¸éœ€è¦æœåŠ¡å™¨ä¸“é—¨å‘é€ 'your_id' äº‹ä»¶ä¹Ÿèƒ½è¯†åˆ«èº«ä»½
            if (newSocket.id) {
                setMySocketId(newSocket.id);
            }
            
            pingInterval = setInterval(() => {
                const start = Date.now();
                // ç¡®ä¿ socket æœ‰æ•ˆ
                if (newSocket.connected) {
                    newSocket.emit('ping', () => {
                        const latency = Date.now() - start;
                        setPing(latency);
                    });
                }
            }, 2000); 
        };

        const onDisconnect = () => {
            console.log("Socket æ–­å¼€è¿æ¥");
            setIsConnected(false);
            if (pingInterval) clearInterval(pingInterval);
        };

        const onConnectError = (err) => {
            console.warn("è¿æ¥é”™è¯¯ (è¯¦ç»†):", err.message);
        };

        // ä¿ç•™è¿™ä¸ªç›‘å¬ä½œä¸ºå…¼å®¹ï¼Œä½†ä¸»è¦ä¾èµ– onConnect ä¸­çš„èµ‹å€¼
        const onYourId = (id) => {
            setMySocketId(id);
        };

        newSocket.on('connect', onConnect);
        newSocket.on('disconnect', onDisconnect);
        newSocket.on('connect_error', onConnectError);
        newSocket.on('your_id', onYourId);

        return () => {
            if (pingInterval) clearInterval(pingInterval);
            newSocket.off('connect', onConnect);
            newSocket.off('disconnect', onDisconnect);
            newSocket.off('connect_error', onConnectError);
            newSocket.off('your_id', onYourId);
            newSocket.close(); // [å»ºè®®] ç»„ä»¶å¸è½½æ—¶å…³é—­è¿æ¥ï¼Œé˜²æ­¢å¤šé‡è¿æ¥
        };
    }, []);

    return { 
        socket, 
        isConnected, 
        mySocketId,
        ping 
    };
};

================================================================================
FILE PATH: client\src\index.css
================================================================================
/* =========================================
   å…¨å±€åŸºç¡€æ ·å¼ (Base & Reset)
   ========================================= */
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  /* é…è‰²æ–¹æ¡ˆ */
  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  /* å­—ä½“æ¸²æŸ“ä¼˜åŒ– */
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  
  /* [ä¼˜åŒ–] ç¦æ­¢ç§»åŠ¨ç«¯ç‚¹å‡»é«˜äº® */
  -webkit-tap-highlight-color: transparent;
}

/* [å…³é”®ä¿®å¤ 0] å…¨å±€ç›’æ¨¡å‹é‡ç½® */
*, *::before, *::after {
  box-sizing: border-box;
}

/* é“¾æ¥æ ·å¼ */
a { font-weight: 500; color: #646cff; text-decoration: inherit; }
a:hover { color: #535bf2; }

/* Body åŸºç¡€è®¾ç½® */
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  /* [å…³é”®ä¿®å¤] å½»åº•ç¦æ­¢æµè§ˆå™¨çš„ä¸‹æ‹‰åˆ·æ–°å’Œå›å¼¹æ•ˆæœ */
  overscroll-behavior: none;
  overflow: hidden; /* é”æ­» Body æ»šåŠ¨ï¼Œåªå…è®¸å†…éƒ¨å…ƒç´ æ»šåŠ¨ */
  position: fixed; /* å¼ºåˆ¶å›ºå®šï¼Œé˜²æ­¢ iOS Safari åœ°å€æ å› ä¸ºé¡µé¢æ»šåŠ¨è€Œå¿½éšå¿½ç° */
}

body {
  display: flex;
  place-items: center;
  min-width: 320px;
}

/* [ä¼˜åŒ–] é’ˆå¯¹æ ¹å®¹å™¨ä¼˜åŒ–è§¦æ‘¸ä½“éªŒ */
#root, .App {
  width: 100%;
  height: 100%;
  overflow-x: hidden;
  /* å…è®¸å†…éƒ¨æ­£å¸¸çš„ç‚¹å‡»å’Œæ»šåŠ¨ */
  touch-action: manipulation;
}

h1 { font-size: 3.2em; line-height: 1.1; }

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover { border-color: #646cff; }
button:focus, button:focus-visible { outline: 4px auto -webkit-focus-ring-color; }

@media (prefers-color-scheme: light) {
  :root { color: #213547; background-color: #ffffff; }
  a:hover { color: #747bff; }
  button { background-color: #f9f9f9; }
}


/* =========================================
   ç§»åŠ¨ç«¯é€‚é…æ ¸å¿ƒåŒº (Mobile Overrides)
   ========================================= */

/* --- 1. æ¨ªå±å¼•å¯¼é®ç½© --- */
.landscape-hint {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(30, 39, 46, 0.95);
    z-index: 9999; 
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
    text-align: center;
    backdrop-filter: blur(10px);
    touch-action: none; 
}

.phone-rotate-icon {
    width: 60px;
    height: 100px; 
    border: 3px solid white; border-radius: 10px; margin-bottom: 20px;
    animation: rotate-phone 2s infinite ease-in-out;
}
@keyframes rotate-phone {
    0% { transform: rotate(0deg); }
    50% { transform: rotate(90deg); }
    100% { transform: rotate(0deg); }
}


/* --- 2. ç§»åŠ¨ç«¯ç«–å±å¸ƒå±€ä¼˜åŒ– (Portrait Core) --- */

@media (max-width: 768px) {
  
  ::-webkit-scrollbar { width: 0px; background: transparent; }

  /* é€šç”¨åˆ—å®¹å™¨ */
  .mobile-layout-column {
    display: flex !important;
    flex-direction: column !important;
    width: 95% !important;     
    max-width: none !important; 
    height: auto !important;
    
    /* ä½¿ç”¨ dvh é€‚é…åŠ¨æ€åœ°å€æ  */
    min-height: 85vh !important;
    min-height: 85dvh !important; 
    
    max-height: 95dvh !important; 
    margin: 10px auto !important; 
    overflow: hidden !important; 
    padding: 0 !important;
  }

  /* --- 2.1 ç™»å½•é¡µ (Login) --- */
  .mobile-login-left {
    flex: 0 0 auto !important;
    width: 100% !important;
    padding: 30px 20px !important; 
    border-radius: 0 0 24px 24px !important; 
    background-color: #242424; 
    min-height: auto !important;
    align-items: center !important; 
    text-align: center !important;
    padding-top: max(30px, env(safe-area-inset-top)) !important;
  }
  
  .mobile-login-left h1 { font-size: 2.5em !important; margin-bottom: 10px !important; }
  .mobile-login-left .logoCircle { width: 70px !important; height: 70px !important; margin-bottom: 15px !important; }
  .mobile-login-left .logoText { font-size: 22px !important; }

  .mobile-login-right {
    flex: 1 !important;
    width: 100% !important;
    padding: 30px 20px !important;
    background: white;
    border-radius: 24px 24px 0 0 !important; 
    margin-top: -20px; 
    position: relative;
    z-index: 2;
    overflow-y: auto !important;
    display: flex !important;
    flex-direction: column !important;
    padding-bottom: max(30px, env(safe-area-inset-bottom)) !important;
  }
  
  .hide-on-mobile { display: none !important; }


  /* --- 2.2 å¤§å…é¡µ (Lobby) --- */
  .lobbyCard.mobile-layout-column {
      height: 92dvh !important;
      position: relative;
      background: white !important;
  }

  .mobile-lobby-content {
      display: flex !important;
      flex-direction: column !important;
      height: 100% !important;
      width: 100%;
      overflow: hidden !important;
  }
  
  .lobbyHeader { 
      flex: 0 0 auto;
      padding: 15px !important;
      padding-top: calc(15px + env(safe-area-inset-top)) !important; 
      background: #f8f9fa; 
  }
  .lobbyHeader h2 { font-size: 20px !important; margin: 0 !important; }

  .mobile-lobby-grid {
      flex: 1 !important; 
      overflow-y: auto !important;
      padding: 10px !important;
      display: grid !important;
      grid-template-columns: repeat(2, 1fr) !important; 
      align-content: start !important;
      gap: 10px !important;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 10px !important;
  }
  
  .mobile-lobby-grid > div { padding: 15px !important; gap: 10px !important; }
  .mobile-lobby-grid .avatar-large { width: 50px !important; height: 50px !important; font-size: 20px !important; }

  .mobile-lobby-footer {
      flex: 0 0 auto !important;
      padding: 12px !important;
      background: white;
      border-top: 1px solid #eee;
      z-index: 10;
      padding-bottom: calc(12px + env(safe-area-inset-bottom)) !important;
      position: static !important; 
      margin-top: auto !important;
      display: flex !important;
      justify-content: space-around !important;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
  }
  
  .mobile-lobby-footer button {
      width: 45% !important;
      padding: 0 !important;
      height: 44px !important; 
      font-size: 14px !important;
      margin: 0 !important;
  }
}


/* --- 3. ç§»åŠ¨ç«¯æ¨ªå±é€‚é… (Landscape Overrides) --- */
@media (max-width: 896px) and (orientation: landscape) {
    
    /* [ç»ˆæä¿®å¤ 1] å¼ºåˆ¶é“ºæ»¡å±å¹•ï¼Œæ— è§†ä»»ä½• marginï¼Œç›´æ¥è¦†ç›– */
    /* [å…³é”® Fix] å¿…é¡»å¼ºåˆ¶é‡ç½® min-height ä¸º 0ï¼Œå¦åˆ™ JS é‡Œçš„ 600px ä¼šæ’‘ç ´å±å¹• */
    .mobile-layout-column {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        min-height: 0 !important; /* æ ¸å¿ƒä¿®å¤ï¼šè§£å†³åº•éƒ¨çœ‹ä¸è§çš„é—®é¢˜ */
        max-height: none !important;
        margin: 0 !important;
        padding: 0 !important;
        flex-direction: row !important;
        z-index: 10;
    }

    /* --- [å…³é”®ä¼˜åŒ–] ç™»å½•é¡µ (Login) --- */
    
    .mobile-login-left {
        display: none !important;
    }

    .mobile-login-right {
        width: 100% !important;
        height: 100% !important;
        flex: 1 !important;
        border-radius: 0 !important;
        margin: 0 !important;
        
        /* é¡¶éƒ¨å¯¹é½ï¼Œé˜²æ­¢è¢«åˆ‡ */
        justify-content: flex-start !important;
        padding-top: max(10px, env(safe-area-inset-top)) !important;
        
        /* [ä¿®å¤] åº•éƒ¨å¢åŠ å¤§å¹…åº¦ Paddingï¼Œç¡®ä¿æ»šåŠ¨åˆ°åº•éƒ¨æ—¶ï¼Œæœ€ä¸‹é¢çš„æŒ‰é’®èƒ½å®Œæ•´éœ²å‡º */
        padding-bottom: max(40px, env(safe-area-inset-bottom)) !important;
        padding-left: max(40px, env(safe-area-inset-left)) !important;
        padding-right: max(40px, env(safe-area-inset-right)) !important; 
        
        overflow-y: auto !important;
        display: flex !important;
        flex-direction: column !important;
    }
    
    .mobile-login-right .formContent {
        max-width: 600px;
        margin: 0 auto;
        width: 100%;
        /* ç¡®ä¿åº•éƒ¨æŒ‰é’®èƒ½å®Œæ•´éœ²å‡º */
        padding-bottom: 20px !important;
    }


    /* --- [å…³é”®ä¼˜åŒ–] å¤§å…é¡µ (Lobby) --- */

    /* [å…³é”®ä¿®å¤ 2] å½»åº•é‡æ„ Lobby å¸ƒå±€ */
    .lobbyCard.mobile-layout-column {
        background: transparent !important;
        border: none !important;
    }
    
    .mobile-lobby-content {
        background: white !important;
        border-radius: 0 !important; 
        height: 100% !important;
        width: 100% !important;
        border: none !important;
        box-shadow: none !important;
        /* ä½¿ç”¨ Flex Column å¸ƒå±€ */
        display: flex !important;
        flex-direction: column !important;
    }

    .lobbyHeader {
        flex: 0 0 auto !important; /* å¤´éƒ¨å›ºå®šé«˜åº¦ï¼Œä¸è®¸ä¼¸ç¼© */
        padding: 8px 20px !important; 
        padding-top: max(10px, env(safe-area-inset-top)) !important;
        background: #f8f9fa;
        z-index: 20;
        border-bottom: 1px solid #eee;
    }
    /* ç¼©å°æ¨ªå±ä¸‹çš„æ ‡é¢˜å­—å· */
    .lobbyHeader h2 { font-size: 18px !important; }

    /* ç©å®¶åˆ—è¡¨ Grid */
    .mobile-lobby-grid {
        /* [æ ¸å¿ƒä¿®å¤] ä¸­é—´åŒºåŸŸè‡ªé€‚åº”ï¼Œå…è®¸æ”¶ç¼©ï¼Œå…è®¸æ»šåŠ¨ */
        flex: 1 1 0% !important; /* å…³é”®ï¼è®¾ä¸º 0% å¼ºåˆ¶è®©å®ƒå»é€‚åº”å‰©ä½™ç©ºé—´ï¼Œè€Œä¸æ˜¯è¢«å†…å®¹æ’‘å¤§ */
        min-height: 0 !important; 
        
        overflow-y: auto !important;
        display: grid !important;
        grid-template-columns: repeat(4, 1fr) !important; 
        gap: 10px !important;
        padding: 10px 20px !important;
        padding-left: max(30px, env(safe-area-inset-left)) !important;
        padding-right: max(30px, env(safe-area-inset-right)) !important;
        align-content: start !important;
    }
    
    @media (max-width: 600px) {
        .mobile-lobby-grid {
            grid-template-columns: repeat(3, 1fr) !important;
        }
    }

    .mobile-lobby-grid > div {
        padding: 6px !important;
        gap: 5px !important;
    }
    
    .mobile-lobby-grid .avatar-large {
        width: 36px !important;
        height: 36px !important;
        font-size: 14px !important;
    }

    /* Footer ä¼˜åŒ– */
    .mobile-lobby-footer {
        flex: 0 0 auto !important; /* åº•éƒ¨å›ºå®šé«˜åº¦ï¼Œä¸è®¸è¢«æŒ¤å‹ */
        position: relative !important;
        z-index: 100 !important;
        
        background: #f8f9fa !important;
        border-top: 1px solid #ddd !important;
        
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        /* [æ ¸å¿ƒä¿®å¤] ç»™åº•éƒ¨ç•™å‡ºè¶³å¤Ÿçš„å®‰å…¨è·ç¦»ï¼Œé˜²æ­¢è¢«æ‰‹åŠ¿æ¡é®æŒ¡æŒ‰ä¸åˆ° */
        padding-top: 8px !important;
        padding-bottom: max(15px, env(safe-area-inset-bottom)) !important;
        padding-left: max(20px, env(safe-area-inset-left)) !important;
        padding-right: max(20px, env(safe-area-inset-right)) !important;
        margin-top: 0 !important; /* æ¸…é™¤ marginTop auto */
    }
    
    .mobile-lobby-footer button {
        height: 40px !important; /* ç¨å¾®è°ƒçŸ®æŒ‰é’® */
        font-size: 14px !important;
    }
}

================================================================================
FILE PATH: client\src\main.jsx
================================================================================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'
// [æ–°å¢] å¼•å…¥ Provider
import { GameProvider } from './context/GameContext.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    {/* [ä¿®æ”¹] ç”¨ GameProvider åŒ…è£¹ App */}
    <GameProvider>
      <App />
    </GameProvider>
  </StrictMode>,
)

================================================================================
FILE PATH: client\src\screens\DrawSeatScreen.jsx
================================================================================
import React, { useState, useEffect } from 'react';
import { Card } from '../components/BaseUI.jsx'; 
import { Shuffle } from 'lucide-react';
import { useGame } from '../context/GameContext.jsx';
import css from './DrawSeatScreen.module.css'; // æ–° CSS

export const DrawSeatScreen = () => {
    const { 
        players, mySocketId, 
        drawState, // { totalCards, history: [...] }
        handleDrawCard,
        roomConfig
    } = useGame();

    const [flippedCards, setFlippedCards] = useState({}); 
    const [infoText, setInfoText] = useState("è¯·ç‚¹å‡»ä¸€å¼ å¡èƒŒè¿›è¡ŒæŠ½ç­¾");

    useEffect(() => {
        if (drawState && drawState.history) {
            const newFlipped = {};
            drawState.history.forEach(item => {
                newFlipped[item.index] = { val: item.val, playerName: item.name };
            });
            setFlippedCards(newFlipped);

            const myLog = drawState.history.find(h => h.playerId === mySocketId);
            if (myLog) {
                setInfoText(`ç­‰å¾…å…¶ä»–ç©å®¶å®ŒæˆæŠ½ç­¾...`);
            }
        }
    }, [drawState, mySocketId]);

    const onCardClick = (index) => {
        if (flippedCards[index]) return; 
        
        const myName = players.find(p=>p.id===mySocketId)?.name;
        if (Object.values(flippedCards).some(c => c.playerName === myName)) {
             return; 
        }
        
        handleDrawCard(index);
    };

    const isTeamMode = roomConfig && roomConfig.isTeamMode && (players.length % 2 === 0);

    return (
        <div className={css.drawTable}>
            <div className={css.contentContainer}>
                
                <div className={css.infoBox}>
                    <h2 className={css.title}>
                        <Shuffle size={24} color="#f1c40f"/> èµ›å‰æŠ½å¡å®šåº§
                    </h2>
                    
                    <div className={css.desc}>
                        {isTeamMode ? (
                            <>
                                ç‚¹æ•°<span style={{color:'#e74c3c', fontWeight:'bold'}}>å¤§</span>çš„åŠæ•°ç©å®¶ â†’ <span style={{color:'#e74c3c'}}>çº¢é˜Ÿ</span> (1, 3, 5å·ä½)<br/>
                                ç‚¹æ•°<span style={{color:'#3498db', fontWeight:'bold'}}>å°</span>çš„åŠæ•°ç©å®¶ â†’ <span style={{color:'#3498db'}}>è“é˜Ÿ</span> (2, 4, 6å·ä½)
                            </>
                        ) : (
                            <>
                                æŠ½ç­¾å†³å®šåº§ä½é¡ºåº<br/>
                                <span style={{color:'#f1c40f'}}>ç‚¹æ•°è¶Šå¤§ï¼Œåº§ä½è¶Šé å‰ (1å·ä½èµ·)</span>
                            </>
                        )}
                        <br/>
                        <span style={{fontSize: 12, opacity: 0.8, marginTop: 5, display:'block'}}>(2 &gt; A &gt; K &gt; ... &gt; 3)</span>
                    </div>
                </div>

                <div className={css.cardGrid}>
                    {Array.from({ length: players.length }).map((_, index) => {
                        const flipData = flippedCards[index];
                        const isFlipped = !!flipData;
                        const isMine = isFlipped && flipData.playerName === players.find(p=>p.id===mySocketId)?.name;

                        return (
                            <div key={index} className={css.cardSlot}>
                                {isFlipped && (
                                    <div className={`${css.nameTag} ${isMine ? css.nameTagMine : ''}`}>
                                        {flipData.playerName}
                                    </div>
                                )}

                                {isFlipped ? (
                                    // ç¿»å¼€åçš„ç‰Œ
                                    <div className={`${css.flippedWrapper} ${isMine ? css.flippedWrapperMine : ''}`}>
                                        <Card 
                                            cardVal={flipData.val} 
                                            index={0} 
                                            isSelected={false} 
                                            onClick={()=>{}} 
                                            onMouseEnter={()=>{}} 
                                            spacing={0}
                                        />
                                    </div>
                                ) : (
                                    // å¡èƒŒ
                                    <div className={css.cardBack} onClick={() => onCardClick(index)}>
                                        <div className={css.cardBackInner}>
                                            <span className={css.cardBackText}>?</span>
                                        </div>
                                    </div>
                                )}
                            </div>
                        );
                    })}
                </div>

                <div className={css.statusText}>
                    {infoText}
                </div>

            </div>
        </div>
    );
};

================================================================================
FILE PATH: client\src\screens\DrawSeatScreen.module.css
================================================================================
/* æŠ½ç­¾é¡µä¸»å®¹å™¨ (å¤ç”¨æ¸¸æˆé¡µèƒŒæ™¯é£æ ¼) */
.drawTable {
    height: 100dvh;
    width: 100vw;
    background-color: #1e3c29;
    background-image: radial-gradient(circle at center, #2d7a54 0%, #173b25 100%);
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    user-select: none;
    
    /* é€‚é…å®‰å…¨åŒºåŸŸ */
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
}

.contentContainer {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
}

/* é¡¶éƒ¨æç¤ºæ¡† */
.infoBox {
    background: rgba(0, 0, 0, 0.6);
    padding: 20px 30px;
    border-radius: 20px;
    margin-bottom: 40px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    text-align: center;
    color: white;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    animation: fadeInDown 0.5s ease-out;
}

.title {
    margin: 0 0 10px 0;
    font-size: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
}

.desc {
    font-size: 14px;
    color: #bdc3c7;
    max-width: 400px;
    line-height: 1.6;
}

/* å¡ç‰Œç½‘æ ¼ */
.cardGrid {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    justify-content: center;
    max-width: 800px;
    padding: 10px;
}

/* å•ä¸ªå¡ä½å®¹å™¨ */
.cardSlot {
    position: relative;
    width: 80px;
    height: 110px;
    display: flex;
    flex-direction: column;
    align-items: center;
    perspective: 1000px; /* ä¸ºç¿»ç‰ŒåŠ¨ç”»åšå‡†å¤‡ */
}

/* åå­—æ ‡ç­¾ */
.nameTag {
    position: absolute;
    top: -28px;
    width: 120px;
    text-align: center;
    font-size: 12px;
    color: white;
    font-weight: bold;
    text-shadow: 0 1px 2px black;
    white-space: nowrap;
    z-index: 10;
    animation: popIn 0.3s ease-back;
}

.nameTagMine {
    color: #f1c40f;
}

/* ç¿»å¼€çš„ç‰ŒåŒ…è£…å™¨ */
.flippedWrapper {
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    pointer-events: auto;
    border-radius: 6px;
    transform-origin: center center;
}

.flippedWrapperMine {
    transform: scale(1.1);
    box-shadow: 0 0 20px rgba(241, 196, 15, 0.6);
}

/* å¡èƒŒ (æœªç¿»å¼€) */
.cardBack {
    width: 55px;
    height: 70px;
    background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
    border-radius: 6px;
    border: 2px solid #bdc3c7;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    transition: transform 0.2s;
    pointer-events: auto;
}

.cardBack:active {
    transform: scale(0.95);
}

.cardBackInner {
    width: 40px;
    height: 55px;
    border: 1px dashed rgba(255, 255, 255, 0.3);
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.cardBackText {
    font-size: 20px;
    opacity: 0.5;
    color: white;
}

/* åº•éƒ¨çŠ¶æ€æ–‡æœ¬ */
.statusText {
    margin-top: 40px;
    color: #f1c40f;
    font-size: 18px;
    font-weight: bold;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    height: 30px;
    animation: pulse 2s infinite;
}

@keyframes fadeInDown {
    from { opacity: 0; transform: translateY(-20px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes popIn {
    from { opacity: 0; transform: scale(0.5); }
    to { opacity: 1; transform: scale(1); }
}

@keyframes pulse {
    0% { opacity: 0.8; }
    50% { opacity: 1; }
    100% { opacity: 0.8; }
}

================================================================================
FILE PATH: client\src\screens\GameScreen.jsx
================================================================================
import React from 'react';
import css from './GameScreen.module.css'; 
import { GameLogPanel } from '../components/BaseUI.jsx';
import { useGame } from '../context/GameContext.jsx';
import { RefreshCw, AlertCircle, Eye } from 'lucide-react';

import { GameHeader } from '../components/game/GameHeader.jsx';
import { TableCenterArea } from '../components/game/TableCenterArea.jsx';
import { SettlementModal } from '../components/game/SettlementModal.jsx';
import { PlayerLayout } from '../components/game/PlayerLayout.jsx';
import { HandArea } from '../components/game/HandArea.jsx';
import { GameActionBar } from '../components/game/GameActionBar.jsx';

export const GameScreen = () => {
    // [ä¿®æ”¹] è§£æ„ isSpectator
    const { players, mySocketId, gameLogs, isSpectator } = useGame();

    const myPlayerExists = players.some(p => p.id === mySocketId);
    
    // [ä¿®æ”¹] å¦‚æœä¸æ˜¯è§‚ä¼—ä¸”æ²¡æœ‰åŒæ­¥åˆ°ç©å®¶æ•°æ®ï¼Œæ‰æ˜¾ç¤ºåŒæ­¥ç•Œé¢
    if (!myPlayerExists && !isSpectator && players.length > 0) {
        return (
            <div className={css.gameTable} style={{
                color:'white', 
                display:'flex', 
                flexDirection: 'column', 
                justifyContent:'center', 
                alignItems:'center',
                gap: 20,
                textAlign: 'center'
            }}>
                <AlertCircle size={40} color="#f1c40f" />
                
                <div>
                    <div style={{fontSize: 20, fontWeight: 'bold', marginBottom: 5}}>æ­£åœ¨åŒæ­¥æ•°æ®...</div>
                    <div style={{fontSize: 14, opacity: 0.7}}>å¦‚æœæ˜¯ä»åå°åˆ‡å›ï¼Œå¯èƒ½éœ€è¦é‡æ–°è¿æ¥</div>
                </div>

                <button 
                    onClick={() => window.location.reload()}
                    style={{
                        background: 'rgba(255,255,255,0.2)',
                        border: '1px solid rgba(255,255,255,0.5)',
                        color: 'white',
                        padding: '10px 25px',
                        borderRadius: 30,
                        display: 'flex',
                        alignItems: 'center',
                        gap: 10,
                        cursor: 'pointer',
                        fontSize: 16,
                        fontWeight: 'bold',
                        marginTop: 10
                    }}
                >
                    <RefreshCw size={18} /> åˆ·æ–°é¡µé¢
                </button>
            </div>
        );
    }

    return (
        <div className={css.gameTable}>
            {/* [æ–°å¢] è§‚ä¼—æ¨¡å¼æ°´å° */}
            {isSpectator && (
                <div style={{
                    position: 'absolute', top: 60, right: 20, 
                    background: 'rgba(0,0,0,0.5)', padding: '5px 15px', 
                    borderRadius: 20, color: '#f1c40f', fontWeight: 'bold',
                    display: 'flex', alignItems: 'center', gap: 6, zIndex: 50,
                    pointerEvents: 'none'
                }}>
                    <Eye size={16}/> è§‚æˆ˜æ¨¡å¼
                </div>
            )}

            <div className={css.gameSafeArea}>
                <GameLogPanel logs={gameLogs} />
                <GameHeader />
                <TableCenterArea />
                <SettlementModal />
                <PlayerLayout />
                <HandArea />
                <GameActionBar />
            </div>
        </div>
    );
};

================================================================================
FILE PATH: client\src\screens\GameScreen.module.css
================================================================================
/* æ¸¸æˆä¸»å®¹å™¨ */
.gameTable {
    height: 100dvh; /* é€‚é…ç§»åŠ¨ç«¯åŠ¨æ€åœ°å€æ  */
    width: 100vw;
    background-color: #1e3c29;
    background-image: radial-gradient(circle at center, #2d7a54 0%, #173b25 100%);
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    user-select: none;
    box-sizing: border-box;

    /* é€‚é…åˆ˜æµ·å±å®‰å…¨åŒºåŸŸ */
    padding-top: env(safe-area-inset-top);
    padding-left: max(15px, env(safe-area-inset-left));
    padding-right: max(15px, env(safe-area-inset-right));
    padding-bottom: env(safe-area-inset-bottom);
}

/* å®‰å…¨åŒºåŸŸåŒ…è£…å±‚ (ç”¨äºå®šä½ UI å…ƒç´ ) */
.gameSafeArea {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    box-sizing: border-box;

    /* åŒæ ·éœ€è¦é€‚é…å®‰å…¨åŒºåŸŸ */
    padding-top: env(safe-area-inset-top);
    padding-left: max(15px, env(safe-area-inset-left));
    padding-right: max(15px, env(safe-area-inset-right));
    padding-bottom: env(safe-area-inset-bottom);

    display: flex;
    flex-direction: column;
    pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€åˆ°åº•å±‚ï¼Œå­å…ƒç´ éœ€å¼€å¯ pointer-events: auto */
}

/* --- å…¨å±€æ ·å¼ (Global Overrides) --- */
/* åŸæœ¬é€šè¿‡ JS æ³¨å…¥çš„æ ·å¼ï¼Œç°åœ¨ç§»åˆ°è¿™é‡Œç»Ÿä¸€ç®¡ç† */

/* æœºå™¨äººå¾½ç«  */
:global(.statusBadgeBot) {
    background: #34495e;
    color: white;
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 10px;
    display: flex;
    align-items: center;
    gap: 2px;
    border: 1px solid rgba(255, 255, 255, 0.3);
}

/* æ‰˜ç®¡å¾½ç«  (å¸¦å‘¼å¸åŠ¨ç”») */
:global(.statusBadgeAuto) {
    background: #e67e22;
    color: white;
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 10px;
    display: flex;
    align-items: center;
    gap: 2px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

/* æ—‹è½¬åŠ¨ç”» (ç”¨äº Timer) */
:global(.spin) {
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* [æ–°å¢] å€’è®¡æ—¶ç´§æ€¥é—ªçƒåŠ¨ç”» */
:global(.critical-pulse) {
    animation: criticalPulse 0.5s infinite;
}

@keyframes criticalPulse {
    0% { transform: scale(1); opacity: 1; filter: drop-shadow(0 0 0px #e74c3c); }
    50% { transform: scale(1.1); opacity: 0.9; filter: drop-shadow(0 0 10px #e74c3c); }
    100% { transform: scale(1); opacity: 1; filter: drop-shadow(0 0 0px #e74c3c); }
}

================================================================================
FILE PATH: client\src\screens\LobbyScreen.jsx
================================================================================
import React, { useState } from 'react';
import { Target, Layers, User, Play, Clock, Bot, Shield, ArrowUp, ArrowDown, Settings, X, Sparkles, Award, ChevronLeft } from 'lucide-react';
import css from './LobbyScreen.module.css'; 
import { useGame } from '../context/GameContext.jsx';
import { RoomSettingsForm } from '../components/game/RoomSettingsForm.jsx';

export const LobbyScreen = () => {
    const { 
        roomId, roomConfig, players, mySocketId, 
        handleStartGame, 
        handleAddBot,
        handleSwitchSeat,
        handleUpdateConfig,
        handleKickPlayer,
        handleLeaveRoom 
    } = useGame();
    
    // ç»Ÿä¸€è·å–å½“å‰ç©å®¶æ˜¯å¦ä¸ºæˆ¿ä¸»
    const amIHost = players.find(p => p.id === mySocketId)?.isHost || false;
    
    const isTeamMode = roomConfig.isTeamMode && roomConfig.maxPlayers % 2 === 0;
    const [showSettings, setShowSettings] = useState(false);
    
    const handleConfigChange = (key, value) => {
        const newConfig = { ...roomConfig, [key]: value };
        handleUpdateConfig(newConfig);
    };

    const renderSettingsModal = () => (
        <div className={css.modalOverlay}>
            <div className={css.modalContent} style={{textAlign:'left'}}>
                <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom: 20, borderBottom:'1px solid #eee', paddingBottom:10, width:'100%'}}>
                    <div style={{display:'flex', alignItems:'center', gap:8, fontSize:18, fontWeight:'bold', color:'#2c3e50'}}>
                        <Settings size={20}/> æˆ¿é—´è§„åˆ™è®¾ç½®
                    </div>
                    <button onClick={()=>setShowSettings(false)} style={{background:'none', border:'none', cursor:'pointer', padding:5}}>
                        <X size={20} color="#999"/>
                    </button>
                </div>

                <div style={{maxHeight: '60vh', overflowY:'auto', paddingRight: 5, width:'100%'}}>
                    <RoomSettingsForm 
                        config={roomConfig} 
                        onChange={handleConfigChange} 
                        readOnly={!amIHost} 
                    />
                </div>

                <div style={{marginTop: 20, textAlign:'center', width:'100%'}}>
                    <button className={css.primaryButton} style={{height: 50, fontSize: 16, marginTop:0}} onClick={() => setShowSettings(false)}>
                        å®Œæˆè®¾ç½®
                    </button>
                </div>
            </div>
        </div>
    );

    return (
    <div className={css.lobbyContainer}>
      {showSettings && renderSettingsModal()}

      <div className={`${css.lobbyCard} mobile-layout-column`}>
          
          <div className="mobile-lobby-content" style={{display:'flex', flexDirection:'column', height:'100%', width: '100%', overflow:'hidden', borderRadius: 20}}>
            
            <div className={css.lobbyHeader}>
                <div style={{display:'flex', alignItems:'center', gap: 10, flexWrap: 'wrap'}}>
                    
                    {/* [ä¿®æ”¹] é€€å‡ºæŒ‰é’®ï¼šæ”¹ä¸ºå‘å·¦çš„è¿”å›ç®­å¤´ï¼Œæ›´åŠ ç®€æ´ */}
                    <button 
                        onClick={handleLeaveRoom}
                        style={{
                            background: 'transparent',
                            border: '1px solid #e1e4e8', 
                            borderRadius: '8px', 
                            padding: '6px 12px 6px 8px', // å·¦ä¾§ç¨å¾®å°‘ä¸€ç‚¹paddingå› ä¸ºæœ‰ç®­å¤´
                            display: 'flex', alignItems: 'center', justifyContent: 'center',
                            gap: 2,
                            cursor: 'pointer', 
                            color: '#7f8c8d', 
                            fontWeight: 'bold',
                            fontSize: 14,
                            transition: 'all 0.2s'
                        }}
                        title="è¿”å›é¦–é¡µ"
                    >
                        <ChevronLeft size={20} /> è¿”å›
                    </button>

                    <h2 style={{margin:0, fontSize: 24}}>æˆ¿é—´: <span style={{fontFamily:'monospace', color:'#27ae60'}}>{roomId}</span></h2>
                    
                    {roomConfig.shuffleStrategy === 'NO_SHUFFLE' && (
                        <span style={{
                            background: 'linear-gradient(to right, #f6d365 0%, #fda085 100%)', 
                            color:'white', fontSize:12, padding:'2px 8px', borderRadius:10, 
                            display:'flex', alignItems:'center', gap:4, fontWeight: 'bold',
                            boxShadow: '0 2px 5px rgba(253, 160, 133, 0.4)'
                        }}>
                            <Sparkles size={12} fill="white"/> ä¸æ´—ç‰Œ(çˆ½å±€)
                        </span>
                    )}

                    {roomConfig.shuffleStrategy === 'SIMULATION' && (
                        <span style={{
                            background: 'linear-gradient(to right, #a18cd1 0%, #fbc2eb 100%)', 
                            color:'white', fontSize:12, padding:'2px 8px', borderRadius:10, 
                            display:'flex', alignItems:'center', gap:4, fontWeight: 'bold',
                            boxShadow: '0 2px 5px rgba(161, 140, 209, 0.4)'
                        }}>
                            <Layers size={12} fill="white"/> æ¨¡æ‹Ÿå ç‰Œ
                        </span>
                    )}

                    {isTeamMode && (
                        <span style={{background:'#27ae60', color:'white', fontSize:12, padding:'2px 8px', borderRadius:10, display:'flex', alignItems:'center', gap:4}}>
                            <Shield size={12}/> ç»„é˜Ÿæ¨¡å¼
                        </span>
                    )}
                </div>
                
                <div style={{display:'flex', gap:10, alignItems:'center'}}>
                    <div style={{display:'flex', gap:10}} className="hide-on-mobile">
                        <span className={css.tag}><Target size={14}/> ç›®æ ‡ {roomConfig.targetScore}</span>
                        <span className={css.tag}><Layers size={14}/> {roomConfig.deckCount}å‰¯</span>
                        <span className={css.tag}><User size={14}/> {roomConfig.maxPlayers}äºº</span>
                    </div>

                    {amIHost && (
                        /* [ä¿®æ”¹] è®¾ç½®æŒ‰é’®ï¼šçº¯é½¿è½®å›¾æ ‡ï¼Œæ— èƒŒæ™¯ï¼Œæ‚¬åœæ—‹è½¬æ•ˆæœ */
                        <button 
                            onClick={() => setShowSettings(true)}
                            style={{
                                background: 'transparent', 
                                border: 'none', 
                                display: 'flex', alignItems: 'center', justifyContent: 'center',
                                cursor: 'pointer', 
                                color: '#34495e', // æ·±è‰²å›¾æ ‡
                                padding: 8,
                                transition: 'transform 0.3s ease'
                            }}
                            title="ä¿®æ”¹æˆ¿é—´è§„åˆ™"
                            onMouseEnter={(e) => e.currentTarget.style.transform = 'rotate(45deg)'}
                            onMouseLeave={(e) => e.currentTarget.style.transform = 'rotate(0deg)'}
                        >
                            <Settings size={24} />
                        </button>
                    )}
                </div>
            </div>
            
            <div style={{padding: '0 15px 10px 15px', display:'flex', gap:8, flexWrap:'wrap', fontSize:12, color:'#666'}} className="mobile-only-tags">
                 <span className={css.tag}><Target size={12}/> {roomConfig.targetScore}</span>
                 <span className={css.tag}><Layers size={12}/> {roomConfig.deckCount}å‰¯</span>
                 <span className={css.tag}><User size={12}/> {roomConfig.maxPlayers}äºº</span>
                 {roomConfig.shuffleStrategy === 'NO_SHUFFLE' && <span className={css.tag} style={{background:'#fdf2e9', color:'#e67e22', border:'1px solid #e67e22'}}><Sparkles size={12}/> ä¸æ´—ç‰Œ</span>}
                 {roomConfig.shuffleStrategy === 'SIMULATION' && <span className={css.tag} style={{background:'#f5eef8', color:'#9b59b6', border:'1px solid #9b59b6'}}><Layers size={12}/> æ¨¡æ‹Ÿå ç‰Œ</span>}
                 {roomConfig.enableRankPenalty && <span className={css.tag} style={{color:'#e67e22', background:'#fdf2e9'}}><Award size={12}/> èµç½š</span>}
            </div>
            <style>{`@media (min-width: 769px) { .mobile-only-tags { display: none !important; } }`}</style>

            <div className={`${css.playerGrid} mobile-lobby-grid`}>
                {players.map((p, i) => {
                    let teamColor = '#eee'; 
                    let teamBg = 'white';   
                    let teamName = null;
                    
                    if (isTeamMode) {
                        const isRedTeam = i % 2 === 0;
                        teamColor = isRedTeam ? '#e74c3c' : '#3498db';
                        teamBg = isRedTeam ? '#fdedec' : '#eaf2f8';
                        teamName = isRedTeam ? 'çº¢é˜Ÿ' : 'è“é˜Ÿ';
                    }

                    const isMe = p.id === mySocketId;
                    if (isMe && !isTeamMode) {
                        teamBg = '#f0fbf4';
                        teamColor = '#27ae60';
                    }
                    const borderWidth = isMe ? 3 : 2;

                    return (
                        <div key={p.id} className={css.lobbyPlayer} style={{
                            borderColor: isMe ? '#2ecc71' : teamColor, 
                            backgroundColor: teamBg,
                            borderWidth: borderWidth
                        }}>
                            {amIHost && !isMe && (
                                <button 
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        const confirmKick = window.confirm(`ç¡®å®šè¦è¸¢å‡º ${p.name} å—ï¼Ÿ`);
                                        if (confirmKick) handleKickPlayer(p.id);
                                    }}
                                    className={css.kickButton}
                                    title="è¸¢å‡ºç©å®¶"
                                >
                                    <X size={14} color="white"/>
                                </button>
                            )}

                            {teamName && (
                                <div style={{
                                    position: 'absolute', top: 0, left: 0, 
                                    background: teamColor, color: 'white', 
                                    fontSize: 10, padding: '2px 8px', 
                                    borderBottomRightRadius: 8, borderTopLeftRadius: 8
                                }}>
                                    {teamName}
                                </div>
                            )}

                            {amIHost && players.length > 1 && (
                                <div style={{
                                    position: 'absolute', right: 5, top: '50%', transform: 'translateY(-50%)',
                                    display:'flex', flexDirection:'column', gap:4
                                }}>
                                    {i > 0 && (
                                        <button 
                                            onClick={(e) => { e.stopPropagation(); handleSwitchSeat(i, i - 1); }}
                                            style={{
                                                padding:4, borderRadius:4, border:'1px solid #ccc', 
                                                background:'white', cursor:'pointer', lineHeight:0
                                            }}
                                            title="ä¸Šç§»"
                                        >
                                            <ArrowUp size={14} color="#666"/>
                                        </button>
                                    )}
                                    {i < players.length - 1 && (
                                        <button 
                                            onClick={(e) => { e.stopPropagation(); handleSwitchSeat(i, i + 1); }}
                                            style={{
                                                padding:4, borderRadius:4, border:'1px solid #ccc', 
                                                background:'white', cursor:'pointer', lineHeight:0
                                            }}
                                            title="ä¸‹ç§»"
                                        >
                                            <ArrowDown size={14} color="#666"/>
                                        </button>
                                    )}
                                </div>
                            )}

                            <div className={css.avatarLarge}>
                                {p.isBot ? <Bot size={40} /> : p.name[0]}
                            </div>
                            <div style={{fontWeight: 'bold', display:'flex', alignItems:'center', gap:5}}>
                                {p.name}
                                {p.isBot && <span style={{fontSize:10, background:'#eee', padding:'2px 5px', borderRadius:4}}>AI</span>}
                            </div>
                            {p.isHost && <span className={css.hostBadge}>æˆ¿ä¸»</span>}
                        </div>
                    );
                })}
                
                {Array.from({length: Math.max(0, roomConfig.maxPlayers - players.length)}).map((_, i) => (
                    <div key={`empty-${i}`} className={css.lobbyPlayer} style={{borderStyle: 'dashed', opacity: 0.5}}>
                        <div className={css.avatarLarge} style={{background:'#f0f0f0', color:'#ccc'}}>?</div>
                        <div style={{color:'#999'}}>ç­‰å¾…åŠ å…¥</div>
                    </div>
                ))}
            </div>

            <div className={`${css.lobbyFooter} mobile-lobby-footer`} style={{flexShrink: 0}}>
                {amIHost ? (
                    <div style={{display:'flex', gap: 15, justifyContent: 'center'}}>
                        <button 
                            className={css.primaryButton}
                            style={{background: '#7f8c8d', width:'auto', padding:'0 20px', fontSize: 16, marginTop:0}} 
                            onClick={handleAddBot}
                            disabled={players.length >= roomConfig.maxPlayers}
                        >
                            <Bot size={18} style={{marginRight:5}}/> +Bot
                        </button>

                        <button className={css.primaryButton} style={{width:'auto', padding:'0 30px', marginTop:0}} onClick={handleStartGame} disabled={players.length < 2}>
                            <Play size={18} style={{marginRight:5}}/> å¼€å§‹å¯¹æˆ˜
                        </button>
                    </div>
                ) : (
                    <div style={{color:'#999', fontSize: 14, display:'flex', alignItems:'center', gap:5}}><Clock size={16}/> ç­‰å¾…æˆ¿ä¸»å¼€å§‹...</div>
                )}
            </div>
          </div>
      </div>
    </div>
    );
};

================================================================================
FILE PATH: client\src\screens\LobbyScreen.module.css
================================================================================
/* --- [æ–°å¢] å¤§å…é¡µä¸“ç”¨å®¹å™¨ --- */
.lobbyContainer {
    height: 100dvh;
    width: 100vw;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #1e272e;
    font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    background-image: radial-gradient(circle at top right, #34495e 0%, #000000 100%);
    overflow: hidden;
}

/* --- å®¹å™¨ä¸å¡ç‰‡ --- */
.lobbyCard {
    background: white;
    padding: 40px;
    border-radius: 20px;
    width: 1000px;
    max-width: 95vw;
    min-height: 600px;
    /* é™åˆ¶æœ€å¤§é«˜åº¦ï¼Œé˜²æ­¢åœ¨å¤§å±æˆ–äººæ•°è¿‡å¤šæ—¶æ’‘ç ´å±å¹• */
    max-height: 85vh;
    display: flex;
    flex-direction: column;
    box-shadow: 0 30px 60px rgba(0, 0, 0, 0.5);
    /* ç¡®ä¿å†…å®¹æº¢å‡ºæ—¶ä¸ä¼šç ´ååœ†è§’æˆ–æº¢å‡º Card */
    overflow: hidden;
}

.lobbyHeader {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 30px;
    padding-bottom: 20px;
    border-bottom: 1px solid #eee;
    /* é˜²æ­¢å¤´éƒ¨è¢«å‹ç¼© */
    flex-shrink: 0;
}

.lobbyFooter {
    margin-top: auto;
    border-top: 1px solid #eee;
    padding-top: 20px;
    display: flex;
    justify-content: center;
    /* é˜²æ­¢åº•éƒ¨è¢«å‹ç¼© */
    flex-shrink: 0;
}

/* --- é€šç”¨å…ƒç´  --- */
.tag {
    background: #f0f9f4;
    color: #27ae60;
    padding: 5px 10px;
    border-radius: 20px;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 5px;
}

.primaryButton {
    margin-top: 25px;
    width: 100%;
    height: 65px;
    background: #2c3e50;
    color: white;
    border: none;
    border-radius: 14px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 19px;
    transition: all 0.2s;
    box-shadow: 0 10px 25px rgba(44, 62, 80, 0.25);
}

.primaryButton:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    background: #95a5a6;
}

/* --- ç©å®¶ç½‘æ ¼åŒºåŸŸ --- */
.playerGrid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 20px;
    flex: 1;
    align-content: start;
    /* å…è®¸ç½‘æ ¼å†…éƒ¨æ»šåŠ¨ */
    overflow-y: auto;
    min-height: 0;
}

.lobbyPlayer {
    border: 2px solid #eee;
    border-radius: 12px;
    padding: 25px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
    position: relative;
    transition: all 0.2s;
}

.avatarLarge {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: #34495e;
    color: white;
    font-size: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
}

.hostBadge {
    position: absolute;
    top: 10px;
    right: 10px;
    background: #f1c40f;
    color: #333;
    font-size: 12px;
    padding: 4px 8px;
    border-radius: 4px;
    font-weight: bold;
}

.kickButton {
    position: absolute;
    top: -8px;
    right: -8px;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background: #e74c3c;
    border: 2px solid white;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    padding: 0;
    z-index: 10;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

/* --- è®¾ç½®å¼¹çª—ç›¸å…³ --- */
.modalOverlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.85);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 99;
    backdrop-filter: blur(8px);
    pointer-events: auto;
}

.modalContent {
    background: white;
    padding: 30px;
    border-radius: 24px;
    text-align: center;
    box-shadow: 0 30px 80px rgba(0, 0, 0, 0.6);
    animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    width: 90%;
    max-width: 500px;
    max-height: 85vh;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    align-items: center;
}

/* --- [è¡¥å…¨] é…ç½®è¡¨å•æ ·å¼ --- */
.configGrid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 25px 35px;
    width: 100%;
}

.configItem {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.configLabel {
    display: flex;
    justify-content: space-between;
    font-size: 14px;
    color: #7f8c8d;
    font-weight: 600;
}

.configValue {
    color: #27ae60;
    font-weight: bold;
}

.rangeInput {
    width: 100%;
    cursor: pointer;
    accent-color: #27ae60;
    height: 6px;
}

.radioGroup {
    display: flex;
    gap: 10px;
}

.radioBtn {
    flex: 1;
    padding: 8px 0;
    border-radius: 8px;
    border: 1px solid #e1e4e8;
    background: white;
    color: #7f8c8d;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.2s;
}

.radioBtnActive {
    flex: 1;
    padding: 8px 0;
    border-radius: 8px;
    border: 1px solid #27ae60;
    background: #eafaf1;
    color: #27ae60;
    font-size: 13px;
    font-weight: bold;
    cursor: pointer;
}

.input {
    padding: 10px;
    border: none;
    background: transparent;
    flex: 1;
    outline: none;
    font-size: 17px;
    color: #2c3e50;
    font-weight: 500;
    border: 1px solid #ddd;
    border-radius: 4px;
}

@keyframes popIn {
    0% { transform: scale(0.8); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
}

================================================================================
FILE PATH: client\src\screens\LoginScreen.jsx
================================================================================
import React, { useState, useEffect } from 'react'; 
import { User, Monitor, RefreshCw, Plus, LogIn, Maximize, Minimize, Wifi, WifiOff, History } from 'lucide-react'; 
import { useGame } from '../context/GameContext.jsx';
import { RoomSettingsForm } from '../components/game/RoomSettingsForm.jsx';

import css from './LoginScreen.module.css';

export const LoginScreen = () => {
    
    const { 
        username, setUsername, 
        roomId, setRoomId, 
        roomConfig, setRoomConfig, 
        isCreatorMode, setIsCreatorMode, 
        handleRoomAction, 
        handleQuickReconnect, // [æ–°å¢]
        isLoading,
        isConnected,
        ping 
    } = useGame();

    const [isFullScreen, setIsFullScreen] = useState(false);
    
    // [æ–°å¢] æ£€æµ‹æ˜¯å¦æœ‰æ–­çº¿è®°å½•
    const [lastSession, setLastSession] = useState(null);

    useEffect(() => {
        const rid = localStorage.getItem('poker_roomid');
        const uid = localStorage.getItem('poker_username');
        // åªæœ‰å½“ä¸¤ä¸ªéƒ½æœ‰å€¼ï¼Œæ‰æ˜¾ç¤ºé‡è¿æŒ‰é’®
        if (rid && uid) {
            setLastSession({ roomId: rid, username: uid });
        }
    }, []);

    const toggleFullScreen = () => {
        if (!document.fullscreenElement) {
            const docEl = document.documentElement;
            const requestFull = docEl.requestFullscreen || docEl.webkitRequestFullscreen;
            if (requestFull) {
                requestFull.call(docEl)
                    .then(() => setIsFullScreen(true))
                    .catch(err => console.log("å…¨å±è¯·æ±‚è¢«æ‹¦æˆª:", err));
            }
        } else {
            const exitFull = document.exitFullscreen || document.webkitExitFullscreen;
            if (exitFull) {
                exitFull.call(document)
                    .then(() => setIsFullScreen(false));
            }
        }
    };

    const tryEnterFullScreen = () => {
        try {
            if (!document.fullscreenElement) {
                const docEl = document.documentElement;
                const requestFull = docEl.requestFullscreen || docEl.webkitRequestFullscreen;
                if (requestFull) {
                    requestFull.call(docEl).catch(() => {});
                }
            }
        } catch (e) {
            // Ignore
        }
    };

    const onActionClick = () => {
        tryEnterFullScreen(); 
        handleRoomAction();   
    };
    
    // [æ–°å¢] ç‚¹å‡»é‡è¿æŒ‰é’®
    const onReconnectClick = () => {
        tryEnterFullScreen();
        handleQuickReconnect();
    };

    const handleConfigChange = (key, value) => {
        setRoomConfig(prev => ({ ...prev, [key]: value }));
    };

    const getPingColor = (p) => {
        if (!isConnected) return '#e74c3c';
        if (p < 100) return '#27ae60';
        if (p < 200) return '#f1c40f';
        return '#e74c3c';
    };

    const pingStyle = {
        background: isConnected ? (ping < 150 ? '#eafaf1' : '#fef9e7') : '#fdedec',
        color: getPingColor(ping),
        borderColor: isConnected ? '#e1e4e8' : '#fadbd8'
    };

    return (
        <div className={css.container}>
            <div className={`${css.loginCard} mobile-layout-column`}>
                
                {/* å·¦ä¾§å“ç‰ŒåŒº */}
                <div className={`${css.loginLeft} mobile-login-left`}>
                    <div className={css.logoCircle}>
                        <div className={css.logoText}>510K</div>
                    </div>
                    <h1 className={css.brandTitle}>æ‰‘å…‹å¯¹æˆ˜</h1>
                    <div className={css.brandSubtitle}>å¤šäººåœ¨çº¿ Â· è‡ªç”±è§„åˆ™ Â· æé€Ÿç•…ç©</div>
                    
                    <div className={`${css.featureList} hide-on-mobile`}>
                        <div className={css.featureItem}>âœ¨ æ”¯æŒ 2-12 äººåŒå°ç«æŠ€</div>
                        <div className={css.featureItem}>ğŸš€ åªæœ‰ 1 å‰¯ç‰Œ? ä¸ï¼Œç°åœ¨æ”¯æŒ 8 å‰¯!</div>
                        <div className={css.featureItem}>â±ï¸ è‡ªå®šä¹‰æ€è€ƒæ—¶é—´ä¸è·èƒœç›®æ ‡</div>
                    </div>
                </div>

                {/* å³ä¾§è¡¨å•åŒº */}
                <div className={`${css.loginRight} mobile-login-right`}>
                    
                    {/* é¡¶éƒ¨å·¥å…·æ  */}
                    <div className={css.topBar}>
                        <button onClick={toggleFullScreen} className={css.fullScreenBtn}>
                            {isFullScreen ? <Minimize size={14}/> : <Maximize size={14}/>}
                            <span>{isFullScreen ? 'é€€å‡ºå…¨å±' : 'å…¨å±æ¨¡å¼'}</span>
                        </button>

                        <div className={css.pingBadge} style={pingStyle}>
                            {isConnected ? <Wifi size={14}/> : <WifiOff size={14}/>}
                            {isConnected ? `${ping}ms` : 'è¿æ¥ä¸­...'}
                        </div>
                    </div>

                    {/* Tab åˆ‡æ¢ */}
                    <div className={css.tabs}>
                        <button 
                            className={!isCreatorMode ? css.tabBtnActive : css.tabBtn} 
                            onClick={()=>setIsCreatorMode(false)}
                        >
                            åŠ å…¥æˆ¿é—´
                        </button>
                        <button 
                            className={isCreatorMode ? css.tabBtnActive : css.tabBtn} 
                            onClick={()=>setIsCreatorMode(true)}
                        >
                            åˆ›å»ºæˆ¿é—´
                        </button>
                    </div>

                    {/* è¡¨å•å†…å®¹ */}
                    <div className={css.formContent}>
                        <div className={css.inputGroup}>
                            <User size={18} color="#7f8c8d" />
                            <input 
                                className={css.input} 
                                value={username} 
                                onChange={e=>setUsername(e.target.value)} 
                                placeholder="è¯·è¾“å…¥ä½ çš„æ˜µç§°" 
                                maxLength={10}
                            />
                        </div>
                        <div className={css.inputGroup}>
                            <Monitor size={18} color="#7f8c8d" />
                            <input 
                                className={css.input} 
                                value={roomId} 
                                onChange={e=>setRoomId(e.target.value)} 
                                placeholder="è¯·è¾“å…¥æˆ¿é—´å· (å¦‚: 888)" 
                                maxLength={6}
                            />
                        </div>

                        {isCreatorMode && (
                            <div className={css.advancedConfigPanel}>
                                <RoomSettingsForm 
                                    config={roomConfig} 
                                    onChange={handleConfigChange} 
                                />
                            </div>
                        )}

                        <div style={{flex: 1}}></div>

                        {/* [æ–°å¢] é‡è¿æŒ‰é’®ï¼šåªåœ¨æœ‰è®°å½•æ—¶æ˜¾ç¤º */}
                        {lastSession && !isCreatorMode && (
                             <button 
                                className={css.reconnectBtn}
                                onClick={onReconnectClick}
                                disabled={isLoading || !isConnected}
                             >
                                <History size={18} />
                                <div style={{display:'flex', flexDirection:'column', alignItems:'flex-start', lineHeight:1.2}}>
                                    <span style={{fontSize: 14, fontWeight:'bold'}}>ä¸€é”®é‡è¿å›æˆ¿é—´</span>
                                    <span style={{fontSize: 11, opacity: 0.8}}>Room: {lastSession.roomId} ({lastSession.username})</span>
                                </div>
                             </button>
                        )}

                        <button 
                            className={css.primaryButton}
                            onClick={onActionClick} 
                            disabled={isLoading || !isConnected}
                            style={{
                                background: (!isConnected) ? '#95a5a6' : '#2c3e50'
                            }}
                        >
                            {(isLoading || !isConnected) ? <RefreshCw className="spin" size={20}/> : (isCreatorMode ? <Plus size={20}/> : <LogIn size={20}/>)}
                            <span style={{marginLeft:10}}>
                                {!isConnected ? "æ­£åœ¨è¿æ¥æœåŠ¡å™¨..." : (isLoading ? "å¤„ç†ä¸­..." : (isCreatorMode ? "ç«‹å³åˆ›å»ºæˆ¿é—´" : "è¿›å…¥æ¸¸æˆæˆ¿é—´"))}
                            </span>
                        </button>
                        
                        {!isConnected && (
                            <div className={css.firstLoadTip}>
                                âš ï¸ é¦–æ¬¡è®¿é—®å¯èƒ½éœ€è¦ 30-50ç§’ å”¤é†’æœåŠ¡å™¨ï¼Œè¯·è€å¿ƒç­‰å¾…å³ä¸Šè§’å˜ä¸ºç»¿è‰²ã€‚
                            </div>
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
};

================================================================================
FILE PATH: client\src\screens\LoginScreen.module.css
================================================================================
/* =========================================
   ç™»å½•é¡µä¸“å±æ ·å¼ (LoginScreen)
   æ›¿ä»£åŸ styles.js ä¸­çš„ loginCard ç›¸å…³æ ·å¼
   ========================================= */

/* é¡µé¢ä¸»å®¹å™¨ (ç»§æ‰¿åŸ styles.container) */
.container {
    height: 100dvh; /* é€‚é…ç§»åŠ¨ç«¯åŠ¨æ€åœ°å€æ  */
    width: 100vw;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #1e272e;
    font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    background-image: radial-gradient(circle at top right, #34495e 0%, #000000 100%);
    overflow: hidden;
}

/* å¡ç‰‡ä¸»ä½“ */
.loginCard {
    background: white;
    border-radius: 24px;
    width: 95%;
    max-width: 1100px;
    min-height: 600px;
    max-height: 90vh;
    display: flex;
    box-shadow: 0 50px 100px -20px rgba(0, 0, 0, 0.7);
    overflow: hidden;
    animation: popIn 0.5s ease-out;
}

/* --- å·¦ä¾§å“ç‰ŒåŒº --- */
.loginLeft {
    flex: 0.8;
    background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
    padding: 60px 50px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: flex-start;
    color: white;
    position: relative;
    overflow: hidden;
}

.logoCircle {
    width: 90px;
    height: 90px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 25px;
    backdrop-filter: blur(10px);
}

.logoText {
    font-size: 28px;
    font-weight: 900;
    color: white;
}

.brandTitle {
    font-size: 48px;
    font-weight: 800;
    margin: 0 0 15px 0;
    letter-spacing: -1.5px;
}

.brandSubtitle {
    font-size: 18px;
    opacity: 0.9;
    margin-bottom: 50px;
    font-weight: 500;
}

.featureList {
    margin-top: auto;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.featureItem {
    font-size: 15px;
    opacity: 0.95;
    display: flex;
    align-items: center;
    font-weight: 500;
}

/* --- å³ä¾§è¡¨å•åŒº --- */
.loginRight {
    flex: 1.2;
    padding: 50px 60px;
    display: flex;
    flex-direction: column;
    background: #ffffff;
    overflow-y: auto;
}

/* é¡¶éƒ¨å·¥å…·æ  */
.topBar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.fullScreenBtn {
    background: #f8f9fa;
    border: 1px solid #e1e4e8;
    border-radius: 20px;
    padding: 6px 12px;
    cursor: pointer;
    color: #7f8c8d;
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    font-weight: bold;
    transition: all 0.2s;
}

.pingBadge {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    padding: 6px 12px;
    border-radius: 20px;
    font-weight: bold;
    border: 1px solid transparent;
}

/* Tab åˆ‡æ¢ */
.tabs {
    display: flex;
    gap: 35px;
    margin-bottom: 35px;
    border-bottom: 2px solid #f1f2f6;
}

.tabBtn {
    padding: 12px 0;
    font-size: 18px;
    font-weight: bold;
    color: #95a5a6;
    background: none;
    border: none;
    cursor: pointer;
    transition: all 0.3s;
    border-bottom: 3px solid transparent;
    margin-bottom: -3px;
}

.tabBtnActive {
    composes: tabBtn;
    color: #2c3e50;
    border-bottom: 3px solid #27ae60;
}

/* è¡¨å•å†…å®¹ */
.formContent {
    flex: 1;
    display: flex;
    flex-direction: column;
}

.inputGroup {
    display: flex;
    align-items: center;
    background: #f8f9fa;
    border-radius: 14px;
    padding: 0 20px;
    margin-bottom: 20px;
    border: 1px solid #e1e4e8;
    height: 60px;
    transition: all 0.2s;
}

.input {
    padding: 10px;
    border: none;
    background: transparent;
    flex: 1;
    outline: none;
    font-size: 17px;
    color: #2c3e50;
    font-weight: 500;
}

/* é«˜çº§è®¾ç½®é¢æ¿å®¹å™¨ */
.advancedConfigPanel {
    margin-top: 15px;
    background: #fff;
    border-radius: 12px;
    animation: fadeIn 0.4s ease;
}

/* ä¸»æŒ‰é’® */
.primaryButton {
    margin-top: 25px;
    width: 100%;
    height: 65px;
    background: #2c3e50;
    color: white;
    border: none;
    border-radius: 14px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 19px;
    transition: all 0.2s;
    box-shadow: 0 10px 25px rgba(44, 62, 80, 0.25);
}

.primaryButton:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    background: #95a5a6 !important; /* å¼ºåˆ¶è¦†ç›– */
}

/* [æ–°å¢] é‡è¿æŒ‰é’®æ ·å¼ */
.reconnectBtn {
    width: 100%;
    height: 60px;
    background: #eafaf1; /* æµ…ç»¿è‰²èƒŒæ™¯ */
    color: #27ae60;      /* æ·±ç»¿è‰²æ–‡å­— */
    border: 1px solid #27ae60;
    border-radius: 14px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 15px;
    font-size: 16px;
    transition: all 0.2s;
    margin-bottom: 0px; /* ç´§è´´ä¸»æŒ‰é’®ä¸Šæ–¹ */
}

.reconnectBtn:hover {
    background: #d5f5e3;
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(39, 174, 96, 0.2);
}

.reconnectBtn:active {
    transform: translateY(0);
}

.reconnectBtn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

/* é¦–æ¬¡åŠ è½½æç¤º */
.firstLoadTip {
    text-align: center;
    margin-top: 15px;
    font-size: 13px;
    color: #e74c3c;
    background: #fdedec;
    padding: 8px;
    border-radius: 8px;
}

/* åŠ¨ç”»å®šä¹‰ */
@keyframes popIn {
    0% { transform: scale(0.95); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

/* Loading æ—‹è½¬åŠ¨ç”» (å…¨å±€) */
:global(.spin) {
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

================================================================================
FILE PATH: client\src\utils\cardLogic.js
================================================================================
// çº¯é€»è¾‘å·¥å…·

// æ’åºæƒé‡ï¼š2(15) > A(14) > K(13)...
export const getSortValue = (cardVal) => {
    const normalized = cardVal % 54;
    if (normalized === 52) return 16;
    if (normalized === 53) return 17;
    const base = normalized % 13;
    if (base === 0) return 14; 
    if (base === 1) return 15; 
    return base + 1;
};

// èŠ±è‰²æ’åºæƒé‡
// [ä¿ç•™] è™½ç„¶ä¸æä¾›èŠ±è‰²æ’åºæ¨¡å¼ï¼Œä½†ç†ç‰Œ(arrangeHand)æ—¶çš„åŒåˆ†æ’åºä»éœ€ä¾èµ–æ­¤å‡½æ•°
export const getSuitSortValue = (cardVal) => {
    if (cardVal >= 52) return cardVal * 100;
    const suit = Math.floor(cardVal / 13) % 4; 
    const val = cardVal % 13;
    return suit * 100 + val; 
};

// åˆ¤æ–­æ˜¯å¦ä¸ºåˆ†ç‰Œ (5, 10, K)
const isScoreCard = (cardVal) => {
    const normalized = cardVal % 54;
    if (normalized >= 52) return false; // ç‹ä¸æ˜¯åˆ†ç‰Œ
    const val = normalized % 13;
    // 0=A, 1=2, 2=3, 3=4(5), ..., 9(10), ..., 12(K)
    return val === 4 || val === 9 || val === 12;
};

// è·å–åˆ†ç‰Œçš„å†…éƒ¨æ’åºæƒé‡ (K > 10 > 5)
const getScoreCardRank = (cardVal) => {
    const val = (cardVal % 54) % 13;
    if (val === 12) return 3; // K
    if (val === 9) return 2;  // 10
    if (val === 4) return 1;  // 5
    return 0;
};

// è·å–å•å¼ ç‰Œçš„æ˜¾ç¤ºä¿¡æ¯
export const getCardDisplay = (cardVal) => {
    const normalizedValue = cardVal % 54; 
    if (normalizedValue === 52) return { suit: 'Joker', text: 'å°ç‹', color: '#000', isScore: false };
    if (normalizedValue === 53) return { suit: 'Joker', text: 'å¤§ç‹', color: '#d00', isScore: false };
    
    const suits = ['â™ ', 'â™¥', 'â™£', 'â™¦'];
    const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
    const valueIndex = normalizedValue % 13;
    const suit = suits[Math.floor(normalizedValue / 13)];
    const color = (suit === 'â™¥' || suit === 'â™¦') ? '#d00' : '#000';
    const text = values[valueIndex];
    const isScore = (text === '5' || text === '10' || text === 'K');
    
    return { suit, text, color, isScore };
};

// æ™ºèƒ½ç†ç‰Œé€»è¾‘
export const arrangeHand = (cards, extractScore = true) => {
    let scoreCards = []; // å³ä¾§ï¼šåˆ†ç‰Œ
    let otherCards = []; // å¾…åˆ†ç±»çš„ç‰Œ

    if (extractScore) {
        // 1. å…ˆæŠŠæ‰€æœ‰åˆ†ç‰Œ(5, 10, K)æå–å‡ºæ¥
        cards.forEach(c => {
            if (isScoreCard(c)) scoreCards.push(c);
            else otherCards.push(c);
        });

        // 2. å¯¹åˆ†ç‰Œè¿›è¡Œæ’åºï¼šK > 10 > 5 (KKKK 1010 5555)
        scoreCards.sort((a, b) => {
            const rA = getScoreCardRank(a);
            const rB = getScoreCardRank(b);
            if (rA !== rB) return rB - rA; // é™åº (K=3, 10=2, 5=1)
            return getSuitSortValue(b) - getSuitSortValue(a); // åŒåˆ†æŒ‰èŠ±è‰²æ’
        });
    } else {
        otherCards = [...cards];
    }

    // 3. å¯¹å‰©ä½™ç‰Œè¿›è¡Œåˆ†ç»„
    const groups = new Map();
    otherCards.forEach(c => {
        const val = getSortValue(c);
        if (!groups.has(val)) groups.set(val, []);
        groups.get(val).push(c);
    });

    const bombs = [];   // å·¦ä¾§ï¼šç‚¸å¼¹
    const triples = []; // ä¸­é—´ï¼šä¸‰å¼ 
    const pairs = [];   // ä¸­é—´ï¼šå¯¹å­
    const singles = []; // ä¸­é—´ï¼šå•å¼ 

    groups.forEach((groupCards, val) => {
        const count = groupCards.length;
        // è§„åˆ™ï¼šæ•°é‡ >= 4 è§†ä¸ºç‚¸å¼¹
        if (count >= 4) {
            bombs.push({ val, cards: groupCards, count });
        } else if (count === 3) {
            triples.push({ val, cards: groupCards });
        } else if (count === 2) {
            pairs.push({ val, cards: groupCards });
        } else {
            singles.push({ val, cards: groupCards });
        }
    });

    // 4. æ’åºç‚¸å¼¹ï¼šå¼ æ•°ä¼˜å…ˆ (10å¼  > 8å¼  > 6å¼ ...)ï¼Œå…¶æ¬¡ç‚¹æ•°
    bombs.sort((a, b) => {
        if (a.count !== b.count) return b.count - a.count; // å¼ æ•°é™åº
        return b.val - a.val; // ç‚¹æ•°é™åº
    });

    // 5. æ’åºä¸­é—´åºŸç‰Œï¼šå„è‡ªæŒ‰ç‚¹æ•°é™åº
    const sortByVal = (a, b) => b.val - a.val;
    triples.sort(sortByVal);
    pairs.sort(sortByVal);
    singles.sort(sortByVal);

    // 6. å±•å¹³æ•°ç»„
    const flatBombs = bombs.flatMap(b => b.cards);
    const flatTriples = triples.flatMap(t => t.cards);
    const flatPairs = pairs.flatMap(p => p.cards);
    const flatSingles = singles.flatMap(s => s.cards);

    // 7. æ‹¼æ¥ï¼šå·¦ç‚¸å¼¹ + ä¸­(ä¸‰+å¯¹+å•) + å³åˆ†ç‰Œ
    return [...flatBombs, ...flatTriples, ...flatPairs, ...flatSingles, ...scoreCards];
};

// æ‰‹ç‰Œæ’åºå…¥å£
export const sortHand = (cards, mode = 'POINT') => {
    // [ä¿®æ”¹] ç§»é™¤äº† mode === 'SUIT' çš„åˆ†æ”¯é€»è¾‘
    if (mode === 'ARRANGE') {
        return arrangeHand(cards, true);
    }
    if (mode === 'ARRANGE_MERGED') {
        return arrangeHand(cards, false);
    }
    // é»˜è®¤ POINT
    return [...cards].sort((a, b) => getSortValue(b) - getSortValue(a));
};

// è®¡ç®—æ‰‹ç‰Œé—´è·
export const calculateCardSpacing = (count, screenWidth) => {
    if (count <= 1) return 0;
    
    // é€‚é…æ‰‹æœºé€»è¾‘ï¼šç•™å‡ºå·¦å³å®‰å…¨è·ç¦»
    const isMobile = screenWidth < 768;
    const padding = isMobile ? 20 : 100; // å‡å°‘ä¸¤ä¾§ç•™ç™½
    
    const w = Math.min(screenWidth - padding, 1200); 
    
    // å¡ç‰Œå®é™…å®½åº¦
    const cardWidth = 55; // ä¸ styles.js ä¸­çš„ card width ä¸€è‡´
    
    // æœ€å¤§é—´è·ï¼šç‰Œå°‘çš„æ—¶å€™ä¸è¦åˆ†å¤ªå¼€
    const maxGap = isMobile ? 35 : 45; 
    
    const neededWidth = (count - 1) * maxGap + cardWidth;
    
    // å¦‚æœéœ€è¦çš„å®½åº¦å°äºå±å¹•å®½ï¼Œå°±ç”¨æœ€å¤§é—´è·
    if (neededWidth <= w) return maxGap;
    
    // å¦åˆ™ï¼ŒæŒ¤å‹ç‰Œçš„é—´è·
    return (w - cardWidth) / (count - 1);
};

// è¾…åŠ©å‡½æ•°ï¼šæ ¹æ®è§¦æ‘¸Xåæ ‡è®¡ç®—æ˜¯ç¬¬å‡ å¼ ç‰Œ
export const getCardIndexFromTouch = (touchX, containerLeft, spacing, count) => {
    const relativeX = touchX - containerLeft;
    let index = Math.floor(relativeX / spacing);
    
    if (index < 0) index = 0;
    if (index >= count) index = count - 1; 
    
    return index;
};

// [æ–°å¢] ç®€æ˜“ç‚¸å¼¹æ£€æµ‹ (ç”¨äºå‰ç«¯äº¤äº’æç¤º)
export const isBomb = (cards) => {
    if (!cards || cards.length < 2) return false;
    
    const points = cards.map(getSortValue).sort((a, b) => a - b);
    const len = points.length;
    const uniquePoints = [...new Set(points)];

    // 1. æ™®é€šç‚¸å¼¹: ç‚¹æ•°å…¨ä¸€æ ·ï¼Œä¸” >= 4å¼ 
    if (uniquePoints.length === 1 && len >= 4) return true;

    // 2. 510K: é•¿åº¦3ï¼Œä¸”ç‚¹æ•°æ˜¯ 5, 10, 13(K)
    if (len === 3) {
        if (points[0] === 5 && points[1] === 10 && points[2] === 13) return true;
    }

    // 3. ç‹ç‚¸: å…¨æ˜¯ç‹ (>= 2å¼ )
    if (points.every(p => p >= 16)) return true;

    return false;
};

================================================================================
FILE PATH: client\src\utils\gameRules.js
================================================================================
/**
 * æ ¸å¿ƒæ¸¸æˆè§„åˆ™ (å¤åˆ»æœåŠ¡ç«¯é€»è¾‘)
 * ç”¨äºå‰ç«¯æœ¬åœ°è¿›è¡Œç‰Œå‹åˆ†æã€åˆæ³•æ€§æ ¡éªŒå’Œå¤§å°æ¯”è¾ƒ
 */

const GameRules = {
    // åŸºç¡€ç‚¹æ•°æ˜ å°„: 3=3 ... K=13, A=14, 2=15, å°ç‹=16, å¤§ç‹=17
    getPoint: (cardVal) => {
        const normalized = cardVal % 54;
        if (normalized === 52) return 16;
        if (normalized === 53) return 17;
        const base = normalized % 13;
        if (base === 0) return 14; // A
        if (base === 1) return 15; // 2
        return base + 1; // 3 => 3
    },

    getSuit: (cardVal) => {
        const normalized = cardVal % 54;
        if (normalized >= 52) return -1; 
        return Math.floor(normalized / 13);
    },

    // æ ¸å¿ƒï¼šç‰Œå‹åˆ†æ
    analyze: (cards, deckCount = 2) => {
        const len = cards.length;
        if (len === 0) return { type: 'EMPTY' };

        // æ’åºï¼šç‚¹æ•°ä»å°åˆ°å¤§
        const points = cards.map(GameRules.getPoint).sort((a, b) => a - b);
        
        // ç»Ÿè®¡ç‚¹æ•°é¢‘ç‡
        const counts = {};
        points.forEach(p => { counts[p] = (counts[p] || 0) + 1; });
        const uniquePoints = Object.keys(counts).map(Number).sort((a,b)=>a-b);
        
        // --- éç‚¸å¼¹ç‰Œå‹ ---

        if (len === 1) return { type: 'SINGLE', val: points[0], level: 0 };

        if (len === 2 && points[0] === points[1]) {
            return { type: 'PAIR', val: points[0], level: 0 };
        }

        if (len === 3 && uniquePoints.length === 1) {
            return { type: 'TRIPLE', val: points[0], level: 0 };
        }

        // è¿å¯¹
        if (len >= 4 && len % 2 === 0) {
            // è¿å¯¹ä¸èƒ½åŒ…å«2å’Œç‹
            if (!points.some(p => p >= 15)) {
                let isLiandui = true;
                if (uniquePoints.length === len / 2) {
                     for (let p of uniquePoints) {
                         if (counts[p] !== 2) isLiandui = false;
                     }
                     // æ£€æŸ¥è¿ç»­æ€§
                     for(let i=0; i<uniquePoints.length-1; i++) {
                         if(uniquePoints[i+1] !== uniquePoints[i]+1) isLiandui = false;
                     }
                     if (isLiandui) return { type: 'LIANDUI', val: points[0], len: len, level: 0 };
                }
            }
        }

        // é£æœº (ä¸‰é¡º)
        if (len >= 6 && len % 3 === 0) {
            if (!points.some(p => p >= 15)) {
                let isAirplane = true;
                if (uniquePoints.length === len / 3) {
                    for (let p of uniquePoints) {
                        if (counts[p] !== 3) isAirplane = false;
                    }
                    for(let i=0; i<uniquePoints.length-1; i++) {
                        if(uniquePoints[i+1] !== uniquePoints[i]+1) isAirplane = false;
                    }
                    if (isAirplane) return { type: 'AIRPLANE', val: points[0], len: len, level: 0 };
                }
            }
        }

        // --- ç‚¸å¼¹ç‰Œå‹ (Level 1-5) ---

        // 510K æ£€æµ‹
        if (len === 3) {
            const has5 = points.includes(5);
            const has10 = points.includes(10);
            const hasK = points.includes(13);
            if (has5 && has10 && hasK) {
                // æ£€æŸ¥èŠ±è‰²
                const suits = cards.map(GameRules.getSuit);
                const isPure = (suits[0] === suits[1] && suits[1] === suits[2]);
                
                if (isPure) {
                    // çº¯510K (Level 2)
                    const suit = suits[0];
                    let suitVal = 0;
                    if (suit === 0) suitVal = 4; // é»‘
                    else if (suit === 1) suitVal = 3; // çº¢
                    else if (suit === 2) suitVal = 2; // æ¢…
                    else if (suit === 3) suitVal = 1; // æ–¹
                    return { type: '510K_PURE', val: suitVal, level: 2 }; 
                } else {
                    // æ‚è‰² 510K (Level 1)
                    return { type: '510K_MIXED', val: 1, level: 1 };
                }
            }
        }

        // Level 3: æ™®é€šç‚¸å¼¹
        if (uniquePoints.length === 1 && len >= 4) {
            if (len === deckCount * 4) {
                 return { type: 'BOMB_MAX', val: points[0], len: len, level: 5 };
            }
            return { type: 'BOMB_STD', val: points[0], len: len, level: 3 };
        }

        // Level 4: å¤©ç‹ç‚¸ (å…¨ç‹)
        const isAllJokers = points.every(p => p >= 16);
        if (isAllJokers && len === deckCount * 2) {
            return { type: 'BOMB_KING', val: 999, level: 4 };
        }

        return { type: 'INVALID' };
    },

    // æ ¡éªŒèƒ½å¦ç®¡ç‰Œ
    canPlay: (newCards, lastCards, deckCount) => {
        const newHand = GameRules.analyze(newCards, deckCount);
        if (newHand.type === 'INVALID') return false;

        // è‡ªç”±å‡ºç‰Œ
        if (!lastCards || lastCards.length === 0) return true;

        const lastHand = GameRules.analyze(lastCards, deckCount);

        // A. ç‚¸å¼¹ vs éç‚¸å¼¹
        if (newHand.level > 0 && lastHand.level === 0) return true;
        if (newHand.level === 0 && lastHand.level > 0) return false;

        // B. ç‚¸å¼¹ä¹‹é—´ (Level æ¯”è¾ƒ)
        if (newHand.level > 0 && lastHand.level > 0) {
            if (newHand.level > lastHand.level) return true;
            if (newHand.level < lastHand.level) return false;

            // åŒçº§åˆ«æ¯”è¾ƒ
            if (newHand.type === '510K_PURE') {
                return newHand.val > lastHand.val;
            }

            if (newHand.type === 'BOMB_STD') {
                // å…ˆæ¯”å¼ æ•°ï¼Œå†æ¯”ç‚¹æ•°
                if (newHand.len > lastHand.len) return true;
                if (newHand.len < lastHand.len) return false;
                return newHand.val > lastHand.val;
            }
            
            // æ‚è‰²510K ä¸èƒ½äº’ç®¡
            if (newHand.type === '510K_MIXED') return false;

            if (newHand.type === 'BOMB_MAX') return newHand.val > lastHand.val;
            
            return false;
        }

        // C. éç‚¸å¼¹ä¹‹é—´ (åŒç‰Œå‹æ¯”è¾ƒ)
        if (newHand.type === lastHand.type) {
            // è¿å¯¹å’Œé£æœºå¿…é¡»å¼ æ•°ç›¸åŒ
            if ((newHand.type === 'LIANDUI' || newHand.type === 'AIRPLANE') && newHand.len !== lastHand.len) return false;
            
            // å…¶ä»–ç‰Œå‹ä¹Ÿä¸€èˆ¬è¦æ±‚å¼ æ•°ç›¸åŒ
            if (newCards.length !== lastCards.length) return false;
            
            // è¿å¯¹æ¯”è¾ƒèµ·å§‹ç‚¹æ•°
            if (newHand.type === 'LIANDUI') {
                return newHand.val > lastHand.val; 
            }
            
            return newHand.val > lastHand.val;
        }

        return false;
    }
};

export default GameRules;

================================================================================
FILE PATH: client\src\utils\smartHint.js
================================================================================
/**
 * æ™ºèƒ½æç¤ºé€»è¾‘
 * æ ¹æ®æ‰‹ç‰Œå’Œä¸Šå®¶ç‰Œå‹ï¼Œè®¡ç®—æ‰€æœ‰å¯è¡Œè§£ï¼Œå¹¶æŒ‰ä¼˜åŠ£æ’åº
 * * [ä¿®æ”¹è®°å½•]
 * 1. è¿‡æ»¤æ‰äº† 510K ç‰Œå‹ï¼Œæç¤ºä¸å†æ¨è 510Kã€‚
 * 2. ä¼˜åŒ–è‡ªç”±å‡ºç‰Œé€»è¾‘ï¼šä¼˜å…ˆå‡ºâ€œçœŸæ­£çš„å•å¼ åºŸç‰Œâ€ï¼Œä¸å†ä¼˜å…ˆæ‹†å¯¹å­å‡ºå•å¼ ã€‚
 */
import GameRules from './gameRules.js';

const SmartHint = {
    
    /**
     * è·å–ç»è¿‡æ™ºèƒ½æ’åºçš„æç¤ºåˆ—è¡¨
     * @param {Array} hand æ‰‹ç‰Œæ•°ç»„
     * @param {Array} lastPlayedCards ä¸Šå®¶å‡ºçš„ç‰Œ (ç©ºæ•°ç»„ä»£è¡¨é¦–å‡º)
     * @param {Number} deckCount ç‰Œå‰¯æ•°
     * @returns {Array[]} å€™é€‰ç‰Œå‹æ•°ç»„
     */
    getSortedHints: (hand, lastPlayedCards, deckCount = 2) => {
        // 1. è·å–æ‰€æœ‰åˆæ³•è§£
        let solutions = SmartHint.findAllSolutions(hand, lastPlayedCards, deckCount);
        if (!solutions || solutions.length === 0) return [];

        // [ä¿®æ”¹] è¿‡æ»¤æ‰ 510K ç‰Œå‹ (æç¤ºå’Œæ‰˜ç®¡ä¸ä¼šè‡ªåŠ¨å‡º 510K)
        solutions = solutions.filter(sol => {
            const type = GameRules.analyze(sol, deckCount).type;
            return type !== '510K_PURE' && type !== '510K_MIXED';
        });

        if (solutions.length === 0) return [];

        // 2. é¢„åˆ†ææ‰‹ç‰Œä¸­çš„ç‚¸å¼¹ï¼ˆç”¨äºåˆ¤æ–­å‡ºç‰Œæ˜¯å¦æ‹†äº†ç‚¸å¼¹ï¼‰
        const myBombs = SmartHint.findAllBombsInHand(hand, deckCount);
        const bombCardsSet = new Set();
        myBombs.forEach(b => b.cards.forEach(c => bombCardsSet.add(c)));

        // 3. åˆ†æä¸Šå®¶ç‰Œå‹
        const lastAnalysis = (lastPlayedCards && lastPlayedCards.length > 0)
            ? GameRules.analyze(lastPlayedCards, deckCount)
            : null;
        const lastIsBomb = lastAnalysis ? lastAnalysis.level > 0 : false;

        // [æ–°å¢] ç»Ÿè®¡æ‰‹ç‰Œä¸­æ¯ä¸ªç‚¹æ•°çš„æ•°é‡ï¼Œç”¨äºè¯†åˆ«â€œåºŸç‰Œâ€
        const handCounts = {};
        hand.forEach(c => {
            const p = GameRules.getPoint(c);
            handCounts[p] = (handCounts[p] || 0) + 1;
        });

        // 4. å¯¹æ¯ä¸ªæ–¹æ¡ˆè®¡ç®— Cost (ä»£ä»·è¶Šä½è¶Šä¼˜å…ˆ)
        const scoredSolutions = solutions.map(sol => {
            const analysis = GameRules.analyze(sol, deckCount);
            let cost = 0;
            
            // --- A. åŸºç¡€åˆ†è®¡ç®— ---
            if (analysis.level > 0) {
                // æ˜¯ç‚¸å¼¹ï¼šLevel æƒé‡æœ€å¤§ï¼Œå…¶æ¬¡æ˜¯å¼ æ•°ï¼Œæœ€åæ˜¯ç‚¹æ•°
                cost += analysis.level * 100000;
                
                // æ™®é€šç‚¸å¼¹å’Œè‡³å°Šç‚¸å¼¹ï¼Œå¼ æ•°æƒé‡å¾ˆé«˜
                if (analysis.type === 'BOMB_STD' || analysis.type === 'BOMB_MAX') {
                    cost += analysis.len * 1000;
                }
                
                cost += analysis.val; // æœ€åæ‰æ˜¯ç‚¹æ•°å¾®è°ƒ
            } else {
                // æ™®é€šç‰Œå‹ (å•å¼ ã€å¯¹å­ç­‰)ï¼šç›´æ¥æŒ‰ç‚¹æ•°æ’
                cost += analysis.val;
            }

            // --- B. æ‹†ç‚¸å¼¹æƒ©ç½š ---
            const isMoveBomb = analysis.level > 0;
            if (!isMoveBomb) {
                // å¦‚æœå‡ºçš„ä¸æ˜¯ç‚¸å¼¹ï¼Œæ£€æŸ¥æ˜¯å¦ç”¨äº†ç‚¸å¼¹é‡Œçš„ç‰Œ
                const breaksBomb = sol.some(c => bombCardsSet.has(c));
                if (breaksBomb) {
                    cost += 2000000; // ä¸¥ç¦æ‹†ç‚¸å¼¹
                }
            }

            // --- C. ç‚¸å¼¹å‹åˆ¶åˆ¤æ–­ (é¿å…å¤§æå°ç”¨) ---
            if (isMoveBomb && !lastIsBomb && lastAnalysis) {
                // ä¸Šå®¶ä¸æ˜¯ç‚¸å¼¹ï¼Œæˆ‘ç”¨ç‚¸å¼¹ç®¡ -> ç•¥äºï¼Œé™¤éè¿™æ˜¯æœ€åä¸€æ‰‹
                cost += 500; 
            }

            // --- D. è‡ªç”±å‡ºç‰Œ (é¦–å‡º) ç­–ç•¥ä¼˜åŒ– ---
            if (!lastAnalysis) {
                if (analysis.type === 'AIRPLANE') cost -= 200;
                else if (analysis.type === 'LIANDUI') cost -= 150;
                else if (analysis.type === 'TRIPLE') cost -= 100;
                else if (analysis.type === 'PAIR') cost -= 50; // å¯¹å­ä¼˜æƒ  50
                
                // [å…³é”®ä¿®æ”¹] å•å¼ é€»è¾‘ç»†åŒ–
                else if (analysis.type === 'SINGLE') {
                    const countInHand = handCounts[analysis.val] || 0;
                    
                    if (countInHand === 1) {
                        // çœŸæ­£çš„åºŸç‰Œï¼ˆæ‰‹é‡Œåªæœ‰è¿™ä¸€å¼ ï¼‰ï¼šç»™äºˆæé«˜ä¼˜å…ˆçº§
                        // è®¾å®šä¸º -80ï¼Œæ¯”å¯¹å­çš„ -50 æ›´å°ï¼Œæ‰€ä»¥ä¼šä¼˜å…ˆå‡ºå•å¼ åºŸç‰Œ
                        cost -= 80; 
                    } else {
                        // å¦‚æœ countInHand > 1ï¼Œè¯´æ˜æ˜¯æ‹†äº†å¯¹å­æˆ–ä¸‰å¼ æ‰“çš„å•ç‰Œ
                        // ä¸ç»™äºˆå‡åˆ†ä¼˜æƒ ï¼ŒCost = val (æ­£æ•°)
                        // è¿™æ · Cost(-80) < Cost(Pair -50) < Cost(Single positive)
                        // é¡ºåºå˜æˆï¼šåºŸç‰Œ > å¯¹å­ > æ‹†å¼€çš„å•ç‰Œ
                    }
                }
                
                // é¦–å‡ºç‚¸å¼¹æƒ©ç½š
                if (isMoveBomb) {
                    // å¦‚æœè¿™æ‰‹ç‰Œå‡ºå®Œå°±è·‘äº†ï¼Œé‚£å°±æ— è§† Cost ä¼˜å…ˆå‡º
                    if (hand.length === sol.length) cost = -9999999;
                    else cost += 8000; // é¿å…èµ·æ‰‹æ‰”ç‚¸å¼¹
                }
            }

            return { sol, cost };
        });

        // 5. æ’åºï¼šä»£ä»·å°çš„åœ¨å‰
        scoredSolutions.sort((a, b) => a.cost - b.cost);

        return scoredSolutions.map(item => item.sol);
    },

    // è¾…åŠ©ï¼šå¿«é€Ÿæ‰¾å‡ºæ‰€æœ‰ç‚¸å¼¹ (çº¯å‡€ç‰ˆï¼Œä¸åŒ…å«å…¶ä»–ç‰Œå‹é€»è¾‘)
    findAllBombsInHand: (hand, deckCount) => {
        // å…ˆå¯¹ç‰Œè¿›è¡Œåˆ†ç»„
        const grouped = {};
        hand.forEach(c => {
            const p = GameRules.getPoint(c);
            if (!grouped[p]) grouped[p] = [];
            grouped[p].push(c);
        });
        
        // è·å–æ‰€æœ‰å»é‡åçš„ç‚¹æ•°
        const points = Object.keys(grouped).map(Number).sort((a, b) => a - b);
        
        // ç›´æ¥è°ƒç”¨æ ¸å¿ƒç‚¸å¼¹æŸ¥æ‰¾é€»è¾‘ï¼Œä¸éœ€è¦ lastPlayedCards å‚æ•°
        return SmartHint.coreFindBombs(hand, grouped, points, deckCount, 0, 0);
    },

    /**
     * [æ ¸å¿ƒé€»è¾‘] ä»…æŸ¥æ‰¾ç‚¸å¼¹
     * æå–å‡ºæ¥ä¾› findAllSolutions å’Œ findAllBombsInHand å¤ç”¨
     */
    coreFindBombs: (hand, grouped, uniquePoints, deckCount, minLevel = 0, minVal = 0) => {
        const bombList = [];

        // A. 510K (Level 1 & 2)
        if (minLevel <= 2) {
            const fives = grouped[5] || [];
            const tens = grouped[10] || [];
            const kings = grouped[13] || []; // K
            
            if (fives.length > 0 && tens.length > 0 && kings.length > 0) {
                // å¯»æ‰¾çº¯è‰²
                let foundPure = false;
                for (let f of fives) {
                    for (let t of tens) {
                        for (let k of kings) {
                            const s1 = GameRules.getSuit(f);
                            const s2 = GameRules.getSuit(t);
                            const s3 = GameRules.getSuit(k);
                            if (s1 === s2 && s2 === s3) {
                                if (2 > minLevel || (2 === minLevel && 100 > minVal)) { 
                                    bombList.push({ cards: [f, t, k], level: 2, val: 999 }); 
                                    foundPure = true;
                                }
                            }
                        }
                        if(foundPure) break;
                    }
                    if(foundPure) break;
                }
                
                // æ‚è‰² (å¦‚æœæ²¡æ‰¾åˆ°çº¯è‰²ï¼Œæˆ–è€…ä¸é™åˆ¶)
                if (!foundPure && minLevel <= 1) {
                    bombList.push({ cards: [fives[0], tens[0], kings[0]], level: 1, val: 1 });
                }
            }
        }

        // B. æ™®é€šç‚¸å¼¹ (Level 3)
        for (let p of uniquePoints) {
            const count = grouped[p].length;
            if (count >= 4) {
                if (minLevel < 3 || (minLevel === 3 && p > minVal)) {
                    bombList.push({ cards: grouped[p], level: 3, val: p });
                }
            }
        }

        // C. å¤©ç‹ç‚¸ (Level 4)
        const jokers = hand.filter(c => GameRules.getPoint(c) >= 16);
        if (jokers.length === deckCount * 2) {
            if (minLevel < 4) {
                bombList.push({ cards: jokers, level: 4, val: 999 });
            }
        }

        return bombList;
    },

    // æ‰¾å‡ºæ‰€æœ‰å¯è¡Œçš„å‡ºç‰Œæ–¹æ¡ˆ
    findAllSolutions: (hand, lastPlayedCards, deckCount) => {
        try {
            const solutions = [];
            
            // æ•´ç†æ‰‹ç‰Œ
            const grouped = {};
            const points = [];
            hand.forEach(c => {
                const p = GameRules.getPoint(c);
                if (!grouped[p]) {
                    grouped[p] = [];
                    points.push(p);
                }
                grouped[p].push(c);
            });
            // æ’åºå»é‡åçš„ç‚¹æ•°
            points.sort((a, b) => a - b); 
            const uniquePoints = [...new Set(points)].sort((a,b)=>a-b);

            // --- åœºæ™¯ 1: è‡ªç”±å‡ºç‰Œ (First Play) ---
            if (!lastPlayedCards || lastPlayedCards.length === 0) {
                // 1. å•å¼ 
                if (uniquePoints.length > 0) solutions.push([grouped[uniquePoints[0]][0]]);
                // 2. å¯¹å­
                for (let p of uniquePoints) {
                    if (grouped[p].length >= 2) {
                        solutions.push(grouped[p].slice(0, 2));
                        // ä¸ breakï¼Œå…è®¸æ‰¾å¤§ä¸€ç‚¹çš„å¯¹å­ï¼Œè®© Cost å‡½æ•°å†³å®š
                    }
                }
                // 3. ä¸‰å¼ 
                for (let p of uniquePoints) {
                    if (grouped[p].length >= 3) {
                        solutions.push(grouped[p].slice(0, 3));
                    }
                }
                // 4. è¿å¯¹ (ç®€å•æ£€æµ‹)
                for(let i=0; i<uniquePoints.length-1; i++) {
                    const p1 = uniquePoints[i];
                    const p2 = uniquePoints[i+1];
                    if (p2 === p1 + 1 && p2 < 15 && grouped[p1].length >=2 && grouped[p2].length >= 2) {
                         solutions.push([...grouped[p1].slice(0,2), ...grouped[p2].slice(0,2)]);
                    }
                }

                // 5. ç‚¸å¼¹ (è°ƒç”¨æ ¸å¿ƒé€»è¾‘)
                const bombs = SmartHint.coreFindBombs(hand, grouped, uniquePoints, deckCount, -1, -1);
                bombs.forEach(b => solutions.push(b.cards));
                
                // å¦‚æœä»¥ä¸Šéƒ½æ²¡ç”Ÿæˆ (æ¯”å¦‚åªæœ‰å•å¼ )ï¼ŒæŠŠå‰3å°çš„å•å¼ åŠ å…¥
                if (solutions.length === 1 && solutions[0].length === 1) {
                    for(let i=1; i<Math.min(uniquePoints.length, 3); i++) {
                        solutions.push([grouped[uniquePoints[i]][0]]);
                    }
                }

                return solutions;
            }

            // --- åœºæ™¯ 2: ç®¡ç‰Œ (Beat It) ---
            const lastState = GameRules.analyze(lastPlayedCards, deckCount);
            if (lastState.type === 'INVALID') return [];

            // ç­–ç•¥ A: åŒç‰Œå‹å‹åˆ¶
            if (['SINGLE', 'PAIR', 'TRIPLE'].includes(lastState.type)) {
                const countNeeded = lastState.type === 'SINGLE' ? 1 : (lastState.type === 'PAIR' ? 2 : 3);
                for (let p of uniquePoints) {
                    if (p > lastState.val && grouped[p].length >= countNeeded) {
                        solutions.push(grouped[p].slice(0, countNeeded));
                    }
                }
            }
            
            // è¿å¯¹å‹åˆ¶
            if (lastState.type === 'LIANDUI') {
                const len = lastState.len;
                const pairCount = len / 2;
                const startVal = lastState.val + 1; 
                
                for(let v = startVal; v <= 14; v++) { 
                    let hasSequence = true;
                    let tempSol = [];
                    for(let k=0; k<pairCount; k++) {
                        const checkP = v + k;
                        if (!grouped[checkP] || grouped[checkP].length < 2) {
                            hasSequence = false;
                            break;
                        }
                        tempSol.push(...grouped[checkP].slice(0, 2));
                    }
                    if (hasSequence) solutions.push(tempSol);
                }
            }
            
            // é£æœºå‹åˆ¶
            if (lastState.type === 'AIRPLANE') {
                 const len = lastState.len;
                 const tripleCount = len / 3;
                 const startVal = lastState.val + 1;
                 
                 for(let v = startVal; v <= 14; v++) {
                    let hasSequence = true;
                    let tempSol = [];
                    for(let k=0; k<tripleCount; k++) {
                        const checkP = v + k;
                        if (!grouped[checkP] || grouped[checkP].length < 3) {
                            hasSequence = false;
                            break;
                        }
                        tempSol.push(...grouped[checkP].slice(0, 3));
                    }
                    if (hasSequence) solutions.push(tempSol);
                 }
            }

            // ç­–ç•¥ C: ç‚¸å¼¹å‹åˆ¶
            const currentLevel = lastState.level || 0;
            const currentVal = lastState.val || 0;
            
            // è°ƒç”¨æ ¸å¿ƒé€»è¾‘
            const bombs = SmartHint.coreFindBombs(hand, grouped, uniquePoints, deckCount, 0, 0);
            
            bombs.forEach(b => {
                if (GameRules.canPlay(b.cards, lastPlayedCards, deckCount)) {
                    solutions.push(b.cards);
                }
            });

            return solutions;
        } catch (e) {
            console.error("SmartHint findAllSolutions error:", e);
            return [];
        }
    }
};

export default SmartHint;

================================================================================
FILE PATH: client\src\utils\SoundManager.js
================================================================================
/**
 * ç®€æ˜“ Web Audio API éŸ³æ•ˆç®¡ç†å™¨
 */
const SoundManager = {
    ctx: null,

    init: () => {
        if (!SoundManager.ctx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            SoundManager.ctx = new AudioContext();
        }
    },

    play: (type) => {
        try {
            if (SoundManager.ctx && SoundManager.ctx.state === 'suspended') {
                SoundManager.ctx.resume();
            }
            if (!SoundManager.ctx) SoundManager.init();

            switch (type) {
                case 'deal': 
                    SoundManager.beep(800, 0.05, 'sine');
                    break;
                case 'play': 
                    SoundManager.noise(0.1); 
                    break;
                case 'win': 
                    SoundManager.arpeggio([523.25, 659.25, 783.99, 1046.50], 0.1);
                    break;
                case 'lose': 
                    SoundManager.beep(150, 0.3, 'sawtooth');
                    break;
                case 'alert': 
                    SoundManager.beep(880, 0.1, 'square');
                    setTimeout(() => SoundManager.beep(880, 0.1, 'square'), 150);
                    break;
                case 'tick': 
                    SoundManager.beep(600, 0.05, 'sine');
                    break;
                case 'pass': 
                    SoundManager.beep(200, 0.15, 'triangle');
                    break;
                default:
                    break;
            }
        } catch (e) {
            console.warn('Audio play failed:', e);
        }
    },

    beep: (freq, duration, type = 'sine') => {
        const ctx = SoundManager.ctx;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        gain.gain.setValueAtTime(0.1, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + duration);
    },

    noise: (duration) => {
        const ctx = SoundManager.ctx;
        const bufferSize = ctx.sampleRate * duration;
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.2, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
        noise.connect(gain);
        gain.connect(ctx.destination);
        noise.start();
    },

    arpeggio: (freqs, interval) => {
        freqs.forEach((f, i) => {
            setTimeout(() => SoundManager.beep(f, 0.2, 'triangle'), i * interval * 1000);
        });
    }
};

export default SoundManager;

================================================================================
FILE PATH: client\vite.config.js
================================================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})


================================================================================
FILE PATH: server\config\constants.js
================================================================================
// ==========================================
// æ¸¸æˆæœåŠ¡ç«¯å…¨å±€é…ç½®æ–‡ä»¶
// æ–¹ä¾¿åç»­è°ƒæ•´æ¸¸æˆå¹³è¡¡æ€§ã€ä¿®æ”¹å¸¸é©»æˆ¿é—´å‚æ•°
// ==========================================

// å¸¸é©»æˆ¿é—´é…ç½® (æœåŠ¡å™¨é‡å¯åä¼šè‡ªåŠ¨åˆ›å»ºè¿™äº›æˆ¿é—´)
const PERMANENT_ROOMS = {
    '888': { 
        deckCount: 2,           // å‡ å‰¯ç‰Œ
        maxPlayers: 4,          // æœ€å¤§äººæ•°
        targetScore: 1000,      // ç›®æ ‡åˆ†æ•°
        turnTimeout: 60000,     // å‡ºç‰Œæ—¶é—´(æ¯«ç§’)
        showCardCountMode: 1,   // å‰©ç‰Œæ˜¾ç¤ºæ¨¡å¼
        isTeamMode: true,      // æ˜¯å¦ç»„é˜Ÿ
        enableRankPenalty: true, // æ’åèµç½š
        rankPenaltyScores: [50, 20], // èµç½šåˆ†æ•°é…ç½®
        shuffleStrategy: 'CLASSIC' // æ´—ç‰Œç­–ç•¥: CLASSIC(éšæœº), NO_SHUFFLE(ä¸æ´—ç‰Œ)
    },
    '666': { 
        deckCount: 3, 
        maxPlayers: 6, 
        targetScore: 1000, 
        turnTimeout: 60000,
        showCardCountMode: 1,
        isTeamMode: true, 
        enableRankPenalty: true,
        rankPenaltyScores: [50, 20],
        shuffleStrategy: 'NO_SHUFFLE'
    }
};

// å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æ›´å¤šå…¨å±€å¸¸é‡
const GLOBAL_CONFIG = {
    SERVER_PORT: 3001,
    // æ¯”å¦‚ï¼šBot çš„æ€è€ƒæ—¶é—´æ³¢åŠ¨èŒƒå›´
    BOT_THINK_MIN: 1000,
    BOT_THINK_MAX: 2000
};

module.exports = {
    PERMANENT_ROOMS,
    GLOBAL_CONFIG
};

================================================================================
FILE PATH: server\game\BotLogic.js
================================================================================
const CardRules = require('./CardRules');

const BotLogic = {
    WEIGHTS: {
        BREAK_BOMB_PENALTY: 100, // æ‹†ç‚¸å¼¹æƒ©ç½š(Botå†³ç­–ç”¨)
        PLAY_TRASH_BONUS: 10,    // å‡ºåºŸç‰Œå¥–åŠ±(Botå†³ç­–ç”¨)
    },

    /**
     * [æ–°å¢/æ ¸å¿ƒ] è·å–ç»è¿‡æ™ºèƒ½æ’åºçš„æç¤ºåˆ—è¡¨
     * @param {Array} hand æ‰‹ç‰Œ
     * @param {Array} lastPlayedCards ä¸Šå®¶å‡ºçš„ç‰Œ
     * @param {Number} deckCount ç‰Œå‰¯æ•°
     * @param {Object} context ç­–ç•¥ä¸Šä¸‹æ–‡ { mode: 'SMART'|'THRIFTY'|'AFK', isTeammate: boolean, pendingScore: number }
     */
    getSortedHints: (hand, lastPlayedCards, deckCount, context = {}) => {
        const { mode = 'SMART', isTeammate = false, pendingScore = 0 } = context;

        // --- ç­–ç•¥å‰ç½®æ‹¦æˆª (èººå¹³æ¨¡å¼) ---
        // å¦‚æœæ˜¯ AFK æ¨¡å¼ï¼Œä¸”ä¸æ˜¯é¦–å‡ºï¼ˆå³éœ€è¦ç®¡åˆ«äººçš„ç‰Œï¼‰ï¼Œç›´æ¥è¿”å›ç©ºæ•°ç»„ï¼ˆPassï¼‰
        if (mode === 'AFK' && lastPlayedCards && lastPlayedCards.length > 0) {
            return [];
        }

        // 1. è·å–æ‰€æœ‰åˆæ³•è§£
        let solutions = BotLogic.findAllSolutions(hand, lastPlayedCards, deckCount);
        if (!solutions || solutions.length === 0) return [];

        // [ä¿®æ”¹] è¿‡æ»¤æ‰ 510K (æ‰˜ç®¡/Bot ä¸è‡ªåŠ¨æ‰“å‡º 510K)
        solutions = solutions.filter(sol => {
            const type = CardRules.analyze(sol, deckCount).type;
            return type !== '510K_PURE' && type !== '510K_MIXED';
        });

        // --- ç­–ç•¥è¿‡æ»¤ (SMART & THRIFTY) ---
        solutions = solutions.filter(sol => {
            const analysis = CardRules.analyze(sol, deckCount);
            const isBomb = analysis.level > 0;

            // æ¨¡å¼1: æ™ºèƒ½æ¨¡å¼ (é»˜è®¤) - é˜Ÿå‹å‡ºçš„ç‰Œï¼Œä¸ç”¨ç‚¸å¼¹ç®¡
            if (mode === 'SMART' && isTeammate && isBomb) {
                return false; 
            }

            // æ¨¡å¼2: çœé’±æ¨¡å¼ - åœºä¸Šæ²¡åˆ†ï¼Œä¸ç”¨ç‚¸å¼¹ç®¡
            if (mode === 'THRIFTY' && pendingScore === 0 && isBomb) {
                // æ³¨æ„ï¼šå¦‚æœæ˜¯é¦–å‡º(lastPlayedCardsä¸ºç©º)ï¼Œé€šå¸¸pendingScoreä¹Ÿæ˜¯0ï¼Œä½†é¦–å‡ºå¯ä»¥ç”¨ç‚¸å¼¹
                // æ‰€ä»¥é™å®šä¸ºç®¡ç‰Œé˜¶æ®µ (lastPlayedCards ä¸ä¸ºç©º)
                if (lastPlayedCards && lastPlayedCards.length > 0) {
                    return false;
                }
            }

            return true;
        });

        if (solutions.length === 0) return [];

        // 2. åˆ†ææ‰‹ç‰Œä¸­çš„ç‚¸å¼¹ï¼ˆç”¨äºåˆ¤æ–­æ˜¯å¦æ‹†äº†ç‚¸å¼¹ï¼‰
        const myBombs = BotLogic.findAllBombsInHand(hand, deckCount);
        const bombCardsSet = new Set();
        myBombs.forEach(b => b.cards.forEach(c => bombCardsSet.add(c)));

        // 3. åˆ†æä¸Šå®¶ç‰Œå‹
        const lastAnalysis = (lastPlayedCards && lastPlayedCards.length > 0)
            ? CardRules.analyze(lastPlayedCards, deckCount)
            : null;
        const lastIsBomb = lastAnalysis ? lastAnalysis.level > 0 : false;

        // [æ–°å¢] ç»Ÿè®¡æ‰‹ç‰Œä¸­æ¯ä¸ªç‚¹æ•°çš„æ•°é‡ï¼Œç”¨äºè¯†åˆ«â€œåºŸç‰Œâ€
        const handCounts = {};
        hand.forEach(c => {
            const p = CardRules.getPoint(c);
            handCounts[p] = (handCounts[p] || 0) + 1;
        });

        // 4. å¯¹æ¯ä¸ªæ–¹æ¡ˆè®¡ç®— Cost (ä»£ä»·è¶Šä½è¶Šä¼˜å…ˆ)
        const scoredSolutions = solutions.map(sol => {
            const analysis = CardRules.analyze(sol, deckCount);
            let cost = 0;
            
            // --- A. åŸºç¡€åˆ† ---
            if (analysis.level > 0) {
                // ç‚¸å¼¹ï¼šLevel æƒé‡ > Length æƒé‡ > Value æƒé‡
                cost += analysis.level * 100000;
                
                if (analysis.type === 'BOMB_STD' || analysis.type === 'BOMB_MAX') {
                    cost += analysis.len * 1000;
                }
                
                cost += analysis.val;
            } else {
                // æ™®é€šç‰Œï¼šç‚¹æ•°è¶Šå°è¶Šå¥½
                cost += analysis.val;
            }

            // --- B. æ‹†ç‚¸å¼¹åˆ¤æ–­ ---
            const isMoveBomb = analysis.level > 0;
            if (!isMoveBomb) {
                // å¦‚æœå‡ºçš„ä¸æ˜¯ç‚¸å¼¹ï¼Œæ£€æŸ¥æ˜¯å¦ç”¨äº†ç‚¸å¼¹é‡Œçš„ç‰Œ
                const breaksBomb = sol.some(c => bombCardsSet.has(c));
                if (breaksBomb) {
                    cost += 2000000; // Bot ä¸¥ç¦æ‹†ç‚¸å¼¹
                }
            }

            // --- C. ç‚¸å¼¹å‹åˆ¶åˆ¤æ–­ ---
            if (isMoveBomb && !lastIsBomb && lastAnalysis) {
                // ä¸Šå®¶ä¸æ˜¯ç‚¸å¼¹ï¼Œæˆ‘ç”¨ç‚¸å¼¹ç®¡ -> äº
                if (hand.length === sol.length) cost = -9999999;
                else cost += 1000; 
            }

            // --- D. è‡ªç”±å‡ºç‰Œ (é¦–å‡º) åå¥½ ---
            if (!lastAnalysis) {
                if (analysis.type === 'AIRPLANE') cost -= 200;
                else if (analysis.type === 'LIANDUI') cost -= 150;
                else if (analysis.type === 'TRIPLE') cost -= 100;
                else if (analysis.type === 'PAIR') cost -= 50;
                
                // [å…³é”®ä¿®æ”¹] å•å¼ é€»è¾‘ç»†åŒ– (åºŸç‰Œä¼˜å…ˆ)
                else if (analysis.type === 'SINGLE') {
                    const countInHand = handCounts[analysis.val] || 0;
                    if (countInHand === 1) {
                        // çœŸæ­£çš„åºŸç‰Œï¼ŒCost æ¯”å¯¹å­è¿˜ä½ï¼Œä¼˜å…ˆæ‰“å‡º
                        cost -= 80;
                    } else {
                        // æ‹†å¯¹å­å‡ºçš„å•ç‰Œï¼ŒCost = val (æ­£æ•°)ï¼Œä¼˜å…ˆçº§å¾ˆä½
                    }
                }

                // ç‚¸å¼¹å°½é‡ç•™åˆ°æœ€åå‡º
                if (isMoveBomb) {
                    if (hand.length === sol.length) cost = -9999999;
                    else cost += 8000; 
                }
            }

            return { sol, cost };
        });

        // 5. æ’åºï¼šä»£ä»·å°çš„åœ¨å‰
        scoredSolutions.sort((a, b) => a.cost - b.cost);

        return scoredSolutions.map(item => item.sol);
    },

    // [æ™ºèƒ½å†³ç­–å…¥å£]
    // å¢åŠ  context å‚æ•°
    decideMove: (hand, lastPlayedCards, deckCount, context = {}) => {
        try {
            // å¦‚æœåªå‰©ä¸€æ‰‹ç‰Œï¼Œç›´æ¥æ¢­å“ˆ
            const analysis = CardRules.analyze(hand, deckCount);
            if (analysis.type !== 'INVALID') {
                if (!lastPlayedCards || lastPlayedCards.length === 0) return hand;
                if (CardRules.canPlay(hand, lastPlayedCards, deckCount)) return hand;
            }

            const solutions = BotLogic.getSortedHints(hand, lastPlayedCards, deckCount, context);
            if (solutions.length === 0) return null;

            // getSortedHints å·²ç»æ’å¥½åºäº†ï¼Œç›´æ¥å–ç¬¬ä¸€ä¸ªæœ€ä¼˜è§£
            return solutions[0];
        } catch (e) {
            console.error("BotLogic decideMove error:", e);
            return null;
        }
    },

    // è¾…åŠ©ï¼šæ‰¾å‡ºæ‰€æœ‰ç‚¸å¼¹
    findAllBombsInHand: (hand, deckCount) => {
        const bombs = [];
        // è°ƒç”¨ findAllSolutions æŸ¥æ‰¾æ‰€æœ‰ç‚¸å¼¹ (level >= 1)
        const allSols = BotLogic.findAllSolutions(hand, [], deckCount);
        allSols.forEach(sol => {
            const analysis = CardRules.analyze(sol, deckCount);
            if (analysis.level > 0) {
                bombs.push({ cards: sol, ...analysis });
            }
        });
        return bombs;
    },

    // æ‰¾å‡ºæ‰€æœ‰å¯è¡Œçš„å‡ºç‰Œæ–¹æ¡ˆ
    findAllSolutions: (hand, lastPlayedCards, deckCount) => {
        try {
            const solutions = [];
            
            const grouped = {};
            const points = [];
            hand.forEach(c => {
                const p = CardRules.getPoint(c);
                if (!grouped[p]) {
                    grouped[p] = [];
                    points.push(p);
                }
                grouped[p].push(c);
            });
            points.sort((a, b) => a - b); 
            const uniquePoints = [...new Set(points)].sort((a,b)=>a-b);

            const findAllBombs = (minLevel = 0, minVal = 0) => {
                const bombList = [];

                // A. 510K (Level 1 & 2)
                if (minLevel <= 2) {
                    const fives = grouped[5] || [];
                    const tens = grouped[10] || [];
                    const kings = grouped[13] || []; // K
                    
                    if (fives.length > 0 && tens.length > 0 && kings.length > 0) {
                        let foundPure = false;
                        for (let f of fives) {
                            for (let t of tens) {
                                for (let k of kings) {
                                    const s1 = CardRules.getSuit(f);
                                    const s2 = CardRules.getSuit(t);
                                    const s3 = CardRules.getSuit(k);
                                    if (s1 === s2 && s2 === s3) {
                                        if (2 > minLevel || (2 === minLevel && 100 > minVal)) { 
                                            bombList.push({ cards: [f, t, k], level: 2, val: 999 }); 
                                            foundPure = true;
                                        }
                                    }
                                }
                                if(foundPure) break;
                            }
                            if(foundPure) break;
                        }
                        
                        if (!foundPure && minLevel <= 1) {
                            bombList.push({ cards: [fives[0], tens[0], kings[0]], level: 1, val: 1 });
                        }
                    }
                }

                // B. æ™®é€šç‚¸å¼¹ (Level 3)
                for (let p of uniquePoints) {
                    const count = grouped[p].length;
                    if (count >= 4) {
                        if (minLevel < 3 || (minLevel === 3 && p > minVal)) {
                            bombList.push({ cards: grouped[p], level: 3, val: p });
                        }
                    }
                }

                // C. å¤©ç‹ç‚¸ (Level 4)
                const jokers = hand.filter(c => CardRules.getPoint(c) >= 16);
                if (jokers.length === deckCount * 2) {
                    if (minLevel < 4) {
                        bombList.push({ cards: jokers, level: 4, val: 999 });
                    }
                }

                return bombList;
            };

            // --- åœºæ™¯ 1: è‡ªç”±å‡ºç‰Œ (First Play) ---
            if (!lastPlayedCards || lastPlayedCards.length === 0) {
                // 1. å•å¼ 
                if (uniquePoints.length > 0) solutions.push([grouped[uniquePoints[0]][0]]);
                // 2. å¯¹å­
                for (let p of uniquePoints) {
                    if (grouped[p].length >= 2) {
                        solutions.push(grouped[p].slice(0, 2));
                        // ä¸ breakï¼Œä¿ç•™æ›´å¤šé€‰æ‹©
                    }
                }
                // 3. ä¸‰å¼ 
                for (let p of uniquePoints) {
                    if (grouped[p].length >= 3) {
                        solutions.push(grouped[p].slice(0, 3));
                    }
                }
                
                // 4. è¿å¯¹ (æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„2è¿å¯¹)
                for(let i=0; i<uniquePoints.length-1; i++) {
                    const p1 = uniquePoints[i];
                    const p2 = uniquePoints[i+1];
                    if (p2 === p1 + 1 && p2 < 15 && grouped[p1].length >= 2 && grouped[p2].length >= 2) {
                         solutions.push([...grouped[p1].slice(0,2), ...grouped[p2].slice(0,2)]);
                    }
                }

                // 5. é£æœº (æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„2è¿ä¸‰å¼ )
                for(let i=0; i<uniquePoints.length-1; i++) {
                    const p1 = uniquePoints[i];
                    const p2 = uniquePoints[i+1];
                    if (p2 === p1 + 1 && p2 < 15 && grouped[p1].length >= 3 && grouped[p2].length >= 3) {
                         solutions.push([...grouped[p1].slice(0,3), ...grouped[p2].slice(0,3)]);
                    }
                }

                // 6. ç‚¸å¼¹ (è°ƒç”¨æ ¸å¿ƒé€»è¾‘)
                const bombs = findAllBombs(-1, -1);
                bombs.forEach(b => solutions.push(b.cards));
                
                // å…œåº•
                if (solutions.length < 3) {
                    for(let i=0; i<Math.min(uniquePoints.length, 3); i++) {
                        solutions.push([grouped[uniquePoints[i]][0]]);
                    }
                }

                return solutions;
            }

            // --- åœºæ™¯ 2: ç®¡ç‰Œ (Beat It) ---
            const lastState = CardRules.analyze(lastPlayedCards, deckCount);
            if (lastState.type === 'INVALID') return [];

            // ç­–ç•¥ A: åŒç‰Œå‹å‹åˆ¶
            if (['SINGLE', 'PAIR', 'TRIPLE'].includes(lastState.type)) {
                const countNeeded = lastState.type === 'SINGLE' ? 1 : (lastState.type === 'PAIR' ? 2 : 3);
                for (let p of uniquePoints) {
                    if (p > lastState.val && grouped[p].length >= countNeeded) {
                        solutions.push(grouped[p].slice(0, countNeeded));
                    }
                }
            }
            
            // è¿å¯¹å‹åˆ¶
            if (lastState.type === 'LIANDUI') {
                const len = lastState.len;
                const pairCount = len / 2;
                const startVal = lastState.val + 1; 
                
                for(let v = startVal; v <= 14; v++) { // A(14)å°é¡¶
                    let hasSequence = true;
                    let tempSol = [];
                    for(let k=0; k<pairCount; k++) {
                        const checkP = v + k;
                        if (!grouped[checkP] || grouped[checkP].length < 2) {
                            hasSequence = false;
                            break;
                        }
                        tempSol.push(...grouped[checkP].slice(0, 2));
                    }
                    if (hasSequence) solutions.push(tempSol);
                }
            }

            // é£æœºå‹åˆ¶
            if (lastState.type === 'AIRPLANE') {
                 const len = lastState.len;
                 const tripleCount = len / 3;
                 const startVal = lastState.val + 1;
                 
                 for(let v = startVal; v <= 14; v++) {
                    let hasSequence = true;
                    let tempSol = [];
                    for(let k=0; k<tripleCount; k++) {
                        const checkP = v + k;
                        if (!grouped[checkP] || grouped[checkP].length < 3) {
                            hasSequence = false;
                            break;
                        }
                        tempSol.push(...grouped[checkP].slice(0, 3));
                    }
                    if (hasSequence) solutions.push(tempSol);
                 }
            }

            // ç­–ç•¥ C: ç‚¸å¼¹å‹åˆ¶
            const currentLevel = lastState.level || 0;
            const currentVal = lastState.val || 0;
            
            const bombs = findAllBombs(currentLevel, currentVal);
            
            bombs.forEach(b => {
                if (CardRules.canPlay(b.cards, lastPlayedCards, deckCount)) {
                    solutions.push(b.cards);
                }
            });

            return solutions;
        } catch (e) {
            console.error("BotLogic findAllSolutions error:", e);
            return [];
        }
    }
};

module.exports = BotLogic;

================================================================================
FILE PATH: server\game\BotManager.js
================================================================================
const BotLogic = require('./BotLogic');
const CardRules = require('./CardRules');

class BotManager {
    constructor(gameInstance) {
        this.game = gameInstance; // æŒæœ‰ GameManager çš„å¼•ç”¨
        this.timer = null;
    }

    // åˆ‡æ¢æ‰˜ç®¡çŠ¶æ€
    toggleAutoPlay(playerId) {
        const player = this.game.players.find(p => p.id === playerId);
        if (!player || player.isBot) return; 

        player.isAutoPlay = !player.isAutoPlay;
        // [ä¿®æ”¹] å¼€å¯æ—¶é‡ç½®ä¸ºé»˜è®¤æ¨¡å¼ (SMART)
        if (player.isAutoPlay) {
            player.autoPlayMode = 'SMART'; 
        }
        
        // å¦‚æœå½“å‰æ­£å¥½è½®åˆ°è¯¥ç©å®¶ï¼Œä¸”å¼€å¯äº†æ‰˜ç®¡ï¼Œç«‹å³è§¦å‘æœºå™¨äººé€»è¾‘
        if (this.game.gameState && 
            this.game.players[this.game.gameState.currentTurnIndex].id === playerId) {
            
            if (player.isAutoPlay) {
                this.checkAndRun();
            } else {
                this.clearTimer();
                // æ¢å¤æ™®é€šå€’è®¡æ—¶
                this.game._resetTimer();
            }
        }
    }

    // æ¸…é™¤æœºå™¨äººæ€è€ƒå®šæ—¶å™¨
    clearTimer() {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
    }

    // æ£€æŸ¥å½“å‰ç©å®¶æ˜¯å¦æ˜¯æœºå™¨äºº/æ‰˜ç®¡ï¼Œå¹¶æ‰§è¡Œé€»è¾‘
    checkAndRun() {
        if (!this.game.gameState) return;
        
        this.clearTimer();

        // ä»…å½“éæœ€åä¸€æ‰‹é˜¶æ®µæ—¶ï¼Œæ‰æ£€æŸ¥ activePlayerCount <= 1 çš„è·³è¿‡é€»è¾‘
        if (!this.game.gameState.lastShotPhase && 
            this.game._getActivePlayerCount() <= 1 && 
            this.game.gameState.lastPlayedCards.length === 0) {
            return;
        }

        const currPlayer = this.game.players[this.game.gameState.currentTurnIndex];
        const isAI = currPlayer.isBot || currPlayer.isAutoPlay;

        // å¦‚æœæ˜¯ AIï¼Œè®¾ç½®æ€è€ƒæ—¶é—´
        if (isAI && this.game.gameState.hands[currPlayer.id].length > 0) {
            const delay = 1000 + Math.random() * 1000; // 1-2ç§’å»¶è¿Ÿ
            this.timer = setTimeout(() => {
                this.executeTurn(currPlayer);
            }, delay);
        } else if (isAI && this.game.gameState.hands[currPlayer.id].length === 0 && this.game.gameState.lastShotPhase) {
            // [ç‰¹æ®Š] å¦‚æœæ˜¯ AI åœ¨æœ€åä¸€æ‰‹é˜¶æ®µæ²¡ç‰Œäº†ï¼Œç›´æ¥è¿‡
             this._forcePass(currPlayer);
        }
    }

    // æ‰§è¡Œæœºå™¨äººçš„å›åˆ
    executeTurn(botPlayer) {
        if (!this.game.gameState) return;
        // åŒé‡æ£€æŸ¥ï¼šç¡®ä¿å½“å‰è¿˜æ˜¯è¯¥æœºå™¨äººå‡ºç‰Œï¼ˆé˜²æ­¢ç½‘ç»œå»¶è¿Ÿå¯¼è‡´çš„å¼‚æ­¥é—®é¢˜ï¼‰
        if (this.game.players[this.game.gameState.currentTurnIndex].id !== botPlayer.id) return;

        try {
            const hand = this.game.gameState.hands[botPlayer.id];
            
            // å¦‚æœå¤„äº lastShotPhase ä¸”è‡ªå·±æ²¡ç‰Œï¼Œç›´æ¥ Pass
            if (!hand || hand.length === 0) {
                 this._forcePass(botPlayer); 
                 return;
            }

            const isNewRound = this.game.gameState.lastPlayedCards.length === 0;
            const cardsToBeat = isNewRound ? [] : this.game.gameState.lastPlayedCards;

            const sortedHand = [...hand].sort((a,b) => CardRules.getPoint(a) - CardRules.getPoint(b));
            
            let cardsToPlay = null;

            // [æ–°å¢] æ„å»ºç­–ç•¥ä¸Šä¸‹æ–‡
            const strategyContext = {
                mode: botPlayer.autoPlayMode || 'SMART',
                pendingScore: this.game.gameState.pendingTablePoints || 0,
                isTeammate: false
            };

            // åˆ¤æ–­ä¸Šå®¶æ˜¯å¦ä¸ºé˜Ÿå‹
            if (!isNewRound && this.game.gameState.roundWinnerId) {
                const lastWinner = this.game.players.find(p => p.id === this.game.gameState.roundWinnerId);
                if (lastWinner && botPlayer.team !== null && botPlayer.team !== undefined) {
                    if (lastWinner.team === botPlayer.team && lastWinner.id !== botPlayer.id) {
                        strategyContext.isTeammate = true;
                    }
                }
            }

            try {
                // [ä¿®æ”¹] ä¼ å…¥ context
                cardsToPlay = BotLogic.decideMove(sortedHand, cardsToBeat, this.game.config.deckCount, strategyContext);
            } catch (err) {
                console.error("[Bot Error] Logic crashed:", err);
            }

            if (cardsToPlay) {
                console.log(`[Bot/Auto] ${botPlayer.name} plays ${cardsToPlay.length} cards (Mode: ${strategyContext.mode}).`);
                // è°ƒç”¨ GameManager çš„æ ¸å¿ƒå‡ºç‰Œæ–¹æ³•
                const result = this.game.playCards(botPlayer.id, cardsToPlay);
                
                if (result.success) {
                    if (!botPlayer.isBot) {
                        this.game.io.to(botPlayer.id).emit('hand_update', this.game.gameState.hands[botPlayer.id]);
                    }

                    const analysis = CardRules.analyze(cardsToPlay, this.game.config.deckCount);
                    const desc = CardRules.getAnalysisText(analysis);
                    let logText = `${botPlayer.name}: ${desc}`;
                    if (result.logText && result.logText.includes('æœ€åä¸€æ‰‹')) {
                        logText = result.logText;
                    } else if (analysis.type === 'BOMB_KING') {
                            logText += ` (+${this.game.config.deckCount * 100}åˆ†)`;
                    }
                    this.game._broadcastUpdate(logText);

                    if (result.isRoundOver) {
                        setTimeout(() => {
                            this.game._handleWin(result, botPlayer.id);
                        }, 3000);
                    } 
                } else {
                    console.error(`[Bot Error] Play failed: ${result.error}`);
                    if (!isNewRound) {
                        this._forcePass(botPlayer);
                    } else {
                        this._playMinCard(botPlayer, sortedHand);
                    }
                }
            } else {
                if (isNewRound) {
                    this._playMinCard(botPlayer, sortedHand);
                } else {
                    this._forcePass(botPlayer);
                }
            }
        } catch (error) {
            console.error(`[Bot Error] Critical Exception in executeTurn:`, error);
            this._forcePass(botPlayer);
        }
    }

    // å†…éƒ¨è¾…åŠ©ï¼šå‡ºä¸€å¼ æœ€å°çš„ç‰Œ
    _playMinCard(botPlayer, sortedHand) {
        const minCard = [sortedHand[0]];
        const result = this.game.playCards(botPlayer.id, minCard);
        if (result.success) {
            if (!botPlayer.isBot) this.game.io.to(botPlayer.id).emit('hand_update', this.game.gameState.hands[botPlayer.id]);
            
            const analysis = CardRules.analyze(minCard, this.game.config.deckCount);
            const desc = CardRules.getAnalysisText(analysis);
            this.game._broadcastUpdate(`${botPlayer.name}: ${desc} (ç³»ç»Ÿ)`);

            if (result.isRoundOver) {
                setTimeout(() => {
                    this.game._handleWin(result, botPlayer.id);
                }, 3000);
            }
        } else {
             this._forcePass(botPlayer); 
        }
    }

    // å†…éƒ¨è¾…åŠ©ï¼šå¼ºåˆ¶è¿‡ç‰Œ
    _forcePass(botPlayer) {
        const result = this.game.passTurn(botPlayer.id);
        
        if (result.isRoundOver) {
             this.game._broadcastUpdate(`${botPlayer.name}: ä¸è¦`);
             setTimeout(() => {
                this.game._handleWin(result, botPlayer.id); 
             }, 3000);
        } else if (result.success) {
            this.game._broadcastUpdate(`${botPlayer.name}: ä¸è¦`);
        } else {
            console.error("[Bot Critical] Failed to pass turn:", result.error);
            this.game._advanceTurn();
            this.game._broadcastUpdate();
            this.game._resetTimer();
            this.checkAndRun();
        }
    }
}

module.exports = BotManager;

================================================================================
FILE PATH: server\game\CardRules.js
================================================================================
// çº¯è§„åˆ™è®¡ç®— (510K é€»è¾‘ã€æ¯”å¤§å°)

const CardRules = {
    // 1. åŸºç¡€æ˜ å°„
    // 3=3 ... K=13, A=14, 2=15, å°ç‹=16, å¤§ç‹=17
    getPoint: (cardVal) => {
        const normalized = cardVal % 54;
        if (normalized === 52) return 16;
        if (normalized === 53) return 17;
        const base = normalized % 13;
        if (base === 0) return 14; // A
        if (base === 1) return 15; // 2
        return base + 1; // 3 => 3
    },

    getSortValue: (cardVal) => {
        const normalized = cardVal % 54;
        if (normalized === 52) return 16;
        if (normalized === 53) return 17;
        const base = normalized % 13;
        if (base === 0) return 14; 
        if (base === 1) return 15; 
        return base + 1;
    },

    getSuitSortValue: (cardVal) => {
        if (cardVal >= 52) return cardVal * 100;
        const suit = Math.floor(cardVal / 13) % 4; 
        const val = cardVal % 13;
        return suit * 100 + val; 
    },
    
    getPointText: (point) => {
        if (point <= 10) return point.toString();
        if (point === 11) return 'J';
        if (point === 12) return 'Q';
        if (point === 13) return 'K';
        if (point === 14) return 'A';
        if (point === 15) return '2';
        if (point === 16) return 'å°ç‹';
        if (point === 17) return 'å¤§ç‹';
        return '?';
    },
    
    getAnalysisText: (analysisResult) => {
        if (!analysisResult || analysisResult.type === 'INVALID') return 'æœªçŸ¥ç‰Œå‹';
        
        const pt = CardRules.getPointText(analysisResult.val);
        
        switch (analysisResult.type) {
            case 'SINGLE': return `å•å¼  ${pt}`;
            case 'PAIR': return `å¯¹ ${pt}`;
            case 'TRIPLE': return `ä¸‰å¼  ${pt}`;
            case 'LIANDUI': return `${analysisResult.len/2}è¿å¯¹ (${pt}èµ·)`;
            case 'AIRPLANE': return `é£æœº (${pt}èµ·)`;
            case '510K_MIXED': return 'æ‚è‰² 510K'; 
            case '510K_PURE': 
                const suitNames = ['é»‘æ¡ƒ', 'çº¢æ¡ƒ', 'æ¢…èŠ±', 'æ–¹ç‰‡'];
                const suitIndex = 4 - analysisResult.val; 
                const sName = suitNames[suitIndex] || 'çº¯';
                return `${sName} 510K`;
            case 'BOMB_STD': return `${analysisResult.len}ç‚¸ (${pt})`;
            case 'BOMB_MAX': return `è‡³å°Š ${analysisResult.len}ç‚¸ (${pt})`;
            case 'BOMB_KING': return 'å¤©ç‹ç‚¸!';
            default: return 'æœªçŸ¥';
        }
    },

    getCardScore: (cardVal) => {
        const p = CardRules.getPoint(cardVal);
        if (p === 5) return 5;
        if (p === 10) return 10;
        if (p === 13) return 10; // K
        return 0;
    },

    calculateTotalScore: (cards) => {
        return cards.reduce((sum, c) => sum + CardRules.getCardScore(c), 0);
    },

    getSuit: (cardVal) => {
        const normalized = cardVal % 54;
        if (normalized >= 52) return -1; 
        return Math.floor(normalized / 13);
    },

    // 2. æ ¸å¿ƒï¼šç‰Œå‹åˆ†æ
    analyze: (cards, deckCount = 1) => {
        const len = cards.length;
        if (len === 0) return { type: 'EMPTY' };

        // æ’åºï¼šç‚¹æ•°ä»å°åˆ°å¤§
        const points = cards.map(CardRules.getPoint).sort((a, b) => a - b);
        
        // ç»Ÿè®¡ç‚¹æ•°é¢‘ç‡
        const counts = {};
        points.forEach(p => { counts[p] = (counts[p] || 0) + 1; });
        const uniquePoints = Object.keys(counts).map(Number).sort((a,b)=>a-b);
        
        // --- éç‚¸å¼¹ç‰Œå‹ ---

        if (len === 1) return { type: 'SINGLE', val: points[0], level: 0 };

        if (len === 2 && points[0] === points[1]) {
            return { type: 'PAIR', val: points[0], level: 0 };
        }

        if (len === 3 && uniquePoints.length === 1) {
            return { type: 'TRIPLE', val: points[0], level: 0 };
        }

        // è¿å¯¹
        if (len >= 4 && len % 2 === 0) {
            if (!points.some(p => p >= 15)) {
                let isLiandui = true;
                if (uniquePoints.length === len / 2) {
                     for (let p of uniquePoints) {
                         if (counts[p] !== 2) isLiandui = false;
                     }
                     for(let i=0; i<uniquePoints.length-1; i++) {
                         if(uniquePoints[i+1] !== uniquePoints[i]+1) isLiandui = false;
                     }
                     if (isLiandui) return { type: 'LIANDUI', val: points[0], len: len, level: 0 };
                }
            }
        }

        // é£æœº
        if (len >= 6 && len % 3 === 0) {
            if (!points.some(p => p >= 15)) {
                let isAirplane = true;
                if (uniquePoints.length === len / 3) {
                    for (let p of uniquePoints) {
                        if (counts[p] !== 3) isAirplane = false;
                    }
                    for(let i=0; i<uniquePoints.length-1; i++) {
                        if(uniquePoints[i+1] !== uniquePoints[i]+1) isAirplane = false;
                    }
                    if (isAirplane) return { type: 'AIRPLANE', val: points[0], len: len, level: 0 };
                }
            }
        }

        // --- ç‚¸å¼¹ç‰Œå‹ (Level 1-5) ---

        // 510K æ£€æµ‹
        if (len === 3) {
            const has5 = points.includes(5);
            const has10 = points.includes(10);
            const hasK = points.includes(13);
            if (has5 && has10 && hasK) {
                // æ£€æŸ¥èŠ±è‰²
                const suits = cards.map(CardRules.getSuit);
                const isPure = (suits[0] === suits[1] && suits[1] === suits[2]);
                
                if (isPure) {
                    // çº¯510K (Level 2)
                    const suit = suits[0];
                    let suitVal = 0;
                    if (suit === 0) suitVal = 4; // é»‘
                    else if (suit === 1) suitVal = 3; // çº¢
                    else if (suit === 2) suitVal = 2; // æ¢…
                    else if (suit === 3) suitVal = 1; // æ–¹
                    return { type: '510K_PURE', val: suitVal, level: 2 }; 
                } else {
                    // æ‚è‰² 510K (Level 1)
                    return { type: '510K_MIXED', val: 1, level: 1 };
                }
            }
        }

        // Level 3: æ™®é€šç‚¸å¼¹
        if (uniquePoints.length === 1 && len >= 4) {
            if (len === deckCount * 4) {
                 // [ä¿®å¤] è¡¥å…¨ len å­—æ®µ
                 return { type: 'BOMB_MAX', val: points[0], len: len, level: 5 };
            }
            return { type: 'BOMB_STD', val: points[0], len: len, level: 3 };
        }

        // Level 4: å¤©ç‹ç‚¸
        const isAllJokers = points.every(p => p >= 16);
        if (isAllJokers && len === deckCount * 2) {
            return { type: 'BOMB_KING', val: 999, level: 4 };
        }

        return { type: 'INVALID' };
    },

    // 3. æ ¡éªŒèƒ½å¦ç®¡ç‰Œ
    canPlay: (newCards, lastCards, deckCount) => {
        const newHand = CardRules.analyze(newCards, deckCount);
        if (newHand.type === 'INVALID') return false;

        // è‡ªç”±å‡ºç‰Œ
        if (!lastCards || lastCards.length === 0) return true;

        const lastHand = CardRules.analyze(lastCards, deckCount);

        // A. ç‚¸å¼¹ vs éç‚¸å¼¹
        if (newHand.level > 0 && lastHand.level === 0) return true;
        if (newHand.level === 0 && lastHand.level > 0) return false;

        // B. ç‚¸å¼¹ä¹‹é—´ (Level æ¯”è¾ƒ)
        if (newHand.level > 0 && lastHand.level > 0) {
            if (newHand.level > lastHand.level) return true;
            if (newHand.level < lastHand.level) return false;

            // åŒçº§åˆ«æ¯”è¾ƒ (Levelç›¸ç­‰æ—¶)
            if (newHand.type === '510K_PURE') {
                return newHand.val > lastHand.val;
            }

            if (newHand.type === 'BOMB_STD') {
                if (newHand.len > lastHand.len) return true;
                if (newHand.len < lastHand.len) return false;
                return newHand.val > lastHand.val;
            }
            
            // æ‚è‰²510K ä¸èƒ½äº’ç®¡
            if (newHand.type === '510K_MIXED') return false;

            if (newHand.type === 'BOMB_MAX') return newHand.val > lastHand.val;
            
            return false;
        }

        // C. éç‚¸å¼¹ä¹‹é—´ (åŒç‰Œå‹æ¯”è¾ƒ)
        if (newHand.type === lastHand.type) {
            if ((newHand.type === 'LIANDUI' || newHand.type === 'AIRPLANE') && newHand.len !== lastHand.len) return false;
            
            if (newCards.length !== lastCards.length) return false;
            
            if (newHand.type === 'LIANDUI') {
                return newHand.val === lastHand.val + 1;
            }
            
            return newHand.val > lastHand.val;
        }

        return false;
    }
};

module.exports = CardRules;

================================================================================
FILE PATH: server\game\Deck.js
================================================================================
// ç‰Œåº“ç”Ÿæˆä¸æ´—ç‰Œ - [å¢å¼ºç‰ˆ] æ”¯æŒå…¬å¹³ä¸æ´—ç‰Œ & æ¨¡æ‹Ÿçº¿ä¸‹å ç‰Œæ¨¡å¼ & ç²¾ç¡®æ§åˆ¶æ¨¡å¼
// åŸºäºã€ŠåŸºäº4äºº4å‰¯ç‰Œçš„æ´—ç‰Œç®—æ³•åŠæ‰©å±•åˆ°3-8é€‚é…çš„è¯´æ˜ã€‹å®ç°
// [ä¿®å¤] å¢åŠ â€œç›®æ ‡åˆ†æ•°è¡¥é½æœºåˆ¶â€ï¼Œç¡®ä¿å¤šå‰¯ç‰Œå±€ä¸€å®šä¼šå‡ºç°å¤§ç‚¸å¼¹
// [ä¿®å¤] ä¼˜åŒ–â€œæ¨¡æ‹Ÿæ´—ç‰Œâ€é€»è¾‘ï¼Œå¢åŠ æ’æ´—é˜²æ­¢ç‰Œåºè¿‡äºæ•´é½å¯¼è‡´Botå´©æºƒï¼Œå¢åŠ åºŸç‰Œå®¹é”™è¡¥é½

const CardRules = require('./CardRules');

class Deck {
    constructor(deckCount = 2) {
        this.deck = [];
        this.deckCount = deckCount;
        // ç”Ÿæˆå¤šå‰¯ç‰Œã€‚æ¯å‰¯ç‰Œæ˜¯ 0-53ã€‚
        // 0-12: é»‘æ¡ƒA-K, 13-25: çº¢æ¡ƒ, 26-38: æ¢…èŠ±, 39-51: æ–¹ç‰‡, 52: å°ç‹, 53: å¤§ç‹
        for (let d = 0; d < deckCount; d++) {
             for (let i = 0; i < 54; i++) {
                this.deck.push(i + d * 54); 
            }
        }

        // --- é…ç½®å‚æ•°å®šä¹‰ (åŸºäºæ–‡æ¡£) ---
        
        // 1. æ¨¡å¼å‚æ•°
        this.modeConfigs = {
            'normal': { 
                name: 'å¸¸è§„æ¨¡å¼',
                bombProb: 0.15,     // åŸºç¡€ç”Ÿæˆæ¦‚ç‡
                scoreFactor: 1.0,   // åˆ†æ•°èŒƒå›´ç³»æ•°
                polarization: 0.2,  // æåŒ–ç¨‹åº¦
                limitPerPoint: 1,   // æ¯ä¸ªç‚¹æ•°æœ€å¤šç”Ÿæˆç‚¸å¼¹æ•°
                dist: { small: 0.50, mid: 0.30, big: 0.15, huge: 0.05 } 
            },
            'stimulating': { 
                name: 'åˆºæ¿€æ¨¡å¼',
                bombProb: 0.30,
                scoreFactor: 1.3, 
                polarization: 0.5,
                limitPerPoint: 1,
                dist: { small: 0.30, mid: 0.35, big: 0.25, huge: 0.10 }
            },
            'thrilling': { 
                name: 'æƒŠé™©æ¨¡å¼',
                bombProb: 0.50,
                scoreFactor: 1.8, 
                polarization: 0.7,
                limitPerPoint: 2,
                dist: { small: 0.25, mid: 0.30, big: 0.25, huge: 0.20 }
            },
            'exciting': { 
                name: 'çˆ½å±€æ¨¡å¼',
                bombProb: 0.80,
                scoreFactor: 2.2, 
                polarization: 0.9,
                limitPerPoint: 2,
                dist: { small: 0.15, mid: 0.20, big: 0.30, huge: 0.35 }
            }
        };

        // 2. åŸºç¡€åˆ†æ•°èŒƒå›´ (åŸºå‡†: 4äºº4å‰¯ç‰Œ)
        this.baseScoreRange = [36, 50]; 
        
        // 3. ç‚¸å¼¹åˆ†çº§å®šä¹‰ (åˆ†æ•°)
        this.bombScores = { small: 1, mid: 2, big: 5, huge: 10 };
    }

    /**
     * è·å–å½“å‰äººæ•°ä¸‹çš„ç‚¸å¼¹å°ºå¯¸é˜ˆå€¼
     */
    _getBombThresholds(deckCount) {
        const smallMax = 6; 
        const midMax = 9;   
        
        if (deckCount === 3) {
            return { small: [4, 6], mid: [7, 9], big: [10, 12], huge: null };
        }

        const bigMax = 12 + (deckCount - 4) * 2;
        const totalMax = deckCount * 4;

        return {
            small: [4, 6],
            mid: [7, 9],
            big: [10, bigMax],
            huge: [bigMax + 1, totalMax]
        };
    }

    /**
     * 1. æ™®é€šæ´—ç‰Œ (Fisher-Yates)
     */
    shuffle() {
        for (let i = this.deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
        }
    }

    /**
     * 2. [å‡è´«å¯Œ] ç®€å•å…¬å¹³ç­–ç•¥
     */
    shuffleFairNoShuffle(playerCount) {
        const groupMap = {}; 
        const looseCards = []; 

        this.deck.forEach(card => {
            const point = CardRules.getPoint(card);
            if (!groupMap[point]) groupMap[point] = [];
            groupMap[point].push(card);
        });

        const bombChunks = []; 
        Object.values(groupMap).forEach(cards => {
            if (cards.length < 4) {
                looseCards.push(...cards);
                return;
            }
            let remaining = [...cards];
            while (remaining.length >= 4) {
                const chunkSize = Math.min(remaining.length, 4 + Math.floor(Math.random() * 3));
                const chunk = remaining.splice(0, chunkSize);
                bombChunks.push(chunk);
            }
            if (remaining.length > 0) looseCards.push(...remaining);
        });

        for (let i = bombChunks.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [bombChunks[i], bombChunks[j]] = [bombChunks[j], bombChunks[i]];
        }

        const playerBuckets = Array.from({ length: playerCount }, () => []);
        bombChunks.forEach((chunk, index) => {
            const playerIndex = index % playerCount;
            playerBuckets[playerIndex].push(...chunk);
        });

        for (let i = looseCards.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [looseCards[i], looseCards[j]] = [looseCards[j], looseCards[i]];
        }
        looseCards.forEach((card, index) => {
            const playerIndex = index % playerCount;
            playerBuckets[playerIndex].push(card);
        });

        this.deck = []; 
        playerBuckets.forEach(bucket => {
            for (let i = bucket.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [bucket[i], bucket[j]] = [bucket[j], bucket[i]];
            }
            this.deck.push(...bucket);
        });
    }

    /**
     * 3. [æ¨¡æ‹Ÿæ´—ç‰Œ] å ç‰Œ + åˆ‡ç‰Œ + æ’æ´—
     * [ä¿®å¤] å¢åŠ å®¹é”™æ€§ï¼Œé˜²æ­¢å› ç‰Œæ•°å¾®å°å·®å¼‚å¯¼è‡´çš„å›é€€
     * [ä¼˜åŒ–] å¢åŠ æ´—ç‰Œæ··ä¹±åº¦ï¼Œé˜²æ­¢ç‰Œåºè¿‡äºæ•´é½å¯¼è‡´ Bot è®¡ç®—å¡æ­»
     */
    shuffleSimulation(lastRoundCards) {
        // 1. åŸºç¡€æ ¡éªŒä¸æ¸…æ´—
        if (!lastRoundCards || !Array.isArray(lastRoundCards)) {
            console.log("[Deck] Invalid last round cards, using random shuffle.");
            this.shuffle();
            return;
        }

        // è¿‡æ»¤éæ³•å¡ç‰Œ (é˜²æ­¢ undefined å¯¼è‡´ crash)
        const cleanCards = lastRoundCards.filter(c => typeof c === 'number' && !isNaN(c));
        
        // 2. é•¿åº¦æ ¡éªŒä¸è¡¥é½
        // å¦‚æœå·®å¼‚è¿‡å¤§ï¼ˆè¶…è¿‡10%ï¼‰ï¼Œè¯´æ˜å¯èƒ½ä¸Šä¸€å±€æ•°æ®æœ‰é—®é¢˜ï¼Œå›é€€éšæœº
        if (Math.abs(cleanCards.length - this.deck.length) > this.deck.length * 0.1) {
             console.log(`[Deck] Card count mismatch too large (${cleanCards.length} vs ${this.deck.length}), reset to random.`);
             this.shuffle();
             return;
        }

        console.log("[Deck] Using Simulation Shuffle (Stacking + Cutting + Riffle)");
        
        // ä½¿ç”¨ä¸Šä¸€å±€çš„ç‰Œ
        this.deck = [...cleanCards];

        // å¦‚æœç‰Œå°‘äº†ï¼Œè¡¥é½ (ä»åŸå§‹ deck é‡Œæ‰¾ç¼ºå¤±çš„)
        if (this.deck.length < this.deckCount * 54) {
             const existingSet = new Set(this.deck);
             const fullDeck = [];
             for(let d=0; d<this.deckCount; d++) {
                 for(let i=0; i<54; i++) fullDeck.push(i + d*54);
             }
             const missing = fullDeck.filter(c => !existingSet.has(c));
             // æ‰“ä¹±ç¼ºå¤±çš„ç‰Œå†è¡¥è¿›å»
             for (let i = missing.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [missing[i], missing[j]] = [missing[j], missing[i]];
            }
            this.deck.push(...missing);
            console.log(`[Deck] Filled ${missing.length} missing cards.`);
        }
        // å¦‚æœç‰Œå¤šäº†ï¼ˆæç½•è§ï¼‰ï¼Œæˆªæ–­
        if (this.deck.length > this.deckCount * 54) {
            this.deck.length = this.deckCount * 54;
        }

        // 3. æ¨¡æ‹Ÿåˆ‡ç‰Œ (å¢åŠ æ¬¡æ•°åˆ° 3-5 æ¬¡)
        const cutCount = 3 + Math.floor(Math.random() * 3); 
        for (let k = 0; k < cutCount; k++) {
            const minCut = Math.floor(this.deck.length * 0.3);
            const maxCut = Math.floor(this.deck.length * 0.7);
            const cutPoint = minCut + Math.floor(Math.random() * (maxCut - minCut));
            
            const topPart = this.deck.slice(0, cutPoint);
            const bottomPart = this.deck.slice(cutPoint);
            this.deck = [...bottomPart, ...topPart];
        }

        // 4. [æ–°å¢] æ¨¡æ‹Ÿæ’æ´— (Riffle Shuffle) - å…³é”®ï¼
        // ä»…åˆ‡ç‰Œä¼šå¯¼è‡´ç‰Œåºä¾ç„¶ä¿ç•™å¤§å—è¿ç»­ï¼Œæ’æ´—èƒ½æœ‰æ•ˆæ‰“æ•£å±€éƒ¨ï¼Œé¿å… Bot æ‹¿åˆ°å¤ªå®Œç¾çš„ç‰Œ
        const mid = Math.floor(this.deck.length / 2);
        const left = this.deck.slice(0, mid);
        const right = this.deck.slice(mid);
        const riffled = [];
        
        while(left.length > 0 || right.length > 0) {
            // éšæœºä»å·¦æˆ–å³æ‰è½ 1-4 å¼ ç‰Œ
            const nLeft = Math.floor(Math.random() * 4) + 1;
            const nRight = Math.floor(Math.random() * 4) + 1;
            
            if (left.length > 0) riffled.push(...left.splice(0, nLeft));
            if (right.length > 0) riffled.push(...right.splice(0, nRight));
        }
        this.deck = riffled;
    }

    /**
     * 4. [ç²¾ç¡®æ§åˆ¶æ´—ç‰Œ] æ ¸å¿ƒç®—æ³•å®ç°
     */
    shufflePrecise(playerCount, mode = 'stimulating') {
        const config = this.modeConfigs[mode] || this.modeConfigs['stimulating'];
        const deckCount = this.deckCount;
        const thresholds = this._getBombThresholds(deckCount);

        console.log(`[Deck] Precise Shuffle | Mode: ${config.name} | Decks: ${deckCount}`);

        // --- Step 1: å½’ç±»æ•´ç† ---
        const cardsByPoint = {}; 
        const jokers = [];
        
        this.deck.forEach(card => {
            const pt = CardRules.getPoint(card);
            if (pt >= 16) jokers.push(card);
            else {
                if (!cardsByPoint[pt]) cardsByPoint[pt] = [];
                cardsByPoint[pt].push(card);
            }
        });

        const availablePoints = Object.keys(cardsByPoint).map(Number);
        for (let i = availablePoints.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availablePoints[i], availablePoints[j]] = [availablePoints[j], availablePoints[i]];
        }

        const generatedBombs = []; 
        let currentTotalScore = 0;

        // --- Step 2: æ¦‚ç‡ç”Ÿæˆ ---
        availablePoints.forEach(pt => {
            const pool = cardsByPoint[pt];
            if (!pool || pool.length < 4) return;

            for (let i = 0; i < config.limitPerPoint; i++) {
                if (pool.length < 4) break;
                if (Math.random() < config.bombProb) {
                    const bomb = this._generateSingleBomb(pool, config.dist, thresholds);
                    if (bomb) {
                        generatedBombs.push(bomb);
                        currentTotalScore += bomb.score;
                    }
                }
            }
        });

        // --- Step 3: ç›®æ ‡åˆ†æ•°è¡¥é½ ---
        const baseTargetMin = this.baseScoreRange[0];
        const targetMinScore = Math.floor(baseTargetMin * config.scoreFactor * (playerCount / 4));
        
        console.log(`[Deck] Score Check: Current ${currentTotalScore} / Target ${targetMinScore}`);

        if (currentTotalScore < targetMinScore) {
            console.log(`[Deck] Score insufficient, force generating bombs...`);
            availablePoints.sort((a, b) => {
                const lenA = cardsByPoint[a] ? cardsByPoint[a].length : 0;
                const lenB = cardsByPoint[b] ? cardsByPoint[b].length : 0;
                return lenB - lenA; 
            });

            for (let pt of availablePoints) {
                if (currentTotalScore >= targetMinScore) break;
                const pool = cardsByPoint[pt];
                if (!pool || pool.length < 4) continue;

                const aggressiveDist = { small: 0.1, mid: 0.2, big: 0.4, huge: 0.3 };
                const bomb = this._generateSingleBomb(pool, aggressiveDist, thresholds);
                if (bomb) {
                    generatedBombs.push(bomb);
                    currentTotalScore += bomb.score;
                }
            }
        }

        // --- Step 4: æåŒ–åˆ†é… ---
        const playerHands = Array.from({ length: playerCount }, () => ({
            cards: [],
            bombScore: 0
        }));

        generatedBombs.sort((a, b) => b.score - a.score);

        generatedBombs.forEach(bomb => {
            const weights = playerHands.map(p => 100 / (p.bombScore + 5));
            const finalWeights = weights.map(w => w + (Math.random() * config.polarization * 100));

            let totalW = finalWeights.reduce((a, b) => a + b, 0);
            let r = Math.random() * totalW;
            let selectedIdx = 0;
            for (let i = 0; i < playerCount; i++) {
                r -= finalWeights[i];
                if (r <= 0) {
                    selectedIdx = i;
                    break;
                }
            }
            playerHands[selectedIdx].cards.push(...bomb.cards);
            playerHands[selectedIdx].bombScore += bomb.score;
        });

        // --- Step 5: å¡«å……å‰©ä½™ç‰Œ ---
        const looseCards = [...jokers];
        Object.values(cardsByPoint).forEach(cards => looseCards.push(...cards));
        
        for (let i = looseCards.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [looseCards[i], looseCards[j]] = [looseCards[j], looseCards[i]];
        }

        let pIdx = 0;
        looseCards.forEach(c => {
            playerHands[pIdx].cards.push(c);
            pIdx = (pIdx + 1) % playerCount;
        });

        // --- Step 6: ç»„è£… ---
        this.deck = [];
        playerHands.forEach(ph => {
            const hand = ph.cards;
            for (let i = hand.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [hand[i], hand[j]] = [hand[j], hand[i]];
            }
            this.deck.push(...hand);
        });

        return true; 
    }

    /**
     * è¾…åŠ©ï¼šä»ç‰Œæ± ä¸­ç”Ÿæˆä¸€ä¸ªç‚¸å¼¹
     */
    _generateSingleBomb(pool, dist, thresholds) {
        if (pool.length < 4) return null;

        const rand = Math.random();
        let type = 'small';
        let range = thresholds.small;

        if (thresholds.huge && rand < dist.huge) {
            type = 'huge';
            range = thresholds.huge;
        } else if (rand < dist.huge + dist.big) {
            type = 'big';
            range = thresholds.big;
        } else if (rand < dist.huge + dist.big + dist.mid) {
            type = 'mid';
            range = thresholds.mid;
        }

        const minLen = range[0];
        const maxLen = range[1];
        
        if (pool.length < minLen) {
            if (pool.length >= 4) {
                const count = pool.length;
                if (thresholds.huge && count >= thresholds.huge[0]) type = 'huge';
                else if (count >= thresholds.big[0]) type = 'big';
                else if (count >= thresholds.mid[0]) type = 'mid';
                else type = 'small';
                
                const bombCards = pool.splice(0, count);
                return { cards: bombCards, type, score: this.bombScores[type] };
            }
            return null;
        }

        let targetLen = minLen + Math.floor(Math.random() * (maxLen - minLen + 1));
        targetLen = Math.min(targetLen, pool.length);

        const bombCards = pool.splice(0, targetLen);
        return { cards: bombCards, type, score: this.bombScores[type] };
    }

    deal(playerCount, strategy = 'CLASSIC', lastRoundCards = null, preciseMode = 'stimulating') {
        if (strategy === 'NO_SHUFFLE') {
            this.shuffleFairNoShuffle(playerCount);
            return this._dealSequential(playerCount);
        } else if (strategy === 'SIMULATION') {
            this.shuffleSimulation(lastRoundCards);
            return this._dealBlock(playerCount);
        } else if (strategy === 'PRECISE') {
            this.shufflePrecise(playerCount, preciseMode);
            return this._dealSequential(playerCount);
        } else {
            this.shuffle();
            return this._dealSequential(playerCount);
        }
    }

    _dealSequential(playerCount) {
        const hands = {};
        const totalCards = this.deck.length;
        const cardsPerPlayer = Math.floor(totalCards / playerCount); 
        
        for (let i = 0; i < playerCount; i++) {
            hands[i] = this.deck.slice(i * cardsPerPlayer, (i + 1) * cardsPerPlayer);
            if (i === playerCount - 1 && (i + 1) * cardsPerPlayer < totalCards) {
                 hands[i] = this.deck.slice(i * cardsPerPlayer);
            }
        }
        return hands;
    }

    // å¢åŠ æ­»å¾ªç¯ä¿æŠ¤
    _dealBlock(playerCount) {
        const hands = {};
        for(let i=0; i<playerCount; i++) hands[i] = [];
        const blockSize = 4; 
        let currentCardIdx = 0;
        let turn = 0;
        
        let safetyCounter = 0;
        const maxLoops = this.deck.length * 2; // å®‰å…¨é˜ˆå€¼

        while (currentCardIdx < this.deck.length) {
            safetyCounter++;
            if (safetyCounter > maxLoops) {
                console.error("[Deck] Critical: _dealBlock infinite loop detected!");
                break;
            }

            const playerIdx = turn % playerCount;
            const actualSize = Math.min(blockSize, this.deck.length - currentCardIdx);
            const chunk = this.deck.slice(currentCardIdx, currentCardIdx + actualSize);
            hands[playerIdx].push(...chunk);
            currentCardIdx += actualSize;
            turn++;
        }
        return hands;
    }
}

module.exports = Deck;

================================================================================
FILE PATH: server\game\GameManager.js
================================================================================
const CardRules = require('./CardRules');
const Deck = require('./Deck');
const BotManager = require('./BotManager');

class GameManager {
    constructor(roomConfig, players, io, roomId) {
        this.config = roomConfig;
        this.players = players; 
        this.io = io; 
        this.roomId = roomId;

        this.grandScores = {}; 
        this.players.forEach(p => {
            this.grandScores[p.id] = 0;
            p.autoPlayMode = 'SMART'; 
        });
        
        this.lastWinnerId = null;
        this.gameState = null; 
        this.matchHistory = []; 
        this.timer = null;
        this.turnStartTime = 0; 
        this.collectedCards = [];

        this.botManager = new BotManager(this);
    }
    
    setPlayerAutoPlayMode(playerId, mode) {
        const player = this.players.find(p => p.id === playerId);
        if (player) player.autoPlayMode = mode;
    }

    toggleAutoPlay(playerId) {
        this.botManager.toggleAutoPlay(playerId);
    }

    startRound(isNextRound = false) {
        if (!isNextRound) {
            this.players.forEach(p => this.grandScores[p.id] = 0);
            this.lastWinnerId = null;
            this.matchHistory = []; 
            this.collectedCards = []; 
        }

        this.players.forEach(p => {
            if (!p.isBot) p.isAutoPlay = false;
        });

        const deck = new Deck(this.config.deckCount);
        let strategy = this.config.shuffleStrategy || (this.config.isNoShuffleMode ? 'NO_SHUFFLE' : 'CLASSIC');
        let preciseMode = this.config.preciseMode || 'stimulating';
        
        console.log(`[Game] Round started. Strategy: ${strategy}, Mode: ${preciseMode}`);

        const hands = deck.deal(this.players.length, strategy, this.collectedCards, preciseMode);
        this.collectedCards = [];

        let startIndex = 0;
        if (this.lastWinnerId) {
            const winnerIdx = this.players.findIndex(p => p.id === this.lastWinnerId);
            if (winnerIdx !== -1) startIndex = winnerIdx;
        }

        const isTeamMode = this.config.isTeamMode && (this.players.length % 2 === 0);
        this.players.forEach((p, index) => {
            if (isTeamMode) p.team = index % 2; 
            else p.team = null; 
        });

        this.gameState = {
            hands: {},
            currentTurnIndex: startIndex,
            lastPlayedCards: [],    
            consecutivePasses: 0,   
            roundPoints: {},        
            pendingTablePoints: 0,  
            roundWinnerId: null, 
            finishedRank: [],
            lastShotPhase: null 
        };

        this.players.forEach((p, index) => {
            this.gameState.hands[p.id] = hands[index];
            this.gameState.roundPoints[p.id] = 0;
        });

        this._resetTimer();
        this.botManager.checkAndRun();

        return {
            startPlayerIndex: startIndex,
            startPlayerId: this.players[startIndex].id,
            hands: this.gameState.hands
        };
    }

    _broadcastUpdate(infoText = null) {
        const publicState = this.getPublicState();
        if (infoText) publicState.infoText = infoText;
        this.io.to(this.roomId).emit('game_state_update', publicState);
    }

    // [æ–°å¢] é€šçŸ¥æ‰‹ç‰Œå˜æ›´ (æ¨é€åˆ° Owner å’Œ è§‚å¯Ÿè€…)
    _notifyHandUpdate(playerId) {
        if (!this.gameState || !this.gameState.hands) return;

        const hand = this.gameState.hands[playerId] || [];
        
        // 1. å‘é€ç»™æ‰‹ç‰ŒæŒæœ‰è€… (å¦‚æœä¸æ˜¯æœºå™¨äºº)
        const owner = this.players.find(p => p.id === playerId);
        if (owner && !owner.isBot) {
            this.io.to(playerId).emit('hand_update', hand);
        }

        // 2. å‘é€ç»™æœ‰èµ„æ ¼çš„è§‚å¯Ÿè€… (å·²æ‰“å®Œç‰Œçš„é˜Ÿå‹/å…¶ä»–äºº)
        this._notifyObservers(playerId, hand);
    }

    // [æ–°å¢] é€šçŸ¥è§‚å¯Ÿè€… (å®Œèµ›é˜Ÿå‹/å…¶ä»–äºº)
    _notifyObservers(targetId, hand) {
        // ç›®æ ‡ç©å®¶ä¿¡æ¯
        const targetPlayer = this.players.find(p => p.id === targetId);
        if (!targetPlayer) return;

        this.players.forEach(observer => {
            // æ’é™¤è‡ªå·±
            if (observer.id === targetId) return;
            // æ’é™¤æœºå™¨äººè§‚å¯Ÿè€…
            if (observer.isBot) return;

            // æ£€æŸ¥è§‚å¯Ÿè€…æ˜¯å¦å·²å‡ºå®Œç‰Œ
            const observerHand = this.gameState.hands[observer.id] || [];
            const isFinished = observerHand.length === 0;

            if (isFinished) {
                let canSee = false;

                // è§„åˆ™ 1: å¦‚æœæ˜¯ç»„é˜Ÿæ¨¡å¼ï¼Œä¸”æ˜¯é˜Ÿå‹ -> å¯ä»¥çœ‹
                if (targetPlayer.team !== null && targetPlayer.team !== undefined) {
                    if (observer.team === targetPlayer.team) {
                        canSee = true;
                    }
                } 
                // è§„åˆ™ 2: å¦‚æœæ˜¯ä¸ªäººæ¨¡å¼ï¼Œæˆ–è€…æ— é˜Ÿå¯ç»„ -> å¯ä»¥çœ‹å…¶ä»–æœªå®Œèµ›çš„äºº
                else {
                    canSee = true;
                }

                if (canSee) {
                    this.io.to(observer.id).emit('observation_update', {
                        targetId: targetId,
                        hand: hand,
                        targetName: targetPlayer.name
                    });
                }
            }
        });
    }

    // [æ–°å¢] å…¨é‡æ¨é€æ‰€æœ‰æ‰‹ç‰Œç»™åˆšæ‰“å®Œç‰Œçš„äºº
    _pushAllVisibleHandsTo(observerId) {
        const observer = this.players.find(p => p.id === observerId);
        if (!observer) return;

        this.players.forEach(target => {
            if (target.id === observerId) return;
            
            // ä»…æ¨é€è¿˜æ²¡æ‰“å®Œçš„äººçš„æ‰‹ç‰Œ
            const targetHand = this.gameState.hands[target.id] || [];
            if (targetHand.length > 0) {
                 let canSee = false;
                 // åŒæ ·çš„å¯è§æ€§åˆ¤å®šé€»è¾‘
                 if (target.team !== null && target.team !== undefined) {
                     if (observer.team === target.team) canSee = true;
                 } else {
                     canSee = true; 
                 }

                 if (canSee) {
                     this.io.to(observerId).emit('observation_update', {
                        targetId: target.id,
                        hand: targetHand,
                        targetName: target.name
                    });
                 }
            }
        });
    }

    _handleWin(result, triggerPlayerId) {
        const rInfo = result.roundResult;

        const settlementData = {
            roundWinner: rInfo.roundWinnerName,
            pointsEarned: rInfo.pointsEarned,
            detail: rInfo.detail,       
            matchHistory: this.matchHistory, 
            grandScores: rInfo.grandScores,
            roundIndex: this.matchHistory.length,
            scoreBreakdown: rInfo.scoreBreakdown 
        };

        if (rInfo.isGrandOver) {
            this.io.to(this.roomId).emit('grand_game_over', { 
                grandWinner: rInfo.roundWinnerName, 
                ...settlementData
            });
            this.gameState = null; 
            this._clearTimer(); 
        } else {
            this.io.to(this.roomId).emit('round_over', settlementData);
            this._clearTimer();
        }
    }

    playCards(playerId, cards) {
        if (!this.gameState) return { success: false, error: 'æ¸¸æˆæœªå¼€å§‹' };
        
        const currPlayer = this.players[this.gameState.currentTurnIndex];
        if (currPlayer.id !== playerId) return { success: false, error: 'è¿˜æ²¡è½®åˆ°ä½ ' };

        const playerHand = this.gameState.hands[playerId];
        if (!this._handContainsCards(playerHand, cards)) {
            return { success: false, error: 'æ‰‹ç‰Œä¸è¶³æˆ–æ•°æ®ä¸åŒæ­¥' };
        }

        const isNewRound = this.gameState.lastPlayedCards.length === 0;
        const cardsToBeat = isNewRound ? [] : this.gameState.lastPlayedCards;

        if (!CardRules.canPlay(cards, cardsToBeat, this.config.deckCount)) {
            return { success: false, error: 'ç‰Œå‹ä¸ç¬¦æˆ–ç®¡ä¸ä¸Š' };
        }

        this._removeCardsFromHand(playerId, cards);
        this.collectedCards.push(...cards);
        this.gameState.pendingTablePoints += CardRules.calculateTotalScore(cards);

        const analysis = CardRules.analyze(cards, this.config.deckCount);
        if (analysis.type === 'BOMB_KING') {
            this.gameState.pendingTablePoints += (this.config.deckCount * 100);
        }

        this.gameState.lastPlayedCards = cards;
        this.gameState.consecutivePasses = 0;
        this.gameState.roundWinnerId = playerId;

        const isFinished = this.gameState.hands[playerId].length === 0;
        if (isFinished) {
            if (!this.gameState.finishedRank.includes(playerId)) {
                this.gameState.finishedRank.push(playerId);
            }
            // [æ–°å¢] ç©å®¶æ‰“å®Œç‰Œäº†ï¼Œç«‹å³æŠŠå…¶ä»–äººçš„ç‰Œæ¨é€ç»™ä»–çœ‹
            this._pushAllVisibleHandsTo(playerId);
        }

        const cardDesc = CardRules.getAnalysisText(analysis);
        let logText = `${currPlayer.name}: ${cardDesc}`;
        if (analysis.type === 'BOMB_KING') logText += ` (+${this.config.deckCount * 100}åˆ†)`;
        if (isFinished) logText += ` (ç‰Œå‡ºå®Œäº†!)`;

        // [ä¿®æ”¹] ä½¿ç”¨ç»Ÿä¸€çš„é€šçŸ¥æ–¹æ³•
        this._notifyHandUpdate(playerId);

        // --- ç»“æŸåˆ¤æ–­é€»è¾‘ ---
        const isTeamMode = this.config.isTeamMode && (this.players.length % 2 === 0);
        let shouldEndGame = false;

        if (isTeamMode) {
            const activeTeams = new Set();
            this.players.forEach(p => {
                if (this.gameState.hands[p.id] && this.gameState.hands[p.id].length > 0) {
                    if (p.team !== undefined && p.team !== null) activeTeams.add(p.team);
                }
            });
            if (activeTeams.size <= 1) shouldEndGame = true;
        } else {
            let activeCount = 0;
            this.players.forEach(p => {
                if (this.gameState.hands[p.id] && this.gameState.hands[p.id].length > 0) activeCount++;
            });
            if (activeCount <= 1) shouldEndGame = true;
        }

        if (shouldEndGame) {
            // å…ˆç»“ç®—ï¼Œå†ç»“æŸ
            const activeCount = this._getActivePlayerCount();
            if (activeCount === 0) {
                this.gameState.roundPoints[playerId] = (this.gameState.roundPoints[playerId] || 0) + this.gameState.pendingTablePoints;
                this.gameState.pendingTablePoints = 0;
                this._clearTimer();
                const roundResult = this._concludeRound();
                return { success: true, isRoundOver: true, roundResult, cardsPlayed: cards, pendingPoints: 0, logText: logText + " - æ¸¸æˆç»“æŸ" };
            }

            if (this.gameState.lastShotPhase) {
                this.gameState.roundPoints[playerId] = (this.gameState.roundPoints[playerId] || 0) + this.gameState.pendingTablePoints;
                this.gameState.pendingTablePoints = 0;
                this._clearTimer();
                const roundResult = this._concludeRound();
                return { success: true, isRoundOver: true, roundResult, cardsPlayed: cards, pendingPoints: 0, logText: logText + " - æœ€åä¸€æ‰‹ç»“æŸ" };
            }

            this.gameState.lastShotPhase = true;
            this._advanceTurn();
            this._resetTimer();
            this.botManager.checkAndRun();
            return { success: true, isRoundOver: false, cardsPlayed: cards, pendingPoints: this.gameState.pendingTablePoints, logText: logText + " (æœ€åä¸€æ‰‹)" };
        }

        this._advanceTurn();
        this._resetTimer();
        this.botManager.checkAndRun();

        return { success: true, isRoundOver: false, cardsPlayed: cards, pendingPoints: this.gameState.pendingTablePoints, logText };
    }

    passTurn(playerId) {
        if (!this.gameState) return { success: false, error: 'æ¸¸æˆæœªå¼€å§‹' };

        const currPlayer = this.players[this.gameState.currentTurnIndex];
        if (currPlayer.id !== playerId) return { success: false, error: 'è¿˜æ²¡è½®åˆ°ä½ ' };

        if (this.gameState.lastPlayedCards.length === 0) {
            return { success: false, error: 'å¿…é¡»å‡ºç‰Œ' };
        }

        this.gameState.consecutivePasses++;
        this._advanceTurn();

        const activeCount = this._getActivePlayerCount();
        const winnerId = this.gameState.roundWinnerId;
        const winnerHand = this.gameState.hands[winnerId];
        const winnerIsActive = winnerHand && winnerHand.length > 0;
        
        const passesNeeded = winnerIsActive ? (activeCount - 1) : activeCount;

        let turnCleared = false;
        let infoMessage = `${currPlayer.name}: ä¸è¦`;

        if (this.gameState.consecutivePasses >= passesNeeded) {
            const wId = this.gameState.roundWinnerId;
            if (wId) {
                this.gameState.roundPoints[wId] = (this.gameState.roundPoints[wId] || 0) + this.gameState.pendingTablePoints;
                this.gameState.pendingTablePoints = 0;

                // æ¥é£é€»è¾‘
                if (this.gameState.hands[wId] && this.gameState.hands[wId].length > 0) {
                     const wIdx = this.players.findIndex(p => p.id === wId);
                     this.gameState.currentTurnIndex = wIdx;
                } else {
                    const winnerPlayer = this.players.find(p => p.id === wId);
                    if (!winnerPlayer) {
                         infoMessage = `${currPlayer.name}: ä¸è¦ (ä¸Šå®¶å·²ç¦»çº¿)`;
                    } else {
                        const isTeamMode = this.config.isTeamMode && (this.players.length % 2 === 0);
                        if (isTeamMode && winnerPlayer.team !== undefined && winnerPlayer.team !== null) {
                            const wIdx = this.players.findIndex(p => p.id === wId);
                            const pCount = this.players.length;
                            let foundTeammate = false;
                            for (let i = 1; i < pCount; i++) {
                                const tIdx = (wIdx + i) % pCount; 
                                const potentialTeammate = this.players[tIdx];
                                if (potentialTeammate.team === winnerPlayer.team && 
                                    this.gameState.hands[potentialTeammate.id] && 
                                    this.gameState.hands[potentialTeammate.id].length > 0) {
                                    this.gameState.currentTurnIndex = tIdx;
                                    infoMessage = `${currPlayer.name}: ä¸è¦ (é˜Ÿå‹æ¥é£)`;
                                    this._broadcastUpdate(`${winnerPlayer.name} å·²é€ƒå‡ºï¼Œé˜Ÿå‹ ${potentialTeammate.name} æ¥é£`);
                                    foundTeammate = true;
                                    break;
                                }
                            }
                            if (!foundTeammate) this._advanceTurn(); 
                        } else {
                            const wIdx = this.players.findIndex(p => p.id === wId);
                            let nextActiveIdx = wIdx;
                            let found = false;
                            for(let i=1; i<this.players.length; i++) {
                                let idx = (wIdx + i) % this.players.length;
                                if (this.gameState.hands[this.players[idx].id].length > 0) {
                                    nextActiveIdx = idx;
                                    found = true;
                                    break;
                                }
                            }
                            if (found) {
                                this.gameState.currentTurnIndex = nextActiveIdx;
                                infoMessage = `${currPlayer.name}: ä¸è¦ (${this.players[nextActiveIdx].name} æ¥é£)`;
                                this._broadcastUpdate(`${winnerPlayer.name} å·²é€ƒå‡ºï¼Œä¸‹å®¶ ${this.players[nextActiveIdx].name} æ¥é£`);
                            }
                        }
                    }
                }
            }
            
            turnCleared = true;
            if (this.gameState.lastShotPhase) {
                const roundResult = this._concludeRound();
                return { success: true, isRoundOver: true, roundResult, turnCleared: true, logText: infoMessage + " - æ— äººæ¥é£ï¼Œç»“æŸ" };
            }

            this.gameState.lastPlayedCards = [];
            this.gameState.consecutivePasses = 0;
        }

        this._resetTimer(); 
        this.botManager.checkAndRun();

        return { success: true, turnCleared, logText: infoMessage };
    }

    _clearTimer() {
        if (this.timer) clearTimeout(this.timer);
        if (this.botManager) this.botManager.clearTimer();
        this.timer = null;
    }

    _resetTimer() {
        this._clearTimer();
        if (this.gameState && this._getActivePlayerCount() > 0) {
            this.turnStartTime = Date.now();
            const timeLimit = this.config.turnTimeout || 60000;
            this.timer = setTimeout(() => {
                this._handleTimeout();
            }, timeLimit);
        }
    }

    _handleTimeout() {
        if (!this.gameState) return;
        const currIdx = this.gameState.currentTurnIndex;
        const currPlayer = this.players[currIdx];
        
        const isNewRound = this.gameState.lastPlayedCards.length === 0;

        if (isNewRound) {
            const hand = this.gameState.hands[currPlayer.id];
            if (!hand || hand.length === 0) { 
                this._advanceTurn(); 
                this._resetTimer(); 
                this.botManager.checkAndRun();
                return; 
            }

            const sorted = hand.map(c => ({ id: c, val: CardRules.getPoint(c) })).sort((a, b) => a.val - b.val);
            const cardToPlay = [sorted[0].id]; 
            const result = this.playCards(currPlayer.id, cardToPlay);
            if (result.success) {
                this._notifyHandUpdate(currPlayer.id);
                const logText = result.logText || `${currPlayer.name} è¶…æ—¶å‡ºç‰Œ`;
                this._broadcastUpdate(logText);
                if (result.isRoundOver) {
                      setTimeout(() => {
                         this._handleWin(result, currPlayer.id);
                      }, 3000);
                }
            }
        } else {
            const result = this.passTurn(currPlayer.id);
            if (result.success) {
                if (result.isRoundOver) {
                      this._broadcastUpdate(`${currPlayer.name}: è¶…æ—¶è¿‡ç‰Œ`);
                      setTimeout(() => {
                         this._handleWin(result, currPlayer.id);
                      }, 3000);
                } else {
                    this._broadcastUpdate(`${currPlayer.name}: è¶…æ—¶è¿‡ç‰Œ`);
                }
            }
        }
    }

    _getActivePlayerCount() {
        if (!this.gameState) return 0;
        let count = 0;
        for (const p of this.players) {
            if (this.gameState.hands[p.id] && this.gameState.hands[p.id].length > 0) {
                count++;
            }
        }
        return count;
    }

    _advanceTurn() {
        const playerCount = this.players.length;
        let nextIndex = this.gameState.currentTurnIndex;
        let attempts = 0;
        do {
            nextIndex = (nextIndex + 1) % playerCount; 
            attempts++;
        } while (
            (this.gameState.hands[this.players[nextIndex].id] || []).length === 0 && 
            attempts < playerCount 
        );
        this.gameState.currentTurnIndex = nextIndex;
    }

    getPublicState() {
        if (!this.gameState) return null;
        
        const currentScoresDisplay = {};
        const roundPointsDisplay = {}; 
        const playersInfo = {};
        const handCounts = {};

        this.players.forEach(p => {
            const grand = this.grandScores[p.id] || 0;
            const round = this.gameState.roundPoints[p.id] || 0;
            currentScoresDisplay[p.id] = grand + round;
            roundPointsDisplay[p.id] = round; 
            
            playersInfo[p.id] = { 
                isBot: p.isBot, 
                isAutoPlay: p.isAutoPlay,
                team: p.team,
                autoPlayMode: p.autoPlayMode 
            };
            handCounts[p.id] = this.gameState.hands[p.id] ? this.gameState.hands[p.id].length : 0;
        });

        const winnerObj = this.players.find(p => p.id === this.gameState.roundWinnerId);

        let remainingSeconds = 0;
        if (this.turnStartTime) {
            const timeLimit = this.config.turnTimeout || 60000;
            const elapsed = Date.now() - this.turnStartTime;
            remainingSeconds = Math.max(0, Math.ceil((timeLimit - elapsed) / 1000));
        }
        
        return {
            turnIndex: this.gameState.currentTurnIndex,
            currentTurnId: this.players[this.gameState.currentTurnIndex].id,
            turnRemaining: remainingSeconds, 
            lastPlayed: this.gameState.lastPlayedCards,
            lastPlayerName: winnerObj ? winnerObj.name : '',
            scores: currentScoresDisplay,
            roundPoints: roundPointsDisplay, 
            pendingPoints: this.gameState.pendingTablePoints,
            finishedRank: this.gameState.finishedRank,
            playersInfo: playersInfo,
            handCounts: handCounts 
        };
    }

    reconnectPlayer(oldId, newId) {
        if (this.grandScores[oldId] !== undefined) {
            this.grandScores[newId] = this.grandScores[oldId];
            delete this.grandScores[oldId];
        }

        if (this.lastWinnerId === oldId) this.lastWinnerId = newId;

        let player = this.players.find(p => p.id === newId);
        if (!player) {
            player = this.players.find(p => p.id === oldId);
            if (player) player.id = newId;
        }

        if (player) {
             player.isAutoPlay = false; 
        }

        if (this.gameState) {
            if (this.gameState.hands && this.gameState.hands[oldId]) {
                this.gameState.hands[newId] = this.gameState.hands[oldId];
                delete this.gameState.hands[oldId];
            } else if (this.gameState.hands) {
                this.gameState.hands[newId] = [];
            }

            if (this.gameState.roundPoints[oldId] !== undefined) {
                this.gameState.roundPoints[newId] = this.gameState.roundPoints[oldId];
                delete this.gameState.roundPoints[oldId];
            }
            if (this.gameState.roundWinnerId === oldId) this.gameState.roundWinnerId = newId;
            
            const rankIdx = this.gameState.finishedRank.indexOf(oldId);
            if (rankIdx !== -1) {
                this.gameState.finishedRank[rankIdx] = newId;
            }
        }

        this.matchHistory.forEach(match => {
            if (match.scores[oldId] !== undefined) {
                match.scores[newId] = match.scores[oldId];
                delete match.scores[oldId];
            }
        });

        return true;
    }

    _handContainsCards(hand, cardsToPlay) {
        if (!hand) return false;
        const tempHand = [...hand];
        for (let c of cardsToPlay) {
            const idx = tempHand.indexOf(c);
            if (idx === -1) return false;
            tempHand.splice(idx, 1);
        }
        return true;
    }

    _removeCardsFromHand(playerId, cards) {
        if (!this.gameState.hands[playerId]) return;
        const newHand = [...this.gameState.hands[playerId]];
        for (let c of cards) {
            const idx = newHand.indexOf(c);
            if (idx !== -1) newHand.splice(idx, 1);
        }
        this.gameState.hands[playerId] = newHand;
    }

    _concludeRound() {
        const fullRankIds = [...this.gameState.finishedRank];
        this.players.forEach(p => {
            if (!fullRankIds.includes(p.id)) fullRankIds.push(p.id);
        });

        const firstWinnerId = fullRankIds[0];
        this.lastWinnerId = firstWinnerId;

        let logLines = []; 
        let penaltyDetails = []; 

        let currentRoundScores = {};
        this.players.forEach(p => {
            currentRoundScores[p.id] = (this.gameState.roundPoints[p.id] || 0);
        });

        const scoreBreakdown = {};
        this.players.forEach(p => {
             scoreBreakdown[p.id] = {
                 id: p.id,
                 name: p.name,
                 team: p.team,
                 tablePoints: this.gameState.roundPoints[p.id] || 0,
                 handCount: (this.gameState.hands[p.id] || []).length,
                 handScore: CardRules.calculateTotalScore(this.gameState.hands[p.id] || []),
                 penalty: 0,
                 final: 0,
                 finishRank: fullRankIds.indexOf(p.id) + 1
             };
        });

        let totalCardPenalty = 0;
        let penaltySources = [];
        
        this.players.forEach(p => {
            const h = this.gameState.hands[p.id] || [];
            const handPts = CardRules.calculateTotalScore(h);
            if (handPts > 0) {
                totalCardPenalty += handPts;
                penaltySources.push(`${p.name}(${handPts})`);
            }
        });

        if (firstWinnerId && totalCardPenalty > 0) {
            currentRoundScores[firstWinnerId] += totalCardPenalty;
            scoreBreakdown[firstWinnerId].penalty += totalCardPenalty;

            const winnerName = this.players.find(p=>p.id===firstWinnerId)?.name;
            logLines.push(`[æ‰‹ç‰Œç½šåˆ†] è¾“å®¶å‰©ä½™æ‰‹ç‰Œåˆ† (${penaltySources.join(', ')}) å…± ${totalCardPenalty} åˆ†ï¼Œå½’å¤´æ¸¸ ${winnerName}ã€‚`);
            penaltyDetails.push(`å¤´æ¸¸ ${winnerName} æ”¶å–æ‰‹ç‰Œåˆ† ${totalCardPenalty}`);
        }

        if (this.config.enableRankPenalty && this.config.rankPenaltyScores && this.config.rankPenaltyScores.length > 0) {
            const penaltyConfig = this.config.rankPenaltyScores;
            const playerCount = fullRankIds.length;
            
            penaltyConfig.forEach((score, index) => {
                const winnerIndex = index; 
                const loserIndex = playerCount - 1 - index; 

                if (winnerIndex < loserIndex) {
                    const winnerId = fullRankIds[winnerIndex];
                    const loserId = fullRankIds[loserIndex];
                    
                    if (winnerId && loserId) {
                        const winner = this.players.find(p=>p.id===winnerId);
                        const loser = this.players.find(p=>p.id===loserId);
                        
                        if (winner && loser) {
                            if (winner.team !== null && winner.team !== undefined && winner.team === loser.team) {
                                logLines.push(`[ğŸ›¡ï¸é˜Ÿå‹ä¿æŠ¤] ç¬¬${winnerIndex+1}å(${winner.name}) ä¸ å€’æ•°ç¬¬${index+1}å(${loser.name}) æ˜¯é˜Ÿå‹ï¼Œ${score}åˆ† å…ç½šï¼`);
                                penaltyDetails.push(`[é˜Ÿå‹ä¿æŠ¤] ${winner.name} å…æ”¶ ${loser.name} ${score} åˆ†`);
                            } else {
                                currentRoundScores[winnerId] += score;
                                currentRoundScores[loserId] -= score;
                                
                                scoreBreakdown[winnerId].penalty += score;
                                scoreBreakdown[loserId].penalty -= score;

                                logLines.push(`[æ’åèµç½š] ç¬¬${winnerIndex+1}å ${winner.name} æ”¶å– å€’æ•°ç¬¬${index+1}å ${loser.name} ${score} åˆ†ã€‚`);
                                penaltyDetails.push(`${loser.name} æ’åè¿›è´¡ ${winner.name} ${score} åˆ†`);
                            }
                        }
                    }
                }
            });
        }

        this.players.forEach(p => {
            this.grandScores[p.id] += currentRoundScores[p.id];
            scoreBreakdown[p.id].final = currentRoundScores[p.id];
            
            if (this.gameState && this.gameState.roundPoints) {
                this.gameState.roundPoints[p.id] = 0;
            }
        });

        this.matchHistory.push({
            roundIndex: this.matchHistory.length + 1,
            scores: {...currentRoundScores}, 
            winnerId: firstWinnerId,
            details: penaltyDetails
        });

        const firstWinnerName = this.players.find(p => p.id === firstWinnerId)?.name || 'æœªçŸ¥';

        let isGrandOver = false;
        const targetScore = this.config.targetScore;
        const isTeamMode = this.config.isTeamMode && (this.players.length % 2 === 0);

        if (isTeamMode) {
            let redTotal = 0;
            let blueTotal = 0;
            this.players.forEach(p => {
                const s = this.grandScores[p.id] || 0;
                if (p.team === 0) redTotal += s;
                else if (p.team === 1) blueTotal += s;
            });
            
            if (redTotal >= targetScore || blueTotal >= targetScore) {
                isGrandOver = true;
            }
        } else {
            const maxScore = Math.max(...Object.values(this.grandScores));
            if (maxScore >= targetScore) {
                isGrandOver = true;
            }
        }

        const totalPointsEarned = currentRoundScores[firstWinnerId];

        return {
            roundWinnerName: firstWinnerName,
            pointsEarned: totalPointsEarned, 
            detail: logLines.join('\n') || 'å®Œç¾ç»“æŸï¼Œæœªè®¾ç½®é¢å¤–ç½šåˆ†', 
            grandScores: this.grandScores,
            isGrandOver,
            scoreBreakdown
        };
    }
    
    getPlayerHand(playerId) {
        if (!this.gameState || !this.gameState.hands) return [];
        return this.gameState.hands[playerId] || [];
    }
}

module.exports = GameManager;

================================================================================
FILE PATH: server\game\SeatManager.js
================================================================================
const CardRules = require('./CardRules');
const Deck = require('./Deck');

class SeatManager {
    constructor(io, roomId, players, isTeamMode) {
        this.io = io;
        this.roomId = roomId;
        this.players = players; 
        this.isTeamMode = isTeamMode; 

        // ç”Ÿæˆä¸€å‰¯ç‰Œï¼Œæ´—ç‰Œ
        const deck = new Deck(1);
        deck.shuffle();
        
        // [ä¿®æ”¹] ä¼˜åŒ–æŠ½ç‰Œæ± ç”Ÿæˆé€»è¾‘ï¼šä¼˜å…ˆä¿è¯ç‚¹æ•°ä¸é‡å¤
        // è¿™æ ·ç©å®¶æŠ½åˆ°çš„ç‰Œå¤§æ¦‚ç‡æ˜¯ 3, 5, K, A è¿™ç§çº¯æ•°å­—å¤§å°æ¯”è¾ƒï¼Œä¸ç”¨æ¯”èŠ±è‰²
        const distinctCards = [];
        const seenPoints = new Set();
        const leftovers = [];

        for (let card of deck.deck) {
            const p = CardRules.getPoint(card);
            if (!seenPoints.has(p)) {
                seenPoints.add(p);
                distinctCards.push(card);
            } else {
                leftovers.push(card);
            }
        }

        // ä¼˜å…ˆç”¨ä¸é‡å¤çš„ç‰Œï¼Œå¦‚æœä¸å¤Ÿï¼ˆæå°‘æƒ…å†µï¼‰å†ç”¨å‰©ä¸‹çš„è¡¥
        const pool = [...distinctCards, ...leftovers];
        
        // å–å‡ºç­‰äºç©å®¶æ•°é‡çš„ç‰Œä½œä¸ºâ€œç­¾â€
        this.availableCards = pool.slice(0, players.length);
        
        // è®°å½•è°æŠ½äº†ä»€ä¹ˆ { playerId: cardVal }
        this.drawResults = {};
        
        // è®°å½•å½“å‰è¿˜å‰©å“ªäº›ä½ç½®çš„ç‰Œæ²¡è¢«ç¿»å¼€
        this.pendingIndices = this.availableCards.map((_, i) => i);
    }

    reconnectPlayer(oldId, newId) {
        if (this.drawResults[oldId] !== undefined) {
            this.drawResults[newId] = this.drawResults[oldId];
            delete this.drawResults[oldId];
            console.log(`[SeatManager] Player reconnected: ${oldId} -> ${newId}, restored draw result.`);
        }
    }

    playerDraw(playerId, cardIndex) {
        if (this.drawResults[playerId] !== undefined) return { success: false, msg: 'ä½ å·²ç»æŠ½è¿‡ç‰Œäº†' };

        const idxInPending = this.pendingIndices.indexOf(cardIndex);
        if (idxInPending === -1) return { success: false, msg: 'è¿™å¼ ç‰Œå·²ç»è¢«è¢«äººæŠ½èµ°äº†' };

        this.pendingIndices.splice(idxInPending, 1);

        const cardVal = this.availableCards[cardIndex];
        this.drawResults[playerId] = cardVal;

        const isFinished = Object.keys(this.drawResults).length === this.players.length;

        return { 
            success: true, 
            cardVal, 
            cardIndex, 
            isFinished 
        };
    }

    finalizeSeats() {
        const results = this.players.map(p => {
            const card = this.drawResults[p.id];
            
            // [å®‰å…¨ä¿æŠ¤] å¦‚æœç©å®¶æ•°æ®å¼‚å¸¸ï¼Œæä¾›é»˜è®¤å€¼é˜²æ­¢å´©æºƒ
            if (card === undefined) {
                console.error(`[SeatManager] Critical Error: Player ${p.name} (${p.id}) missing draw card!`);
                return { ...p, drawCard: 0, sortVal: 0 };
            }

            return {
                ...p,
                drawCard: card,
                sortVal: CardRules.getSortValue(card) 
            };
        });

        results.sort((a, b) => {
            if (b.sortVal !== a.sortVal) return b.sortVal - a.sortVal;
            return CardRules.getSuitSortValue(b.drawCard) - CardRules.getSuitSortValue(a.drawCard);
        });

        let newOrder = [];

        if (this.isTeamMode) {
            const mid = Math.ceil(results.length / 2);
            const bigTeam = results.slice(0, mid); 
            const smallTeam = results.slice(mid);  

            const maxLen = Math.max(bigTeam.length, smallTeam.length);
            for (let i = 0; i < maxLen; i++) {
                if (bigTeam[i]) newOrder.push(bigTeam[i]); 
                if (smallTeam[i]) newOrder.push(smallTeam[i]); 
            }
        } else {
            newOrder = results;
        }

        return {
            newPlayers: newOrder,
            drawDetails: this.drawResults 
        };
    }
}

module.exports = SeatManager;

================================================================================
FILE PATH: server\handlers\gameHandler.js
================================================================================
const SeatManager = require('../game/SeatManager');
const GameManager = require('../game/GameManager');

module.exports = (io, socket, rooms) => {

    // è¾…åŠ©å‡½æ•°ï¼šå¹¿æ’­æ¸¸æˆçŠ¶æ€
    const broadcastGameState = (roomId, room, infoText = null) => {
        if (!room.gameManager) return;
        const publicState = room.gameManager.getPublicState();
        if (!publicState) return;
        if (infoText) publicState.infoText = infoText;
        io.to(roomId).emit('game_state_update', publicState);
    };

    // è¾…åŠ©å‡½æ•°ï¼šå¹¿æ’­æˆ¿é—´ä¿¡æ¯ï¼ˆç”¨äºå¤§å…/æˆ¿é—´ç­‰å¾…é˜¶æ®µï¼‰
    const broadcastRoomInfo = (roomId, room) => {
        const currentGrandScores = room.gameManager ? room.gameManager.grandScores : {};
        // ç¡®ä¿æ‰€æœ‰ç©å®¶éƒ½æœ‰å¤§åˆ†è®°å½•
        if (Object.keys(currentGrandScores).length === 0) {
            room.players.forEach(p => {
                if (currentGrandScores[p.id] === undefined) currentGrandScores[p.id] = 0;
            });
        }
        
        const spectatorCount = room.spectators ? room.spectators.length : 0;

        io.to(roomId).emit('room_info', { 
            roomId, 
            config: room.config, 
            players: room.players, 
            grandScores: currentGrandScores,
            spectatorCount
        });
    };

    // å¤„ç†æ¸¸æˆå¼€å§‹é€»è¾‘
    const handleGameStart = (roomId, isNextRound) => {
        const room = rooms[roomId];
        if (!room) return;

        // å¦‚æœæ˜¯æ–°ä¸€å±€æˆ–æ²¡æœ‰ç®¡ç†å™¨ï¼Œé‡æ–°å®ä¾‹åŒ–
        if (!isNextRound || !room.gameManager) {
            room.gameManager = new GameManager(room.config, room.players, io, roomId);
        }

        const startInfo = room.gameManager.startRound(isNextRound);

        // ç»™æ¯ä¸ªéæœºå™¨äººç©å®¶å‘é€æ‰‹ç‰Œ
        room.players.forEach((p) => {
            if (!p.isBot) { 
                const hand = startInfo.hands[p.id];
                io.to(p.id).emit('game_started', { 
                    hand: hand, 
                    grandScores: room.gameManager.grandScores,
                    handCounts: room.gameManager.getPublicState().handCounts
                });
            }
        });

        // [æ–°å¢] å‘è§‚ä¼—å‘é€æ¸¸æˆå¼€å§‹ä¿¡å·
        if (room.spectators) {
            room.spectators.forEach(s => {
                io.to(s.id).emit('game_started', {
                    hand: [],
                    startPlayerId: startInfo.startPlayerId,
                    grandScores: room.gameManager.grandScores,
                    handCounts: room.gameManager.getPublicState().handCounts,
                    isSpectator: true
                });
            });
        }

        const startPlayerName = room.players[startInfo.startPlayerIndex].name;
        const msg = isNextRound 
            ? `æ–°ä¸€è½®å¼€å§‹ï¼ç”± ${startPlayerName} å…ˆå‡º` 
            : `æ¸¸æˆå¼€å§‹ï¼ç›®æ ‡ ${room.config.targetScore} åˆ†`;
        
        broadcastGameState(roomId, room, msg);
    };

    // --- äº‹ä»¶ç›‘å¬ (ä»…ä¿ç•™æ¸¸æˆç›¸å…³) ---

    // 1. å¼€å§‹æ¸¸æˆ (æŠ½ç‰Œ/ç›´æ¥å¼€å§‹)
    socket.on('start_game', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room) return;
        
        const player = room.players.find(p => p.id === socket.id);
        if (!player || !player.isHost) return socket.emit('error_msg', 'åªæœ‰æˆ¿ä¸»å¯ä»¥å¼€å§‹æ¸¸æˆ');
        if (room.players.length < 2) return socket.emit('error_msg', 'äººæ•°ä¸è¶³');

        // æ¸…ç†æ—§çš„æ¸¸æˆç®¡ç†å™¨
        if (room.gameManager) {
            if (room.gameManager._clearTimer) room.gameManager._clearTimer();
            room.gameManager = null;
        }
        
        // ç»„é˜Ÿæ¨¡å¼äººæ•°æ£€æŸ¥
        if (room.config.isTeamMode && room.players.length % 2 !== 0) {
            room.config.isTeamMode = false;
            io.to(roomId).emit('error_msg', 'äººæ•°ä¸ºå¥‡æ•°ï¼Œå·²è‡ªåŠ¨å…³é—­ç»„é˜Ÿæ¨¡å¼');
            broadcastRoomInfo(roomId, room);
        }

        const isTeamMode = room.config.isTeamMode && (room.players.length % 2 === 0);
        
        // åˆå§‹åŒ–åº§ä½ç®¡ç†å™¨ (ç”¨äºæŠ½ç‰Œé€‰åº§)
        room.seatManager = new SeatManager(io, roomId, room.players, isTeamMode);
        
        // é€šçŸ¥å‰ç«¯è¿›å…¥æŠ½ç‰Œé˜¶æ®µ
        io.to(roomId).emit('enter_draw_phase', { totalCards: room.players.length });
        
        // æœºå™¨äººè‡ªåŠ¨æŠ½ç‰Œé€»è¾‘
        const bots = room.players.filter(p => p.isBot);
        bots.forEach((bot, i) => {
            setTimeout(() => {
                if (!rooms[roomId]) return; 

                if(room.seatManager) {
                    const availableIdx = room.seatManager.pendingIndices[0];
                    if (availableIdx !== undefined) {
                        const res = room.seatManager.playerDraw(bot.id, availableIdx);
                        if(res.success) {
                            io.to(roomId).emit('seat_draw_update', {
                                index: res.cardIndex,
                                val: res.cardVal,
                                playerId: bot.id,
                                name: bot.name
                            });
                            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰äººéƒ½æŠ½å®Œäº†
                            if (res.isFinished) {
                                setTimeout(() => {
                                    if (!rooms[roomId]) return;
                                    const { newPlayers } = room.seatManager.finalizeSeats();
                                    room.players = newPlayers;
                                    room.seatManager = null;
                                    io.to(roomId).emit('seat_draw_finished', { players: newPlayers });
                                    setTimeout(() => handleGameStart(roomId, false), 3000);
                                }, 1000);
                            }
                        }
                    }
                }
            }, 1000 + i * 1500); 
        });
    });

    // 2. ç©å®¶æŠ½åº§æ¬¡ç‰Œ
    socket.on('draw_seat_card', ({ roomId, cardIndex }) => {
        const room = rooms[roomId];
        if (!room || !room.seatManager) return;

        const result = room.seatManager.playerDraw(socket.id, cardIndex);
        if (!result.success) return socket.emit('error_msg', result.msg);

        const player = room.players.find(p => p.id === socket.id);
        io.to(roomId).emit('seat_draw_update', {
            index: cardIndex,
            val: result.cardVal,
            playerId: socket.id,
            name: player ? player.name : 'æœªçŸ¥'
        });

        if (result.isFinished) {
            setTimeout(() => {
                if (!rooms[roomId]) return; 

                const { newPlayers, drawDetails } = room.seatManager.finalizeSeats();
                room.players = newPlayers;
                room.seatManager = null; 

                io.to(roomId).emit('seat_draw_finished', {
                    players: newPlayers,
                    details: drawDetails
                });

                setTimeout(() => handleGameStart(roomId, false), 3000);
            }, 1000); 
        }
    });

    // 3. ä¸‹ä¸€å±€
    socket.on('next_round', ({ roomId }) => handleGameStart(roomId, true));

    // 4. å‡ºç‰Œ
    socket.on('play_cards', ({ roomId, cards }) => {
        const room = rooms[roomId];
        if (!room || !room.gameManager) return;
        
        const result = room.gameManager.playCards(socket.id, cards);

        if (!result.success) return socket.emit('play_error', result.error);

        const currentHand = room.gameManager.gameState.hands[socket.id];
        io.to(socket.id).emit('hand_update', currentHand);

        if (result.isRoundOver) { 
            if (result.cardsPlayed && result.cardsPlayed.length > 0) {
                 broadcastGameState(roomId, room, result.logText);
            }

            setTimeout(() => {
                if (!rooms[roomId]) return;
                room.gameManager._handleWin(result, socket.id);

                // å¦‚æœå¤§å±€ç»“æŸï¼Œæ¸…ç† GameManager
                if (result.roundResult.isGrandOver) {
                    room.gameManager = null; 
                }
            }, 3000); 
        } else {
            broadcastGameState(roomId, room, result.logText);
        }
    });

    // 5. ä¸è¦/è¿‡ç‰Œ
    socket.on('pass_turn', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room || !room.gameManager) return;

        const result = room.gameManager.passTurn(socket.id);
        if (!result.success) return socket.emit('play_error', result.error);

        if (result.isRoundOver) {
            broadcastGameState(roomId, room, result.logText);
            
            setTimeout(() => {
                if (!rooms[roomId]) return;
                room.gameManager._handleWin(result, socket.id);
                
                if (result.roundResult && result.roundResult.isGrandOver) {
                    room.gameManager = null;
                }
            }, 3000);
        } else {
            broadcastGameState(roomId, room, result.logText || "PASS");
        }
    });

    // 6. åˆ‡æ¢æ‰˜ç®¡å¼€å…³
    socket.on('toggle_auto_play', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room || !room.gameManager) return;

        room.gameManager.toggleAutoPlay(socket.id);
        broadcastGameState(roomId, room);
    });

    // 7. åˆ‡æ¢æ‰˜ç®¡æ¨¡å¼ (æ™ºèƒ½/çœé’±/èººå¹³)
    socket.on('switch_autoplay_mode', ({ roomId, mode }) => {
        const room = rooms[roomId];
        if (!room || !room.gameManager) return;

        room.gameManager.setPlayerAutoPlayMode(socket.id, mode);
        broadcastGameState(roomId, room);
    });

    // 8. è¯·æ±‚æç¤º
    socket.on('request_hint', ({ roomId }) => {
        const room = rooms[roomId];
        if (room && room.gameManager) {
            const cards = room.gameManager.getHint(socket.id);
            socket.emit('hint_response', cards);
        }
    });
};

================================================================================
FILE PATH: server\handlers\roomHandler.js
================================================================================
module.exports = (io, socket, rooms) => {
    
    // --- åŸºç¡€è¿æ¥æ£€æµ‹ ---
    socket.on('ping', (callback) => {
        if (typeof callback === 'function') {
            callback();
        }
    });

    // --- è¾…åŠ©å‡½æ•°ï¼šå¹¿æ’­æˆ¿é—´ä¿¡æ¯ ---
    const broadcastRoomInfo = (roomId) => {
        const room = rooms[roomId];
        if (!room) return;
        
        const currentGrandScores = room.gameManager ? room.gameManager.grandScores : {};
        // å¦‚æœæ²¡æœ‰ç§¯åˆ†æ•°æ®ï¼Œåˆå§‹åŒ–ä¸º0
        if (Object.keys(currentGrandScores).length === 0) {
            room.players.forEach(p => currentGrandScores[p.id] = 0);
        }

        // å¹¿æ’­æ—¶å¸¦ä¸Šè§‚ä¼—äººæ•°
        const spectatorCount = room.spectators ? room.spectators.length : 0;

        const data = { 
            roomId, 
            config: room.config, 
            players: room.players, 
            grandScores: currentGrandScores,
            spectatorCount 
        };
        io.to(roomId).emit('room_info', data);
    };

    // --- è¾…åŠ©å‡½æ•°ï¼šå¹¿æ’­æ¸¸æˆçŠ¶æ€ ---
    const broadcastGameState = (roomId, room, infoText = null) => {
        if (!room.gameManager) return;
        const publicState = room.gameManager.getPublicState();
        if (!publicState) return;
        if (infoText) publicState.infoText = infoText;
        io.to(roomId).emit('game_state_update', publicState);
    };

    // ==========================================
    //               æˆ¿é—´ç®¡ç†äº‹ä»¶
    // ==========================================

    socket.on('create_room', ({ roomId, username, config }) => {
        if (rooms[roomId]) {
            if (rooms[roomId].isPermanent) {
                 return socket.emit('error_msg', 'å¸¸é©»æˆ¿é—´å·²å­˜åœ¨ï¼Œè¯·ç›´æ¥åŠ å…¥');
            }
            return socket.emit('error_msg', 'æˆ¿é—´å·²å­˜åœ¨');
        }
        
        const cleanName = String(username || '').trim();
        if (!cleanName) return socket.emit('error_msg', 'ç”¨æˆ·åä¸èƒ½ä¸ºç©º');

        const roomConfig = { 
            deckCount: 1, 
            maxPlayers: 3, 
            targetScore: 500, 
            shuffleStrategy: 'CLASSIC',
            ...config 
        };
        
        rooms[roomId] = {
            config: roomConfig,
            players: [],
            spectators: [], // è§‚ä¼—åˆ—è¡¨
            gameManager: null,
            seatManager: null, 
            destroyTimer: null 
        };
        
        socket.join(roomId);
        rooms[roomId].players.push({ id: socket.id, name: cleanName, isHost: true, online: true });
        
        broadcastRoomInfo(roomId);
    });

    // åŠ å…¥æˆ¿é—´é€»è¾‘ (æ”¯æŒè§‚æˆ˜)
    socket.on('join_room', ({ roomId, username }) => {
        const room = rooms[roomId];
        if (!room) return socket.emit('error_msg', 'æˆ¿é—´ä¸å­˜åœ¨');

        const cleanName = String(username || '').trim();
        if (!cleanName) return socket.emit('error_msg', 'ç”¨æˆ·åä¸èƒ½ä¸ºç©º');

        const existingPlayerIndex = room.players.findIndex(p => p.name === cleanName);
        let isReconnect = false;
        let oldSocketId = null;

        if (existingPlayerIndex !== -1) {
            // --- é‡è¿é€»è¾‘ ---
            const existingPlayer = room.players[existingPlayerIndex];
            
            if (existingPlayer.online && existingPlayer.id !== socket.id) {
                 const oldSocket = io.sockets.sockets.get(existingPlayer.id);
                 if (oldSocket) {
                     oldSocket.emit('error_msg', 'æ‚¨çš„è´¦å·å·²åœ¨å…¶ä»–é¡µé¢ç™»å½•');
                     oldSocket.disconnect(); 
                 }
            }

            isReconnect = true;
            oldSocketId = existingPlayer.id;
            existingPlayer.id = socket.id;
            existingPlayer.online = true; 

            if (room.destroyTimer) {
                clearTimeout(room.destroyTimer);
                room.destroyTimer = null;
            }

            if (room.gameManager) room.gameManager.reconnectPlayer(oldSocketId, socket.id);
            if (room.seatManager) room.seatManager.reconnectPlayer(oldSocketId, socket.id);

            socket.join(roomId);
        } else {
            // --- æ–°ç©å®¶æˆ–è§‚ä¼—é€»è¾‘ ---
            const isFull = room.players.length >= room.config.maxPlayers;
            const isGameRunning = room.gameManager && room.gameManager.gameState;

            if (isFull || isGameRunning) {
                // è¿›å…¥è§‚æˆ˜æ¨¡å¼
                socket.join(roomId);
                if (!room.spectators) room.spectators = [];
                const existingSpec = room.spectators.find(s => s.id === socket.id);
                if (!existingSpec) {
                    room.spectators.push({ id: socket.id, name: cleanName });
                }
                socket.emit('spectator_join', { message: 'æˆ¿é—´å·²æ»¡æˆ–æ¸¸æˆä¸­ï¼Œæ‚¨å·²è¿›å…¥è§‚æˆ˜æ¨¡å¼' });
            } else {
                // æ­£å¸¸åŠ å…¥
                socket.join(roomId);
                if (!room.players.find(u => u.id === socket.id)) {
                    const hasHost = room.players.some(p => p.isHost && p.online);
                    const isHost = !hasHost;
                    room.players.push({ id: socket.id, name: cleanName, isHost: isHost, online: true });
                }
            }
        }

        broadcastRoomInfo(roomId);

        // å¦‚æœæ¸¸æˆè¿›è¡Œä¸­ï¼Œå‘é€çŠ¶æ€
        if (room.gameManager && room.gameManager.gameState) {
            if (isReconnect) {
                const hand = room.gameManager.getPlayerHand(socket.id);
                socket.emit('game_started', { 
                    hand: hand, 
                    grandScores: room.gameManager.grandScores,
                    handCounts: room.gameManager.getPublicState().handCounts
                });
            } else {
                // è§‚ä¼—æˆ–æ–°åŠ å…¥è€…
                socket.emit('game_started', { 
                    hand: [], 
                    grandScores: room.gameManager.grandScores,
                    handCounts: room.gameManager.getPublicState().handCounts,
                    isSpectator: true 
                });
            }
            broadcastGameState(roomId, room);
        }
        
        // æŠ“ç‰Œé˜¶æ®µåŒæ­¥ (å¦‚æœå­˜åœ¨ SeatManager)
        if (room.seatManager && room.seatManager.drawResults) {
             socket.emit('enter_draw_phase', { totalCards: room.players.length });
             Object.entries(room.seatManager.drawResults).forEach(([pid, val]) => {
                 const pName = room.players.find(p=>p.id===pid)?.name || 'æœªçŸ¥';
                 let cardIndex = -1;
                 room.seatManager.availableCards.forEach((c, idx) => { if (c === val) cardIndex = idx; });
                 socket.emit('seat_draw_update', { index: cardIndex, val: val, playerId: pid, name: pName });
             });
        }
    });

    socket.on('update_room_config', ({ roomId, config }) => {
        const room = rooms[roomId];
        if (!room) return;
        const player = room.players.find(p => p.id === socket.id);
        if (!player || !player.isHost) return socket.emit('error_msg', 'åªæœ‰æˆ¿ä¸»å¯ä»¥ä¿®æ”¹è§„åˆ™');
        if (room.gameManager || room.seatManager) return socket.emit('error_msg', 'æ¸¸æˆè¿›è¡Œä¸­æ— æ³•ä¿®æ”¹è§„åˆ™');

        if (config.isNoShuffleMode !== undefined) room.config.shuffleStrategy = config.isNoShuffleMode ? 'NO_SHUFFLE' : 'CLASSIC';
        if (config.shuffleStrategy) room.config.shuffleStrategy = config.shuffleStrategy;

        room.config = { ...room.config, ...config };
        broadcastRoomInfo(roomId);
    });

    socket.on('add_bot', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room) return;
        if (room.players.length >= room.config.maxPlayers) return socket.emit('error_msg', 'æˆ¿é—´å·²æ»¡');
        
        const botId = `bot_${Date.now()}_${Math.floor(Math.random()*1000)}`;
        let botName = `Bot_${Date.now().toString().slice(-4)}`;
        room.players.push({ id: botId, name: botName, isHost: false, online: true, isBot: true });
        broadcastRoomInfo(roomId);
    });

    socket.on('kick_player', ({ roomId, targetId }) => {
        const room = rooms[roomId];
        if (!room) return;
        const sender = room.players.find(p => p.id === socket.id);
        if (!sender || !sender.isHost) return socket.emit('error_msg', 'åªæœ‰æˆ¿ä¸»å¯ä»¥è¸¢äºº');
        if (room.gameManager || room.seatManager) return socket.emit('error_msg', 'æ¸¸æˆè¿›è¡Œä¸­æ— æ³•è¸¢äºº');

        const targetIndex = room.players.findIndex(p => p.id === targetId);
        if (targetIndex === -1) return;
        const targetPlayer = room.players[targetIndex];
        if (targetPlayer.id === socket.id) return;

        room.players.splice(targetIndex, 1);
        if (!targetPlayer.isBot) {
            io.to(targetPlayer.id).emit('kicked', 'ä½ å·²è¢«æˆ¿ä¸»ç§»å‡ºæˆ¿é—´');
            const targetSocket = io.sockets.sockets.get(targetPlayer.id);
            if (targetSocket) targetSocket.leave(roomId);
        }
        broadcastRoomInfo(roomId);
    });

    socket.on('switch_seat', ({ roomId, index1, index2 }) => {
        const room = rooms[roomId];
        if (!room) return;
        const requestPlayer = room.players.find(p => p.id === socket.id);
        if (!requestPlayer || !requestPlayer.isHost) return socket.emit('error_msg', 'åªæœ‰æˆ¿ä¸»å¯ä»¥è°ƒæ•´åº§ä½');
        if (room.gameManager && room.gameManager.gameState) return socket.emit('error_msg', 'æ¸¸æˆä¸­æ— æ³•è°ƒæ•´åº§ä½');
        if (index1 < 0 || index1 >= room.players.length || index2 < 0 || index2 >= room.players.length) return;

        const temp = room.players[index1];
        room.players[index1] = room.players[index2];
        room.players[index2] = temp;
        broadcastRoomInfo(roomId);
    });

    // ==========================================
    //          æ–­å¼€è¿æ¥å¤„ç†
    // ==========================================
    
    socket.on('disconnecting', () => {
        const roomsToLeave = [...socket.rooms];
        roomsToLeave.forEach(roomId => {
            const room = rooms[roomId];
            if (room) {
                // 1. å¤„ç†è§‚ä¼—ç¦»å¼€
                if (room.spectators) {
                    const specIndex = room.spectators.findIndex(s => s.id === socket.id);
                    if (specIndex !== -1) {
                        console.log(`[Spectator] Left: ${room.spectators[specIndex].name}`);
                        room.spectators.splice(specIndex, 1);
                        broadcastRoomInfo(roomId);
                        return; // å¦‚æœæ˜¯è§‚ä¼—ï¼Œå¤„ç†å®Œå°±é€€å‡ºï¼Œä¸æ¶‰åŠç©å®¶é€»è¾‘
                    }
                }

                // 2. å¤„ç†æ­£å¼ç©å®¶ç¦»å¼€
                const player = room.players.find(p => p.id === socket.id);
                if (player) {
                    console.log(`[Disconnect] Player ${player.name} (${player.id}) disconnected from room ${roomId}`);
                    
                    if (room.gameManager && room.gameManager.gameState) {
                        // æ¸¸æˆè¿›è¡Œä¸­ï¼šæ ‡è®°ç¦»çº¿ï¼Œä¸ç§»é™¤
                        player.online = false;
                        broadcastRoomInfo(roomId);
                        // å¦‚æœå¼€å¯äº†æ‰˜ç®¡ï¼Œè‡ªåŠ¨æ¥ç®¡
                        if (!player.isAutoPlay && !player.isBot) {
                            player.isAutoPlay = true;
                            room.gameManager.botManager.checkAndRun();
                            broadcastGameState(roomId, room, `${player.name} æ–­çº¿ï¼Œè‡ªåŠ¨æ‰˜ç®¡`);
                        }
                    } else {
                        // æ¸¸æˆæœªå¼€å§‹ï¼šç›´æ¥ç§»é™¤
                        room.players = room.players.filter(p => p.id !== socket.id);
                        
                        // ç§»äº¤æˆ¿ä¸»æƒé™
                        if (player.isHost && room.players.length > 0) {
                            const nextHost = room.players.find(p => !p.isBot && p.online) || room.players[0];
                            nextHost.isHost = true;
                        }
                        
                        broadcastRoomInfo(roomId);
                    }

                    // æ£€æŸ¥æ˜¯å¦ç©ºæˆ¿é—´ï¼Œç©ºåˆ™é”€æ¯
                    const realPlayers = room.players.filter(p => !p.isBot);
                    const onlineRealPlayers = realPlayers.filter(p => p.online);

                    if (onlineRealPlayers.length === 0) {
                        // è®¾ç½®é”€æ¯å®šæ—¶å™¨ (1å°æ—¶åé”€æ¯ï¼Œä¿ç•™ä¸€æ®µæ—¶é—´ç»™ç©å®¶é‡è¿)
                        if (!room.isPermanent) {
                             if (room.destroyTimer) clearTimeout(room.destroyTimer);
                             room.destroyTimer = setTimeout(() => {
                                 console.log(`[Room] Destroying empty room ${roomId}`);
                                 delete rooms[roomId];
                             }, 3600000); 
                        }
                    }
                }
            }
        });
    });
};

================================================================================
FILE PATH: server\index.js
================================================================================
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const cors = require('cors');
const path = require('path');

// [ä¿®å¤] å¼•å…¥é…ç½®æ–‡ä»¶å’Œé€»è¾‘å¤„ç†å™¨
const { PERMANENT_ROOMS, GLOBAL_CONFIG } = require('./config/constants');
const registerRoomHandlers = require('./handlers/roomHandler');
const registerGameHandlers = require('./handlers/gameHandler');

const app = express();
app.use(cors());

const server = http.createServer(app);
const io = new Server(server, {
    cors: {
        origin: "*", 
        methods: ["GET", "POST"]
    }
});

// å…¨å±€æˆ¿é—´æ•°æ®å­˜å‚¨
const rooms = {};

// [ä¿®å¤] åˆå§‹åŒ–å¸¸é©»æˆ¿é—´ (æ ¹æ® constants.js é…ç½®)
if (PERMANENT_ROOMS) {
    Object.entries(PERMANENT_ROOMS).forEach(([id, config]) => {
        rooms[id] = {
            config: config,
            players: [],
            gameManager: null,
            seatManager: null,
            isPermanent: true
        };
        console.log(`[Init] Permanent room ${id} created.`);
    });
}

io.on('connection', (socket) => {
    console.log(`User Connected: ${socket.id}`);
    registerRoomHandlers(io, socket, rooms);
    registerGameHandlers(io, socket, rooms);

    // æ–­å¼€è¿æ¥å¤„ç†
    socket.on('disconnect', () => {
        console.log('User Disconnected', socket.id);
        
        // éå†æˆ¿é—´ï¼Œæ ‡è®°ç©å®¶ç¦»çº¿
        for (const roomId in rooms) {
            const room = rooms[roomId];
            const player = room.players.find(p => p.id === socket.id);
            
            if (player) {
                player.online = false;
                // å¦‚æœåœ¨æ¸¸æˆä¸­ï¼Œå¯èƒ½éœ€è¦é€šçŸ¥å…¶ä»–äºº (gameHandler ä¸­é€šå¸¸ä¼šæœ‰æ›´ç»†è‡´çš„å¤„ç†ï¼Œè¿™é‡Œä»…åšåŸºç¡€æ ‡è®°)
                // å¹¿æ’­æˆ¿é—´æœ€æ–°ä¿¡æ¯ï¼Œè®©å‰ç«¯çœ‹åˆ°ç°å¤´åƒ
                const currentGrandScores = room.gameManager ? room.gameManager.grandScores : {};
                if (Object.keys(currentGrandScores).length === 0 && room.players.length > 0) {
                     room.players.forEach(p => currentGrandScores[p.id] = (room.gameManager?.grandScores?.[p.id] || 0));
                }

                io.to(roomId).emit('room_info', { 
                    roomId, 
                    config: room.config, 
                    players: room.players, 
                    grandScores: currentGrandScores 
                });
                
                // å¦‚æœæ˜¯ä¸´æ—¶æˆ¿é—´ä¸”ç©ºäº†ï¼Œå¯ä»¥åœ¨è¿™é‡ŒåŠ æ¸…ç†é€»è¾‘ï¼ˆç›®å‰ä¸ºäº†æ–­çº¿é‡è¿ä¿ç•™æˆ¿é—´ï¼‰
            }
        }
    });
});

// é”™è¯¯å¤„ç†
process.on('uncaughtException', (err) => {
    console.error('[FATAL ERROR] Uncaught Exception:', err);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('[FATAL ERROR] Unhandled Rejection at:', promise, 'reason:', reason);
});

// ç”Ÿäº§ç¯å¢ƒé™æ€æ–‡ä»¶æœåŠ¡
if (process.env.NODE_ENV === 'production') {
    const buildPath = path.join(__dirname, '../client/dist');
    app.use(express.static(buildPath));
    app.get(/(.*)/, (req, res) => {
        res.sendFile(path.join(__dirname, '../client/dist', 'index.html'));
    });
}

const PORT = process.env.PORT || GLOBAL_CONFIG.SERVER_PORT || 3001;
server.listen(PORT, () => {
    console.log(`>>> Server Running on port ${PORT}`);
});

================================================================================
FILE PATH: server\package.json
================================================================================
{
  "name": "server",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^5.2.1",
    "nodemon": "^3.1.11",
    "socket.io": "^4.8.1"
  }
}


================================================================================
FILE PATH: server\utils\socketAuth.js
================================================================================
// (å¯é€‰) èº«ä»½éªŒè¯å·¥å…·
