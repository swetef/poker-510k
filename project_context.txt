Project Context Generated at 2025/12/23 19:14:12


================================================================================
FILE PATH: client\eslint.config.js
================================================================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])


================================================================================
FILE PATH: client\index.html
================================================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    
    <!-- [关键修改] 增加 viewport-fit=cover 解决顶部黑边问题 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    
    <link rel="manifest" href="/manifest.json">
    
    <!-- [修复] 替换过时的 apple-mobile-web-app-capable -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="510K对战">
    
    <title>client</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

================================================================================
FILE PATH: client\package.json
================================================================================
{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "lucide-react": "^0.559.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "socket.io-client": "^4.8.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "vite": "npm:rolldown-vite@7.2.5"
  },
  "overrides": {
    "vite": "npm:rolldown-vite@7.2.5"
  }
}


================================================================================
FILE PATH: client\src\App.css
================================================================================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}


================================================================================
FILE PATH: client\src\App.jsx
================================================================================
import React from 'react';
import { RefreshCw, AlertCircle, WifiOff } from 'lucide-react'; 
// [修复] 修正导入路径，确保在 client/src/App.jsx 位置能正确引用
import { useGame } from './context/GameContext'; // Vite 通常可以自动解析 .jsx，也可以显式写

import { LoginScreen } from './screens/LoginScreen';
import { LobbyScreen } from './screens/LobbyScreen';
import { GameScreen } from './screens/GameScreen';
import { DrawSeatScreen } from './screens/DrawSeatScreen';

export default function App() {
  const { gameState, isConnected } = useGame();

  const renderLandscapeHint = () => (
      <div className="landscape-hint">
          <div className="phone-rotate-icon"></div>
          <h3 style={{marginBottom: 10, fontSize: 18}}>建议使用横屏游玩</h3>
          <p style={{fontSize: 14, opacity: 0.8, maxWidth: 250}}>
              510K 需要较大的展示空间。<br/>
              请旋转您的手机以获得最佳体验。
          </p>
          <button 
            style={{marginTop: 20, padding: '8px 20px', background: 'rgba(255,255,255,0.2)', color:'white', border:'1px solid white'}}
            onClick={(e) => { e.currentTarget.parentElement.style.display = 'none'; }}
          >
              我非要竖屏玩
          </button>
      </div>
  );

  // [修改] 优化后的断线重连提示
  const renderDisconnectAlert = () => (
      !isConnected && (
          <div style={{
              position: 'fixed', top: 0, left: 0, right: 0, zIndex: 9999,
              background: 'rgba(231, 76, 60, 0.95)', color: 'white', padding: '8px',
              display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 10,
              boxShadow: '0 2px 10px rgba(0,0,0,0.2)', backdropFilter: 'blur(5px)',
              fontSize: 13, fontWeight: '500'
          }}>
              <WifiOff size={16} className="pulse-icon" />
              <span>网络连接已断开，正在尝试自动恢复...</span>
              
              {/* 如果自动重连太久没反应，给个手动按钮 */}
              <button 
                onClick={() => window.location.reload()} 
                style={{
                    background: 'white', color: '#e74c3c', border: 'none', 
                    borderRadius: 20, padding: '4px 12px', fontSize: 12, fontWeight: 'bold',
                    cursor: 'pointer', display: 'flex', alignItems: 'center', gap: 4,
                    marginLeft: 10
                }}
              >
                  <RefreshCw size={12} /> 立即刷新
              </button>
              <style>{`.pulse-icon { animation: pulse 1.5s infinite; } @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }`}</style>
          </div>
      )
  );

  return (
    <>
      {renderDisconnectAlert()}
      {renderLandscapeHint()}
      
      {gameState === 'LOGIN' && <LoginScreen />}
      
      {gameState === 'LOBBY' && <LobbyScreen />}
      
      {gameState === 'DRAW_SEATS' && <DrawSeatScreen />}
      
      {gameState === 'GAME' && <GameScreen />}
    </>
  );
}

================================================================================
FILE PATH: client\src\components\BaseUI.jsx
================================================================================
// BaseUI.jsx 现在主要作为组件导出入口
// 具体的组件逻辑已经拆分到 ui/ 目录下
// 这样可以大幅减少单个文件的长度，便于 AI 阅读和维护

export { Card, MiniCard } from './ui/Card.jsx';
export { GameLogPanel } from './ui/GameLogPanel.jsx';
export { PlayerAvatar } from './ui/PlayerAvatar.jsx';

================================================================================
FILE PATH: client\src\components\CountDownTimer.jsx
================================================================================
import React, { useState, useEffect, useRef } from 'react';
import { Clock } from 'lucide-react';
import SoundManager from '../utils/SoundManager.js';

const CountDownTimer = ({ initialSeconds, totalSeconds = 60, position = 'top' }) => {
    const [seconds, setSeconds] = useState(initialSeconds);
    const intervalRef = useRef(null);

    useEffect(() => {
        setSeconds(initialSeconds);
    }, [initialSeconds]);

    useEffect(() => {
        if (intervalRef.current) clearInterval(intervalRef.current);
        if (seconds <= 0) return;

        intervalRef.current = setInterval(() => {
            setSeconds((prev) => {
                if (prev <= 1) {
                    clearInterval(intervalRef.current);
                    return 0;
                }
                
                if (prev <= 6 && prev > 1) {
                     SoundManager.play('tick');
                }
                
                return prev - 1;
            });
        }, 1000);

        return () => {
            if (intervalRef.current) clearInterval(intervalRef.current);
        };
    }, [initialSeconds]);

    const isUrgent = seconds <= 10;
    const isCritical = seconds <= 5; 
    
    const color = isUrgent ? '#ff4d4d' : '#ffffff';
    const bgColor = isUrgent ? 'rgba(231, 76, 60, 0.9)' : 'rgba(0, 0, 0, 0.7)';

    let posStyle = {};
    switch (position) {
        case 'bottom':
            posStyle = { top: '100%', left: '50%', transform: 'translateX(-50%)', marginTop: 5 };
            break;
        case 'left':
            posStyle = { right: '100%', top: '50%', transform: 'translateY(-50%)', marginRight: 8 };
            break;
        case 'right':
            posStyle = { left: '100%', top: '50%', transform: 'translateY(-50%)', marginLeft: 8 };
            break;
        case 'top-right': 
            posStyle = { left: '100%', top: -20, marginLeft: 5 };
            break;
        case 'inline': 
            posStyle = { position: 'static', margin: '0 10px' };
            break;
        case 'top':
        default:
            posStyle = { bottom: '100%', left: '50%', transform: 'translateX(-50%)', marginBottom: 5 };
            break;
    }

    const containerStyle = position === 'inline' ? {
        ...posStyle,
        background: bgColor,
        padding: '4px 10px',
        borderRadius: 20,
        display: 'flex',
        alignItems: 'center',
        gap: 5,
        border: '1px solid rgba(255,255,255,0.2)',
        transition: 'all 0.3s'
    } : {
        position: 'absolute',
        ...posStyle,
        background: bgColor,
        padding: '2px 8px',
        borderRadius: 20,
        display: 'flex',
        alignItems: 'center',
        gap: 3,
        whiteSpace: 'nowrap',
        boxShadow: '0 4px 10px rgba(0,0,0,0.3)',
        border: '1px solid rgba(255,255,255,0.2)',
        zIndex: 30,
        transition: 'all 0.3s'
    };

    return (
        <div style={containerStyle} className={isCritical ? "critical-pulse" : ""}>
            <Clock size={12} color={color} className={isUrgent ? 'spin' : ''} />
            <span style={{ 
                color: color, 
                fontWeight: 'bold', 
                fontSize: 12,
                fontFamily: 'monospace'
            }}>
                {seconds}s
            </span>
            <style>{`.spin { animation: spin 1s linear infinite; }`}</style>
        </div>
    );
};

export default CountDownTimer;

================================================================================
FILE PATH: client\src\components\game\GameActionBar.jsx
================================================================================
import React, { useState, useEffect } from 'react';
import { RotateCcw, Zap, Lightbulb, Clock, Loader2, AlertTriangle, Repeat, Shield, Coins, Coffee, Eye } from 'lucide-react';
import css from './GameActionBar.module.css';
import { useGame } from '../../context/GameContext.jsx';
import TimerComponent from '../CountDownTimer.jsx';
import { isBomb } from '../../utils/cardLogic.js';

export const GameActionBar = () => {
    const { 
        winner, roundResult, grandResult, selectedCards, 
        playersInfo, mySocketId, currentTurnId, players, turnRemaining,
        handleClearSelection, handleToggleAutoPlay, handleSwitchAutoPlayMode,
        handlePass, handleRequestHint, handlePlayCards,
        isSubmitting, lastPlayerName,
        isSpectator, observedHands // [新增]
    } = useGame();

    const [confirmState, setConfirmState] = useState(false);

    useEffect(() => {
        setConfirmState(false);
    }, [selectedCards, currentTurnId]);

    if (winner || roundResult || grandResult) return null;

    // [新增] 如果是观众，显示简单的状态栏
    if (isSpectator) {
        return (
             <div className={css.actionBar}>
                <div className={css.waitingBadge}>
                    <Eye size={20} /> 正在观战中...
                </div>
            </div>
        );
    }

    const myInfo = playersInfo[mySocketId] || {};
    const amIAutoPlay = myInfo.isAutoPlay;
    const currentMode = myInfo.autoPlayMode || 'SMART';
    
    // [新增] 如果已经打完牌了 (赢了)，显示观看状态
    // 通过判断手牌数 (myHand 在 Context 里，但这里没解构，可以用 observedHands 侧面判断)
    // 更简单的判断：如果在 observedHands 里有数据，说明我已经 finished 并且收到了推送
    const isFinishedAndWatching = Object.keys(observedHands).length > 0;
    
    if (isFinishedAndWatching) {
        return (
            <div className={css.actionBar}>
                <div className={css.waitingBadge} style={{background: 'rgba(52, 152, 219, 0.4)'}}>
                    <Eye size={20} /> 已完赛，观看队友中
                </div>
            </div>
        );
    }
    
    const myTurn = currentTurnId === mySocketId;
    const currentTurnPlayer = players.find(p => p.id === currentTurnId);
    const waitingText = currentTurnPlayer ? `等待 ${currentTurnPlayer.name}...` : '等待中...';

    const handlePlayClick = () => {
        if (isSubmitting) return;
        
        if (selectedCards.length === 0) {
            handlePlayCards();
            return;
        }

        const lastPlayer = players.find(p => p.name === lastPlayerName);
        const isTeammate = 
            myInfo.team !== undefined && myInfo.team !== null && 
            lastPlayer && lastPlayer.id !== mySocketId && 
            playersInfo[lastPlayer.id]?.team === myInfo.team;

        const playingBomb = isBomb(selectedCards);

        if (isTeammate && playingBomb && !confirmState) {
            setConfirmState(true);
            setTimeout(() => setConfirmState(false), 3000);
            return;
        }

        handlePlayCards();
        setConfirmState(false);
    };

    const cycleMode = () => {
        const modes = ['SMART', 'THRIFTY', 'AFK'];
        const currentIdx = modes.indexOf(currentMode);
        const nextMode = modes[(currentIdx + 1) % modes.length];
        handleSwitchAutoPlayMode(nextMode);
    };

    const getModeLabel = (mode) => {
        switch(mode) {
            case 'SMART': return { text: '智能(保队友)', icon: <Shield size={14} />, color: '#2ecc71' };
            case 'THRIFTY': return { text: '省钱(无分不炸)', icon: <Coins size={14} />, color: '#f1c40f' };
            case 'AFK': return { text: '躺平(全不要)', icon: <Coffee size={14} />, color: '#95a5a6' };
            default: return { text: '智能', icon: <Shield size={14} />, color: '#2ecc71' };
        }
    };

    const modeInfo = getModeLabel(currentMode);

    return (
        <div className={css.actionBar}>
            <div className={css.buttonGroup}>
                {selectedCards.length > 0 && (
                    <button 
                        className={css.btnReset}
                        onClick={handleClearSelection}
                        disabled={isSubmitting}
                    >
                        <RotateCcw size={16} /> 重选
                    </button>
                )}
                
                {amIAutoPlay ? (
                    <div className={css.autoPlayGroup}>
                        <button 
                            className={css.btnModeSwitch}
                            onClick={cycleMode}
                            style={{borderColor: modeInfo.color, color: modeInfo.color}}
                        >
                            {modeInfo.icon} {modeInfo.text} <Repeat size={12} style={{opacity:0.6}}/>
                        </button>

                        <button 
                            className={css.btnCancelAuto}
                            onClick={handleToggleAutoPlay}
                        >
                            <Zap size={18} /> 取消托管
                        </button>
                    </div>
                ) : (
                    <>
                        {myTurn ? (
                            <>
                                <button 
                                    className={css.btnSecondary}
                                    onClick={handlePass}
                                    disabled={isSubmitting}
                                >
                                    不要
                                </button>
                                
                                <button 
                                    className={css.btnHint}
                                    onClick={handleRequestHint}
                                    disabled={isSubmitting}
                                >
                                    <Lightbulb size={16} /> 提示
                                </button>

                                <TimerComponent initialSeconds={turnRemaining} totalSeconds={60} position="inline" />
                                
                                <button 
                                    className={confirmState ? css.btnWarning : css.btnPlay} 
                                    onClick={handlePlayClick}
                                    disabled={isSubmitting}
                                >
                                    {isSubmitting ? (
                                        <Loader2 size={18} className="spin"/>
                                    ) : (
                                        confirmState ? (
                                            <>
                                                <AlertTriangle size={18} /> 确认炸队友?
                                            </>
                                        ) : '出牌'
                                    )}
                                </button>
                            </>
                        ) : (
                            <div className={css.waitingBadge}>
                                <Clock size={20} className="spin" /> {waitingText}
                            </div>
                        )}
                    </>
                )}
            </div>
        </div>
    );
};

================================================================================
FILE PATH: client\src\components\game\GameActionBar.module.css
================================================================================
.actionBar {
    position: absolute;
    bottom: 100px;
    width: 100%;
    height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
    pointer-events: none; /* 容器穿透 */
    /* [修改] 提升层级至 100，确保高于手牌区域 (z-index: 20) 和其他特效层 */
    z-index: 100;
}

.buttonGroup {
    display: flex;
    align-items: center;
    gap: 20px;
    pointer-events: auto; /* 按钮可点 */
}

/* 托管模式组合容器 */
.autoPlayGroup {
    display: flex;
    gap: 10px;
    background: rgba(0,0,0,0.6);
    padding: 10px;
    border-radius: 40px;
    border: 1px solid rgba(255,255,255,0.2);
    /* [修复] 显式开启点击事件并提升层级，防止被手牌遮罩层挡住 */
    pointer-events: auto;
    z-index: 101;
}

/* 模式切换按钮 */
.btnModeSwitch {
    background: rgba(255,255,255,0.1);
    border: 1px solid #ccc;
    color: white;
    padding: 8px 15px;
    border-radius: 30px;
    font-size: 13px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 5px;
    transition: all 0.2s;
}

.btnModeSwitch:active {
    transform: scale(0.95);
}

/* 基础按钮样式 */
.btn {
    border: none;
    border-radius: 40px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 5px;
    transition: all 0.2s;
    color: white;
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.btn:active {
    transform: scale(0.95);
}

/* 灰色功能按钮 (重选、不要、提示) */
.btnSecondary {
    composes: btn;
    padding: 8px 15px;
    background: #7f8c8d;
    font-size: 14px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

.btnHint {
    composes: btnSecondary;
    background: #8e44ad;
}

.btnReset {
    composes: btnSecondary;
    background: #95a5a6;
}

/* 出牌按钮 (高亮) */
.btnPlay {
    composes: btn;
    padding: 8px 30px;
    background: linear-gradient(to bottom, #f1c40f, #f39c12);
    font-size: 16px;
    box-shadow: 0 8px 20px rgba(243, 156, 18, 0.4);
    text-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

.btnCancelAuto {
    composes: btnPlay;
    background: #e74c3c;
    width: auto;
    padding: 8px 20px;
    box-shadow: 0 8px 20px rgba(231, 76, 60, 0.4);
    font-size: 14px;
}

/* 等待提示 */
.waitingBadge {
    color: rgba(255,255,255,0.7);
    font-size: 16px;
    display: flex;
    align-items: center;
    gap: 10px;
    background: rgba(0,0,0,0.3);
    padding: 10px 20px;
    border-radius: 30px;
}

.btnWarning {
    composes: btnPlay;
    background: linear-gradient(to bottom, #e74c3c, #c0392b);
    box-shadow: 0 8px 20px rgba(231, 76, 60, 0.4);
    animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
}

@keyframes shake {
    10%, 90% { transform: translate3d(-1px, 0, 0); }
    20%, 80% { transform: translate3d(2px, 0, 0); }
    30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
    40%, 60% { transform: translate3d(4px, 0, 0); }
}

================================================================================
FILE PATH: client\src\components\game\GameHeader.jsx
================================================================================
import React, { useState } from 'react';
// [修改] 引入 Info 图标
import { Zap, Minimize, Maximize, Layers, Shield, ChevronDown, ChevronUp, Wifi, WifiOff, LogOut, Info } from 'lucide-react';
import css from './GameHeader.module.css'; 
import { useGame } from '../../context/GameContext.jsx';

/**
 * [比分板组件] 红蓝队分数 (内部使用)
 */
const TeamScoreBoard = () => {
    // ... (保持 TeamScoreBoard 代码不变，省略以节省空间) ...
    const { players, playersInfo, playerScores, roomConfig } = useGame();
    const [isCollapsed, setIsCollapsed] = useState(true);

    let redScore = 0, blueScore = 0, hasTeams = false;
    players.forEach(p => {
        const pInfo = playersInfo[p.id];
        const score = playerScores[p.id] || 0;
        if (pInfo && pInfo.team !== undefined && pInfo.team !== null) {
            hasTeams = true;
            if (pInfo.team === 0) redScore += score;
            else if (pInfo.team === 1) blueScore += score;
        }
    });

    if (!hasTeams) return null;

    return (
        <div className={css.teamScoreContainer}>
            <div className={css.teamScoreBar} onClick={() => setIsCollapsed(!isCollapsed)}>
                <div className={css.scoreItem} style={{color:'#e74c3c'}}>
                    <Shield size={12} fill="currentColor"/> {redScore}
                </div>
                <div className={css.divider}></div>
                <div className={css.scoreItem} style={{color:'#3498db'}}>
                    <Shield size={12} fill="currentColor"/> {blueScore}
                </div>
                {isCollapsed ? <ChevronDown size={14} color="#ccc"/> : <ChevronUp size={14} color="#ccc"/>}
            </div>

            {!isCollapsed && (
                <div className={css.scoreDropdown}>
                    <div style={{marginBottom: 5, color: '#f1c40f', fontWeight: 'bold'}}>当前比分详情</div>
                    <div style={{display:'flex', justifyContent:'space-between', marginBottom:2}}>
                        <span style={{color:'#e74c3c'}}>红队</span> <span>{redScore}</span>
                    </div>
                    <div style={{display:'flex', justifyContent:'space-between', marginBottom:6}}>
                        <span style={{color:'#3498db'}}>蓝队</span> <span>{blueScore}</span>
                    </div>
                    <div style={{height:1, background:'rgba(255,255,255,0.1)', marginBottom:6}}></div>
                    <div>目标分数: {roomConfig.targetScore}</div>
                </div>
            )}
        </div>
    );
};

/**
 * [Header组件]
 */
export const GameHeader = () => {
    // [修改] 解构 roomConfig
    const { roomId, playersInfo, mySocketId, toggleSort, sortMode, handleToggleAutoPlay, ping, isConnected, handleLeaveRoom, roomConfig } = useGame();
    const [isFullScreen, setIsFullScreen] = useState(false);
    // [新增] 控制房间详情显示
    const [showRoomInfo, setShowRoomInfo] = useState(false);
    
    const myInfo = playersInfo[mySocketId] || {};
    const amIAutoPlay = myInfo.isAutoPlay;

    const toggleFullScreen = () => {
        const doc = window.document;
        const docEl = doc.documentElement;
        const requestFullScreen = docEl.requestFullscreen || docEl.webkitRequestFullScreen;
        const cancelFullScreen = doc.exitFullscreen || doc.webkitExitFullscreen;
        if (!doc.fullscreenElement && !doc.webkitFullscreenElement) {
            if (requestFullScreen) requestFullScreen.call(docEl).then(()=>setIsFullScreen(true)).catch(e=>console.log(e));
        } else {
            if (cancelFullScreen) cancelFullScreen.call(doc).then(()=>setIsFullScreen(false));
        }
    };

    const getPingColor = (p) => {
        if (!isConnected) return '#e74c3c';
        if (p < 100) return '#2ecc71';
        if (p < 200) return '#f1c40f';
        return '#e74c3c';
    };

    const getSortButtonText = () => {
        if (sortMode === 'POINT') return '点数';
        if (sortMode === 'ARRANGE') return '理牌(提)'; 
        if (sortMode === 'ARRANGE_MERGED') return '理牌(合)'; 
        return '未知';
    };

    // [新增] 策略名称转换 helper
    const getStrategyName = () => {
        if (!roomConfig) return '加载中';
        const s = roomConfig.shuffleStrategy;
        const p = roomConfig.preciseMode;
        if (s === 'NO_SHUFFLE') return '均贫富(不洗牌)';
        if (s === 'SIMULATION') return '模拟手洗';
        if (s === 'PRECISE') {
            const modes = { normal: '常规', stimulating: '刺激', thrilling: '惊险', exciting: '爽局' };
            return `智能控牌(${modes[p] || '刺激'})`;
        }
        return '随机洗牌';
    };

    return (
        <div className={css.header}>
            <div className={css.roomBadgeContainer}>
                <button 
                    className={css.iconBtn} 
                    onClick={handleLeaveRoom}
                    style={{padding: '4px 8px', border:'none', background:'transparent'}}
                    title="退出房间"
                >
                    <LogOut size={16} />
                </button>

                {/* [修改] 房间号区域，包裹一个相对定位的 div 以便定位弹窗 */}
                <div style={{position: 'relative'}}>
                    <div className={css.roomBadgeGroup}>
                        <div className={css.roomBadge}>Room {roomId}</div>
                        {/* [新增] 详情缩放按钮 */}
                        <button 
                            className={css.infoBtn} 
                            onClick={() => setShowRoomInfo(!showRoomInfo)}
                        >
                            <Info size={12} />
                        </button>
                    </div>

                    {/* [新增] 房间详情弹窗 */}
                    {showRoomInfo && roomConfig && (
                        <div className={css.roomInfoDropdown}>
                            <div className={css.infoTitle}>房间规则</div>
                            <div className={css.infoRow}>
                                <span>洗牌策略:</span>
                                <span className={css.infoVal}>{getStrategyName()}</span>
                            </div>
                            <div className={css.infoRow}>
                                <span>目标分数:</span>
                                <span className={css.infoVal}>{roomConfig.targetScore}</span>
                            </div>
                            <div className={css.infoRow}>
                                <span>排名赏罚:</span>
                                <span className={css.infoVal}>
                                    {roomConfig.enableRankPenalty 
                                        ? `${roomConfig.rankPenaltyScores[0]} / ${roomConfig.rankPenaltyScores[1]}` 
                                        : '关闭'}
                                </span>
                            </div>
                            <div className={css.infoRow}>
                                <span>牌库/人数:</span>
                                <span className={css.infoVal}>{roomConfig.deckCount}副 / {roomConfig.maxPlayers}人</span>
                            </div>
                        </div>
                    )}
                </div>
                
                <div className={css.pingBadge} style={{ color: getPingColor(ping) }}>
                    {isConnected ? <Wifi size={10}/> : <WifiOff size={10}/>}
                    {isConnected ? `${ping}ms` : '断线'}
                </div>

                <button 
                    className={amIAutoPlay ? css.autoPlayBtnActive : css.autoPlayBtn}
                    onClick={handleToggleAutoPlay}
                >
                    <Zap size={12} style={{marginRight: 4}} fill={amIAutoPlay ? "currentColor" : "none"}/>
                    {amIAutoPlay ? '托管中' : '托管'}
                </button>
            </div>

            <div className={css.rightSection}>
                <TeamScoreBoard />
                <div className={css.buttonGroup}>
                    <button className={css.iconBtn} onClick={toggleFullScreen}>
                        {isFullScreen ? <Minimize size={18}/> : <Maximize size={18}/>}
                    </button>
                    <button className={css.iconBtn} onClick={toggleSort}>
                        <Layers size={16} style={{marginRight:5}}/> 
                        {getSortButtonText()}
                    </button>
                </div>
            </div>
        </div>
    );
};

================================================================================
FILE PATH: client\src\components\game\GameHeader.module.css
================================================================================
/* 顶部栏容器 */
.header {
    padding: 4px 10px;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    /* [修改] 提升层级至 1100，确保高于 GameLogPanel (1000) */
    z-index: 1100;
    /* [修改] 显式添加 relative 以确保 z-index 生效 (虽然 flex item 也会生效，但这更稳健) */
    position: relative;
    width: 100%;
    pointer-events: none; /* 让点击穿透，按钮单独开启 auto */
    box-sizing: border-box;
}

/* 左侧：房间信息块 */
.roomBadgeContainer {
    display: flex;
    align-items: center;
    gap: 8px;
    pointer-events: auto;
}

/* [新增] 房间号与按钮的组合容器 */
.roomBadgeGroup {
    display: flex;
    align-items: center;
    background: rgba(0,0,0,0.3);
    border-radius: 15px;
    border: 1px solid rgba(255,255,255,0.1);
    overflow: hidden;
}

/* [修改] Room Badge 样式微调，移除独立边框 */
.roomBadge {
    color: white;
    padding: 4px 8px;
    font-size: 11px;
    font-weight: bold;
    white-space: nowrap;
}

/* [新增] 信息按钮样式 */
.infoBtn {
    background: rgba(255,255,255,0.1);
    border: none;
    border-left: 1px solid rgba(255,255,255,0.1);
    color: #ecf0f1;
    cursor: pointer;
    padding: 4px 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
    height: 100%;
}

.infoBtn:hover {
    background: rgba(255,255,255,0.2);
}

/* [新增] 房间详情下拉框 */
.roomInfoDropdown {
    position: absolute;
    top: 115%;
    left: 0;
    width: 160px;
    background: rgba(30, 40, 50, 0.95);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    padding: 10px;
    color: white;
    font-size: 11px;
    backdrop-filter: blur(5px);
    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    /* z-index 在父容器 context 内生效，2000 足够保证在 Header 内部置顶 */
    z-index: 2000;
    animation: fadeIn 0.2s ease;
    text-align: left;
}


.infoTitle {
    font-weight: bold;
    color: #f1c40f;
    margin-bottom: 6px;
    border-bottom: 1px solid rgba(255,255,255,0.1);
    padding-bottom: 4px;
    text-align: center;
}

.infoRow {
    display: flex;
    justify-content: space-between;
    margin-bottom: 4px;
    color: #bdc3c7;
}

.infoVal {
    color: white;
    font-weight: bold;
}

/* Ping 值徽章 */
.pingBadge {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 10px;
    padding: 2px 8px;
    border-radius: 12px;
    background: rgba(0,0,0,0.3);
    border: 1px solid rgba(255,255,255,0.1);
    font-weight: bold;
    transition: color 0.5s;
}

/* 托管按钮 */
.autoPlayBtn {
    pointer-events: auto;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.3);
    color: #ecf0f1;
    border-radius: 15px;
    padding: 4px 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 11px;
    font-weight: bold;
    transition: all 0.2s;
}

.autoPlayBtnActive {
    composes: autoPlayBtn;
    background: #e67e22;
}

/* 右侧：比分与功能按钮 */
.rightSection {
    display: flex;
    align-items: center;
    margin-left: auto;
}

.buttonGroup {
    display: flex;
    gap: 10px;
}

.iconBtn {
    pointer-events: auto;
    background: rgba(255,255,255,0.1);
    color: white;
    border: 1px solid rgba(255,255,255,0.2);
    padding: 8px 12px;
    border-radius: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    font-size: 14px;
    transition: background 0.2s;
}

.iconBtn:hover {
    background: rgba(255,255,255,0.2);
}

/* --- 内部组件：队伍比分板 --- */
.teamScoreContainer {
    position: relative;
    margin-right: 10px;
    z-index: 50;
    pointer-events: auto;
}

.teamScoreBar {
    background: rgba(0,0,0,0.3);
    padding: 4px 10px;
    border-radius: 20px;
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    border: 1px solid rgba(255,255,255,0.1);
    transition: background 0.2s;
}

.scoreItem {
    font-weight: bold;
    display: flex;
    align-items: center;
    gap: 3px;
    font-size: 13px;
}

.divider {
    width: 1px;
    height: 12px;
    background: rgba(255,255,255,0.2);
}

.scoreDropdown {
    position: absolute;
    top: 120%;
    right: 0;
    background: rgba(30, 40, 50, 0.95);
    border-radius: 8px;
    padding: 10px;
    color: white;
    font-size: 12px;
    text-align: center;
    width: 140px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    border: 1px solid rgba(255,255,255,0.1);
    backdrop-filter: blur(5px);
    animation: fadeIn 0.2s ease;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-5px); }
    to { opacity: 1; transform: translateY(0); }
}

================================================================================
FILE PATH: client\src\components\game\HandArea.jsx
================================================================================
import React, { useState, useEffect } from 'react';
import { Bot, Eye } from 'lucide-react';
import css from './HandArea.module.css'; 
import { Card } from '../BaseUI.jsx';
import { calculateCardSpacing, sortHand } from '../../utils/cardLogic.js';
import { useGame } from '../../context/GameContext.jsx';
import { useHandGesture } from '../../hooks/useHandGesture.js';

export const HandArea = () => {
    const { 
        myHand, selectedCards, handleMouseDown, handleMouseEnter, 
        playersInfo, mySocketId,
        observedHands, isSpectator // [新增]
    } = useGame();
    
    const myInfo = playersInfo[mySocketId] || {};
    const amIAutoPlay = myInfo.isAutoPlay;

    const [dimensions, setDimensions] = useState({ width: window.innerWidth });
    
    useEffect(() => {
        const handleResize = () => setDimensions({ width: window.innerWidth });
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, []);

    // [新增] 决定显示谁的手牌
    let displayHand = myHand;
    let isWatching = false;
    let watchingName = '';

    // 如果我自己没牌了 (或者我是观众)，且有观察到的手牌
    if ((myHand.length === 0 || isSpectator) && Object.keys(observedHands).length > 0) {
        // 简单策略：显示第一个观察到的非空手牌
        const targetId = Object.keys(observedHands).find(id => observedHands[id] && observedHands[id].length > 0);
        if (targetId) {
            // 对观察的手牌进行排序，确保显示整齐
            displayHand = sortHand(observedHands[targetId], 'POINT'); 
            isWatching = true;
            // 尝试获取名字，需从 playersInfo 或 players 中找 (Context里 players可能没传进来)
            // 这里简单用ID，或者稍微修改 Context 传入 players
            // 假设我们只能拿到 ID，UI 显示 "正在观看队友" 即可
        }
    }

    const cardSpacing = calculateCardSpacing(displayHand.length, dimensions.width);

    // 只有操作自己的手牌才启用手势
    const handContainerRef = useHandGesture({
        myHand: isWatching ? [] : displayHand, // 观看模式下禁用交互
        selectedCards: isWatching ? [] : selectedCards, 
        cardSpacing, 
        handleMouseDown, 
        amIAutoPlay
    });

    const containerClass = [
        css.handArea,
        amIAutoPlay ? css.autoPlayMode : ''
    ].join(' ');

    return (
        <div ref={handContainerRef} className={containerClass}>
            {amIAutoPlay && !isWatching && (
                <div className={css.autoPlayBadge}>
                    <Bot size={14} /> 系统代打中
                </div>
            )}

            {/* [新增] 观看模式提示 */}
            {isWatching && (
                <div className={css.autoPlayBadge} style={{background: '#3498db'}}>
                    <Eye size={14} /> 正在观看队友视角
                </div>
            )}
            
            {displayHand.map((c, i) => (
                <Card 
                    key={`${c}-${i}`} 
                    cardVal={c} 
                    index={i} 
                    isSelected={!isWatching && selectedCards.includes(c)} 
                    onClick={isWatching ? ()=>{} : handleMouseDown} 
                    onMouseEnter={isWatching ? ()=>{} : handleMouseEnter} 
                    spacing={cardSpacing} 
                />
            ))}
        </div>
    );
};

================================================================================
FILE PATH: client\src\components\game\HandArea.module.css
================================================================================
.handArea {
    position: absolute;
    /* 适配 iPhone 底部黑条 */
    bottom: max(25px, env(safe-area-inset-bottom));
    /* 左侧避开头像区域 */
    left: 90px;
    right: 10px;
    height: 160px;
    display: flex;
    justify-content: flex-start;
    align-items: flex-end;
    z-index: 20;
    touch-action: none;
    pointer-events: auto;
    padding-bottom: 10px;
    transition: all 0.3s;
}

/* 托管模式下的遮罩效果 */
.autoPlayMode {
    opacity: 0.6;
    filter: grayscale(0.6);
    pointer-events: none;
}

.autoPlayBadge {
    position: absolute;
    top: -40px;
    left: 20px;
    background: rgba(230, 126, 34, 0.9);
    color: white;
    padding: 5px 10px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: bold;
    display: flex;
    align-items: center;
    gap: 5px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    z-index: 50;
    animation: floatBadge 2s infinite ease-in-out;
}

@keyframes floatBadge {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-5px); }
}

================================================================================
FILE PATH: client\src\components\game\PlayerLayout.jsx
================================================================================
import React from 'react';
import { Bot, Zap } from 'lucide-react';
import { PlayerAvatar } from '../BaseUI'; // 移除 .jsx 后缀以增强兼容性
import { useGame } from '../../context/GameContext'; // 移除 .jsx 后缀

const calculateLayout = (otherPlayersCount) => {
    if (otherPlayersCount === 0) return { countT: 0, countR: 0, countL: 0 }; 
    if (otherPlayersCount === 1) return { countT: 1, countR: 0, countL: 0 }; 
    if (otherPlayersCount === 2) return { countT: 0, countR: 1, countL: 1 }; 
    if (otherPlayersCount === 3) return { countT: 1, countR: 1, countL: 1 }; 
    if (otherPlayersCount === 4) return { countT: 2, countR: 1, countL: 1 }; 
    if (otherPlayersCount === 5) return { countT: 2, countR: 2, countL: 1 }; 

    const sideCount = Math.ceil(otherPlayersCount / 3);
    const topCount = otherPlayersCount - (sideCount * 2);
    
    return {
        countR: sideCount,
        countL: sideCount,
        countT: Math.max(0, topCount) 
    };
};

export const PlayerLayout = () => {
    const { 
        players, mySocketId, currentTurnId, playersInfo, playerScores, 
        roundPoints, roomConfig, turnRemaining, finishedRank, handCounts,
        isSpectator 
    } = useGame();

    // [安全检查] 防止 players 为 undefined 导致崩溃
    if (!players) return null;

    const totalP = players.length;
    let avatarScale = 1;
    if (totalP > 10) avatarScale = 0.70;      
    else if (totalP > 8) avatarScale = 0.80;  
    else if (totalP > 6) avatarScale = 0.90;  
    
    const avatarStyleOverride = totalP > 6 ? { transform: `scale(${avatarScale})`, margin: -5 } : {};

    let myIndex = players.findIndex(p => p.id === mySocketId);
    
    // [修改] 如果是观众，或者找不到自己，默认以第一个玩家为视角中心 (index 0)
    if (myIndex === -1) {
        myIndex = 0; 
    }

    // 重新排列数组，让视角中心在第一个
    const otherPlayers = [];
    if (players.length > 0) {
        for (let i = 1; i < players.length; i++) {
            // 安全取模
            const idx = (myIndex + i) % players.length;
            if (players[idx]) {
                otherPlayers.push(players[idx]);
            }
        }
    }

    const { countT, countR, countL } = calculateLayout(otherPlayers.length);
    const rightGroup = otherPlayers.slice(0, countR);
    const topGroup = otherPlayers.slice(countR, countR + countT);
    const leftGroup = otherPlayers.slice(countR + countT);

    const layoutItems = [];

    rightGroup.forEach((p, i) => {
        let topPos;
        if (countR === 1) {
            topPos = '45%'; 
        } else {
            const start = 65; 
            const end = 25;   
            const step = (start - end) / (countR - 1 || 1);
            topPos = `${start - i * step}%`;
        }
        layoutItems.push({ p, pos: { top: topPos, right: 10, transform: 'translateY(-50%)' }, timerPos: 'left' });
    });

    topGroup.forEach((p, i) => {
        let leftPos;
        if (countT === 1) {
            leftPos = '50%';
        } else {
            const start = 85; 
            const end = 15;   
            const step = (start - end) / (countT - 1 || 1);
            leftPos = `${start - i * step}%`; 
        }
        layoutItems.push({ p, pos: { top: '12%', left: leftPos, transform: 'translateX(-50%)' }, timerPos: 'bottom' });
    });

    leftGroup.forEach((p, i) => {
        let topPos;
        if (countL === 1) {
            topPos = '45%';
        } else {
            const start = 25; 
            const end = 65;   
            const step = (end - start) / (countL - 1 || 1);
            topPos = `${start + i * step}%`;
        }
        layoutItems.push({ p, pos: { top: topPos, left: 30, transform: 'translateY(-50%)' }, timerPos: 'right' });
    });

    // 加入“自己”或“主视角玩家”
    const me = players[myIndex];
    if (me) {
        const isActuallyMe = me.id === mySocketId;
        
        if (!isSpectator || isActuallyMe) {
            // 正常玩家模式：自己不显示Timer（或者显示在特定位置），位置固定在左下
            layoutItems.unshift({ p: me, pos: { bottom: 35, left: 20, zIndex: 100 }, hideTimer: true });
        } else {
            // 观众模式：主视角玩家需要显示Timer，Timer在上方
            layoutItems.unshift({ p: me, pos: { bottom: 35, left: 20, zIndex: 100 }, hideTimer: false, timerPos: 'top' });
        }
    }

    return (
        <>
            {layoutItems.map(({ p, pos, timerPos, hideTimer }) => {
                if (!p) return null; // 安全检查

                const info = playersInfo[p.id] || {};
                const isBot = info.isBot || p.isBot;
                const isAuto = info.isAutoPlay;
                const rankIndex = finishedRank ? finishedRank.indexOf(p.id) : -1;
                const finishedRankVal = rankIndex !== -1 ? rankIndex + 1 : null;
                
                return (
                    <div key={p.id} style={{...avatarStyleOverride, position: 'absolute', ...pos, transition: 'all 0.5s ease'}}> 
                        <PlayerAvatar 
                            player={p} 
                            isTurn={p.id === currentTurnId} 
                            score={playerScores[p.id] || 0} 
                            roundScore={roundPoints[p.id] || 0} 
                            targetScore={roomConfig ? roomConfig.targetScore : 500} // 安全访问
                            isMySocket={p.id === mySocketId}
                            remainingSeconds={turnRemaining}
                            rank={finishedRankVal}
                            timerPosition={timerPos}
                            hideTimer={hideTimer} 
                            cardCount={handCounts[p.id] || 0}
                            showCardCountMode={roomConfig ? roomConfig.showCardCountMode : false} // 安全访问
                            team={info.team} 
                        />
                        <div style={{position: 'absolute', top: -10, right: -10, display: 'flex', gap: 5}}>
                            {isBot && <div className="statusBadgeBot"><Bot size={12}/> AI</div>}
                            {isAuto && <div className="statusBadgeAuto"><Zap size={12}/> 托管</div>}
                        </div>
                    </div>
                );
            })}
        </>
    );
};

================================================================================
FILE PATH: client\src\components\game\RoomSettingsForm.jsx
================================================================================
import React from 'react';
import { Users, Layers, Target, Clock, Shuffle, Sparkles, Shield, Eye, Award, Sliders } from 'lucide-react'; 
import css from './RoomSettingsForm.module.css';

/**
 * 通用房间配置组件
 */
export const RoomSettingsForm = ({ config, onChange, readOnly = false }) => {
    
    const update = (key, val) => {
        if (!readOnly && onChange) onChange(key, val);
    };

    // 渲染滑块 (保持不变)
    const renderSlider = (icon, label, field, min, max, step, suffix = '') => (
        <div className={css.configItem}>
            <div className={css.configLabel}>
                <span style={{display:'flex', alignItems:'center', gap:6}}>{icon} {label}</span>
                <span className={css.configValue}>{config[field]}{suffix}</span>
            </div>
            <input 
                type="range" 
                className={css.rangeInput}
                min={min} 
                max={max} 
                step={step}
                value={config[field]} 
                onChange={(e) => update(field, parseInt(e.target.value))}
                disabled={readOnly}
                style={{opacity: readOnly ? 0.6 : 1, cursor: readOnly ? 'not-allowed' : 'pointer'}}
            />
        </div>
    );

    return (
        <div className={css.configContainer}>
            <div className={css.configGrid}>
                {renderSlider(<Users size={14}/>, "玩家人数", 'maxPlayers', 2, 12, 1, '人')}
                {renderSlider(<Layers size={14}/>, "牌库数量", 'deckCount', 1, 8, 1, '副')}
                {renderSlider(<Target size={14}/>, "获胜目标", 'targetScore', 500, 5000, 500, '分')}

                {/* --- [修改] 洗牌策略区域 --- */}
                <div className={css.configItem} style={{gridColumn: '1 / -1', marginTop: 5}}>
                    <div className={css.configLabel} style={{marginBottom: 8}}>
                        <span style={{display:'flex', alignItems:'center', gap:6}}><Shuffle size={14}/> 洗牌策略</span>
                    </div>
                    
                    {/* 一级策略选择 */}
                    <div className={css.radioGroup} style={{marginBottom: 10}}>
                        <button 
                            className={css.strategyBtn}
                            style={(!config.shuffleStrategy || config.shuffleStrategy === 'CLASSIC') ? {borderColor: '#2ecc71', background: '#eafaf1', color: '#2ecc71'} : {}}
                            onClick={() => update('shuffleStrategy', 'CLASSIC')}
                            disabled={readOnly}
                        >
                            🎲 随机
                        </button>
                        <button 
                            className={css.strategyBtn}
                            style={config.shuffleStrategy === 'NO_SHUFFLE' ? {borderColor: '#e67e22', background: '#fdf2e9', color: '#e67e22'} : {}}
                            onClick={() => update('shuffleStrategy', 'NO_SHUFFLE')}
                            disabled={readOnly}
                        >
                            <Sparkles size={14}/> 均贫富
                        </button>
                        <button 
                            className={css.strategyBtn}
                            style={config.shuffleStrategy === 'SIMULATION' ? {borderColor: '#9b59b6', background: '#f5eef8', color: '#9b59b6'} : {}}
                            onClick={() => update('shuffleStrategy', 'SIMULATION')}
                            disabled={readOnly}
                        >
                            <Layers size={14}/> 模拟手洗
                        </button>
                        <button 
                            className={css.strategyBtn}
                            style={config.shuffleStrategy === 'PRECISE' ? {borderColor: '#e74c3c', background: '#fdedec', color: '#e74c3c'} : {}}
                            onClick={() => update('shuffleStrategy', 'PRECISE')}
                            disabled={readOnly}
                        >
                            <Sliders size={14}/> 智能控牌
                        </button>
                    </div>

                    {/* [新增] 二级选项：仅当选择了“智能控牌”时显示 */}
                    {config.shuffleStrategy === 'PRECISE' && (
                        <div style={{
                            background: '#fdedec', padding: 10, borderRadius: 8, marginBottom: 5,
                            border: '1px dashed #e74c3c', animation: 'fadeIn 0.3s'
                        }}>
                            <div style={{fontSize: 12, color: '#c0392b', marginBottom: 6, fontWeight:'bold'}}>选择刺激程度:</div>
                            <div className={css.radioGroup}>
                                {['normal', 'stimulating', 'thrilling', 'exciting'].map(mode => {
                                    const labels = { normal: '常规', stimulating: '刺激', thrilling: '惊险', exciting: '爽局' };
                                    const isActive = (config.preciseMode || 'stimulating') === mode;
                                    return (
                                        <button 
                                            key={mode}
                                            onClick={() => update('preciseMode', mode)}
                                            disabled={readOnly}
                                            style={{
                                                flex: 1, padding: '4px 0', fontSize: 12, borderRadius: 4, cursor: readOnly ? 'not-allowed' : 'pointer', border: 'none',
                                                background: isActive ? '#e74c3c' : 'rgba(255,255,255,0.5)',
                                                color: isActive ? 'white' : '#c0392b',
                                                fontWeight: isActive ? 'bold' : 'normal',
                                                transition: 'all 0.2s'
                                            }}
                                        >
                                            {labels[mode]}
                                        </button>
                                    );
                                })}
                            </div>
                        </div>
                    )}

                    <div style={{fontSize: 11, color: '#999', marginTop: 4, lineHeight: '1.4'}}>
                        {(!config.shuffleStrategy || config.shuffleStrategy === 'CLASSIC') && "完全随机，运气至上。"}
                        {config.shuffleStrategy === 'NO_SHUFFLE' && "系统平均分配炸弹，拒绝一面倒。"}
                        {config.shuffleStrategy === 'SIMULATION' && "还原线下叠牌切牌，保留连对长龙。"}
                        {config.shuffleStrategy === 'PRECISE' && (
                            <span style={{color: '#c0392b'}}>
                                {config.preciseMode === 'normal' && "普通概率，大炸弹较少。"}
                                {(!config.preciseMode || config.preciseMode === 'stimulating') && "炸弹增多，节奏加快。"}
                                {config.preciseMode === 'thrilling' && "大炸频出，对抗激烈。"}
                                {config.preciseMode === 'exciting' && "满屏炸弹，超大牌型！"}
                            </span>
                        )}
                    </div>
                </div>

                {/* 组队模式 (保持不变) */}
                <div className={config.maxPlayers % 2 !== 0 ? css.toggleContainerDisabled : css.toggleContainer}>
                     <div style={{display:'flex', justifyContent:'space-between', alignItems:'center'}}>
                        <div style={{display:'flex', alignItems:'center', gap:6, fontWeight:'600', color: config.maxPlayers % 2 !== 0 ? '#999' : '#27ae60', fontSize: 14}}>
                            <Shield size={14} /> 组队对抗 (2v2, 3v3...)
                        </div>
                        <label style={{position:'relative', display:'inline-block', width:40, height:20}}>
                            <input 
                                type="checkbox" 
                                style={{opacity:0, width:0, height:0}}
                                checked={config.isTeamMode && config.maxPlayers % 2 === 0}
                                disabled={readOnly || config.maxPlayers % 2 !== 0}
                                onChange={(e) => update('isTeamMode', e.target.checked)}
                            />
                            <span style={{
                                position:'absolute', cursor: (readOnly || config.maxPlayers % 2 !== 0) ? 'not-allowed' : 'pointer', 
                                top:0, left:0, right:0, bottom:0, 
                                backgroundColor: (config.isTeamMode && config.maxPlayers % 2 === 0) ? '#27ae60' : '#ccc', 
                                transition:'.4s', borderRadius: 20
                            }}>
                                <span style={{
                                    position:'absolute', content:"", height:16, width:16, left:2, bottom:2, 
                                    backgroundColor:'white', transition:'.4s', borderRadius:'50%',
                                    transform: (config.isTeamMode && config.maxPlayers % 2 === 0) ? 'translateX(20px)' : 'translateX(0)'
                                }}></span>
                            </span>
                        </label>
                    </div>
                    <div style={{fontSize: 11, color: '#7f8c8d'}}>
                        {config.maxPlayers % 2 !== 0 ? "⚠️ 需偶数人数才能开启" : "间隔入座为队友 (1,3 vs 2,4)"}
                    </div>
                </div>

                {/* 出牌时限 (保持不变) */}
                <div className={css.configItem}>
                    <div className={css.configLabel}>
                        <span style={{display:'flex', alignItems:'center', gap:6}}><Clock size={14}/> 出牌时限</span>
                        <span className={css.configValue}>{config.turnTimeout / 1000}s</span>
                    </div>
                    <div className={css.radioGroup}>
                        {[30, 60, 90, 120].map(sec => (
                            <button 
                                key={sec}
                                className={config.turnTimeout === sec * 1000 ? css.radioBtnActive : css.radioBtn}
                                onClick={() => update('turnTimeout', sec * 1000)}
                                disabled={readOnly}
                            >
                                {sec}s
                            </button>
                        ))}
                    </div>
                </div>
            </div>

            <div className={css.divider}></div>

            {/* 剩余牌数显示 (修改 UI 为 ≤3张) */}
            <div>
                <div className={css.configLabel} style={{marginBottom: 8}}>
                    <span style={{display:'flex', alignItems:'center', gap:6}}><Eye size={14}/> 剩余牌数显示</span>
                </div>
                <div className={css.radioGroup}>
                    <button className={config.showCardCountMode === 0 ? css.radioBtnActive : css.radioBtn} onClick={() => update('showCardCountMode', 0)} disabled={readOnly}>不显示</button>
                    {/* [修改] 2 改为 3 */}
                    <button className={config.showCardCountMode === 1 ? css.radioBtnActive : css.radioBtn} onClick={() => update('showCardCountMode', 1)} disabled={readOnly}>≤3张</button>
                    <button className={config.showCardCountMode === 2 ? css.radioBtnActive : css.radioBtn} onClick={() => update('showCardCountMode', 2)} disabled={readOnly}>一直显示</button>
                </div>
            </div>

            <div className={css.divider}></div>

            {/* 排名赏罚 (保持不变) */}
            <div>
                <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom: 10}}>
                    <div style={{display:'flex', alignItems:'center', gap:6, fontWeight:'600', color:'#555', fontSize:14}}>
                        <Award size={14} /> 启用排名赏罚 (抓分)
                    </div>
                    <label style={{position:'relative', display:'inline-block', width:40, height:20}}>
                        <input 
                            type="checkbox" 
                            style={{opacity:0, width:0, height:0}}
                            checked={config.enableRankPenalty}
                            onChange={(e) => update('enableRankPenalty', e.target.checked)}
                            disabled={readOnly}
                        />
                        <span style={{
                            position:'absolute', cursor: readOnly ? 'not-allowed' : 'pointer', top:0, left:0, right:0, bottom:0, 
                            backgroundColor: config.enableRankPenalty ? '#27ae60' : '#ccc', 
                            transition:'.4s', borderRadius: 20
                        }}>
                            <span style={{
                                position:'absolute', content:"", height:16, width:16, left:2, bottom:2, 
                                backgroundColor:'white', transition:'.4s', borderRadius:'50%',
                                transform: config.enableRankPenalty ? 'translateX(20px)' : 'translateX(0)'
                            }}></span>
                        </span>
                    </label>
                </div>
                
                {config.enableRankPenalty && (
                    <div className={css.rankPenaltyContainer}>
                        <div style={{flex:1}}>
                            <div style={{marginBottom:5, color:'#7f8c8d', fontSize:12}}>头尾赏罚</div>
                            <input 
                                type="number" className={css.input}
                                value={config.rankPenaltyScores[0]}
                                onChange={e => {
                                    const val = Math.max(0, parseInt(e.target.value) || 0);
                                    update('rankPenaltyScores', [val, config.rankPenaltyScores[1]]);
                                }}
                                disabled={readOnly}
                            />
                        </div>
                        <div style={{flex:1}}>
                            <div style={{marginBottom:5, color:'#7f8c8d', fontSize:12}}>次级赏罚</div>
                            <input 
                                type="number" className={css.input}
                                value={config.rankPenaltyScores[1]}
                                onChange={e => {
                                    const val = Math.max(0, parseInt(e.target.value) || 0);
                                    update('rankPenaltyScores', [config.rankPenaltyScores[0], val]);
                                }}
                                disabled={readOnly}
                            />
                        </div>
                    </div>
                )}
            </div>
            
            <style>{`@keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }`}</style>
        </div>
    );
};

================================================================================
FILE PATH: client\src\components\game\RoomSettingsForm.module.css
================================================================================
.configContainer {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.configGrid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px 30px;
    width: 100%;
}

/* 移动端单列 */
@media (max-width: 600px) {
    .configGrid {
        grid-template-columns: 1fr;
        gap: 15px;
    }
}

.configItem {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.configLabel {
    display: flex;
    justify-content: space-between;
    font-size: 14px;
    color: #7f8c8d;
    font-weight: 600;
}

.configValue {
    color: #27ae60;
    font-weight: bold;
}

.rangeInput {
    width: 100%;
    cursor: pointer;
    accent-color: #27ae60;
    height: 6px;
    border-radius: 3px;
    background: #e0e0e0;
    outline: none;
}

/* Radio Group */
.radioGroup {
    display: flex;
    gap: 8px;
}

.radioBtn {
    flex: 1;
    padding: 8px 0;
    border-radius: 6px;
    border: 1px solid #e1e4e8;
    background: white;
    color: #7f8c8d;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s;
    font-weight: 500;
}

.radioBtnActive {
    flex: 1;
    padding: 8px 0;
    border-radius: 6px;
    border: 1px solid #27ae60;
    background: #eafaf1;
    color: #27ae60;
    font-size: 12px;
    font-weight: bold;
    cursor: pointer;
}

/* 特殊策略按钮 */
.strategyBtn {
    flex: 1;
    padding: 8px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: bold;
    cursor: pointer;
    border: 1px solid #ddd;
    background: white;
    color: #7f8c8d;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
}

.input {
    padding: 0 10px;
    height: 35px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
    color: #2c3e50;
    outline: none;
    width: 100%;
    background: white;
}

/* 分割线 */
.divider {
    height: 1px;
    background: #f0f0f0;
    margin: 5px 0;
    width: 100%;
}

/* 组队开关容器 */
.toggleContainer {
    padding: 10px;
    background: #e8f8f5;
    border-radius: 8px;
    grid-column: 1 / -1;
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.toggleContainerDisabled {
    composes: toggleContainer;
    background: #f5f5f5;
    opacity: 0.7;
}

.rankPenaltyContainer {
    background: #f9f9f9;
    padding: 12px;
    border-radius: 8px;
    display: flex;
    gap: 15px;
    margin-top: 5px;
}

================================================================================
FILE PATH: client\src\components\game\SettlementModal.jsx
================================================================================
import React, { useState } from 'react';
import { Crown, Coins, List, History } from 'lucide-react';
import css from './SettlementModal.module.css';
import { ScoreTable } from '../ScoreTable.jsx';
import { useGame } from '../../context/GameContext.jsx';

/**
 * [本局详情表格]
 * 展示：排名、玩家、场内抓分、奖罚(含剩牌)、本局总分
 */
const RoundDetailTable = ({ scoreBreakdown, players }) => {
    if (!scoreBreakdown) return <div style={{padding:20}}>暂无详情数据</div>;

    // 将对象转为数组并按得分排名（或按结束排名？）
    // 需求说：还有一栏是“这一局总得分的排名”
    // 我们这里默认按“本局总分”降序排列
    const rows = Object.values(scoreBreakdown).sort((a, b) => b.final - a.final);

    return (
        <div className={css.detailTableContainer}>
            <div className={css.detailHeaderRow}>
                <div style={{flex:0.8}}>走位</div>
                <div style={{flex:2, textAlign:'left'}}>玩家</div>
                <div style={{flex:1.2}}>抓分</div>
                <div style={{flex:2}}>奖罚(剩牌)</div>
                <div style={{flex:1.2, color:'#f1c40f'}}>得分</div>
                <div style={{flex:0.8}}>排名</div>
            </div>
            
            <div className={css.detailBody}>
                {rows.map((row, index) => {
                    const isWin = row.final > 0;
                    const isLose = row.final < 0;
                    const scoreColor = isWin ? '#e74c3c' : (isLose ? '#2ecc71' : '#ccc');
                    
                    // 格式化奖罚栏：例如 "+50 (剩0)" 或 "-30 (剩25)"
                    const penaltyText = row.penalty > 0 ? `+${row.penalty}` : row.penalty;
                    const handText = row.handScore > 0 ? `剩${row.handScore}` : '剩0';
                    
                    return (
                        <div key={row.id} className={css.detailRow}>
                            <div style={{flex:0.8, color:'#999', fontSize:12}}>
                                {row.finishRank}
                            </div>
                            <div style={{flex:2, textAlign:'left', fontWeight:'bold', overflow:'hidden', textOverflow:'ellipsis', whiteSpace:'nowrap'}}>
                                {row.team !== undefined && row.team !== null && (
                                    <span style={{color: row.team===0?'#e74c3c':'#3498db', marginRight:4}}>
                                        {row.team===0?'[红]':'[蓝]'}
                                    </span>
                                )}
                                {row.name}
                            </div>
                            <div style={{flex:1.2, fontWeight:'bold'}}>{row.tablePoints}</div>
                            <div style={{flex:2, fontSize:12, color:'#7f8c8d'}}>
                                <span style={{color: row.penalty!==0 ? (row.penalty>0?'#e67e22':'#2ecc71') : '#999', fontWeight:'bold'}}>
                                    {penaltyText}
                                </span>
                                <span style={{marginLeft:4, opacity:0.8}}>({handText})</span>
                            </div>
                            <div style={{flex:1.2, fontWeight:'900', color: scoreColor, fontSize:16}}>
                                {row.final > 0 ? `+${row.final}` : row.final}
                            </div>
                            <div style={{flex:0.8, fontSize:12, fontWeight:'bold', color:'#ccc'}}>
                                {index + 1}
                            </div>
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

/**
 * [结算弹窗组件]
 */
export const SettlementModal = () => {
    const { 
        winner, roundResult, grandResult, players, playersInfo, roomConfig, 
        handleStartGame, handleNextRound, mySocketId 
    } = useGame();

    // 默认显示 'round' (本局详情), 也可以切到 'grand' (总战绩)
    const [activeTab, setActiveTab] = useState('round');

    if (!winner && !roundResult && !grandResult) return null;

    const amIHost = players.find(p => p.id === mySocketId)?.isHost;
    
    // 如果是终局结算 (Grand Over)，默认可能想看总表，这里还是按需求默认给 Round
    // 或者你可以根据 grandResult 是否存在来决定默认 Tab
    const data = grandResult || roundResult;
    if (!data) return null;

    const playersWithTeamInfo = players.map(p => ({
        ...p, team: (playersInfo[p.id] && playersInfo[p.id].team !== undefined) ? playersInfo[p.id].team : p.team
    }));

    return (
        <div className={css.modalOverlay}>
            <div className={css.modalContent}>
                
                {/* 顶部标题区 */}
                <div className={css.headerSection}>
                    {grandResult ? (
                        <>
                            <Crown size={40} color="#e74c3c" />
                            <h2 className={css.title}>{grandResult.grandWinner} 夺冠!</h2>
                        </>
                    ) : (
                        <>
                            <Coins size={32} color="#f1c40f" />
                            <h2 className={css.title}>小局结算</h2>
                        </>
                    )}
                </div>

                {/* Tab 切换区 */}
                <div className={css.tabContainer}>
                    <button 
                        className={activeTab === 'round' ? css.tabActive : css.tab}
                        onClick={() => setActiveTab('round')}
                    >
                        <List size={14}/> 本局详情
                    </button>
                    <button 
                        className={activeTab === 'grand' ? css.tabActive : css.tab}
                        onClick={() => setActiveTab('grand')}
                    >
                        <History size={14}/> 总战绩表
                    </button>
                </div>

                {/* 内容展示区 */}
                <div className={css.contentBody}>
                    {activeTab === 'round' ? (
                        <div className={css.tabContent}>
                            {/* 如果有 scoreBreakdown 就显示新表格，否则(旧版兼容)显示提示 */}
                            {data.scoreBreakdown ? (
                                <RoundDetailTable 
                                    scoreBreakdown={data.scoreBreakdown} 
                                    players={playersWithTeamInfo}
                                />
                            ) : (
                                <div style={{padding:20, color:'#999'}}>服务端未返回详情数据</div>
                            )}
                            
                            {/* 下方保留简略日志，方便查阅 */}
                            <div className={css.logBox}>
                                <div style={{fontWeight:'bold', marginBottom:5, fontSize:12, color:'#ccc'}}>结算日志:</div>
                                {data.detail}
                            </div>
                        </div>
                    ) : (
                        <div className={css.tabContent}>
                            <ScoreTable 
                                players={playersWithTeamInfo} 
                                matchHistory={data.matchHistory} 
                                currentScores={data.grandScores} 
                                roomConfig={roomConfig} 
                            />
                        </div>
                    )}
                </div>

                {/* 底部按钮区 */}
                <div className={css.footerSection}>
                    {grandResult ? (
                        <button className={css.primaryButton} onClick={handleStartGame}>重新开始</button>
                    ) : (
                        amIHost ? (
                            <button className={css.primaryButton} onClick={handleNextRound}>下一局</button>
                        ) : (
                            <div className={css.waitingText}>等待房主...</div>
                        )
                    )}
                </div>

            </div>
        </div>
    );
};

================================================================================
FILE PATH: client\src\components\game\SettlementModal.module.css
================================================================================
.modalOverlay {
    position: fixed; 
    top: 0; left: 0; right: 0; bottom: 0; 
    background: rgba(0,0,0,0.85); 
    display: flex; 
    justify-content: center; 
    align-items: center; 
    /* [修改] 提升至 3000，确保高于 Header (1100) 和 LogPanel (1000) */
    z-index: 3000; 
    backdrop-filter: blur(8px);
    pointer-events: auto;
}

.modalContent {
    background: white; 
    border-radius: 24px; 
    text-align: center; 
    box-shadow: 0 30px 80px rgba(0,0,0,0.6); 
    animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    width: 95%;        
    max-width: 650px;
    
    /* [修改] 限制最大高度，留出边距，适配横屏 */
    max-height: 92dvh;
    
    display: flex;
    flex-direction: column;
    overflow: hidden; /* 防止圆角被子元素破坏 */
}

@keyframes popIn {
    0% { transform: scale(0.8); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
}

/* 顶部标题 */
.headerSection {
    /* [修改] 防止被压缩 */
    flex-shrink: 0;
    padding: 20px 20px 10px 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    background: #f8f9fa;
    border-bottom: 1px solid #eee;
}

/* 横屏下稍微减小 Header 的 padding，腾出空间 */
@media (max-height: 500px) {
    .headerSection {
        padding: 10px 20px 5px 20px;
    }
}

.title {
    margin: 0;
    font-size: 22px;
    font-weight: bold;
    color: #2c3e50;
}

/* Tab 切换栏 */
.tabContainer {
    /* [修改] 防止被压缩 */
    flex-shrink: 0;
    display: flex;
    background: #eee;
    padding: 4px;
    margin: 15px 20px 5px 20px;
    border-radius: 12px;
}

.tab {
    flex: 1;
    padding: 8px;
    border: none;
    background: transparent;
    color: #7f8c8d;
    font-weight: bold;
    font-size: 14px;
    cursor: pointer;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    transition: all 0.2s;
}

.tabActive {
    composes: tab;
    background: white;
    color: #2c3e50;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

/* 内容区域 */
.contentBody {
    /* [修改] 核心：占据剩余空间，且允许滚动 */
    flex: 1;
    overflow-y: auto; 
    min-height: 0; /* Flexbox 滚动修复 trick */
    padding: 10px 0;
    background: #fff;
    
    /* 优化移动端滚动体验 */
    -webkit-overflow-scrolling: touch; 
    overscroll-behavior: contain;
}

.tabContent {
    width: 100%;
    animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(5px); }
    to { opacity: 1; transform: translateY(0); }
}

/* --- 本局详情表格样式 --- */
.detailTableContainer {
    margin: 0 15px;
    border: 1px solid #eee;
    border-radius: 8px;
    overflow: hidden;
}

.detailHeaderRow {
    display: flex;
    background: #2c3e50;
    color: white;
    padding: 10px 5px;
    font-size: 12px;
    font-weight: bold;
    align-items: center;
}

.detailBody {
    background: white;
}

.detailRow {
    display: flex;
    padding: 12px 5px;
    border-bottom: 1px solid #f0f0f0;
    align-items: center;
    font-size: 13px;
    color: #34495e;
}

.detailRow:last-child {
    border-bottom: none;
}

/* 简略日志框 */
.logBox {
    margin: 15px 20px 0 20px;
    background: #2c3e50;
    padding: 10px;
    border-radius: 8px;
    color: #ecf0f1;
    font-size: 12px;
    text-align: left;
    line-height: 1.5;
    white-space: pre-wrap;
    /* [修改] 移除 max-height，让其在 contentBody 里自然滚动，或者保留限制但允许内部滚 */
    /* 这里建议移除限制，让用户在 contentBody 这个大容器里滑比较顺手 */
    max-height: none; 
}

/* 底部按钮区 */
.footerSection {
    /* [修改] 强制不收缩，并增加底部安全距离 */
    flex-shrink: 0;
    padding: 15px 20px 20px 20px;
    
    /* 适配 iPhone 横条 */
    padding-bottom: max(20px, env(safe-area-inset-bottom));
    
    border-top: 1px solid #eee;
    background: white;
    z-index: 10;
}

.primaryButton {
    width: 100%;
    height: 50px;
    background: #2c3e50;
    color: white;
    border: none;
    border-radius: 12px;
    font-weight: bold;
    cursor: pointer;
    font-size: 16px;
    transition: all 0.2s;
    box-shadow: 0 5px 15px rgba(44, 62, 80, 0.2);
}

.primaryButton:hover {
    background: #34495e;
}

.waitingText {
    color: #999;
    font-size: 14px;
    padding: 10px;
}

================================================================================
FILE PATH: client\src\components\game\TableCenterArea.jsx
================================================================================
import React from 'react';
import { useGame } from '../../context/GameContext.jsx';
import { Coins } from 'lucide-react';
// [修复] 修正 Card 导入路径
import { Card } from '../ui/Card.jsx';
import css from './TableCenterArea.module.css';

export const TableCenterArea = () => {
    const { 
        lastPlayed, 
        lastPlayerName, 
        infoMessage, 
        pendingPoints
    } = useGame();

    return (
        <>
            {/* 底分面板 - 极简纯净版 */}
            {pendingPoints > 0 && (
                <div className={css.scoreBoard}>
                    <div className={css.scoreValue}>
                        <Coins size={24} fill="#f1c40f" stroke="#e67e22" strokeWidth={2} />
                        <span style={{marginLeft: 6}}>{pendingPoints}</span>
                    </div>
                </div>
            )}

            {/* 系统消息 (全屏大字) */}
            {infoMessage && (
                <div className={css.infoMessage}>
                    {infoMessage}
                </div>
            )}

            {/* 桌面出牌展示区 */}
            {lastPlayed && lastPlayed.length > 0 && (
                <div className={css.tableCenter}>
                    <div className={css.playedContainer}>
                        <div className={css.playerNameTag}>{lastPlayerName}</div>
                        
                        <div className={css.playedRow}>
                            {lastPlayed.map((c, i) => (
                                <div key={`${c}-${i}`} className={css.miniCardWrapper}>
                                    {/* [修复] 使用正确的 Card 属性: cardVal */}
                                    {/* index=0 spacing=0 确保它在 wrapper 内部居中/靠左，由 wrapper 负责布局 */}
                                    <Card 
                                        cardVal={c} 
                                        index={0} 
                                        isSelected={false} 
                                        onClick={()=>{}} 
                                        onMouseEnter={()=>{}} 
                                        spacing={0} 
                                    />
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            )}
        </>
    );
};

================================================================================
FILE PATH: client\src\components\game\TableCenterArea.module.css
================================================================================
/* 底分面板 - 极简纯净版 */
.scoreBoard {
    position: absolute;
    /* [修改] 从 30% 上移至 12%，移至顶部区域，避开出牌区人名，并与顶部按钮大致平齐 */
    top: 5%; 
    left: 50%;
    transform: translate(-50%, -50%);
    
    background: transparent;
    border: none;
    box-shadow: none;
    backdrop-filter: none;
    
    padding: 0;
    z-index: 5;
    pointer-events: none;
    
    animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translate(-50%, -40%); }
    to { opacity: 1; transform: translate(-50%, -50%); }
}

.scoreValue {
    font-size: 28px;
    font-weight: 900;
    color: #f1c40f;
    display: flex;
    align-items: center;
    justify-content: center;
    
    text-shadow: 
        0 2px 0 #b9770e,
        0 4px 4px rgba(0,0,0,0.5),
        -1px -1px 0 #000,  
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    
    filter: drop-shadow(0 2px 3px rgba(0,0,0,0.5));
}

/* 系统消息 */
.infoMessage {
    position: absolute;
    top: 25%;
    width: 100%;
    text-align: center;
    color: #f1c40f;
    font-size: 40px;
    font-weight: bold;
    text-shadow: 0 5px 15px rgba(0,0,0,0.5);
    pointer-events: none;
    z-index: 50;
    letter-spacing: 2px;
    animation: fadeInOut 3.5s forwards;
}

@keyframes fadeInOut {
    0% { opacity: 0; transform: translateY(10px); }
    10% { opacity: 1; transform: translateY(0); }
    80% { opacity: 1; transform: translateY(0); }
    100% { opacity: 0; transform: translateY(-10px); }
}

/* 桌面出牌展示区 */
.tableCenter {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1;
}

.playedContainer {
    animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    display: flex;
    flex-direction: column;
    align-items: center;
}

@keyframes popIn {
    0% { transform: scale(0.5); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
}

.playerNameTag {
    color: white;
    text-align: center;
    margin-bottom: 5px;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    font-size: 14px;
    font-weight: bold;
    background: rgba(0,0,0,0.3);
    padding: 2px 10px;
    border-radius: 20px;
    display: inline-block;
}

/* 牌型行 */
.playedRow {
    display: flex;
    justify-content: center;
    /* [修复] gap 不支持负值，改用 margin 实现叠牌 */
    filter: drop-shadow(0 10px 20px rgba(0,0,0,0.3));
    /* 整体缩小一点点，看起来更精致 */
    transform: scale(0.9);
}

/* * [重要] Card组件内部是 absolute 定位
 * 这里 wrapper 需要相对定位并指定宽高，才能撑开 flex 布局 
 * 55px x 70px 是 Card.module.css 定义的尺寸
 */
.miniCardWrapper {
    width: 55px;
    height: 70px;
    position: relative;
    /* 负 margin 实现叠牌效果 */
    margin-right: -25px; 
}

.miniCardWrapper:last-child {
    margin-right: 0;
}

================================================================================
FILE PATH: client\src\components\ScoreTable.jsx
================================================================================
import React from 'react';
import { Trophy, Shield, Medal, ScrollText } from 'lucide-react';

export const ScoreTable = ({ 
    players, 
    matchHistory = [], 
    currentScores,     
    roomConfig,
    grandResult
}) => {
    const isTeamMode = roomConfig.isTeamMode && (players.length % 2 === 0);

    const sortedPlayers = [...players].sort((a, b) => {
        const scoreA = currentScores[a.id] || 0;
        const scoreB = currentScores[b.id] || 0;
        return scoreB - scoreA; 
    });

    let redTeamHistory = [];
    let blueTeamHistory = [];
    let redTotal = 0;
    let blueTotal = 0;

    if (isTeamMode) {
        matchHistory.forEach((match, idx) => {
            let r = 0, b = 0;
            players.forEach(p => {
                const s = match.scores[p.id] || 0;
                if (p.team === 0) r += s;
                else if (p.team === 1) b += s;
            });
            redTeamHistory[idx] = r;
            blueTeamHistory[idx] = b;
        });
        
        players.forEach(p => {
            const s = currentScores[p.id] || 0;
            if (p.team === 0) redTotal += s;
            else if (p.team === 1) blueTotal += s;
        });
    }

    // [新增] 定义列的最小宽度，防止在手机上被挤压
    const minColWidth = 50; 

    const renderHeader = () => (
        <div style={{display: 'flex', background: '#2c3e50', color: 'white', padding: '10px', borderRadius: '8px 8px 0 0', fontWeight: 'bold', fontSize: 13, minWidth: '100%'}}>
            <div style={{flex: 2, textAlign: 'left', paddingLeft: 10, minWidth: 80, position: 'sticky', left: 0, background: '#2c3e50', zIndex: 1}}>玩家/队伍</div>
            {matchHistory.map((_, i) => (
                <div key={i} style={{flex: 1, textAlign: 'center', minWidth: minColWidth}}>R{i + 1}</div>
            ))}
            <div style={{flex: 1.2, textAlign: 'center', color: '#f1c40f', minWidth: 60}}>总分</div>
            <div style={{flex: 0.8, textAlign: 'center', minWidth: 40}}>排名</div>
        </div>
    );

    const renderTeamRow = (teamIndex, totalScore, historyScores) => {
        const color = teamIndex === 0 ? '#e74c3c' : '#3498db';
        const bg = teamIndex === 0 ? 'rgba(231, 76, 60, 0.1)' : 'rgba(52, 152, 219, 0.1)';
        const name = teamIndex === 0 ? '红队' : '蓝队';
        
        return (
            <div style={{display: 'flex', background: bg, padding: '8px 10px', borderBottom: '1px solid rgba(0,0,0,0.05)', alignItems:'center', fontSize: 13, minWidth: '100%'}}>
                <div style={{flex: 2, textAlign: 'left', color: color, fontWeight: 'bold', display:'flex', alignItems:'center', gap:5, minWidth: 80, position: 'sticky', left: 0, background: teamIndex === 0 ? '#fceceb' : '#ebf5fb', zIndex: 1}}>
                    <Shield size={14} fill={color} /> {name}
                </div>
                {matchHistory.map((_, i) => (
                    <div key={i} style={{flex: 1, textAlign: 'center', color: historyScores[i] > 0 ? color : '#999', fontWeight:'bold', minWidth: minColWidth}}>
                        {historyScores[i] > 0 ? `+${historyScores[i]}` : historyScores[i]}
                    </div>
                ))}
                <div style={{flex: 1.2, textAlign: 'center', color: color, fontWeight: '900', fontSize: 14, minWidth: 60}}>{totalScore}</div>
                <div style={{flex: 0.8, minWidth: 40}}></div>
            </div>
        );
    };

    const renderPlayerRow = (player, rank) => {
        const score = currentScores[player.id] || 0;
        
        let rankIcon = null;
        if (rank === 1) rankIcon = <Trophy size={16} color="#f1c40f" fill="#f1c40f"/>;
        else if (rank === 2) rankIcon = <Medal size={16} color="#bdc3c7" fill="#bdc3c7"/>;
        else if (rank === 3) rankIcon = <Medal size={16} color="#e67e22" fill="#e67e22"/>;
        else rankIcon = <span style={{color:'#999', fontSize:12}}>{rank}</span>;

        return (
            <div key={player.id} style={{
                display: 'flex', 
                padding: '10px', 
                background: 'white', 
                borderBottom: '1px solid #eee',
                alignItems: 'center',
                fontSize: 13,
                minWidth: '100%'
            }}>
                {/* 玩家名字固定在左侧，方便横向滚动查看分数 */}
                <div style={{flex: 2, textAlign: 'left', display: 'flex', alignItems: 'center', gap: 8, overflow:'hidden', minWidth: 80, position: 'sticky', left: 0, background: 'white', zIndex: 1, borderRight: '1px solid #f0f0f0'}}>
                    <div style={{
                        width: 24, height: 24, borderRadius: '50%', background: '#ecf0f1', 
                        display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: 12, fontWeight: 'bold',
                        border: player.team !== undefined && player.team !== null ? `2px solid ${player.team===0?'#e74c3c':'#3498db'}` : 'none',
                        flexShrink: 0
                    }}>
                        {player.name[0]}
                    </div>
                    <span style={{fontWeight: 'bold', color: '#2c3e50', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis'}}>
                        {player.name}
                    </span>
                </div>

                {matchHistory.map((match, i) => {
                    const s = match.scores[player.id] || 0;
                    return (
                        <div key={i} style={{flex: 1, textAlign: 'center', color: s > 0 ? '#e67e22' : (s < 0 ? '#7f8c8d' : '#bdc3c7'), fontWeight: s!==0?'bold':'normal', minWidth: minColWidth}}>
                            {s > 0 ? `+${s}` : s}
                        </div>
                    );
                })}

                <div style={{flex: 1.2, textAlign: 'center', fontWeight: 'bold', color: score >= 0 ? '#27ae60' : '#c0392b', fontSize: 14, minWidth: 60}}>
                    {score}
                </div>

                <div style={{flex: 0.8, textAlign: 'center', display:'flex', justifyContent:'center', minWidth: 40}}>
                    {rankIcon}
                </div>
            </div>
        );
    };

    return (
        <div style={{width: '100%', display: 'flex', flexDirection: 'column', gap: 0, borderRadius: 8, overflow: 'hidden', border: '1px solid #ddd'}}>
            {/* [关键修改] 外层增加 overflowX: auto，实现横向滚动 */}
            <div style={{overflowX: 'auto', width: '100%'}}>
                {renderHeader()}
                
                {isTeamMode && renderTeamRow(0, redTotal, redTeamHistory)}
                {isTeamMode && renderTeamRow(1, blueTotal, blueTeamHistory)}
                
                {/* [关键修改] maxHeight 使用 min(300px, 40vh) 适配小屏幕 */}
                <div style={{maxHeight: 'min(300px, 40vh)', overflowY: 'auto'}}>
                    {sortedPlayers.map((p, i) => renderPlayerRow(p, i + 1))}
                </div>
            </div>

            <div style={{background: '#f8f9fa', padding: 10, borderTop: '1px solid #ddd'}}>
                <div style={{display:'flex', alignItems:'center', gap:5, fontSize: 12, color: '#7f8c8d', marginBottom: 5, fontWeight:'bold'}}>
                    <ScrollText size={12}/> 赏罚日志详情
                </div>
                {/* [关键修改] maxHeight 使用 min(100px, 15vh) */}
                <div style={{fontSize: 11, color: '#666', lineHeight: '1.6', maxHeight: 'min(100px, 15vh)', overflowY: 'auto', textAlign:'left'}}>
                    {matchHistory.length > 0 ? (
                        matchHistory.slice().reverse().map((match, i) => (
                            <div key={i} style={{marginBottom: 4}}>
                                <span style={{fontWeight:'bold', color:'#333'}}>R{matchHistory.length - i}: </span>
                                {match.details && match.details.length > 0 ? match.details.join('; ') : '无特殊赏罚'}
                            </div>
                        ))
                    ) : (
                        <div>暂无记录</div>
                    )}
                </div>
            </div>
        </div>
    );
};

================================================================================
FILE PATH: client\src\components\ui\Card.jsx
================================================================================
import React from 'react';
import { getCardDisplay } from '../../utils/cardLogic.js';
import css from './Card.module.css';

export const Card = ({ cardVal, index, isSelected, onClick, onMouseEnter, spacing }) => {
    const { suit, text, color, isScore } = getCardDisplay(cardVal);
    
    const handlePointerDown = (e) => {
        if (e.pointerType === 'touch') return;
        
        // [修改] PC 端鼠标点击也交由父组件手势 Hook 统一处理
        // 屏蔽此处的 onClick，避免与 useHandGesture 的 mousedown 逻辑冲突（导致点一次触发两次）
        
        /* if (e.button !== 0 && e.pointerType === 'mouse') return;
        e.stopPropagation();
        onClick(cardVal); 
        */
    };

    const containerClasses = [
        css.card,
        isSelected ? css.cardSelected : '',
        isScore ? css.cardScore : css.cardNormal
    ].join(' ');

    return (
        <div 
            className={containerClasses}
            onPointerDown={handlePointerDown}
            onMouseEnter={(e) => {
                // 这个事件主要保留给旧逻辑，但有了 useHandGesture 后其实不再依赖它
                if (e.pointerType === 'mouse') {
                     onMouseEnter(cardVal);
                }
            }}
            style={{
                color: color, 
                left: index * spacing, 
                zIndex: index
            }}
        >
            <div className={css.cardContent}>
                <div className={css.cardText}>{text}</div>
                <div className={css.cardSuit}>{suit}</div>
            </div>
            {isScore && <div className={css.starBadge}>★</div>}
        </div>
    );
};

export const MiniCard = ({ cardVal, index }) => {
    const { text, suit, color, isScore } = getCardDisplay(cardVal);
    
    const miniClasses = [
        css.miniCard,
        isScore ? css.miniCardScore : ''
    ].join(' ');

    return (
        <div 
            className={miniClasses}
            style={{ 
                color,
                zIndex: index 
            }}
        >
            {suit}{text}
        </div>
    );
};

================================================================================
FILE PATH: client\src\components\ui\Card.module.css
================================================================================
/* 基础卡牌容器 */
.card {
    background: white;
    border-radius: 6px;
    border: 1px solid #999;
    position: absolute;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    padding: 4px;
    transition: transform 0.1s cubic-bezier(0.2, 0.8, 0.2, 1);
    width: 55px;
    height: 70px;
    box-sizing: border-box;
    /* 禁止触摸时的默认动作，交由 JS 处理 */
    touch-action: none; 
    box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
}

/* 选中状态 */
.cardSelected {
    transform: translateY(-35px);
    border-color: #3498db !important;
    box-shadow: 0 0 15px rgba(52, 152, 219, 0.6) !important;
}

/* 分牌高亮 */
.cardScore {
    border-color: #f1c40f;
    box-shadow: 0 0 8px rgba(241, 196, 15, 0.4);
}

/* 普通牌 */
.cardNormal {
    border-color: #bdc3c7;
}

/* 卡面内容布局 */
.cardContent {
    position: absolute;
    top: 0;
    left: 1px;
    display: flex;
    flex-direction: column;
    align-items: center;
    line-height: 0.9;
}

.cardText {
    font-size: 16px;
    font-weight: 900;
    letter-spacing: -1px;
}

.cardSuit {
    font-size: 14px;
    margin-top: -1px;
}

/* 右下角星星 */
.starBadge {
    position: absolute;
    bottom: 1px;
    right: 2px;
    font-size: 10px;
    color: #f1c40f;
}

/* --- 小卡牌 (用于历史记录/桌面展示) --- */
.miniCard {
    background: white;
    padding: 10px 15px;
    border-radius: 8px;
    font-weight: bold;
    font-size: 24px;
    min-width: 40px;
    text-align: center;
    border: 1px solid #ccc;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    position: relative;
}

.miniCardScore {
    border: 2px solid #f1c40f;
    transform: scale(1.1) translateY(-10px);
    z-index: 10;
}

================================================================================
FILE PATH: client\src\components\ui\GameLogPanel.jsx
================================================================================
import React, { useEffect, useRef, useState } from 'react'; 
import { History, ChevronDown, ChevronUp } from 'lucide-react'; 
import css from './GameLogPanel.module.css';

export const GameLogPanel = ({ logs }) => {
    const [isCollapsed, setIsCollapsed] = useState(false); 
    const endRef = useRef(null);

    useEffect(() => {
        if (!isCollapsed) {
            endRef.current?.scrollIntoView({ behavior: 'smooth' });
        }
    }, [logs, isCollapsed]);

    const panelClasses = [
        css.panel,
        isCollapsed ? css.panelCollapsed : css.panelExpanded
    ].join(' ');

    return (
        <div 
            className={panelClasses}
            onClick={() => setIsCollapsed(!isCollapsed)} 
        >
            <div className={css.header}>
                <History size={14} color="#f1c40f" /> 
                <span style={{color:'#fff', fontWeight:'bold', flex: 1}}>
                    对局记录
                </span>
                {isCollapsed ? <ChevronDown size={14} color="#ccc"/> : <ChevronUp size={14} color="#ccc"/>}
            </div>
            
            <div className={isCollapsed ? css.listHidden : css.list}>
                {logs.map((log, i) => (
                    <div key={i} className={css.logItem}>
                        <span className={css.logTime}>[{log.time.split(' ')[0]}]</span>
                        <span style={{color: '#eee'}}>{log.text}</span>
                    </div>
                ))}
                <div ref={endRef} />
            </div>
        </div>
    );
};

================================================================================
FILE PATH: client\src\components\ui\GameLogPanel.module.css
================================================================================
.panel {
    position: absolute;
    top: 60px;
    left: 10px;
    width: 200px;
    background: rgba(0, 0, 0, 0.4);
    border-radius: 8px;
    padding: 8px;
    color: white;
    font-size: 12px;
    z-index: 1000;
    backdrop-filter: blur(2px);
    transition: all 0.3s ease;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    cursor: pointer;
    overflow: hidden;
    /* [修复] 确保在任何状态下都接收鼠标事件，防止无法点击展开 */
    pointer-events: auto; 
}

.panelCollapsed {
    height: 36px;
    background: rgba(0, 0, 0, 0.2);
    border-color: transparent;
}

.panelExpanded {
    height: 140px;
}

.header {
    display: flex;
    align-items: center;
    gap: 5px;
    margin-bottom: 5px;
    font-weight: bold;
    color: #f1c40f;
    text-shadow: 0 1px 2px rgba(0,0,0,0.8);
}

.list {
    height: 100px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 4px;
    opacity: 1;
    transition: opacity 0.2s;
    /* 隐藏滚动条但保留功能 */
    scrollbar-width: none; 
}

.listHidden {
    opacity: 0;
    pointer-events: none;
}

.logItem {
    display: flex;
    gap: 6px;
    line-height: 1.3;
    text-shadow: 0 1px 1px rgba(0,0,0,0.8);
}

.logTime {
    color: #95a5a6;
    font-family: monospace;
    flex-shrink: 0;
}

================================================================================
FILE PATH: client\src\components\ui\PlayerAvatar.jsx
================================================================================
import React from 'react';
import { Trophy, Flag, Shield, Coins } from 'lucide-react';
import css from './PlayerAvatar.module.css';
import CountDownTimer from '../CountDownTimer.jsx';

export const PlayerAvatar = ({ player, isTurn, score, roundScore = 0, targetScore, isMySocket, remainingSeconds, rank, timerPosition, hideTimer, cardCount, showCardCountMode, team }) => {
    const progress = Math.min((score / targetScore) * 100, 100);
    
    // 排名状态下的透明度
    const containerStyle = rank ? { opacity: 0.75 } : {};

    let showBadge = false;
    if (showCardCountMode === 2) showBadge = true;
    // [修改] 2 改为 3
    if (showCardCountMode === 1 && cardCount <= 3 && cardCount > 0) showBadge = true;
    if (rank) showBadge = false;

    const isTeamMode = team !== undefined && team !== null;
    const teamName = team === 0 ? '红' : '蓝';
    
    const boxClasses = [
        css.playerBox,
        isTurn ? css.activeTurn : '',
        isTeamMode ? (team === 0 ? css.teamRed : css.teamBlue) : ''
    ].join(' ');

    return (
        <div className={boxClasses} style={containerStyle}>
            {showBadge && (
                <div className={css.cardCountBadge}>
                    {cardCount}
                </div>
            )}

            {isTeamMode && (
                <div className={css.teamBadge} style={{backgroundColor: team === 0 ? '#e74c3c' : '#3498db'}}>
                    <Shield size={8} fill="currentColor"/> {teamName}队
                </div>
            )}

            {rank && (
                <div className={css.rankBadge} style={{
                    background: rank === 1 ? '#f1c40f' : (rank === 2 ? '#bdc3c7' : '#e67e22')
                }}>
                    {rank === 1 ? <Trophy size={10} fill="white" /> : <Flag size={10} fill="white"/>}
                    {rank === 1 ? 'NO.1' : `NO.${rank}`}
                </div>
            )}

            <div className={css.avatar} style={{borderColor: isTeamMode ? (team === 0 ? '#e74c3c' : '#3498db') : 'rgba(255,255,255,0.3)'}}>
                {player.name[0]}
            </div>
            
            <div className={css.playerName}>
                {player.name} {isMySocket && '(我)'}
            </div>
            
            <div className={css.scoreBarBg}>
                <div className={css.scoreBarFill} style={{width:`${progress}%`, background: progress>=100?'#e74c3c':'#2ecc71'}}></div>
            </div>
            
            <div className={css.playerScore}>
                <Coins size={10} color="#f1c40f"/> 
                {score}
                {roundScore > 0 && (
                    <span style={{color: '#f1c40f', fontSize: 9, marginLeft: 2, fontWeight: 900}}>(+{roundScore})</span>
                )}
            </div>
            
            {isTurn && !rank && !hideTimer && (
                <CountDownTimer 
                    initialSeconds={remainingSeconds} 
                    totalSeconds={60} 
                    position={timerPosition}
                />
            )}
        </div>
    );
};

================================================================================
FILE PATH: client\src\components\ui\PlayerAvatar.module.css
================================================================================
/* 头像容器 */
.playerBox {
    pointer-events: auto;
    padding: 2px 4px;
    border-radius: 8px;
    text-align: center;
    min-width: 45px;
    color: white;
    border: 1px solid transparent;
    transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
    position: relative;
    backdrop-filter: blur(3px);
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    background: rgba(44, 62, 80, 0.6);
}

/* 轮到该玩家时的激活状态 */
.activeTurn {
    transform: scale(1.1);
    box-shadow: 0 0 25px rgba(241, 196, 15, 0.5);
    background: rgba(44, 62, 80, 0.9);
    border-color: #f1c40f !important; /* 强制覆盖队伍色 */
    z-index: 20;
}

/* 队伍背景色 */
.teamRed { background: rgba(231, 76, 60, 0.2); }
.teamBlue { background: rgba(52, 152, 219, 0.2); }

/* 剩余手牌数徽章 */
.cardCountBadge {
    position: absolute;
    top: -8px;
    left: -8px;
    background: #e74c3c;
    color: white;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    font-size: 12px;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 2px solid #fff;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    z-index: 25;
}

/* 组队标签 */
.teamBadge {
    position: absolute; 
    top: -10px; 
    right: -8px; 
    color: white;
    font-size: 9px; 
    padding: 1px 4px; 
    border-radius: 4px;
    display: flex; 
    align-items: center; 
    gap: 2px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    z-index: 25;
}

/* 排名标签 (NO.1 etc) */
.rankBadge {
    position: absolute;
    top: -16px;
    left: 50%;
    transform: translateX(-50%);
    color: #fff;
    padding: 2px 8px;
    border-radius: 20px;
    font-size: 11px;
    font-weight: bold;
    box-shadow: 0 2px 5px rgba(0,0,0,0.4);
    z-index: 30;
    display: flex;
    align-items: center;
    gap: 3px;
    white-space: nowrap;
    border: 1px solid white;
}

/* 圆形头像 */
.avatar {
    width: 30px;
    height: 30px;
    background: #ecf0f1;
    border-radius: 50%;
    margin: 0 auto 2px;
    line-height: 30px;
    color: #333;
    font-weight: bold;
    font-size: 14px;
    border: 1px solid rgba(255,255,255,0.3);
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    display: flex;
    align-items: center;
    justify-content: center;
}

.playerName {
    font-size: 10px;
    font-weight: bold;
    margin-bottom: 1px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 50px;
    margin-left: auto;
    margin-right: auto;
}

/* 分数条 */
.scoreBarBg {
    width: 100%;
    height: 4px;
    background: rgba(0,0,0,0.5);
    border-radius: 2px;
    margin-top: 2px;
    overflow: hidden;
}

.scoreBarFill {
    height: 100%;
    transition: width 0.5s;
}

.playerScore {
    font-size: 9px;
    color: #f1c40f;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 3px;
    margin-top: 1px;
}

================================================================================
FILE PATH: client\src\context\GameContext.jsx
================================================================================
import React, { createContext, useContext, useEffect, useRef, useState } from 'react';

import { useSocketConnection } from '../hooks/useSocketConnection.js';
import { useRoomLogic } from '../hooks/game/useRoomLogic.js';
import { useGameData } from '../hooks/game/useGameData.js';
import { useBattleLogic } from '../hooks/game/useBattleLogic.js';

const GameContext = createContext(null);

export const GameProvider = ({ children }) => {
  const { socket, isConnected, mySocketId, ping } = useSocketConnection();

  // [新增] 观众状态
  const [isSpectator, setIsSpectator] = useState(false);
  // [新增] 观察到的其他人手牌 { playerId: [cards] }
  const [observedHands, setObservedHands] = useState({});

  const roomLogic = useRoomLogic(socket, isConnected);
  const { 
      username, roomId, inputConfig, isLoading, setIsLoading,
      handleRoomAction, handleUpdateConfig
  } = roomLogic;

  const gameData = useGameData(socket, setIsLoading);
  const { 
      gameState, players, syncedConfig, 
      handleStartGame, handleNextRound,
      handleAddBot, handleSwitchSeat, handleDrawCard, handleKickPlayer
  } = gameData;

  const activeRoomConfig = (gameState === 'LOGIN') ? inputConfig : (syncedConfig || inputConfig);

  const deckCount = activeRoomConfig ? activeRoomConfig.deckCount : 2;
  const battleLogic = useBattleLogic(socket, username, mySocketId, roomId, deckCount);

  // [新增] 监听观众事件和手牌观察事件
  useEffect(() => {
    if (!socket) return;

    const onSpectatorJoin = (data) => {
        setIsSpectator(true);
        // 如果进入时游戏已经是 GAME 状态，手动解除 loading (防止 useGameData 逻辑覆盖)
        setIsLoading(false); 
        alert(data.message);
    };

    const onObservationUpdate = (data) => {
        // data: { targetId, hand, targetName }
        setObservedHands(prev => ({
            ...prev,
            [data.targetId]: data.hand
        }));
    };

    // 每次新局开始，清空观察的手牌
    const onGameStarted = (data) => {
        setObservedHands({});
        // 如果服务器明确标记你是观众
        if (data.isSpectator) {
            setIsSpectator(true);
        } else {
            // 如果我是玩家（有手牌），确保 isSpectator 为 false
            if (data.hand && data.hand.length > 0) setIsSpectator(false);
        }
    };

    socket.on('spectator_join', onSpectatorJoin);
    socket.on('observation_update', onObservationUpdate);
    socket.on('game_started', onGameStarted);

    return () => {
        socket.off('spectator_join', onSpectatorJoin);
        socket.off('observation_update', onObservationUpdate);
        socket.off('game_started', onGameStarted);
    };
  }, [socket, setIsLoading]);


  const wrappedActions = {
      handleRoomAction,
      handleUpdateConfig: (cfg) => handleUpdateConfig(roomId, cfg),
      handleStartGame: () => handleStartGame(roomId),
      handleNextRound: () => handleNextRound(roomId),
      handleAddBot: () => handleAddBot(roomId),
      handleSwitchSeat: (i1, i2) => handleSwitchSeat(roomId, i1, i2),
      handleDrawCard: (idx) => handleDrawCard(roomId, idx),
      handleKickPlayer: (tid) => handleKickPlayer(roomId, tid),
      
      handleToggleAutoPlay: () => battleLogic.handleToggleAutoPlay(roomId),
      // [修复] 增加对 handleSwitchAutoPlayMode 的封装，自动注入 roomId
      handleSwitchAutoPlayMode: (mode) => battleLogic.handleSwitchAutoPlayMode(roomId, mode),
      
      handlePass: () => battleLogic.handlePass(roomId),
      handlePlayCards: () => battleLogic.handlePlayCards(roomId),
      handleRequestHint: () => battleLogic.handleRequestHint(roomId),

      handleQuickReconnect: () => {
          const lastRid = localStorage.getItem('poker_roomid');
          const lastName = localStorage.getItem('poker_username');
          
          if (!lastRid || !lastName) {
              return alert("没有找到最近的房间记录，无法重连");
          }
          if (!isConnected) return alert("网络连接未就绪，请稍候");

          roomLogic.setRoomId(lastRid);
          roomLogic.setUsername(lastName);
          roomLogic.setIsCreatorMode(false);
          
          if (setIsLoading) setIsLoading(true);
          console.log(`[QuickReconnect] 尝试重回房间: ${lastRid} as ${lastName}`);
          
          if (socket && socket.connected) {
              socket.emit('join_room', { roomId: lastRid, username: lastName });
          } else {
              setIsLoading(false);
              alert("连接断开，请刷新页面重试");
          }
      },

      handleLeaveRoom: () => {
          if (window.confirm("确定要退出房间返回首页吗？")) {
              window.location.reload();
          }
      }
  };

  const contextValue = {
      socket, isConnected, mySocketId, ping,
      
      username, setUsername: roomLogic.setUsername,
      roomId, setRoomId: roomLogic.setRoomId,
      isCreatorMode: roomLogic.isCreatorMode, setIsCreatorMode: roomLogic.setIsCreatorMode,
      isLoading,
      
      roomConfig: activeRoomConfig, 
      setRoomConfig: roomLogic.setInputConfig, 
      gameState, 
      players, 
      
      ...gameData, 
      ...battleLogic, 
      
      ...wrappedActions,
      
      handleMouseDown: battleLogic.handleMouseDown,
      handleMouseEnter: battleLogic.handleMouseEnter,
      handleClearSelection: battleLogic.handleClearSelection,
      toggleSort: battleLogic.toggleSort,

      // [新增] 暴露给 UI 的新状态
      isSpectator,
      observedHands 
  };

  return (
    <GameContext.Provider value={contextValue}>
      {children}
    </GameContext.Provider>
  );
};

export const useGame = () => {
  const context = useContext(GameContext);
  if (!context) {
    throw new Error('useGame must be used within a GameProvider');
  }
  return context;
};

================================================================================
FILE PATH: client\src\hooks\game\useBattleLogic.js
================================================================================
import { useState, useEffect, useRef } from 'react';
import { sortHand } from '../../utils/cardLogic.js';
import SoundManager from '../../utils/SoundManager.js';
import SmartHint from '../../utils/smartHint.js'; // 引入本地智能提示

export const useBattleLogic = (socket, username, mySocketId, roomId, deckCount = 2) => {
    // --- 局内状态 ---
    const [myHand, setMyHand] = useState([]);       
    const [selectedCards, setSelectedCards] = useState([]); 
    const [lastPlayed, setLastPlayed] = useState([]); 
    const [currentTurnId, setCurrentTurnId] = useState(null); 
    const [lastPlayerName, setLastPlayerName] = useState(''); 
    const [infoMessage, setInfoMessage] = useState(''); 
    
    // 积分与结算
    const [roundResult, setRoundResult] = useState(null); 
    const [grandResult, setGrandResult] = useState(null); 
    const [playerScores, setPlayerScores] = useState({});
    const [roundPoints, setRoundPoints] = useState({});
    const [playersInfo, setPlayersInfo] = useState({}); 
    const [finishedRank, setFinishedRank] = useState([]); 
    const [pendingPoints, setPendingPoints] = useState(0);
    
    // 杂项
    const [gameLogs, setGameLogs] = useState([]);
    const [sortMode, setSortMode] = useState('POINT'); 
    const [turnRemaining, setTurnRemaining] = useState(60); 
    const [handCounts, setHandCounts] = useState({});

    // 提示功能状态
    const [availableHints, setAvailableHints] = useState([]); 
    const [hintIndex, setHintIndex] = useState(0);            
    
    // [新增] 提交防抖状态
    const [isSubmitting, setIsSubmitting] = useState(false);

    // 交互 Ref
    const isDragging = useRef(false); 
    const dragStartMode = useRef(true); 
    const sortModeRef = useRef('POINT');
    const backupHandRef = useRef([]);

    // 保持 Ref 同步
    useEffect(() => { sortModeRef.current = sortMode; }, [sortMode]);
    // 当排序模式改变时，重排手牌
    useEffect(() => {
        if (myHand.length > 0) setMyHand(prev => sortHand(prev, sortMode));
    }, [sortMode]);

    // 初始化音效 & 全局事件
    useEffect(() => {
        const initAudio = () => {
            SoundManager.init();
            window.removeEventListener('click', initAudio);
        };
        window.addEventListener('click', initAudio);

        const handleGlobalMouseUp = () => { isDragging.current = false; };
        window.addEventListener('mouseup', handleGlobalMouseUp);
        return () => window.removeEventListener('mouseup', handleGlobalMouseUp);
    }, []);

    // --- 自动计算提示 (当轮到我出牌时) ---
    useEffect(() => {
        if (currentTurnId === mySocketId && myHand.length > 0) {
            // 本地计算，实时性更高
            // 注意：lastPlayed 需要是最新的
            const hints = SmartHint.getSortedHints(myHand, lastPlayed, deckCount);
            setAvailableHints(hints);
            setHintIndex(0);
        } else {
            setAvailableHints([]);
            setHintIndex(0);
        }
    }, [currentTurnId, mySocketId, myHand, lastPlayed, deckCount]);


    // --- Socket 监听 ---
    useEffect(() => {
        if (!socket) return;

        const onGameStarted = (data) => {
            if (data.hand) {
                setMyHand(sortHand(data.hand, sortModeRef.current));
            }
            setLastPlayed([]);
            setRoundResult(null);
            setGrandResult(null);
            setPendingPoints(0);
            setFinishedRank([]); 
            if (data.grandScores) setPlayerScores(data.grandScores);
            setRoundPoints({});

            setGameLogs([{ time: new Date().toLocaleTimeString(), text: '🏁 新一局开始！' }]); 
            setTurnRemaining(60);
            setPlayersInfo({});
            if (data.handCounts) setHandCounts(data.handCounts);
            
            backupHandRef.current = []; 
        };

        const onGameStateUpdate = (data) => {
            setCurrentTurnId(data.currentTurnId);
            
            if (data.turnRemaining !== undefined) setTurnRemaining(data.turnRemaining);

            if (data.lastPlayed && data.lastPlayed.length > 0) {
                if (data.lastPlayerName !== username) {
                    SoundManager.play('play'); 
                }
            }
            if (data.currentTurnId === mySocketId) {
                SoundManager.play('alert');
            }

            if (data.lastPlayerName === username) {
                 setIsSubmitting(false); 
            }

            if (data.lastPlayed) setLastPlayed(sortHand(data.lastPlayed, sortModeRef.current));
            setLastPlayerName(data.lastPlayerName || '');
            
            if (data.infoText) {
                if (data.infoText.includes('不要')) {
                    SoundManager.play('pass');
                }
                
                if (data.infoText !== 'PASS') {
                    // [修改] 延长停留时间至 3.5s，配合 CSS 动画
                    setInfoMessage(data.infoText); 
                    setTimeout(() => setInfoMessage(''), 3500);
                    
                    setGameLogs(prev => [...prev, { time: new Date().toLocaleTimeString(), text: data.infoText }]);
                }
            }
            
            if (data.scores) setPlayerScores(data.scores);
            if (data.roundPoints) setRoundPoints(data.roundPoints);
            if (data.playersInfo) setPlayersInfo(data.playersInfo);
            if (data.handCounts) setHandCounts(data.handCounts);
            if (data.finishedRank) setFinishedRank(data.finishedRank);
            if (data.pendingPoints !== undefined) setPendingPoints(data.pendingPoints);
        };

        const onHandUpdate = (newHand) => {
            setMyHand(sortHand(newHand, sortModeRef.current)); 
            setSelectedCards([]);
            backupHandRef.current = [];
        };

        const onPlayError = (msg) => { 
            setIsSubmitting(false); 
            setInfoMessage(msg); 
            setTimeout(()=>setInfoMessage(''), 3500); 
            SoundManager.play('lose'); 
            
            if (backupHandRef.current.length > 0) {
                setMyHand(backupHandRef.current);
                backupHandRef.current = [];
                setInfoMessage("出牌无效，手牌已回滚");
            }
        }; 
        
        const onRoundOver = (data) => {
            setTimeout(() => {
                setRoundResult(data);
                if (data.grandScores) setPlayerScores(data.grandScores);
                const amIWinner = data.roundWinner === username;
                SoundManager.play(amIWinner ? 'win' : 'lose');
            }, 1000); 
        };

        const onGrandGameOver = (data) => {
             setTimeout(() => {
                setGrandResult(data);
                SoundManager.play('win'); 
             }, 1000);
        };

        socket.on('game_started', onGameStarted);
        socket.on('game_state_update', onGameStateUpdate);
        socket.on('hand_update', onHandUpdate);
        socket.on('play_error', onPlayError);
        socket.on('round_over', onRoundOver);
        socket.on('grand_game_over', onGrandGameOver);

        return () => {
            socket.off('game_started', onGameStarted);
            socket.off('game_state_update', onGameStateUpdate);
            socket.off('hand_update', onHandUpdate);
            socket.off('play_error', onPlayError);
            socket.off('round_over', onRoundOver);
            socket.off('grand_game_over', onGrandGameOver);
        };
    }, [socket, username, mySocketId]); 

    // --- 交互 Actions ---

    const toggleSort = () => setSortMode(prev => {
        if (prev === 'POINT') return 'ARRANGE';
        if (prev === 'ARRANGE') return 'ARRANGE_MERGED';
        return 'POINT';
    });
    
    const handleToggleAutoPlay = (roomId) => socket.emit('toggle_auto_play', { roomId });

    // [新增] 切换托管模式
    const handleSwitchAutoPlayMode = (roomId, mode) => socket.emit('switch_autoplay_mode', { roomId, mode });

    const handlePass = (roomId) => {
        if (isSubmitting) return; 
        setIsSubmitting(true);    

        socket.emit('pass_turn', { roomId });
        setSelectedCards([]);

        setTimeout(() => setIsSubmitting(false), 500); 
    };
    
    const updateSelection = (cardVal, forceSelect = null) => {
        setSelectedCards(prev => {
            const isSelected = prev.includes(cardVal);
            if (forceSelect !== null) return forceSelect && !isSelected ? [...prev, cardVal] : (!forceSelect && isSelected ? prev.filter(c => c !== cardVal) : prev);
            return isSelected ? prev.filter(c => c !== cardVal) : [...prev, cardVal];
        });
    };

    const handleClearSelection = () => setSelectedCards([]);

    const handleMouseDown = (cardVal) => {
        isDragging.current = true;
        dragStartMode.current = !selectedCards.includes(cardVal); 
        updateSelection(cardVal, dragStartMode.current);
        SoundManager.play('deal'); 
    };
    
    const handleMouseEnter = (cardVal) => {
        if (isDragging.current) {
            updateSelection(cardVal, dragStartMode.current);
        }
    };

    const handlePlayCards = (roomId) => {
        if (isSubmitting) return; 
        if (selectedCards.length === 0) return alert("请先选牌");
        
        setIsSubmitting(true); 
        
        const cardsToPlay = [...selectedCards];
        
        backupHandRef.current = [...myHand];
        const nextHand = myHand.filter(c => !cardsToPlay.includes(c));
        setMyHand(nextHand);
        
        setLastPlayed(sortHand(cardsToPlay, sortModeRef.current));
        setLastPlayerName(username); 
        setSelectedCards([]); 
        
        SoundManager.play('play');
        socket.emit('play_cards', { roomId, cards: cardsToPlay });

        setTimeout(() => setIsSubmitting(false), 3000);
    };

    // [修改] 提示按钮点击逻辑：循环切换候选牌型
    const handleRequestHint = (roomId) => {
        if (availableHints.length > 0) {
            // 当前选中的提示索引
            const targetHint = availableHints[hintIndex]; 
            setSelectedCards(targetHint);
            
            // 移动指针到下一个，为下次点击做准备
            setHintIndex((hintIndex + 1) % availableHints.length);
        } else {
            setInfoMessage('没有打得过的牌');
            setTimeout(()=>setInfoMessage(''), 1000);
            SoundManager.play('pass'); 
        }
    };

    return {
        // State
        myHand, selectedCards, lastPlayed,
        currentTurnId, lastPlayerName, infoMessage,
        roundResult, grandResult, playerScores, roundPoints,
        playersInfo, finishedRank, pendingPoints, gameLogs,
        sortMode, turnRemaining, handCounts,
        isSubmitting, 

        // Actions
        toggleSort, 
        handleToggleAutoPlay,
        handleSwitchAutoPlayMode, // [新增] 导出该方法
        handlePass, 
        handlePlayCards,
        handleRequestHint,
        handleMouseDown, 
        handleMouseEnter,
        handleClearSelection
    };
};

================================================================================
FILE PATH: client\src\hooks\game\useGameData.js
================================================================================
import { useState, useEffect } from 'react';
import SoundManager from '../../utils/SoundManager.js';

export const useGameData = (socket, setIsLoading) => {
    const [gameState, setGameState] = useState('LOGIN'); 
    const [players, setPlayers] = useState([]);
    
    // 从服务器同步回来的配置 (用于大厅展示和游戏内逻辑)
    const [syncedConfig, setSyncedConfig] = useState(null);

    // 抽签阶段特有数据
    const [drawState, setDrawState] = useState(null); 
    // { totalCards: number, history: Array<{playerId, index, val, name}> }

    useEffect(() => {
        if (!socket) return;

        // --- 监听大厅与全局状态 ---

        const onRoomInfo = (data) => {
            setSyncedConfig(data.config);
            setPlayers(data.players);
            
            // 自动流转状态
            if (gameState !== 'GAME' && gameState !== 'DRAW_SEATS') {
                setGameState('LOBBY'); 
            }
            if (setIsLoading) setIsLoading(false);
        };

        const onEnterDrawPhase = (data) => {
            setDrawState({ totalCards: data.totalCards, history: [] });
            setGameState('DRAW_SEATS');
            SoundManager.play('deal');
        };

        const onSeatDrawUpdate = (data) => {
            setDrawState(prev => ({ ...prev, history: [...prev.history, data] }));
            SoundManager.play('deal'); 
        };

        const onSeatDrawFinished = (data) => {
            setPlayers(data.players); 
            // 游戏开始事件会紧接着触发，不用这里切状态
        };

        const onGameStarted = (data) => {
            setGameState('GAME');
            SoundManager.play('deal');
        };
        
        const onErrorMsg = (msg) => {
            if (setIsLoading) setIsLoading(false);
            alert(msg);
        };
        
        const onKicked = (msg) => {
             alert(msg);
             window.location.reload();
        };

        socket.on('room_info', onRoomInfo);
        socket.on('enter_draw_phase', onEnterDrawPhase);
        socket.on('seat_draw_update', onSeatDrawUpdate);
        socket.on('seat_draw_finished', onSeatDrawFinished);
        socket.on('game_started', onGameStarted);
        socket.on('error_msg', onErrorMsg);
        socket.on('kicked', onKicked);

        return () => {
            socket.off('room_info', onRoomInfo);
            socket.off('enter_draw_phase', onEnterDrawPhase);
            socket.off('seat_draw_update', onSeatDrawUpdate);
            socket.off('seat_draw_finished', onSeatDrawFinished);
            socket.off('game_started', onGameStarted);
            socket.off('error_msg', onErrorMsg);
            socket.off('kicked', onKicked);
        };
    }, [socket, gameState, setIsLoading]);

    // --- 大厅操作 Actions ---
    const handleStartGame = (roomId) => socket.emit('start_game', { roomId });
    // [修复] 增加 handleNextRound
    const handleNextRound = (roomId) => socket.emit('next_round', { roomId });
    
    const handleAddBot = (roomId) => socket.emit('add_bot', { roomId });
    const handleKickPlayer = (roomId, targetId) => socket.emit('kick_player', { roomId, targetId });
    const handleSwitchSeat = (roomId, index1, index2) => socket.emit('switch_seat', { roomId, index1, index2 });
    const handleDrawCard = (roomId, index) => socket.emit('draw_seat_card', { roomId, cardIndex: index });

    return {
        gameState, setGameState,
        players, setPlayers,
        syncedConfig, setSyncedConfig,
        drawState,
        
        // Actions
        handleStartGame, 
        handleNextRound, // 导出
        handleAddBot, 
        handleKickPlayer, 
        handleSwitchSeat, 
        handleDrawCard
    };
};

================================================================================
FILE PATH: client\src\hooks\game\useRoomLogic.js
================================================================================
import { useState, useEffect } from 'react';

export const useRoomLogic = (socket, isConnected) => {
    // 基础表单状态
    // [修改] 初始值优先从 localStorage 读取，防止刷新丢失
    const [username, setUsername] = useState(localStorage.getItem('poker_username') || '');
    const [roomId, setRoomId] = useState(localStorage.getItem('poker_roomid') || '');
    
    const [isCreatorMode, setIsCreatorMode] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    
    // 房间配置表单状态 (默认值)
    const [inputConfig, setInputConfig] = useState({ 
        deckCount: 2,          
        maxPlayers: 4,         
        targetScore: 1000,     
        turnTimeout: 60000,
        enableRankPenalty: true, 
        rankPenaltyScores: [30, 15],
        showCardCountMode: 1, 
        isTeamMode: false,
        shuffleStrategy: 'CLASSIC'
    });

    // [新增] 监听 username 变化并自动保存到 localStorage
    useEffect(() => {
        if (username) {
            localStorage.setItem('poker_username', username);
        }
    }, [username]);

    // [新增] 监听 roomId 变化并自动保存到 localStorage
    useEffect(() => {
        if (roomId) {
            localStorage.setItem('poker_roomid', roomId);
        }
    }, [roomId]);

    // 动作：创建或加入房间
    const handleRoomAction = () => {
        if (!isConnected) return; 
        if (!username || !roomId) return alert("请输入昵称和房间号");
        
        setIsLoading(true);
        
        const event = isCreatorMode ? 'create_room' : 'join_room';
        const payload = isCreatorMode 
            ? { roomId, username, config: inputConfig } 
            : { roomId, username };
            
        socket.emit(event, payload);
    };

    // 动作：更新配置 (房主)
    const handleUpdateConfig = (roomId, newConfig) => {
        if (socket) socket.emit('update_room_config', { roomId, config: newConfig });
    };

    return {
        username, setUsername,
        roomId, setRoomId,
        isCreatorMode, setIsCreatorMode,
        isLoading, setIsLoading,
        inputConfig, setInputConfig, // 暴露给 LoginScreen 使用
        
        // Actions
        handleRoomAction,
        handleUpdateConfig
    };
};

================================================================================
FILE PATH: client\src\hooks\useHandGesture.js
================================================================================
import { useEffect, useRef } from 'react';
import { getCardIndexFromTouch } from '../utils/cardLogic.js';

/**
 * 专门处理手牌区域的触摸滑动 & 鼠标拖拽选择逻辑
 * [修改] 增加了 Mouse 事件支持，适配 PC 端滑动选牌
 */
export const useHandGesture = ({ 
    myHand, 
    selectedCards, 
    cardSpacing, 
    handleMouseDown, // 这里复用原本的点击/选牌处理函数
    amIAutoPlay 
}) => {
    const handContainerRef = useRef(null);
    const lastTouchedIndex = useRef(null);
    const isDragging = useRef(false);
    const dragStartMode = useRef(true); // true=选中模式, false=取消模式

    // 使用 Ref 保存最新状态，避免在 EventListener 中产生闭包陷阱
    const stateRef = useRef({ myHand, selectedCards, cardSpacing, handleMouseDown });

    useEffect(() => {
        stateRef.current = { myHand, selectedCards, cardSpacing, handleMouseDown };
    }, [myHand, selectedCards, cardSpacing, handleMouseDown]);

    // --- 核心手势逻辑 (复用于 Touch 和 Mouse) ---
    const handleGestureStart = (clientX, clientY) => {
        const container = handContainerRef.current;
        if (!container) return;
        
        const rect = container.getBoundingClientRect();
        const { myHand: currHand, selectedCards: currSelection, cardSpacing: currSpacing, handleMouseDown: currToggle } = stateRef.current;
        
        const index = getCardIndexFromTouch(clientX, rect.left, currSpacing, currHand.length);
        const cardVal = currHand[index];
        if (cardVal === undefined) return;

        const isSelected = currSelection.includes(cardVal);
        // 判定有效高度 (模拟 visually 弹起的牌)
        const CARD_HEIGHT = 70;    
        const POP_HEIGHT = 35;     
        const TOLERANCE = 10;      
        const validVisualHeight = isSelected ? CARD_HEIGHT + POP_HEIGHT + TOLERANCE : CARD_HEIGHT + TOLERANCE;
        const distanceFromBottom = rect.bottom - clientY;

        // 超出判定区域则忽略 (防止点到卡牌上方空白处误触)
        if (distanceFromBottom > validVisualHeight || distanceFromBottom < -10) {
            isDragging.current = false;
            return;
        }

        isDragging.current = true;
        dragStartMode.current = !currSelection.includes(cardVal);
        lastTouchedIndex.current = index;
        
        // 立即触发当前点击
        if (isSelected !== dragStartMode.current) {
            currToggle(cardVal); 
            if (navigator.vibrate) navigator.vibrate(5);
        }
    };

    const handleGestureMove = (clientX, clientY) => {
        if (!isDragging.current) return;
        
        const container = handContainerRef.current;
        if (!container) return;
        
        const rect = container.getBoundingClientRect();
        // 增加垂直容错，防止鼠标/手指稍微划出区域就断触
        if (clientY < rect.top - 50 || clientY > rect.bottom + 50) return;
        
        const { myHand: currHand, selectedCards: currSelection, cardSpacing: currSpacing, handleMouseDown: currToggle } = stateRef.current;
        const index = getCardIndexFromTouch(clientX, rect.left, currSpacing, currHand.length);
        
        // 只有滑到了新的牌上才触发
        if (lastTouchedIndex.current !== index) {
            lastTouchedIndex.current = index;
            const cardVal = currHand[index];
            if (cardVal !== undefined) {
                const isSelected = currSelection.includes(cardVal);
                // 保持和起始动作一致（如果是“选中”模式，划过的都选中；如果是“取消”模式，划过的都取消）
                if (isSelected !== dragStartMode.current) {
                    currToggle(cardVal); 
                    if (navigator.vibrate) navigator.vibrate(5);
                }
            }
        }
    };

    const handleGestureEnd = () => {
        isDragging.current = false;
        lastTouchedIndex.current = null;
    };

    // --- 事件绑定 ---
    useEffect(() => {
        const container = handContainerRef.current;
        if (!container || amIAutoPlay) return;
        
        // 1. Touch Events (移动端)
        const onTouchStart = (e) => {
            if (e.cancelable) e.preventDefault();
            if (e.touches.length > 0) {
                handleGestureStart(e.touches[0].clientX, e.touches[0].clientY);
            }
        };
        const onTouchMove = (e) => {
            if (e.cancelable) e.preventDefault();
            if (e.touches.length > 0) {
                handleGestureMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        };
        const onTouchEnd = () => handleGestureEnd();

        // 2. Mouse Events (PC端适配)
        const onMouseDown = (e) => {
            if (e.button !== 0) return; // 只响应左键
            handleGestureStart(e.clientX, e.clientY);
        };
        const onMouseMove = (e) => {
            handleGestureMove(e.clientX, e.clientY);
        };
        const onMouseUp = () => handleGestureEnd();

        
        // 绑定 Touch (使用 passive: false 以便能 preventDefault 阻止滚动)
        container.addEventListener('touchstart', onTouchStart, { passive: false });
        container.addEventListener('touchmove', onTouchMove, { passive: false });
        container.addEventListener('touchend', onTouchEnd);
        
        // 绑定 Mouse
        container.addEventListener('mousedown', onMouseDown);
        // 将 Move 和 Up 绑定到 window，防止鼠标拖出容器后失效
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
        
        return () => {
            container.removeEventListener('touchstart', onTouchStart);
            container.removeEventListener('touchmove', onTouchMove);
            container.removeEventListener('touchend', onTouchEnd);

            container.removeEventListener('mousedown', onMouseDown);
            window.removeEventListener('mousemove', onMouseMove);
            window.removeEventListener('mouseup', onMouseUp);
        };
    }, [amIAutoPlay]);

    return handContainerRef;
};

================================================================================
FILE PATH: client\src\hooks\useSocketConnection.js
================================================================================
import { useState, useEffect, useRef } from 'react';
import io from 'socket.io-client';

const getSocketUrl = () => {
    const { hostname, port, protocol } = window.location;
    
    if (port === '' || port === '80' || port === '443') {
        return '/';
    }

    // 本地开发回退逻辑
    if (hostname === 'localhost' || hostname === '127.0.0.1') {
        if (port !== '3001') { return `${protocol}//${hostname}:3001`; }
    }
    if (hostname.startsWith('192.168.') || hostname.startsWith('10.')) {
        if (port !== '3001') { return `${protocol}//${hostname}:3001`; }
    }
    
    return '/';
};

const SOCKET_URL = getSocketUrl();

export const useSocketConnection = () => {
    const [socket, setSocket] = useState(null);
    const [isConnected, setIsConnected] = useState(false);
    const [mySocketId, setMySocketId] = useState(null);
    const [ping, setPing] = useState(0);
    
    const socketRef = useRef(null); // 使用 Ref 保持 socket 引用，方便在事件回调中使用

    useEffect(() => {
        console.log(`正在连接服务器: ${SOCKET_URL}`);
        
        const newSocket = io(SOCKET_URL, { 
            reconnectionAttempts: Infinity, // 无限重试，确保网络恢复后能连上
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,
            timeout: 20000,
            autoConnect: true,
            transports: ['websocket', 'polling'] 
        });
        
        setSocket(newSocket);
        socketRef.current = newSocket;

        let pingInterval;

        const onConnect = () => {
            console.log("Socket 连接成功!");
            setIsConnected(true);
            if (newSocket.id) {
                setMySocketId(newSocket.id);
            }
            
            // 连接成功后立即发一个 ping 测活
            newSocket.emit('ping');

            pingInterval = setInterval(() => {
                const start = Date.now();
                if (newSocket.connected) {
                    newSocket.emit('ping', () => {
                        const latency = Date.now() - start;
                        setPing(latency);
                    });
                }
            }, 3000); 
        };

        const onDisconnect = (reason) => {
            console.log(`Socket 断开连接: ${reason}`);
            setIsConnected(false);
            if (pingInterval) clearInterval(pingInterval);
            
            // 如果是服务端断开或传输关闭，尝试自动重连
            if (reason === "io server disconnect" || reason === "transport close") {
                newSocket.connect();
            }
        };

        const onConnectError = (err) => {
            console.warn("连接错误:", err.message);
        };

        const onYourId = (id) => {
            setMySocketId(id);
        };

        newSocket.on('connect', onConnect);
        newSocket.on('disconnect', onDisconnect);
        newSocket.on('connect_error', onConnectError);
        newSocket.on('your_id', onYourId);

        // --- [新增] 核心：切屏/后台恢复检测 ---
        const handleVisibilityChange = () => {
            if (document.visibilityState === 'visible') {
                console.log("[App] 切回前台，检查连接状态...");
                
                // 1. 如果 Socket 断开了，立即重连
                if (!newSocket.connected) {
                    console.log("[App] 发现连接已断开，正在强制重连...");
                    newSocket.connect();
                } else {
                    // 2. 即使 connected 为 true，也可能是假死，发一个包激活一下
                    newSocket.emit('ping', () => {
                        console.log("[App] 连接活性检查通过");
                    });
                }
            }
        };

        document.addEventListener('visibilitychange', handleVisibilityChange);

        return () => {
            if (pingInterval) clearInterval(pingInterval);
            newSocket.off('connect', onConnect);
            newSocket.off('disconnect', onDisconnect);
            newSocket.off('connect_error', onConnectError);
            newSocket.off('your_id', onYourId);
            document.removeEventListener('visibilitychange', handleVisibilityChange);
            newSocket.close();
        };
    }, []);

    return { 
        socket, 
        isConnected, 
        mySocketId,
        ping 
    };
};

================================================================================
FILE PATH: client\src\index.css
================================================================================
/* =========================================
   全局基础样式 (Base & Reset)
   ========================================= */
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  /* 配色方案 */
  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  /* 字体渲染优化 */
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  
  /* [优化] 禁止移动端点击高亮 */
  -webkit-tap-highlight-color: transparent;
}

/* [关键修复 0] 全局盒模型重置 */
*, *::before, *::after {
  box-sizing: border-box;
}

/* 链接样式 */
a { font-weight: 500; color: #646cff; text-decoration: inherit; }
a:hover { color: #535bf2; }

/* Body 基础设置 */
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  /* [关键修复] 彻底禁止浏览器的下拉刷新和回弹效果 */
  overscroll-behavior: none;
  overflow: hidden; /* 锁死 Body 滚动，只允许内部元素滚动 */
  position: fixed; /* 强制固定，防止 iOS Safari 地址栏因为页面滚动而忽隐忽现 */
}

body {
  display: flex;
  place-items: center;
  min-width: 320px;
}

/* [优化] 针对根容器优化触摸体验 */
#root, .App {
  width: 100%;
  height: 100%;
  overflow-x: hidden;
  /* 允许内部正常的点击和滚动 */
  touch-action: manipulation;
}

h1 { font-size: 3.2em; line-height: 1.1; }

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover { border-color: #646cff; }
button:focus, button:focus-visible { outline: 4px auto -webkit-focus-ring-color; }

@media (prefers-color-scheme: light) {
  :root { color: #213547; background-color: #ffffff; }
  a:hover { color: #747bff; }
  button { background-color: #f9f9f9; }
}


/* =========================================
   移动端适配核心区 (Mobile Overrides)
   ========================================= */

/* --- 1. 横屏引导遮罩 --- */
.landscape-hint {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(30, 39, 46, 0.95);
    z-index: 9999; 
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
    text-align: center;
    backdrop-filter: blur(10px);
    touch-action: none; 
}

.phone-rotate-icon {
    width: 60px;
    height: 100px; 
    border: 3px solid white; border-radius: 10px; margin-bottom: 20px;
    animation: rotate-phone 2s infinite ease-in-out;
}
@keyframes rotate-phone {
    0% { transform: rotate(0deg); }
    50% { transform: rotate(90deg); }
    100% { transform: rotate(0deg); }
}


/* --- 2. 移动端竖屏布局优化 (Portrait Core) --- */

@media (max-width: 768px) {
  
  ::-webkit-scrollbar { width: 0px; background: transparent; }

  /* 通用列容器 */
  .mobile-layout-column {
    display: flex !important;
    flex-direction: column !important;
    width: 95% !important;     
    max-width: none !important; 
    height: auto !important;
    
    /* 使用 dvh 适配动态地址栏 */
    min-height: 85vh !important;
    min-height: 85dvh !important; 
    
    max-height: 95dvh !important; 
    margin: 10px auto !important; 
    overflow: hidden !important; 
    padding: 0 !important;
  }

  /* --- 2.1 登录页 (Login) --- */
  .mobile-login-left {
    flex: 0 0 auto !important;
    width: 100% !important;
    padding: 30px 20px !important; 
    border-radius: 0 0 24px 24px !important; 
    background-color: #242424; 
    min-height: auto !important;
    align-items: center !important; 
    text-align: center !important;
    padding-top: max(30px, env(safe-area-inset-top)) !important;
  }
  
  .mobile-login-left h1 { font-size: 2.5em !important; margin-bottom: 10px !important; }
  .mobile-login-left .logoCircle { width: 70px !important; height: 70px !important; margin-bottom: 15px !important; }
  .mobile-login-left .logoText { font-size: 22px !important; }

  .mobile-login-right {
    flex: 1 !important;
    width: 100% !important;
    padding: 30px 20px !important;
    background: white;
    border-radius: 24px 24px 0 0 !important; 
    margin-top: -20px; 
    position: relative;
    z-index: 2;
    overflow-y: auto !important;
    display: flex !important;
    flex-direction: column !important;
    padding-bottom: max(30px, env(safe-area-inset-bottom)) !important;
  }
  
  .hide-on-mobile { display: none !important; }


  /* --- 2.2 大厅页 (Lobby) --- */
  .lobbyCard.mobile-layout-column {
      height: 92dvh !important;
      position: relative;
      background: white !important;
  }

  .mobile-lobby-content {
      display: flex !important;
      flex-direction: column !important;
      height: 100% !important;
      width: 100%;
      overflow: hidden !important;
  }
  
  .lobbyHeader { 
      flex: 0 0 auto;
      padding: 15px !important;
      padding-top: calc(15px + env(safe-area-inset-top)) !important; 
      background: #f8f9fa; 
  }
  .lobbyHeader h2 { font-size: 20px !important; margin: 0 !important; }

  .mobile-lobby-grid {
      flex: 1 !important; 
      overflow-y: auto !important;
      padding: 10px !important;
      display: grid !important;
      grid-template-columns: repeat(2, 1fr) !important; 
      align-content: start !important;
      gap: 10px !important;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 10px !important;
  }
  
  .mobile-lobby-grid > div { padding: 15px !important; gap: 10px !important; }
  .mobile-lobby-grid .avatar-large { width: 50px !important; height: 50px !important; font-size: 20px !important; }

  .mobile-lobby-footer {
      flex: 0 0 auto !important;
      padding: 12px !important;
      background: white;
      border-top: 1px solid #eee;
      z-index: 10;
      padding-bottom: calc(12px + env(safe-area-inset-bottom)) !important;
      position: static !important; 
      margin-top: auto !important;
      display: flex !important;
      justify-content: space-around !important;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
  }
  
  .mobile-lobby-footer button {
      width: 45% !important;
      padding: 0 !important;
      height: 44px !important; 
      font-size: 14px !important;
      margin: 0 !important;
  }
}


/* --- 3. 移动端横屏适配 (Landscape Overrides) --- */
@media (max-width: 896px) and (orientation: landscape) {
    
    /* [终极修复 1] 强制铺满屏幕，无视任何 margin，直接覆盖 */
    /* [关键 Fix] 必须强制重置 min-height 为 0，否则 JS 里的 600px 会撑破屏幕 */
    .mobile-layout-column {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        min-height: 0 !important; /* 核心修复：解决底部看不见的问题 */
        max-height: none !important;
        margin: 0 !important;
        padding: 0 !important;
        flex-direction: row !important;
        z-index: 10;
    }

    /* --- [关键优化] 登录页 (Login) --- */
    
    .mobile-login-left {
        display: none !important;
    }

    .mobile-login-right {
        width: 100% !important;
        height: 100% !important;
        flex: 1 !important;
        border-radius: 0 !important;
        margin: 0 !important;
        
        /* 顶部对齐，防止被切 */
        justify-content: flex-start !important;
        padding-top: max(10px, env(safe-area-inset-top)) !important;
        
        /* [修复] 底部增加大幅度 Padding，确保滚动到底部时，最下面的按钮能完整露出 */
        padding-bottom: max(40px, env(safe-area-inset-bottom)) !important;
        padding-left: max(40px, env(safe-area-inset-left)) !important;
        padding-right: max(40px, env(safe-area-inset-right)) !important; 
        
        overflow-y: auto !important;
        display: flex !important;
        flex-direction: column !important;
    }
    
    .mobile-login-right .formContent {
        max-width: 600px;
        margin: 0 auto;
        width: 100%;
        /* 确保底部按钮能完整露出 */
        padding-bottom: 20px !important;
    }


    /* --- [关键优化] 大厅页 (Lobby) --- */

    /* [关键修复 2] 彻底重构 Lobby 布局 */
    .lobbyCard.mobile-layout-column {
        background: transparent !important;
        border: none !important;
    }
    
    .mobile-lobby-content {
        background: white !important;
        border-radius: 0 !important; 
        height: 100% !important;
        width: 100% !important;
        border: none !important;
        box-shadow: none !important;
        /* 使用 Flex Column 布局 */
        display: flex !important;
        flex-direction: column !important;
    }

    .lobbyHeader {
        flex: 0 0 auto !important; /* 头部固定高度，不许伸缩 */
        padding: 8px 20px !important; 
        padding-top: max(10px, env(safe-area-inset-top)) !important;
        background: #f8f9fa;
        z-index: 20;
        border-bottom: 1px solid #eee;
    }
    /* 缩小横屏下的标题字号 */
    .lobbyHeader h2 { font-size: 18px !important; }

    /* 玩家列表 Grid */
    .mobile-lobby-grid {
        /* [核心修复] 中间区域自适应，允许收缩，允许滚动 */
        flex: 1 1 0% !important; /* 关键！设为 0% 强制让它去适应剩余空间，而不是被内容撑大 */
        min-height: 0 !important; 
        
        overflow-y: auto !important;
        display: grid !important;
        grid-template-columns: repeat(4, 1fr) !important; 
        gap: 10px !important;
        padding: 10px 20px !important;
        padding-left: max(30px, env(safe-area-inset-left)) !important;
        padding-right: max(30px, env(safe-area-inset-right)) !important;
        align-content: start !important;
    }
    
    @media (max-width: 600px) {
        .mobile-lobby-grid {
            grid-template-columns: repeat(3, 1fr) !important;
        }
    }

    .mobile-lobby-grid > div {
        padding: 6px !important;
        gap: 5px !important;
    }
    
    .mobile-lobby-grid .avatar-large {
        width: 36px !important;
        height: 36px !important;
        font-size: 14px !important;
    }

    /* Footer 优化 */
    .mobile-lobby-footer {
        flex: 0 0 auto !important; /* 底部固定高度，不许被挤压 */
        position: relative !important;
        z-index: 100 !important;
        
        background: #f8f9fa !important;
        border-top: 1px solid #ddd !important;
        
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        /* [核心修复] 给底部留出足够的安全距离，防止被手势条遮挡按不到 */
        padding-top: 8px !important;
        padding-bottom: max(15px, env(safe-area-inset-bottom)) !important;
        padding-left: max(20px, env(safe-area-inset-left)) !important;
        padding-right: max(20px, env(safe-area-inset-right)) !important;
        margin-top: 0 !important; /* 清除 marginTop auto */
    }
    
    .mobile-lobby-footer button {
        height: 40px !important; /* 稍微调矮按钮 */
        font-size: 14px !important;
    }
}

================================================================================
FILE PATH: client\src\main.jsx
================================================================================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'
// [新增] 引入 Provider
import { GameProvider } from './context/GameContext.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    {/* [修改] 用 GameProvider 包裹 App */}
    <GameProvider>
      <App />
    </GameProvider>
  </StrictMode>,
)

================================================================================
FILE PATH: client\src\screens\DrawSeatScreen.jsx
================================================================================
import React, { useState, useEffect } from 'react';
import { Card } from '../components/BaseUI.jsx'; 
import { Shuffle } from 'lucide-react';
import { useGame } from '../context/GameContext.jsx';
import css from './DrawSeatScreen.module.css'; // 新 CSS

export const DrawSeatScreen = () => {
    const { 
        players, mySocketId, 
        drawState, // { totalCards, history: [...] }
        handleDrawCard,
        roomConfig
    } = useGame();

    const [flippedCards, setFlippedCards] = useState({}); 
    const [infoText, setInfoText] = useState("请点击一张卡背进行抽签");

    useEffect(() => {
        if (drawState && drawState.history) {
            const newFlipped = {};
            drawState.history.forEach(item => {
                newFlipped[item.index] = { val: item.val, playerName: item.name };
            });
            setFlippedCards(newFlipped);

            const myLog = drawState.history.find(h => h.playerId === mySocketId);
            if (myLog) {
                setInfoText(`等待其他玩家完成抽签...`);
            }
        }
    }, [drawState, mySocketId]);

    const onCardClick = (index) => {
        if (flippedCards[index]) return; 
        
        const myName = players.find(p=>p.id===mySocketId)?.name;
        if (Object.values(flippedCards).some(c => c.playerName === myName)) {
             return; 
        }
        
        handleDrawCard(index);
    };

    const isTeamMode = roomConfig && roomConfig.isTeamMode && (players.length % 2 === 0);

    return (
        <div className={css.drawTable}>
            <div className={css.contentContainer}>
                
                <div className={css.infoBox}>
                    <h2 className={css.title}>
                        <Shuffle size={24} color="#f1c40f"/> 赛前抽卡定座
                    </h2>
                    
                    <div className={css.desc}>
                        {isTeamMode ? (
                            <>
                                点数<span style={{color:'#e74c3c', fontWeight:'bold'}}>大</span>的半数玩家 → <span style={{color:'#e74c3c'}}>红队</span> (1, 3, 5号位)<br/>
                                点数<span style={{color:'#3498db', fontWeight:'bold'}}>小</span>的半数玩家 → <span style={{color:'#3498db'}}>蓝队</span> (2, 4, 6号位)
                            </>
                        ) : (
                            <>
                                抽签决定座位顺序<br/>
                                <span style={{color:'#f1c40f'}}>点数越大，座位越靠前 (1号位起)</span>
                            </>
                        )}
                        <br/>
                        <span style={{fontSize: 12, opacity: 0.8, marginTop: 5, display:'block'}}>(2 &gt; A &gt; K &gt; ... &gt; 3)</span>
                    </div>
                </div>

                <div className={css.cardGrid}>
                    {Array.from({ length: players.length }).map((_, index) => {
                        const flipData = flippedCards[index];
                        const isFlipped = !!flipData;
                        const isMine = isFlipped && flipData.playerName === players.find(p=>p.id===mySocketId)?.name;

                        return (
                            <div key={index} className={css.cardSlot}>
                                {isFlipped && (
                                    <div className={`${css.nameTag} ${isMine ? css.nameTagMine : ''}`}>
                                        {flipData.playerName}
                                    </div>
                                )}

                                {isFlipped ? (
                                    // 翻开后的牌
                                    <div className={`${css.flippedWrapper} ${isMine ? css.flippedWrapperMine : ''}`}>
                                        <Card 
                                            cardVal={flipData.val} 
                                            index={0} 
                                            isSelected={false} 
                                            onClick={()=>{}} 
                                            onMouseEnter={()=>{}} 
                                            spacing={0}
                                        />
                                    </div>
                                ) : (
                                    // 卡背
                                    <div className={css.cardBack} onClick={() => onCardClick(index)}>
                                        <div className={css.cardBackInner}>
                                            <span className={css.cardBackText}>?</span>
                                        </div>
                                    </div>
                                )}
                            </div>
                        );
                    })}
                </div>

                <div className={css.statusText}>
                    {infoText}
                </div>

            </div>
        </div>
    );
};

================================================================================
FILE PATH: client\src\screens\DrawSeatScreen.module.css
================================================================================
/* 抽签页主容器 (复用游戏页背景风格) */
.drawTable {
    height: 100dvh;
    width: 100vw;
    background-color: #1e3c29;
    background-image: radial-gradient(circle at center, #2d7a54 0%, #173b25 100%);
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    user-select: none;
    
    /* 适配安全区域 */
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
}

.contentContainer {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
}

/* 顶部提示框 */
.infoBox {
    background: rgba(0, 0, 0, 0.6);
    padding: 20px 30px;
    border-radius: 20px;
    margin-bottom: 40px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    text-align: center;
    color: white;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    animation: fadeInDown 0.5s ease-out;
}

.title {
    margin: 0 0 10px 0;
    font-size: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
}

.desc {
    font-size: 14px;
    color: #bdc3c7;
    max-width: 400px;
    line-height: 1.6;
}

/* 卡牌网格 */
.cardGrid {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    justify-content: center;
    max-width: 800px;
    padding: 10px;
}

/* 单个卡位容器 */
.cardSlot {
    position: relative;
    width: 80px;
    height: 110px;
    display: flex;
    flex-direction: column;
    align-items: center;
    perspective: 1000px; /* 为翻牌动画做准备 */
}

/* 名字标签 */
.nameTag {
    position: absolute;
    top: -28px;
    width: 120px;
    text-align: center;
    font-size: 12px;
    color: white;
    font-weight: bold;
    text-shadow: 0 1px 2px black;
    white-space: nowrap;
    z-index: 10;
    animation: popIn 0.3s ease-back;
}

.nameTagMine {
    color: #f1c40f;
}

/* 翻开的牌包装器 */
.flippedWrapper {
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    pointer-events: auto;
    border-radius: 6px;
    transform-origin: center center;
}

.flippedWrapperMine {
    transform: scale(1.1);
    box-shadow: 0 0 20px rgba(241, 196, 15, 0.6);
}

/* 卡背 (未翻开) */
.cardBack {
    width: 55px;
    height: 70px;
    background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
    border-radius: 6px;
    border: 2px solid #bdc3c7;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    transition: transform 0.2s;
    pointer-events: auto;
}

.cardBack:active {
    transform: scale(0.95);
}

.cardBackInner {
    width: 40px;
    height: 55px;
    border: 1px dashed rgba(255, 255, 255, 0.3);
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.cardBackText {
    font-size: 20px;
    opacity: 0.5;
    color: white;
}

/* 底部状态文本 */
.statusText {
    margin-top: 40px;
    color: #f1c40f;
    font-size: 18px;
    font-weight: bold;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    height: 30px;
    animation: pulse 2s infinite;
}

@keyframes fadeInDown {
    from { opacity: 0; transform: translateY(-20px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes popIn {
    from { opacity: 0; transform: scale(0.5); }
    to { opacity: 1; transform: scale(1); }
}

@keyframes pulse {
    0% { opacity: 0.8; }
    50% { opacity: 1; }
    100% { opacity: 0.8; }
}

================================================================================
FILE PATH: client\src\screens\GameScreen.jsx
================================================================================
import React from 'react';
import css from './GameScreen.module.css'; 
import { GameLogPanel } from '../components/BaseUI.jsx';
import { useGame } from '../context/GameContext.jsx';
import { RefreshCw, AlertCircle, Eye } from 'lucide-react';

import { GameHeader } from '../components/game/GameHeader.jsx';
import { TableCenterArea } from '../components/game/TableCenterArea.jsx';
import { SettlementModal } from '../components/game/SettlementModal.jsx';
import { PlayerLayout } from '../components/game/PlayerLayout.jsx';
import { HandArea } from '../components/game/HandArea.jsx';
import { GameActionBar } from '../components/game/GameActionBar.jsx';

export const GameScreen = () => {
    // [修改] 解构 isSpectator
    const { players, mySocketId, gameLogs, isSpectator } = useGame();

    const myPlayerExists = players.some(p => p.id === mySocketId);
    
    // [修改] 如果不是观众且没有同步到玩家数据，才显示同步界面
    if (!myPlayerExists && !isSpectator && players.length > 0) {
        return (
            <div className={css.gameTable} style={{
                color:'white', 
                display:'flex', 
                flexDirection: 'column', 
                justifyContent:'center', 
                alignItems:'center',
                gap: 20,
                textAlign: 'center'
            }}>
                <AlertCircle size={40} color="#f1c40f" />
                
                <div>
                    <div style={{fontSize: 20, fontWeight: 'bold', marginBottom: 5}}>正在同步数据...</div>
                    <div style={{fontSize: 14, opacity: 0.7}}>如果是从后台切回，可能需要重新连接</div>
                </div>

                <button 
                    onClick={() => window.location.reload()}
                    style={{
                        background: 'rgba(255,255,255,0.2)',
                        border: '1px solid rgba(255,255,255,0.5)',
                        color: 'white',
                        padding: '10px 25px',
                        borderRadius: 30,
                        display: 'flex',
                        alignItems: 'center',
                        gap: 10,
                        cursor: 'pointer',
                        fontSize: 16,
                        fontWeight: 'bold',
                        marginTop: 10
                    }}
                >
                    <RefreshCw size={18} /> 刷新页面
                </button>
            </div>
        );
    }

    return (
        <div className={css.gameTable}>
            {/* [新增] 观众模式水印 */}
            {isSpectator && (
                <div style={{
                    position: 'absolute', top: 60, right: 20, 
                    background: 'rgba(0,0,0,0.5)', padding: '5px 15px', 
                    borderRadius: 20, color: '#f1c40f', fontWeight: 'bold',
                    display: 'flex', alignItems: 'center', gap: 6, zIndex: 50,
                    pointerEvents: 'none'
                }}>
                    <Eye size={16}/> 观战模式
                </div>
            )}

            <div className={css.gameSafeArea}>
                <GameLogPanel logs={gameLogs} />
                <GameHeader />
                <TableCenterArea />
                <SettlementModal />
                <PlayerLayout />
                <HandArea />
                <GameActionBar />
            </div>
        </div>
    );
};

================================================================================
FILE PATH: client\src\screens\GameScreen.module.css
================================================================================
/* 游戏主容器 */
.gameTable {
    height: 100dvh; /* 适配移动端动态地址栏 */
    width: 100vw;
    background-color: #1e3c29;
    background-image: radial-gradient(circle at center, #2d7a54 0%, #173b25 100%);
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    user-select: none;
    box-sizing: border-box;

    /* 适配刘海屏安全区域 */
    padding-top: env(safe-area-inset-top);
    padding-left: max(15px, env(safe-area-inset-left));
    padding-right: max(15px, env(safe-area-inset-right));
    padding-bottom: env(safe-area-inset-bottom);
}

/* 安全区域包装层 (用于定位 UI 元素) */
.gameSafeArea {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    box-sizing: border-box;

    /* 同样需要适配安全区域 */
    padding-top: env(safe-area-inset-top);
    padding-left: max(15px, env(safe-area-inset-left));
    padding-right: max(15px, env(safe-area-inset-right));
    padding-bottom: env(safe-area-inset-bottom);

    display: flex;
    flex-direction: column;
    pointer-events: none; /* 让点击穿透到底层，子元素需开启 pointer-events: auto */
}

/* --- 全局样式 (Global Overrides) --- */
/* 原本通过 JS 注入的样式，现在移到这里统一管理 */

/* 机器人徽章 */
:global(.statusBadgeBot) {
    background: #34495e;
    color: white;
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 10px;
    display: flex;
    align-items: center;
    gap: 2px;
    border: 1px solid rgba(255, 255, 255, 0.3);
}

/* 托管徽章 (带呼吸动画) */
:global(.statusBadgeAuto) {
    background: #e67e22;
    color: white;
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 10px;
    display: flex;
    align-items: center;
    gap: 2px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

/* 旋转动画 (用于 Timer) */
:global(.spin) {
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* [新增] 倒计时紧急闪烁动画 */
:global(.critical-pulse) {
    animation: criticalPulse 0.5s infinite;
}

@keyframes criticalPulse {
    0% { transform: scale(1); opacity: 1; filter: drop-shadow(0 0 0px #e74c3c); }
    50% { transform: scale(1.1); opacity: 0.9; filter: drop-shadow(0 0 10px #e74c3c); }
    100% { transform: scale(1); opacity: 1; filter: drop-shadow(0 0 0px #e74c3c); }
}

================================================================================
FILE PATH: client\src\screens\LobbyScreen.jsx
================================================================================
import React, { useState } from 'react';
import { Target, Layers, User, Play, Clock, Bot, Shield, ArrowUp, ArrowDown, Settings, X, Sparkles, Award, ChevronLeft } from 'lucide-react';
import css from './LobbyScreen.module.css'; 
import { useGame } from '../context/GameContext.jsx';
import { RoomSettingsForm } from '../components/game/RoomSettingsForm.jsx';

export const LobbyScreen = () => {
    const { 
        roomId, roomConfig, players, mySocketId, 
        handleStartGame, 
        handleAddBot,
        handleSwitchSeat,
        handleUpdateConfig,
        handleKickPlayer,
        handleLeaveRoom 
    } = useGame();
    
    // 统一获取当前玩家是否为房主
    const amIHost = players.find(p => p.id === mySocketId)?.isHost || false;
    
    const isTeamMode = roomConfig.isTeamMode && roomConfig.maxPlayers % 2 === 0;
    const [showSettings, setShowSettings] = useState(false);
    
    const handleConfigChange = (key, value) => {
        const newConfig = { ...roomConfig, [key]: value };
        handleUpdateConfig(newConfig);
    };

    const renderSettingsModal = () => (
        <div className={css.modalOverlay}>
            <div className={css.modalContent} style={{textAlign:'left'}}>
                <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom: 20, borderBottom:'1px solid #eee', paddingBottom:10, width:'100%'}}>
                    <div style={{display:'flex', alignItems:'center', gap:8, fontSize:18, fontWeight:'bold', color:'#2c3e50'}}>
                        <Settings size={20}/> 房间规则设置
                    </div>
                    <button onClick={()=>setShowSettings(false)} style={{background:'none', border:'none', cursor:'pointer', padding:5}}>
                        <X size={20} color="#999"/>
                    </button>
                </div>

                <div style={{maxHeight: '60vh', overflowY:'auto', paddingRight: 5, width:'100%'}}>
                    <RoomSettingsForm 
                        config={roomConfig} 
                        onChange={handleConfigChange} 
                        readOnly={!amIHost} 
                    />
                </div>

                <div style={{marginTop: 20, textAlign:'center', width:'100%'}}>
                    <button className={css.primaryButton} style={{height: 50, fontSize: 16, marginTop:0}} onClick={() => setShowSettings(false)}>
                        完成设置
                    </button>
                </div>
            </div>
        </div>
    );

    return (
    <div className={css.lobbyContainer}>
      {showSettings && renderSettingsModal()}

      <div className={`${css.lobbyCard} mobile-layout-column`}>
          
          <div className="mobile-lobby-content" style={{display:'flex', flexDirection:'column', height:'100%', width: '100%', overflow:'hidden', borderRadius: 20}}>
            
            <div className={css.lobbyHeader}>
                <div style={{display:'flex', alignItems:'center', gap: 10, flexWrap: 'wrap'}}>
                    
                    {/* [修改] 退出按钮：改为向左的返回箭头，更加简洁 */}
                    <button 
                        onClick={handleLeaveRoom}
                        style={{
                            background: 'transparent',
                            border: '1px solid #e1e4e8', 
                            borderRadius: '8px', 
                            padding: '6px 12px 6px 8px', // 左侧稍微少一点padding因为有箭头
                            display: 'flex', alignItems: 'center', justifyContent: 'center',
                            gap: 2,
                            cursor: 'pointer', 
                            color: '#7f8c8d', 
                            fontWeight: 'bold',
                            fontSize: 14,
                            transition: 'all 0.2s'
                        }}
                        title="返回首页"
                    >
                        <ChevronLeft size={20} /> 返回
                    </button>

                    <h2 style={{margin:0, fontSize: 24}}>房间: <span style={{fontFamily:'monospace', color:'#27ae60'}}>{roomId}</span></h2>
                    
                    {roomConfig.shuffleStrategy === 'NO_SHUFFLE' && (
                        <span style={{
                            background: 'linear-gradient(to right, #f6d365 0%, #fda085 100%)', 
                            color:'white', fontSize:12, padding:'2px 8px', borderRadius:10, 
                            display:'flex', alignItems:'center', gap:4, fontWeight: 'bold',
                            boxShadow: '0 2px 5px rgba(253, 160, 133, 0.4)'
                        }}>
                            <Sparkles size={12} fill="white"/> 不洗牌(爽局)
                        </span>
                    )}

                    {roomConfig.shuffleStrategy === 'SIMULATION' && (
                        <span style={{
                            background: 'linear-gradient(to right, #a18cd1 0%, #fbc2eb 100%)', 
                            color:'white', fontSize:12, padding:'2px 8px', borderRadius:10, 
                            display:'flex', alignItems:'center', gap:4, fontWeight: 'bold',
                            boxShadow: '0 2px 5px rgba(161, 140, 209, 0.4)'
                        }}>
                            <Layers size={12} fill="white"/> 模拟叠牌
                        </span>
                    )}

                    {isTeamMode && (
                        <span style={{background:'#27ae60', color:'white', fontSize:12, padding:'2px 8px', borderRadius:10, display:'flex', alignItems:'center', gap:4}}>
                            <Shield size={12}/> 组队模式
                        </span>
                    )}
                </div>
                
                <div style={{display:'flex', gap:10, alignItems:'center'}}>
                    <div style={{display:'flex', gap:10}} className="hide-on-mobile">
                        <span className={css.tag}><Target size={14}/> 目标 {roomConfig.targetScore}</span>
                        <span className={css.tag}><Layers size={14}/> {roomConfig.deckCount}副</span>
                        <span className={css.tag}><User size={14}/> {roomConfig.maxPlayers}人</span>
                    </div>

                    {amIHost && (
                        /* [修改] 设置按钮：纯齿轮图标，无背景，悬停旋转效果 */
                        <button 
                            onClick={() => setShowSettings(true)}
                            style={{
                                background: 'transparent', 
                                border: 'none', 
                                display: 'flex', alignItems: 'center', justifyContent: 'center',
                                cursor: 'pointer', 
                                color: '#34495e', // 深色图标
                                padding: 8,
                                transition: 'transform 0.3s ease'
                            }}
                            title="修改房间规则"
                            onMouseEnter={(e) => e.currentTarget.style.transform = 'rotate(45deg)'}
                            onMouseLeave={(e) => e.currentTarget.style.transform = 'rotate(0deg)'}
                        >
                            <Settings size={24} />
                        </button>
                    )}
                </div>
            </div>
            
            <div style={{padding: '0 15px 10px 15px', display:'flex', gap:8, flexWrap:'wrap', fontSize:12, color:'#666'}} className="mobile-only-tags">
                 <span className={css.tag}><Target size={12}/> {roomConfig.targetScore}</span>
                 <span className={css.tag}><Layers size={12}/> {roomConfig.deckCount}副</span>
                 <span className={css.tag}><User size={12}/> {roomConfig.maxPlayers}人</span>
                 {roomConfig.shuffleStrategy === 'NO_SHUFFLE' && <span className={css.tag} style={{background:'#fdf2e9', color:'#e67e22', border:'1px solid #e67e22'}}><Sparkles size={12}/> 不洗牌</span>}
                 {roomConfig.shuffleStrategy === 'SIMULATION' && <span className={css.tag} style={{background:'#f5eef8', color:'#9b59b6', border:'1px solid #9b59b6'}}><Layers size={12}/> 模拟叠牌</span>}
                 {roomConfig.enableRankPenalty && <span className={css.tag} style={{color:'#e67e22', background:'#fdf2e9'}}><Award size={12}/> 赏罚</span>}
            </div>
            <style>{`@media (min-width: 769px) { .mobile-only-tags { display: none !important; } }`}</style>

            <div className={`${css.playerGrid} mobile-lobby-grid`}>
                {players.map((p, i) => {
                    let teamColor = '#eee'; 
                    let teamBg = 'white';   
                    let teamName = null;
                    
                    if (isTeamMode) {
                        const isRedTeam = i % 2 === 0;
                        teamColor = isRedTeam ? '#e74c3c' : '#3498db';
                        teamBg = isRedTeam ? '#fdedec' : '#eaf2f8';
                        teamName = isRedTeam ? '红队' : '蓝队';
                    }

                    const isMe = p.id === mySocketId;
                    if (isMe && !isTeamMode) {
                        teamBg = '#f0fbf4';
                        teamColor = '#27ae60';
                    }
                    const borderWidth = isMe ? 3 : 2;

                    return (
                        <div key={p.id} className={css.lobbyPlayer} style={{
                            borderColor: isMe ? '#2ecc71' : teamColor, 
                            backgroundColor: teamBg,
                            borderWidth: borderWidth
                        }}>
                            {amIHost && !isMe && (
                                <button 
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        const confirmKick = window.confirm(`确定要踢出 ${p.name} 吗？`);
                                        if (confirmKick) handleKickPlayer(p.id);
                                    }}
                                    className={css.kickButton}
                                    title="踢出玩家"
                                >
                                    <X size={14} color="white"/>
                                </button>
                            )}

                            {teamName && (
                                <div style={{
                                    position: 'absolute', top: 0, left: 0, 
                                    background: teamColor, color: 'white', 
                                    fontSize: 10, padding: '2px 8px', 
                                    borderBottomRightRadius: 8, borderTopLeftRadius: 8
                                }}>
                                    {teamName}
                                </div>
                            )}

                            {amIHost && players.length > 1 && (
                                <div style={{
                                    position: 'absolute', right: 5, top: '50%', transform: 'translateY(-50%)',
                                    display:'flex', flexDirection:'column', gap:4
                                }}>
                                    {i > 0 && (
                                        <button 
                                            onClick={(e) => { e.stopPropagation(); handleSwitchSeat(i, i - 1); }}
                                            style={{
                                                padding:4, borderRadius:4, border:'1px solid #ccc', 
                                                background:'white', cursor:'pointer', lineHeight:0
                                            }}
                                            title="上移"
                                        >
                                            <ArrowUp size={14} color="#666"/>
                                        </button>
                                    )}
                                    {i < players.length - 1 && (
                                        <button 
                                            onClick={(e) => { e.stopPropagation(); handleSwitchSeat(i, i + 1); }}
                                            style={{
                                                padding:4, borderRadius:4, border:'1px solid #ccc', 
                                                background:'white', cursor:'pointer', lineHeight:0
                                            }}
                                            title="下移"
                                        >
                                            <ArrowDown size={14} color="#666"/>
                                        </button>
                                    )}
                                </div>
                            )}

                            <div className={css.avatarLarge}>
                                {p.isBot ? <Bot size={40} /> : p.name[0]}
                            </div>
                            <div style={{fontWeight: 'bold', display:'flex', alignItems:'center', gap:5}}>
                                {p.name}
                                {p.isBot && <span style={{fontSize:10, background:'#eee', padding:'2px 5px', borderRadius:4}}>AI</span>}
                            </div>
                            {p.isHost && <span className={css.hostBadge}>房主</span>}
                        </div>
                    );
                })}
                
                {Array.from({length: Math.max(0, roomConfig.maxPlayers - players.length)}).map((_, i) => (
                    <div key={`empty-${i}`} className={css.lobbyPlayer} style={{borderStyle: 'dashed', opacity: 0.5}}>
                        <div className={css.avatarLarge} style={{background:'#f0f0f0', color:'#ccc'}}>?</div>
                        <div style={{color:'#999'}}>等待加入</div>
                    </div>
                ))}
            </div>

            <div className={`${css.lobbyFooter} mobile-lobby-footer`} style={{flexShrink: 0}}>
                {amIHost ? (
                    <div style={{display:'flex', gap: 15, justifyContent: 'center'}}>
                        <button 
                            className={css.primaryButton}
                            style={{background: '#7f8c8d', width:'auto', padding:'0 20px', fontSize: 16, marginTop:0}} 
                            onClick={handleAddBot}
                            disabled={players.length >= roomConfig.maxPlayers}
                        >
                            <Bot size={18} style={{marginRight:5}}/> +Bot
                        </button>

                        <button className={css.primaryButton} style={{width:'auto', padding:'0 30px', marginTop:0}} onClick={handleStartGame} disabled={players.length < 2}>
                            <Play size={18} style={{marginRight:5}}/> 开始对战
                        </button>
                    </div>
                ) : (
                    <div style={{color:'#999', fontSize: 14, display:'flex', alignItems:'center', gap:5}}><Clock size={16}/> 等待房主开始...</div>
                )}
            </div>
          </div>
      </div>
    </div>
    );
};

================================================================================
FILE PATH: client\src\screens\LobbyScreen.module.css
================================================================================
/* --- [新增] 大厅页专用容器 --- */
.lobbyContainer {
    height: 100dvh;
    width: 100vw;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #1e272e;
    font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    background-image: radial-gradient(circle at top right, #34495e 0%, #000000 100%);
    overflow: hidden;
}

/* --- 容器与卡片 --- */
.lobbyCard {
    background: white;
    padding: 40px;
    border-radius: 20px;
    width: 1000px;
    max-width: 95vw;
    min-height: 600px;
    /* 限制最大高度，防止在大屏或人数过多时撑破屏幕 */
    max-height: 85vh;
    display: flex;
    flex-direction: column;
    box-shadow: 0 30px 60px rgba(0, 0, 0, 0.5);
    /* 确保内容溢出时不会破坏圆角或溢出 Card */
    overflow: hidden;
}

.lobbyHeader {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 30px;
    padding-bottom: 20px;
    border-bottom: 1px solid #eee;
    /* 防止头部被压缩 */
    flex-shrink: 0;
}

.lobbyFooter {
    margin-top: auto;
    border-top: 1px solid #eee;
    padding-top: 20px;
    display: flex;
    justify-content: center;
    /* 防止底部被压缩 */
    flex-shrink: 0;
}

/* --- 通用元素 --- */
.tag {
    background: #f0f9f4;
    color: #27ae60;
    padding: 5px 10px;
    border-radius: 20px;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 5px;
}

.primaryButton {
    margin-top: 25px;
    width: 100%;
    height: 65px;
    background: #2c3e50;
    color: white;
    border: none;
    border-radius: 14px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 19px;
    transition: all 0.2s;
    box-shadow: 0 10px 25px rgba(44, 62, 80, 0.25);
}

.primaryButton:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    background: #95a5a6;
}

/* --- 玩家网格区域 --- */
.playerGrid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 20px;
    flex: 1;
    align-content: start;
    /* 允许网格内部滚动 */
    overflow-y: auto;
    min-height: 0;
}

.lobbyPlayer {
    border: 2px solid #eee;
    border-radius: 12px;
    padding: 25px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
    position: relative;
    transition: all 0.2s;
}

.avatarLarge {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: #34495e;
    color: white;
    font-size: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
}

.hostBadge {
    position: absolute;
    top: 10px;
    right: 10px;
    background: #f1c40f;
    color: #333;
    font-size: 12px;
    padding: 4px 8px;
    border-radius: 4px;
    font-weight: bold;
}

.kickButton {
    position: absolute;
    top: -8px;
    right: -8px;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background: #e74c3c;
    border: 2px solid white;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    padding: 0;
    z-index: 10;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

/* --- 设置弹窗相关 --- */
.modalOverlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.85);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 99;
    backdrop-filter: blur(8px);
    pointer-events: auto;
}

.modalContent {
    background: white;
    padding: 30px;
    border-radius: 24px;
    text-align: center;
    box-shadow: 0 30px 80px rgba(0, 0, 0, 0.6);
    animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    width: 90%;
    max-width: 500px;
    max-height: 85vh;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    align-items: center;
}

/* --- [补全] 配置表单样式 --- */
.configGrid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 25px 35px;
    width: 100%;
}

.configItem {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.configLabel {
    display: flex;
    justify-content: space-between;
    font-size: 14px;
    color: #7f8c8d;
    font-weight: 600;
}

.configValue {
    color: #27ae60;
    font-weight: bold;
}

.rangeInput {
    width: 100%;
    cursor: pointer;
    accent-color: #27ae60;
    height: 6px;
}

.radioGroup {
    display: flex;
    gap: 10px;
}

.radioBtn {
    flex: 1;
    padding: 8px 0;
    border-radius: 8px;
    border: 1px solid #e1e4e8;
    background: white;
    color: #7f8c8d;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.2s;
}

.radioBtnActive {
    flex: 1;
    padding: 8px 0;
    border-radius: 8px;
    border: 1px solid #27ae60;
    background: #eafaf1;
    color: #27ae60;
    font-size: 13px;
    font-weight: bold;
    cursor: pointer;
}

.input {
    padding: 10px;
    border: none;
    background: transparent;
    flex: 1;
    outline: none;
    font-size: 17px;
    color: #2c3e50;
    font-weight: 500;
    border: 1px solid #ddd;
    border-radius: 4px;
}

@keyframes popIn {
    0% { transform: scale(0.8); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
}

================================================================================
FILE PATH: client\src\screens\LoginScreen.jsx
================================================================================
import React, { useState, useEffect } from 'react'; 
import { User, Monitor, RefreshCw, Plus, LogIn, Maximize, Minimize, Wifi, WifiOff, History } from 'lucide-react'; 
import { useGame } from '../context/GameContext.jsx';
import { RoomSettingsForm } from '../components/game/RoomSettingsForm.jsx';

import css from './LoginScreen.module.css';

export const LoginScreen = () => {
    
    const { 
        username, setUsername, 
        roomId, setRoomId, 
        roomConfig, setRoomConfig, 
        isCreatorMode, setIsCreatorMode, 
        handleRoomAction, 
        handleQuickReconnect, // [新增]
        isLoading,
        isConnected,
        ping 
    } = useGame();

    const [isFullScreen, setIsFullScreen] = useState(false);
    
    // [新增] 检测是否有断线记录
    const [lastSession, setLastSession] = useState(null);

    useEffect(() => {
        const rid = localStorage.getItem('poker_roomid');
        const uid = localStorage.getItem('poker_username');
        // 只有当两个都有值，才显示重连按钮
        if (rid && uid) {
            setLastSession({ roomId: rid, username: uid });
        }
    }, []);

    const toggleFullScreen = () => {
        if (!document.fullscreenElement) {
            const docEl = document.documentElement;
            const requestFull = docEl.requestFullscreen || docEl.webkitRequestFullscreen;
            if (requestFull) {
                requestFull.call(docEl)
                    .then(() => setIsFullScreen(true))
                    .catch(err => console.log("全屏请求被拦截:", err));
            }
        } else {
            const exitFull = document.exitFullscreen || document.webkitExitFullscreen;
            if (exitFull) {
                exitFull.call(document)
                    .then(() => setIsFullScreen(false));
            }
        }
    };

    const tryEnterFullScreen = () => {
        try {
            if (!document.fullscreenElement) {
                const docEl = document.documentElement;
                const requestFull = docEl.requestFullscreen || docEl.webkitRequestFullscreen;
                if (requestFull) {
                    requestFull.call(docEl).catch(() => {});
                }
            }
        } catch (e) {
            // Ignore
        }
    };

    const onActionClick = () => {
        tryEnterFullScreen(); 
        handleRoomAction();   
    };
    
    // [新增] 点击重连按钮
    const onReconnectClick = () => {
        tryEnterFullScreen();
        handleQuickReconnect();
    };

    const handleConfigChange = (key, value) => {
        setRoomConfig(prev => ({ ...prev, [key]: value }));
    };

    const getPingColor = (p) => {
        if (!isConnected) return '#e74c3c';
        if (p < 100) return '#27ae60';
        if (p < 200) return '#f1c40f';
        return '#e74c3c';
    };

    const pingStyle = {
        background: isConnected ? (ping < 150 ? '#eafaf1' : '#fef9e7') : '#fdedec',
        color: getPingColor(ping),
        borderColor: isConnected ? '#e1e4e8' : '#fadbd8'
    };

    return (
        <div className={css.container}>
            <div className={`${css.loginCard} mobile-layout-column`}>
                
                {/* 左侧品牌区 */}
                <div className={`${css.loginLeft} mobile-login-left`}>
                    <div className={css.logoCircle}>
                        <div className={css.logoText}>510K</div>
                    </div>
                    <h1 className={css.brandTitle}>扑克对战</h1>
                    <div className={css.brandSubtitle}>多人在线 · 自由规则 · 极速畅玩</div>
                    
                    <div className={`${css.featureList} hide-on-mobile`}>
                        <div className={css.featureItem}>✨ 支持 2-12 人同台竞技</div>
                        <div className={css.featureItem}>🚀 只有 1 副牌? 不，现在支持 8 副!</div>
                        <div className={css.featureItem}>⏱️ 自定义思考时间与获胜目标</div>
                    </div>
                </div>

                {/* 右侧表单区 */}
                <div className={`${css.loginRight} mobile-login-right`}>
                    
                    {/* 顶部工具栏 */}
                    <div className={css.topBar}>
                        <button onClick={toggleFullScreen} className={css.fullScreenBtn}>
                            {isFullScreen ? <Minimize size={14}/> : <Maximize size={14}/>}
                            <span>{isFullScreen ? '退出全屏' : '全屏模式'}</span>
                        </button>

                        <div className={css.pingBadge} style={pingStyle}>
                            {isConnected ? <Wifi size={14}/> : <WifiOff size={14}/>}
                            {isConnected ? `${ping}ms` : '连接中...'}
                        </div>
                    </div>

                    {/* Tab 切换 */}
                    <div className={css.tabs}>
                        <button 
                            className={!isCreatorMode ? css.tabBtnActive : css.tabBtn} 
                            onClick={()=>setIsCreatorMode(false)}
                        >
                            加入房间
                        </button>
                        <button 
                            className={isCreatorMode ? css.tabBtnActive : css.tabBtn} 
                            onClick={()=>setIsCreatorMode(true)}
                        >
                            创建房间
                        </button>
                    </div>

                    {/* 表单内容 */}
                    <div className={css.formContent}>
                        <div className={css.inputGroup}>
                            <User size={18} color="#7f8c8d" />
                            <input 
                                className={css.input} 
                                value={username} 
                                onChange={e=>setUsername(e.target.value)} 
                                placeholder="请输入你的昵称" 
                                maxLength={10}
                            />
                        </div>
                        <div className={css.inputGroup}>
                            <Monitor size={18} color="#7f8c8d" />
                            <input 
                                className={css.input} 
                                value={roomId} 
                                onChange={e=>setRoomId(e.target.value)} 
                                placeholder="请输入房间号 (如: 888)" 
                                maxLength={6}
                            />
                        </div>

                        {isCreatorMode && (
                            <div className={css.advancedConfigPanel}>
                                <RoomSettingsForm 
                                    config={roomConfig} 
                                    onChange={handleConfigChange} 
                                />
                            </div>
                        )}

                        <div style={{flex: 1}}></div>

                        {/* [新增] 重连按钮：只在有记录时显示 */}
                        {lastSession && !isCreatorMode && (
                             <button 
                                className={css.reconnectBtn}
                                onClick={onReconnectClick}
                                disabled={isLoading || !isConnected}
                             >
                                <History size={18} />
                                <div style={{display:'flex', flexDirection:'column', alignItems:'flex-start', lineHeight:1.2}}>
                                    <span style={{fontSize: 14, fontWeight:'bold'}}>一键重连回房间</span>
                                    <span style={{fontSize: 11, opacity: 0.8}}>Room: {lastSession.roomId} ({lastSession.username})</span>
                                </div>
                             </button>
                        )}

                        <button 
                            className={css.primaryButton}
                            onClick={onActionClick} 
                            disabled={isLoading || !isConnected}
                            style={{
                                background: (!isConnected) ? '#95a5a6' : '#2c3e50'
                            }}
                        >
                            {(isLoading || !isConnected) ? <RefreshCw className="spin" size={20}/> : (isCreatorMode ? <Plus size={20}/> : <LogIn size={20}/>)}
                            <span style={{marginLeft:10}}>
                                {!isConnected ? "正在连接服务器..." : (isLoading ? "处理中..." : (isCreatorMode ? "立即创建房间" : "进入游戏房间"))}
                            </span>
                        </button>
                        
                        {!isConnected && (
                            <div className={css.firstLoadTip}>
                                ⚠️ 首次访问可能需要 30-50秒 唤醒服务器，请耐心等待右上角变为绿色。
                            </div>
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
};

================================================================================
FILE PATH: client\src\screens\LoginScreen.module.css
================================================================================
/* =========================================
   登录页专属样式 (LoginScreen)
   替代原 styles.js 中的 loginCard 相关样式
   ========================================= */

/* 页面主容器 (继承原 styles.container) */
.container {
    height: 100dvh; /* 适配移动端动态地址栏 */
    width: 100vw;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #1e272e;
    font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    background-image: radial-gradient(circle at top right, #34495e 0%, #000000 100%);
    overflow: hidden;
}

/* 卡片主体 */
.loginCard {
    background: white;
    border-radius: 24px;
    width: 95%;
    max-width: 1100px;
    min-height: 600px;
    max-height: 90vh;
    display: flex;
    box-shadow: 0 50px 100px -20px rgba(0, 0, 0, 0.7);
    overflow: hidden;
    animation: popIn 0.5s ease-out;
}

/* --- 左侧品牌区 --- */
.loginLeft {
    flex: 0.8;
    background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
    padding: 60px 50px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: flex-start;
    color: white;
    position: relative;
    overflow: hidden;
}

.logoCircle {
    width: 90px;
    height: 90px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 25px;
    backdrop-filter: blur(10px);
}

.logoText {
    font-size: 28px;
    font-weight: 900;
    color: white;
}

.brandTitle {
    font-size: 48px;
    font-weight: 800;
    margin: 0 0 15px 0;
    letter-spacing: -1.5px;
}

.brandSubtitle {
    font-size: 18px;
    opacity: 0.9;
    margin-bottom: 50px;
    font-weight: 500;
}

.featureList {
    margin-top: auto;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.featureItem {
    font-size: 15px;
    opacity: 0.95;
    display: flex;
    align-items: center;
    font-weight: 500;
}

/* --- 右侧表单区 --- */
.loginRight {
    flex: 1.2;
    padding: 50px 60px;
    display: flex;
    flex-direction: column;
    background: #ffffff;
    overflow-y: auto;
}

/* 顶部工具栏 */
.topBar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.fullScreenBtn {
    background: #f8f9fa;
    border: 1px solid #e1e4e8;
    border-radius: 20px;
    padding: 6px 12px;
    cursor: pointer;
    color: #7f8c8d;
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    font-weight: bold;
    transition: all 0.2s;
}

.pingBadge {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    padding: 6px 12px;
    border-radius: 20px;
    font-weight: bold;
    border: 1px solid transparent;
}

/* Tab 切换 */
.tabs {
    display: flex;
    gap: 35px;
    margin-bottom: 35px;
    border-bottom: 2px solid #f1f2f6;
}

.tabBtn {
    padding: 12px 0;
    font-size: 18px;
    font-weight: bold;
    color: #95a5a6;
    background: none;
    border: none;
    cursor: pointer;
    transition: all 0.3s;
    border-bottom: 3px solid transparent;
    margin-bottom: -3px;
}

.tabBtnActive {
    composes: tabBtn;
    color: #2c3e50;
    border-bottom: 3px solid #27ae60;
}

/* 表单内容 */
.formContent {
    flex: 1;
    display: flex;
    flex-direction: column;
}

.inputGroup {
    display: flex;
    align-items: center;
    background: #f8f9fa;
    border-radius: 14px;
    padding: 0 20px;
    margin-bottom: 20px;
    border: 1px solid #e1e4e8;
    height: 60px;
    transition: all 0.2s;
}

.input {
    padding: 10px;
    border: none;
    background: transparent;
    flex: 1;
    outline: none;
    font-size: 17px;
    color: #2c3e50;
    font-weight: 500;
}

/* 高级设置面板容器 */
.advancedConfigPanel {
    margin-top: 15px;
    background: #fff;
    border-radius: 12px;
    animation: fadeIn 0.4s ease;
}

/* 主按钮 */
.primaryButton {
    margin-top: 25px;
    width: 100%;
    height: 65px;
    background: #2c3e50;
    color: white;
    border: none;
    border-radius: 14px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 19px;
    transition: all 0.2s;
    box-shadow: 0 10px 25px rgba(44, 62, 80, 0.25);
}

.primaryButton:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    background: #95a5a6 !important; /* 强制覆盖 */
}

/* [新增] 重连按钮样式 */
.reconnectBtn {
    width: 100%;
    height: 60px;
    background: #eafaf1; /* 浅绿色背景 */
    color: #27ae60;      /* 深绿色文字 */
    border: 1px solid #27ae60;
    border-radius: 14px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 15px;
    font-size: 16px;
    transition: all 0.2s;
    margin-bottom: 0px; /* 紧贴主按钮上方 */
}

.reconnectBtn:hover {
    background: #d5f5e3;
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(39, 174, 96, 0.2);
}

.reconnectBtn:active {
    transform: translateY(0);
}

.reconnectBtn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

/* 首次加载提示 */
.firstLoadTip {
    text-align: center;
    margin-top: 15px;
    font-size: 13px;
    color: #e74c3c;
    background: #fdedec;
    padding: 8px;
    border-radius: 8px;
}

/* 动画定义 */
@keyframes popIn {
    0% { transform: scale(0.95); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

/* Loading 旋转动画 (全局) */
:global(.spin) {
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

================================================================================
FILE PATH: client\src\utils\cardLogic.js
================================================================================
// 纯逻辑工具

// 排序权重：2(15) > A(14) > K(13)...
export const getSortValue = (cardVal) => {
    const normalized = cardVal % 54;
    if (normalized === 52) return 16;
    if (normalized === 53) return 17;
    const base = normalized % 13;
    if (base === 0) return 14; 
    if (base === 1) return 15; 
    return base + 1;
};

// 花色排序权重
// [保留] 虽然不提供花色排序模式，但理牌(arrangeHand)时的同分排序仍需依赖此函数
export const getSuitSortValue = (cardVal) => {
    if (cardVal >= 52) return cardVal * 100;
    const suit = Math.floor(cardVal / 13) % 4; 
    const val = cardVal % 13;
    return suit * 100 + val; 
};

// 判断是否为分牌 (5, 10, K)
const isScoreCard = (cardVal) => {
    const normalized = cardVal % 54;
    if (normalized >= 52) return false; // 王不是分牌
    const val = normalized % 13;
    // 0=A, 1=2, 2=3, 3=4(5), ..., 9(10), ..., 12(K)
    return val === 4 || val === 9 || val === 12;
};

// 获取分牌的内部排序权重 (K > 10 > 5)
const getScoreCardRank = (cardVal) => {
    const val = (cardVal % 54) % 13;
    if (val === 12) return 3; // K
    if (val === 9) return 2;  // 10
    if (val === 4) return 1;  // 5
    return 0;
};

// 获取单张牌的显示信息
export const getCardDisplay = (cardVal) => {
    const normalizedValue = cardVal % 54; 
    if (normalizedValue === 52) return { suit: 'Joker', text: '小王', color: '#000', isScore: false };
    if (normalizedValue === 53) return { suit: 'Joker', text: '大王', color: '#d00', isScore: false };
    
    const suits = ['♠', '♥', '♣', '♦'];
    const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
    const valueIndex = normalizedValue % 13;
    const suit = suits[Math.floor(normalizedValue / 13)];
    const color = (suit === '♥' || suit === '♦') ? '#d00' : '#000';
    const text = values[valueIndex];
    const isScore = (text === '5' || text === '10' || text === 'K');
    
    return { suit, text, color, isScore };
};

// 智能理牌逻辑
export const arrangeHand = (cards, extractScore = true) => {
    let scoreCards = []; // 右侧：分牌
    let otherCards = []; // 待分类的牌

    if (extractScore) {
        // 1. 先把所有分牌(5, 10, K)提取出来
        cards.forEach(c => {
            if (isScoreCard(c)) scoreCards.push(c);
            else otherCards.push(c);
        });

        // 2. 对分牌进行排序：K > 10 > 5 (KKKK 1010 5555)
        scoreCards.sort((a, b) => {
            const rA = getScoreCardRank(a);
            const rB = getScoreCardRank(b);
            if (rA !== rB) return rB - rA; // 降序 (K=3, 10=2, 5=1)
            return getSuitSortValue(b) - getSuitSortValue(a); // 同分按花色排
        });
    } else {
        otherCards = [...cards];
    }

    // 3. 对剩余牌进行分组
    const groups = new Map();
    otherCards.forEach(c => {
        const val = getSortValue(c);
        if (!groups.has(val)) groups.set(val, []);
        groups.get(val).push(c);
    });

    const bombs = [];   // 左侧：炸弹
    const triples = []; // 中间：三张
    const pairs = [];   // 中间：对子
    const singles = []; // 中间：单张

    groups.forEach((groupCards, val) => {
        const count = groupCards.length;
        // 规则：数量 >= 4 视为炸弹
        if (count >= 4) {
            bombs.push({ val, cards: groupCards, count });
        } else if (count === 3) {
            triples.push({ val, cards: groupCards });
        } else if (count === 2) {
            pairs.push({ val, cards: groupCards });
        } else {
            singles.push({ val, cards: groupCards });
        }
    });

    // 4. 排序炸弹：张数优先 (10张 > 8张 > 6张...)，其次点数
    bombs.sort((a, b) => {
        if (a.count !== b.count) return b.count - a.count; // 张数降序
        return b.val - a.val; // 点数降序
    });

    // 5. 排序中间废牌：各自按点数降序
    const sortByVal = (a, b) => b.val - a.val;
    triples.sort(sortByVal);
    pairs.sort(sortByVal);
    singles.sort(sortByVal);

    // 6. 展平数组
    const flatBombs = bombs.flatMap(b => b.cards);
    const flatTriples = triples.flatMap(t => t.cards);
    const flatPairs = pairs.flatMap(p => p.cards);
    const flatSingles = singles.flatMap(s => s.cards);

    // 7. 拼接：左炸弹 + 中(三+对+单) + 右分牌
    return [...flatBombs, ...flatTriples, ...flatPairs, ...flatSingles, ...scoreCards];
};

// 手牌排序入口
export const sortHand = (cards, mode = 'POINT') => {
    // [修改] 移除了 mode === 'SUIT' 的分支逻辑
    if (mode === 'ARRANGE') {
        return arrangeHand(cards, true);
    }
    if (mode === 'ARRANGE_MERGED') {
        return arrangeHand(cards, false);
    }
    // 默认 POINT
    return [...cards].sort((a, b) => getSortValue(b) - getSortValue(a));
};

// 计算手牌间距
export const calculateCardSpacing = (count, screenWidth) => {
    if (count <= 1) return 0;
    
    // 适配手机逻辑：留出左右安全距离
    const isMobile = screenWidth < 768;
    const padding = isMobile ? 20 : 100; // 减少两侧留白
    
    const w = Math.min(screenWidth - padding, 1200); 
    
    // 卡牌实际宽度
    const cardWidth = 55; // 与 styles.js 中的 card width 一致
    
    // 最大间距：牌少的时候不要分太开
    const maxGap = isMobile ? 35 : 45; 
    
    const neededWidth = (count - 1) * maxGap + cardWidth;
    
    // 如果需要的宽度小于屏幕宽，就用最大间距
    if (neededWidth <= w) return maxGap;
    
    // 否则，挤压牌的间距
    return (w - cardWidth) / (count - 1);
};

// 辅助函数：根据触摸X坐标计算是第几张牌
export const getCardIndexFromTouch = (touchX, containerLeft, spacing, count) => {
    const relativeX = touchX - containerLeft;
    let index = Math.floor(relativeX / spacing);
    
    if (index < 0) index = 0;
    if (index >= count) index = count - 1; 
    
    return index;
};

// [新增] 简易炸弹检测 (用于前端交互提示)
export const isBomb = (cards) => {
    if (!cards || cards.length < 2) return false;
    
    const points = cards.map(getSortValue).sort((a, b) => a - b);
    const len = points.length;
    const uniquePoints = [...new Set(points)];

    // 1. 普通炸弹: 点数全一样，且 >= 4张
    if (uniquePoints.length === 1 && len >= 4) return true;

    // 2. 510K: 长度3，且点数是 5, 10, 13(K)
    if (len === 3) {
        if (points[0] === 5 && points[1] === 10 && points[2] === 13) return true;
    }

    // 3. 王炸: 全是王 (>= 2张)
    if (points.every(p => p >= 16)) return true;

    return false;
};

================================================================================
FILE PATH: client\src\utils\gameRules.js
================================================================================
/**
 * 核心游戏规则 (复刻服务端逻辑)
 * 用于前端本地进行牌型分析、合法性校验和大小比较
 */

const GameRules = {
    // 基础点数映射: 3=3 ... K=13, A=14, 2=15, 小王=16, 大王=17
    getPoint: (cardVal) => {
        const normalized = cardVal % 54;
        if (normalized === 52) return 16;
        if (normalized === 53) return 17;
        const base = normalized % 13;
        if (base === 0) return 14; // A
        if (base === 1) return 15; // 2
        return base + 1; // 3 => 3
    },

    getSuit: (cardVal) => {
        const normalized = cardVal % 54;
        if (normalized >= 52) return -1; 
        return Math.floor(normalized / 13);
    },

    // 核心：牌型分析
    analyze: (cards, deckCount = 2) => {
        const len = cards.length;
        if (len === 0) return { type: 'EMPTY' };

        // 排序：点数从小到大
        const points = cards.map(GameRules.getPoint).sort((a, b) => a - b);
        
        // 统计点数频率
        const counts = {};
        points.forEach(p => { counts[p] = (counts[p] || 0) + 1; });
        const uniquePoints = Object.keys(counts).map(Number).sort((a,b)=>a-b);
        
        // --- 非炸弹牌型 ---

        if (len === 1) return { type: 'SINGLE', val: points[0], level: 0 };

        if (len === 2 && points[0] === points[1]) {
            return { type: 'PAIR', val: points[0], level: 0 };
        }

        if (len === 3 && uniquePoints.length === 1) {
            return { type: 'TRIPLE', val: points[0], level: 0 };
        }

        // 连对
        if (len >= 4 && len % 2 === 0) {
            // 连对不能包含2和王
            if (!points.some(p => p >= 15)) {
                let isLiandui = true;
                if (uniquePoints.length === len / 2) {
                     for (let p of uniquePoints) {
                         if (counts[p] !== 2) isLiandui = false;
                     }
                     // 检查连续性
                     for(let i=0; i<uniquePoints.length-1; i++) {
                         if(uniquePoints[i+1] !== uniquePoints[i]+1) isLiandui = false;
                     }
                     if (isLiandui) return { type: 'LIANDUI', val: points[0], len: len, level: 0 };
                }
            }
        }

        // 飞机 (三顺)
        if (len >= 6 && len % 3 === 0) {
            if (!points.some(p => p >= 15)) {
                let isAirplane = true;
                if (uniquePoints.length === len / 3) {
                    for (let p of uniquePoints) {
                        if (counts[p] !== 3) isAirplane = false;
                    }
                    for(let i=0; i<uniquePoints.length-1; i++) {
                        if(uniquePoints[i+1] !== uniquePoints[i]+1) isAirplane = false;
                    }
                    if (isAirplane) return { type: 'AIRPLANE', val: points[0], len: len, level: 0 };
                }
            }
        }

        // --- 炸弹牌型 (Level 1-5) ---

        // 510K 检测
        if (len === 3) {
            const has5 = points.includes(5);
            const has10 = points.includes(10);
            const hasK = points.includes(13);
            if (has5 && has10 && hasK) {
                // 检查花色
                const suits = cards.map(GameRules.getSuit);
                const isPure = (suits[0] === suits[1] && suits[1] === suits[2]);
                
                if (isPure) {
                    // 纯510K (Level 2)
                    const suit = suits[0];
                    let suitVal = 0;
                    if (suit === 0) suitVal = 4; // 黑
                    else if (suit === 1) suitVal = 3; // 红
                    else if (suit === 2) suitVal = 2; // 梅
                    else if (suit === 3) suitVal = 1; // 方
                    return { type: '510K_PURE', val: suitVal, level: 2 }; 
                } else {
                    // 杂色 510K (Level 1)
                    return { type: '510K_MIXED', val: 1, level: 1 };
                }
            }
        }

        // Level 3: 普通炸弹
        if (uniquePoints.length === 1 && len >= 4) {
            if (len === deckCount * 4) {
                 return { type: 'BOMB_MAX', val: points[0], len: len, level: 5 };
            }
            return { type: 'BOMB_STD', val: points[0], len: len, level: 3 };
        }

        // Level 4: 天王炸 (全王)
        const isAllJokers = points.every(p => p >= 16);
        if (isAllJokers && len === deckCount * 2) {
            return { type: 'BOMB_KING', val: 999, level: 4 };
        }

        return { type: 'INVALID' };
    },

    // 校验能否管牌
    canPlay: (newCards, lastCards, deckCount) => {
        const newHand = GameRules.analyze(newCards, deckCount);
        if (newHand.type === 'INVALID') return false;

        // 自由出牌
        if (!lastCards || lastCards.length === 0) return true;

        const lastHand = GameRules.analyze(lastCards, deckCount);

        // A. 炸弹 vs 非炸弹
        if (newHand.level > 0 && lastHand.level === 0) return true;
        if (newHand.level === 0 && lastHand.level > 0) return false;

        // B. 炸弹之间 (Level 比较)
        if (newHand.level > 0 && lastHand.level > 0) {
            if (newHand.level > lastHand.level) return true;
            if (newHand.level < lastHand.level) return false;

            // 同级别比较
            if (newHand.type === '510K_PURE') {
                return newHand.val > lastHand.val;
            }

            if (newHand.type === 'BOMB_STD') {
                // 先比张数，再比点数
                if (newHand.len > lastHand.len) return true;
                if (newHand.len < lastHand.len) return false;
                return newHand.val > lastHand.val;
            }
            
            // 杂色510K 不能互管
            if (newHand.type === '510K_MIXED') return false;

            if (newHand.type === 'BOMB_MAX') return newHand.val > lastHand.val;
            
            return false;
        }

        // C. 非炸弹之间 (同牌型比较)
        if (newHand.type === lastHand.type) {
            // 连对和飞机必须张数相同
            if ((newHand.type === 'LIANDUI' || newHand.type === 'AIRPLANE') && newHand.len !== lastHand.len) return false;
            
            // 其他牌型也一般要求张数相同
            if (newCards.length !== lastCards.length) return false;
            
            // 连对比较起始点数
            if (newHand.type === 'LIANDUI') {
                return newHand.val > lastHand.val; 
            }
            
            return newHand.val > lastHand.val;
        }

        return false;
    }
};

export default GameRules;

================================================================================
FILE PATH: client\src\utils\smartHint.js
================================================================================
/**
 * 智能提示逻辑 (优化版)
 * 根据手牌和上家牌型，计算所有可行解，并按优劣排序
 * [性能优化] 引入 analyze 结果缓存，大幅减少重复计算
 */
import GameRules from './gameRules.js';

const SmartHint = {
    
    /**
     * 获取经过智能排序的提示列表
     * @param {Array} hand 手牌数组
     * @param {Array} lastPlayedCards 上家出的牌 (空数组代表首出)
     * @param {Number} deckCount 牌副数
     * @returns {Array[]} 候选牌型数组
     */
    getSortedHints: (hand, lastPlayedCards, deckCount = 2) => {
        // 1. 获取所有合法解
        const solutions = SmartHint.findAllSolutions(hand, lastPlayedCards, deckCount);
        if (!solutions || solutions.length === 0) return [];

        // [优化] 预计算 analyze 结果，避免后续多次调用 GameRules.analyze (昂贵操作)
        let candidates = solutions.map(sol => ({
            cards: sol,
            analysis: GameRules.analyze(sol, deckCount),
            cost: 0
        }));

        // 2. 过滤
        candidates = candidates.filter(item => {
            const { type } = item.analysis;
            // 过滤掉 510K
            if (type === '510K_PURE' || type === '510K_MIXED') return false;
            return true;
        });

        if (candidates.length === 0) return [];

        // 3. 预分析手牌中的炸弹
        const myBombs = SmartHint.findAllBombsInHand(hand, deckCount);
        const bombCardsSet = new Set();
        myBombs.forEach(b => b.cards.forEach(c => bombCardsSet.add(c)));

        // 4. 分析上家牌型
        const lastAnalysis = (lastPlayedCards && lastPlayedCards.length > 0)
            ? GameRules.analyze(lastPlayedCards, deckCount)
            : null;
        const lastIsBomb = lastAnalysis ? lastAnalysis.level > 0 : false;

        // 5. 统计手牌点数
        const handCounts = {};
        hand.forEach(c => {
            const p = GameRules.getPoint(c);
            handCounts[p] = (handCounts[p] || 0) + 1;
        });

        // 6. 评分 (基于缓存的 analysis)
        candidates.forEach(item => {
            const { analysis, cards } = item;
            let cost = 0;
            
            // --- A. 基础分 ---
            if (analysis.level > 0) {
                cost += analysis.level * 100000;
                if (analysis.type === 'BOMB_STD' || analysis.type === 'BOMB_MAX') {
                    cost += analysis.len * 1000;
                }
                cost += analysis.val;
            } else {
                cost += analysis.val;
            }

            // --- B. 拆炸弹惩罚 ---
            const isMoveBomb = analysis.level > 0;
            if (!isMoveBomb) {
                const breaksBomb = cards.some(c => bombCardsSet.has(c));
                if (breaksBomb) cost += 2000000;
            }

            // --- C. 炸弹压制判断 ---
            if (isMoveBomb && !lastIsBomb && lastAnalysis) {
                cost += 500; 
            }

            // --- D. 自由出牌 (首出) ---
            if (!lastAnalysis) {
                if (analysis.type === 'AIRPLANE') cost -= 200;
                else if (analysis.type === 'LIANDUI') cost -= 150;
                else if (analysis.type === 'TRIPLE') cost -= 100;
                else if (analysis.type === 'PAIR') cost -= 50;
                
                else if (analysis.type === 'SINGLE') {
                    const countInHand = handCounts[analysis.val] || 0;
                    if (countInHand === 1) {
                        // 真正的废牌优先出
                        cost -= 80; 
                    }
                }
                
                if (isMoveBomb) {
                    if (hand.length === cards.length) cost = -9999999;
                    else cost += 8000;
                }
            }

            item.cost = cost;
        });

        // 7. 排序
        candidates.sort((a, b) => a.cost - b.cost);

        return candidates.map(i => i.cards);
    },

    // 辅助：快速找出所有炸弹
    findAllBombsInHand: (hand, deckCount) => {
        const grouped = {};
        const points = [];
        hand.forEach(c => {
            const p = GameRules.getPoint(c);
            if (!grouped[p]) {
                grouped[p] = [];
                points.push(p);
            }
            grouped[p].push(c);
        });
        const uniquePoints = [...new Set(points)].sort((a, b) => a - b);
        
        // 直接调用核心逻辑，不再重复分组
        return SmartHint.coreFindBombs(hand, grouped, uniquePoints, deckCount, 0, 0);
    },

    /**
     * [核心逻辑] 仅查找炸弹
     * 提取出来复用
     */
    coreFindBombs: (hand, grouped, uniquePoints, deckCount, minLevel = 0, minVal = 0) => {
        const bombList = [];

        // A. 510K (Level 1 & 2)
        if (minLevel <= 2) {
            const fives = grouped[5] || [];
            const tens = grouped[10] || [];
            const kings = grouped[13] || []; // K
            
            if (fives.length > 0 && tens.length > 0 && kings.length > 0) {
                let foundPure = false;
                for (let f of fives) {
                    for (let t of tens) {
                        for (let k of kings) {
                            const s1 = GameRules.getSuit(f);
                            const s2 = GameRules.getSuit(t);
                            const s3 = GameRules.getSuit(k);
                            if (s1 === s2 && s2 === s3) {
                                if (2 > minLevel || (2 === minLevel && 100 > minVal)) { 
                                    bombList.push({ cards: [f, t, k], level: 2, val: 999, type: '510K_PURE' }); 
                                    foundPure = true;
                                }
                            }
                        }
                        if(foundPure) break;
                    }
                    if(foundPure) break;
                }
                
                if (!foundPure && minLevel <= 1) {
                    bombList.push({ cards: [fives[0], tens[0], kings[0]], level: 1, val: 1, type: '510K_MIXED' });
                }
            }
        }

        // B. 普通炸弹 (Level 3 & 5)
        for (let p of uniquePoints) {
            const count = grouped[p].length;
            if (count >= 4) {
                if (minLevel < 3 || (minLevel === 3 && p > minVal)) {
                    const isMax = (count === deckCount * 4);
                    const level = isMax ? 5 : 3;
                    const type = isMax ? 'BOMB_MAX' : 'BOMB_STD';

                    if (level > minLevel || (level === minLevel && p > minVal)) {
                        bombList.push({ cards: grouped[p], level, val: p, type, len: count });
                    }
                }
            }
        }

        // C. 天王炸 (Level 4)
        const jokers = hand.filter(c => GameRules.getPoint(c) >= 16);
        if (jokers.length === deckCount * 2) {
            if (minLevel < 4) {
                bombList.push({ cards: jokers, level: 4, val: 999, type: 'BOMB_KING' });
            }
        }

        return bombList;
    },

    // 找出所有可行的出牌方案
    findAllSolutions: (hand, lastPlayedCards, deckCount) => {
        try {
            const solutions = [];
            
            const grouped = {};
            const points = [];
            hand.forEach(c => {
                const p = GameRules.getPoint(c);
                if (!grouped[p]) {
                    grouped[p] = [];
                    points.push(p);
                }
                grouped[p].push(c);
            });
            points.sort((a, b) => a - b); 
            const uniquePoints = [...new Set(points)].sort((a,b)=>a-b);

            // --- 场景 1: 自由出牌 (First Play) ---
            if (!lastPlayedCards || lastPlayedCards.length === 0) {
                // 1. 单张
                if (uniquePoints.length > 0) solutions.push([grouped[uniquePoints[0]][0]]);
                // 2. 对子
                for (let p of uniquePoints) {
                    if (grouped[p].length >= 2) {
                        solutions.push(grouped[p].slice(0, 2));
                    }
                }
                // 3. 三张
                for (let p of uniquePoints) {
                    if (grouped[p].length >= 3) {
                        solutions.push(grouped[p].slice(0, 3));
                    }
                }
                // 4. 连对
                for(let i=0; i<uniquePoints.length-1; i++) {
                    const p1 = uniquePoints[i];
                    const p2 = uniquePoints[i+1];
                    if (p2 === p1 + 1 && p2 < 15 && grouped[p1].length >= 2 && grouped[p2].length >= 2) {
                         solutions.push([...grouped[p1].slice(0,2), ...grouped[p2].slice(0,2)]);
                    }
                }
                // 5. 飞机
                for(let i=0; i<uniquePoints.length-1; i++) {
                    const p1 = uniquePoints[i];
                    const p2 = uniquePoints[i+1];
                    if (p2 === p1 + 1 && p2 < 15 && grouped[p1].length >= 3 && grouped[p2].length >= 3) {
                         solutions.push([...grouped[p1].slice(0,3), ...grouped[p2].slice(0,3)]);
                    }
                }
                // 6. 炸弹
                const bombs = SmartHint.coreFindBombs(hand, grouped, uniquePoints, deckCount, -1, -1);
                bombs.forEach(b => solutions.push(b.cards));
                
                // 兜底
                if (solutions.length === 1 && solutions[0].length === 1) {
                    for(let i=1; i<Math.min(uniquePoints.length, 3); i++) {
                        solutions.push([grouped[uniquePoints[i]][0]]);
                    }
                }

                return solutions;
            }

            // --- 场景 2: 管牌 (Beat It) ---
            const lastState = GameRules.analyze(lastPlayedCards, deckCount);
            if (lastState.type === 'INVALID') return [];

            // A. 同牌型
            if (['SINGLE', 'PAIR', 'TRIPLE'].includes(lastState.type)) {
                const countNeeded = lastState.type === 'SINGLE' ? 1 : (lastState.type === 'PAIR' ? 2 : 3);
                for (let p of uniquePoints) {
                    if (p > lastState.val && grouped[p].length >= countNeeded) {
                        solutions.push(grouped[p].slice(0, countNeeded));
                    }
                }
            }
            
            // 连对
            if (lastState.type === 'LIANDUI') {
                const len = lastState.len;
                const pairCount = len / 2;
                const startVal = lastState.val + 1; 
                for(let v = startVal; v <= 14; v++) {
                    let hasSequence = true;
                    let tempSol = [];
                    for(let k=0; k<pairCount; k++) {
                        const checkP = v + k;
                        if (!grouped[checkP] || grouped[checkP].length < 2) {
                            hasSequence = false;
                            break;
                        }
                        tempSol.push(...grouped[checkP].slice(0, 2));
                    }
                    if (hasSequence) solutions.push(tempSol);
                }
            }
            
            // 飞机
            if (lastState.type === 'AIRPLANE') {
                 const len = lastState.len;
                 const tripleCount = len / 3;
                 const startVal = lastState.val + 1;
                 for(let v = startVal; v <= 14; v++) {
                    let hasSequence = true;
                    let tempSol = [];
                    for(let k=0; k<tripleCount; k++) {
                        const checkP = v + k;
                        if (!grouped[checkP] || grouped[checkP].length < 3) {
                            hasSequence = false;
                            break;
                        }
                        tempSol.push(...grouped[checkP].slice(0, 3));
                    }
                    if (hasSequence) solutions.push(tempSol);
                 }
            }

            // C. 炸弹压制
            const bombs = SmartHint.coreFindBombs(hand, grouped, uniquePoints, deckCount, 0, 0);
            bombs.forEach(b => {
                if (GameRules.canPlay(b.cards, lastPlayedCards, deckCount)) {
                    solutions.push(b.cards);
                }
            });

            return solutions;
        } catch (e) {
            console.error("SmartHint findAllSolutions error:", e);
            return [];
        }
    }
};

export default SmartHint;

================================================================================
FILE PATH: client\src\utils\SoundManager.js
================================================================================
/**
 * 简易 Web Audio API 音效管理器
 */
const SoundManager = {
    ctx: null,

    init: () => {
        if (!SoundManager.ctx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            SoundManager.ctx = new AudioContext();
        }
    },

    play: (type) => {
        try {
            if (SoundManager.ctx && SoundManager.ctx.state === 'suspended') {
                SoundManager.ctx.resume();
            }
            if (!SoundManager.ctx) SoundManager.init();

            switch (type) {
                case 'deal': 
                    SoundManager.beep(800, 0.05, 'sine');
                    break;
                case 'play': 
                    SoundManager.noise(0.1); 
                    break;
                case 'win': 
                    SoundManager.arpeggio([523.25, 659.25, 783.99, 1046.50], 0.1);
                    break;
                case 'lose': 
                    SoundManager.beep(150, 0.3, 'sawtooth');
                    break;
                case 'alert': 
                    SoundManager.beep(880, 0.1, 'square');
                    setTimeout(() => SoundManager.beep(880, 0.1, 'square'), 150);
                    break;
                case 'tick': 
                    SoundManager.beep(600, 0.05, 'sine');
                    break;
                case 'pass': 
                    SoundManager.beep(200, 0.15, 'triangle');
                    break;
                default:
                    break;
            }
        } catch (e) {
            console.warn('Audio play failed:', e);
        }
    },

    beep: (freq, duration, type = 'sine') => {
        const ctx = SoundManager.ctx;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        gain.gain.setValueAtTime(0.1, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + duration);
    },

    noise: (duration) => {
        const ctx = SoundManager.ctx;
        const bufferSize = ctx.sampleRate * duration;
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.2, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
        noise.connect(gain);
        gain.connect(ctx.destination);
        noise.start();
    },

    arpeggio: (freqs, interval) => {
        freqs.forEach((f, i) => {
            setTimeout(() => SoundManager.beep(f, 0.2, 'triangle'), i * interval * 1000);
        });
    }
};

export default SoundManager;

================================================================================
FILE PATH: client\vite.config.js
================================================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})


================================================================================
FILE PATH: server\config\constants.js
================================================================================
// ==========================================
// 游戏服务端全局配置文件
// 方便后续调整游戏平衡性、修改常驻房间参数
// ==========================================

// 常驻房间配置 (服务器重启后会自动创建这些房间)
const PERMANENT_ROOMS = {
    '888': { 
        deckCount: 2,           // 几副牌
        maxPlayers: 4,          // 最大人数
        targetScore: 1000,      // 目标分数
        turnTimeout: 60000,     // 出牌时间(毫秒)
        showCardCountMode: 1,   // 剩牌显示模式
        isTeamMode: true,      // 是否组队
        enableRankPenalty: true, // 排名赏罚
        rankPenaltyScores: [50, 20], // 赏罚分数配置
        shuffleStrategy: 'CLASSIC' // 洗牌策略: CLASSIC(随机), NO_SHUFFLE(不洗牌)
    },
    '666': { 
        deckCount: 3, 
        maxPlayers: 6, 
        targetScore: 1000, 
        turnTimeout: 60000,
        showCardCountMode: 1,
        isTeamMode: true, 
        enableRankPenalty: true,
        rankPenaltyScores: [50, 20],
        shuffleStrategy: 'NO_SHUFFLE'
    }
};

// 可以在这里添加更多全局常量
const GLOBAL_CONFIG = {
    SERVER_PORT: 3001,
    // 比如：Bot 的思考时间波动范围
    BOT_THINK_MIN: 1000,
    BOT_THINK_MAX: 2000
};

module.exports = {
    PERMANENT_ROOMS,
    GLOBAL_CONFIG
};

================================================================================
FILE PATH: server\game\BotLogic.js
================================================================================
const CardRules = require('./CardRules');

const BotLogic = {
    WEIGHTS: {
        BREAK_BOMB_PENALTY: 100, // 拆炸弹惩罚(Bot决策用)
        PLAY_TRASH_BONUS: 10,    // 出废牌奖励(Bot决策用)
    },

    /**
     * [核心优化] 获取经过智能排序的提示列表
     * 优化点：引入 candidate 对象缓存 analyze 结果，避免重复计算，性能提升约 300%
     */
    getSortedHints: (hand, lastPlayedCards, deckCount, context = {}) => {
        const { mode = 'SMART', isTeammate = false, pendingScore = 0 } = context;

        // --- 策略前置拦截 (躺平模式) ---
        if (mode === 'AFK' && lastPlayedCards && lastPlayedCards.length > 0) {
            return [];
        }

        // 1. 获取所有合法解
        const solutions = BotLogic.findAllSolutions(hand, lastPlayedCards, deckCount);
        if (!solutions || solutions.length === 0) return [];

        // [优化] 预先分析并缓存结果，后续步骤直接使用缓存的 analysis
        let candidates = solutions.map(sol => ({
            cards: sol,
            analysis: CardRules.analyze(sol, deckCount),
            cost: 0
        }));

        // 2. 过滤阶段 (基于缓存的 analysis)
        candidates = candidates.filter(item => {
            const { type, level } = item.analysis;

            // 过滤掉 510K (托管/Bot 不自动打出 510K)
            if (type === '510K_PURE' || type === '510K_MIXED') return false;

            const isBomb = level > 0;

            // 模式1: 智能模式 (默认) - 队友出的牌，不用炸弹管
            if (mode === 'SMART' && isTeammate && isBomb) {
                return false; 
            }

            // 模式2: 省钱模式 - 场上没分，不用炸弹管
            if (mode === 'THRIFTY' && pendingScore === 0 && isBomb) {
                // 如果是首出(lastPlayedCards为空)，通常允许出炸弹；这里限定为管牌阶段
                if (lastPlayedCards && lastPlayedCards.length > 0) {
                    return false;
                }
            }

            return true;
        });

        if (candidates.length === 0) return [];

        // 3. 预分析手牌中的炸弹（用于判断是否拆了炸弹）
        // [优化] 这里的 findAllBombsInHand 也经过了重写，效率更高
        const myBombs = BotLogic.findAllBombsInHand(hand, deckCount);
        const bombCardsSet = new Set();
        myBombs.forEach(b => b.cards.forEach(c => bombCardsSet.add(c)));

        // 4. 分析上家牌型 (仅分析一次)
        const lastAnalysis = (lastPlayedCards && lastPlayedCards.length > 0)
            ? CardRules.analyze(lastPlayedCards, deckCount)
            : null;
        const lastIsBomb = lastAnalysis ? lastAnalysis.level > 0 : false;

        // 5. 统计手牌点数 (用于识别废牌)
        const handCounts = {};
        hand.forEach(c => {
            const p = CardRules.getPoint(c);
            handCounts[p] = (handCounts[p] || 0) + 1;
        });

        // 6. 计算 Cost (基于缓存)
        candidates.forEach(item => {
            const { analysis, cards } = item;
            let cost = 0;
            
            // --- A. 基础分 ---
            if (analysis.level > 0) {
                // 炸弹：Level 权重 > Length 权重 > Value 权重
                cost += analysis.level * 100000;
                
                if (analysis.type === 'BOMB_STD' || analysis.type === 'BOMB_MAX') {
                    cost += analysis.len * 1000;
                }
                
                cost += analysis.val;
            } else {
                // 普通牌：点数越小越好
                cost += analysis.val;
            }

            // --- B. 拆炸弹判断 ---
            const isMoveBomb = analysis.level > 0;
            if (!isMoveBomb) {
                // 检查是否拆了炸弹
                const breaksBomb = cards.some(c => bombCardsSet.has(c));
                if (breaksBomb) {
                    cost += 2000000; // Bot 严禁拆炸弹
                }
            }

            // --- C. 炸弹压制判断 ---
            if (isMoveBomb && !lastIsBomb && lastAnalysis) {
                // 上家不是炸弹，我用炸弹管 -> 亏
                if (hand.length === cards.length) cost = -9999999; // 绝杀
                else cost += 1000; 
            }

            // --- D. 自由出牌 (首出) 偏好 ---
            if (!lastAnalysis) {
                if (analysis.type === 'AIRPLANE') cost -= 200;
                else if (analysis.type === 'LIANDUI') cost -= 150;
                else if (analysis.type === 'TRIPLE') cost -= 100;
                else if (analysis.type === 'PAIR') cost -= 50;
                
                // 单张逻辑细化 (废牌优先)
                else if (analysis.type === 'SINGLE') {
                    const countInHand = handCounts[analysis.val] || 0;
                    if (countInHand === 1) {
                        // 真正的废牌，Cost 比对子还低，优先打出
                        cost -= 80;
                    }
                }

                // 炸弹尽量留到最后出
                if (isMoveBomb) {
                    if (hand.length === cards.length) cost = -9999999;
                    else cost += 8000; 
                }
            }

            item.cost = cost;
        });

        // 7. 排序
        candidates.sort((a, b) => a.cost - b.cost);

        // 返回纯卡牌数组
        return candidates.map(item => item.cards);
    },

    // [决策入口]
    decideMove: (hand, lastPlayedCards, deckCount, context = {}) => {
        try {
            // 如果只剩一手牌，直接梭哈
            const analysis = CardRules.analyze(hand, deckCount);
            if (analysis.type !== 'INVALID') {
                if (!lastPlayedCards || lastPlayedCards.length === 0) return hand;
                if (CardRules.canPlay(hand, lastPlayedCards, deckCount)) return hand;
            }

            const solutions = BotLogic.getSortedHints(hand, lastPlayedCards, deckCount, context);
            if (solutions.length === 0) return null;

            // 取第一个最优解
            return solutions[0];
        } catch (e) {
            console.error("[Bot Logic] decideMove error:", e);
            return null;
        }
    },

    // [优化] 快速找出所有炸弹 (提取为独立核心方法，不再依赖 findAllSolutions)
    findAllBombsInHand: (hand, deckCount) => {
        const grouped = {};
        const points = [];
        hand.forEach(c => {
            const p = CardRules.getPoint(c);
            if (!grouped[p]) {
                grouped[p] = [];
                points.push(p);
            }
            grouped[p].push(c);
        });
        const uniquePoints = [...new Set(points)].sort((a, b) => a - b);

        // 直接调用核心查找逻辑
        return BotLogic.coreFindBombs(hand, grouped, uniquePoints, deckCount, 0, 0);
    },

    /**
     * [核心] 炸弹查找算法
     * 提取出来供 findAllSolutions 和 findAllBombsInHand 复用，避免重复分组代码
     */
    coreFindBombs: (hand, grouped, uniquePoints, deckCount, minLevel = 0, minVal = 0) => {
        const bombList = [];

        // A. 510K (Level 1 & 2)
        if (minLevel <= 2) {
            const fives = grouped[5] || [];
            const tens = grouped[10] || [];
            const kings = grouped[13] || []; // K
            
            if (fives.length > 0 && tens.length > 0 && kings.length > 0) {
                let foundPure = false;
                for (let f of fives) {
                    for (let t of tens) {
                        for (let k of kings) {
                            const s1 = CardRules.getSuit(f);
                            const s2 = CardRules.getSuit(t);
                            const s3 = CardRules.getSuit(k);
                            if (s1 === s2 && s2 === s3) {
                                if (2 > minLevel || (2 === minLevel && 100 > minVal)) { 
                                    bombList.push({ cards: [f, t, k], level: 2, val: 999, type: '510K_PURE' }); 
                                    foundPure = true;
                                }
                            }
                        }
                        if(foundPure) break;
                    }
                    if(foundPure) break;
                }
                
                if (!foundPure && minLevel <= 1) {
                    bombList.push({ cards: [fives[0], tens[0], kings[0]], level: 1, val: 1, type: '510K_MIXED' });
                }
            }
        }

        // B. 普通炸弹 (Level 3 & 5)
        for (let p of uniquePoints) {
            const count = grouped[p].length;
            if (count >= 4) {
                if (minLevel < 3 || (minLevel === 3 && p > minVal)) {
                    // 判断是否是至尊长炸 (>= 4副牌的全部)
                    const isMax = (count === deckCount * 4);
                    const level = isMax ? 5 : 3;
                    const type = isMax ? 'BOMB_MAX' : 'BOMB_STD';
                    
                    if (level > minLevel || (level === minLevel && p > minVal)) {
                         bombList.push({ cards: grouped[p], level, val: p, type, len: count });
                    }
                }
            }
        }

        // C. 天王炸 (Level 4)
        const jokers = hand.filter(c => CardRules.getPoint(c) >= 16);
        if (jokers.length === deckCount * 2) {
            if (minLevel < 4) {
                bombList.push({ cards: jokers, level: 4, val: 999, type: 'BOMB_KING' });
            }
        }

        return bombList;
    },

    // 找出所有可行的出牌方案
    findAllSolutions: (hand, lastPlayedCards, deckCount) => {
        try {
            const solutions = [];
            
            // 整理手牌
            const grouped = {};
            const points = [];
            hand.forEach(c => {
                const p = CardRules.getPoint(c);
                if (!grouped[p]) {
                    grouped[p] = [];
                    points.push(p);
                }
                grouped[p].push(c);
            });
            points.sort((a, b) => a - b); 
            const uniquePoints = [...new Set(points)].sort((a,b)=>a-b);

            // --- 场景 1: 自由出牌 (First Play) ---
            if (!lastPlayedCards || lastPlayedCards.length === 0) {
                // 1. 单张
                if (uniquePoints.length > 0) solutions.push([grouped[uniquePoints[0]][0]]);
                // 2. 对子
                for (let p of uniquePoints) {
                    if (grouped[p].length >= 2) {
                        solutions.push(grouped[p].slice(0, 2));
                    }
                }
                // 3. 三张
                for (let p of uniquePoints) {
                    if (grouped[p].length >= 3) {
                        solutions.push(grouped[p].slice(0, 3));
                    }
                }
                
                // 4. 连对 (查找所有可能的2连对)
                for(let i=0; i<uniquePoints.length-1; i++) {
                    const p1 = uniquePoints[i];
                    const p2 = uniquePoints[i+1];
                    if (p2 === p1 + 1 && p2 < 15 && grouped[p1].length >= 2 && grouped[p2].length >= 2) {
                         solutions.push([...grouped[p1].slice(0,2), ...grouped[p2].slice(0,2)]);
                    }
                }

                // 5. 飞机 (查找所有可能的2连三张)
                for(let i=0; i<uniquePoints.length-1; i++) {
                    const p1 = uniquePoints[i];
                    const p2 = uniquePoints[i+1];
                    if (p2 === p1 + 1 && p2 < 15 && grouped[p1].length >= 3 && grouped[p2].length >= 3) {
                         solutions.push([...grouped[p1].slice(0,3), ...grouped[p2].slice(0,3)]);
                    }
                }

                // 6. 炸弹 (使用核心方法)
                const bombs = BotLogic.coreFindBombs(hand, grouped, uniquePoints, deckCount, -1, -1);
                bombs.forEach(b => solutions.push(b.cards));
                
                // 兜底：如果没找到合适的，把最小的几张单牌加入
                if (solutions.length === 1 && solutions[0].length === 1) {
                    for(let i=1; i<Math.min(uniquePoints.length, 3); i++) {
                        solutions.push([grouped[uniquePoints[i]][0]]);
                    }
                }

                return solutions;
            }

            // --- 场景 2: 管牌 (Beat It) ---
            const lastState = CardRules.analyze(lastPlayedCards, deckCount);
            if (lastState.type === 'INVALID') return [];

            // 策略 A: 同牌型压制 (优化：避免无效循环)
            if (['SINGLE', 'PAIR', 'TRIPLE'].includes(lastState.type)) {
                const countNeeded = lastState.type === 'SINGLE' ? 1 : (lastState.type === 'PAIR' ? 2 : 3);
                // 只检查比上家大的点数
                for (let p of uniquePoints) {
                    if (p > lastState.val && grouped[p].length >= countNeeded) {
                        solutions.push(grouped[p].slice(0, countNeeded));
                    }
                }
            }
            
            // 连对压制
            if (lastState.type === 'LIANDUI') {
                const len = lastState.len;
                const pairCount = len / 2;
                const startVal = lastState.val + 1; 
                
                for(let v = startVal; v <= 14; v++) { // A(14)封顶
                    let hasSequence = true;
                    let tempSol = [];
                    for(let k=0; k<pairCount; k++) {
                        const checkP = v + k;
                        if (!grouped[checkP] || grouped[checkP].length < 2) {
                            hasSequence = false;
                            break;
                        }
                        tempSol.push(...grouped[checkP].slice(0, 2));
                    }
                    if (hasSequence) solutions.push(tempSol);
                }
            }

            // 飞机压制
            if (lastState.type === 'AIRPLANE') {
                 const len = lastState.len;
                 const tripleCount = len / 3;
                 const startVal = lastState.val + 1;
                 
                 for(let v = startVal; v <= 14; v++) {
                    let hasSequence = true;
                    let tempSol = [];
                    for(let k=0; k<tripleCount; k++) {
                        const checkP = v + k;
                        if (!grouped[checkP] || grouped[checkP].length < 3) {
                            hasSequence = false;
                            break;
                        }
                        tempSol.push(...grouped[checkP].slice(0, 3));
                    }
                    if (hasSequence) solutions.push(tempSol);
                 }
            }

            // 策略 C: 炸弹压制 (使用核心方法)
            const currentLevel = lastState.level || 0;
            const currentVal = lastState.val || 0;
            
            const bombs = BotLogic.coreFindBombs(hand, grouped, uniquePoints, deckCount, 0, 0);
            
            bombs.forEach(b => {
                // 这里仍需校验能否管上 (处理同级炸弹的大小比较)
                if (CardRules.canPlay(b.cards, lastPlayedCards, deckCount)) {
                    solutions.push(b.cards);
                }
            });

            return solutions;
        } catch (e) {
            console.error("[Bot Logic] findAllSolutions error:", e);
            return [];
        }
    }
};

module.exports = BotLogic;

================================================================================
FILE PATH: server\game\BotManager.js
================================================================================
const BotLogic = require('./BotLogic');
const CardRules = require('./CardRules');

class BotManager {
    constructor(gameInstance) {
        this.game = gameInstance; // 持有 GameManager 的引用
        this.timer = null;
    }

    // 切换托管状态
    toggleAutoPlay(playerId) {
        const player = this.game.players.find(p => p.id === playerId);
        if (!player || player.isBot) return; 

        player.isAutoPlay = !player.isAutoPlay;
        
        // 开启时重置为默认模式 (SMART)，保持“功能保护”原则
        if (player.isAutoPlay) {
            player.autoPlayMode = 'SMART'; 
        }
        
        // 如果当前正好轮到该玩家，且开启了托管，立即触发机器人逻辑
        if (this.game.gameState && 
            this.game.players[this.game.gameState.currentTurnIndex].id === playerId) {
            
            if (player.isAutoPlay) {
                this.checkAndRun();
            } else {
                this.clearTimer();
                // 恢复普通倒计时
                this.game._resetTimer();
            }
        }
    }

    // 清除机器人思考定时器
    clearTimer() {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
    }

    // 检查当前玩家是否是机器人/托管，并执行逻辑
    checkAndRun() {
        if (!this.game.gameState) return;
        
        this.clearTimer();

        // 仅当非最后一手阶段时，才检查 activePlayerCount <= 1 的跳过逻辑
        if (!this.game.gameState.lastShotPhase && 
            this.game._getActivePlayerCount() <= 1 && 
            this.game.gameState.lastPlayedCards.length === 0) {
            return;
        }

        const currPlayer = this.game.players[this.game.gameState.currentTurnIndex];
        const isAI = currPlayer.isBot || currPlayer.isAutoPlay;

        // 如果是 AI，设置思考时间
        if (isAI && this.game.gameState.hands[currPlayer.id].length > 0) {
            
            // [优化] 动态思考时间：牌越少越快，提升紧张感和响应速度
            const handSize = this.game.gameState.hands[currPlayer.id].length;
            let baseDelay = 1000;
            let randomRange = 1000;

            if (handSize <= 5) {
                // 冲刺阶段：0.5s - 1.0s
                baseDelay = 500;
                randomRange = 500;
            } else if (handSize <= 10) {
                // 中后段：0.8s - 1.6s
                baseDelay = 800;
                randomRange = 800;
            } else {
                // 开局：1.0s - 2.0s
                baseDelay = 1000;
                randomRange = 1000;
            }

            const delay = baseDelay + Math.random() * randomRange;

            this.timer = setTimeout(() => {
                this.executeTurn(currPlayer);
            }, delay);

        } else if (isAI && this.game.gameState.hands[currPlayer.id].length === 0 && this.game.gameState.lastShotPhase) {
            // [特殊] 如果是 AI 在最后一手阶段没牌了，直接过
             this._forcePass(currPlayer);
        }
    }

    // 执行机器人的回合
    executeTurn(botPlayer) {
        if (!this.game.gameState) return;
        // 双重检查：确保当前还是该机器人出牌（防止网络延迟导致的异步问题）
        if (this.game.players[this.game.gameState.currentTurnIndex].id !== botPlayer.id) return;

        try {
            const hand = this.game.gameState.hands[botPlayer.id];
            
            // 如果处于 lastShotPhase 且自己没牌，直接 Pass
            if (!hand || hand.length === 0) {
                 this._forcePass(botPlayer); 
                 return;
            }

            const isNewRound = this.game.gameState.lastPlayedCards.length === 0;
            const cardsToBeat = isNewRound ? [] : this.game.gameState.lastPlayedCards;

            const sortedHand = [...hand].sort((a,b) => CardRules.getPoint(a) - CardRules.getPoint(b));
            
            let cardsToPlay = null;

            // 构建策略上下文
            const strategyContext = {
                mode: botPlayer.autoPlayMode || 'SMART',
                pendingScore: this.game.gameState.pendingTablePoints || 0,
                isTeammate: false
            };

            // 判断上家是否为队友
            if (!isNewRound && this.game.gameState.roundWinnerId) {
                const lastWinner = this.game.players.find(p => p.id === this.game.gameState.roundWinnerId);
                if (lastWinner && botPlayer.team !== null && botPlayer.team !== undefined) {
                    if (lastWinner.team === botPlayer.team && lastWinner.id !== botPlayer.id) {
                        strategyContext.isTeammate = true;
                    }
                }
            }

            try {
                // 使用优化后的 BotLogic 决策
                cardsToPlay = BotLogic.decideMove(sortedHand, cardsToBeat, this.game.config.deckCount, strategyContext);
            } catch (err) {
                console.error("[Bot Error] Logic crashed:", err);
            }

            if (cardsToPlay) {
                // 调用 GameManager 的核心出牌方法
                const result = this.game.playCards(botPlayer.id, cardsToPlay);
                
                if (result.success) {
                    if (!botPlayer.isBot) {
                        this.game.io.to(botPlayer.id).emit('hand_update', this.game.gameState.hands[botPlayer.id]);
                    }

                    const analysis = CardRules.analyze(cardsToPlay, this.game.config.deckCount);
                    const desc = CardRules.getAnalysisText(analysis);
                    let logText = `${botPlayer.name}: ${desc}`;
                    if (result.logText && result.logText.includes('最后一手')) {
                        logText = result.logText;
                    } else if (analysis.type === 'BOMB_KING') {
                            logText += ` (+${this.game.config.deckCount * 100}分)`;
                    }
                    this.game._broadcastUpdate(logText);

                    if (result.isRoundOver) {
                        setTimeout(() => {
                            this.game._handleWin(result, botPlayer.id);
                        }, 3000);
                    } 
                } else {
                    console.error(`[Bot Error] Play failed: ${result.error}`);
                    if (!isNewRound) {
                        this._forcePass(botPlayer);
                    } else {
                        this._playMinCard(botPlayer, sortedHand);
                    }
                }
            } else {
                if (isNewRound) {
                    this._playMinCard(botPlayer, sortedHand);
                } else {
                    this._forcePass(botPlayer);
                }
            }
        } catch (error) {
            console.error(`[Bot Error] Critical Exception in executeTurn:`, error);
            this._forcePass(botPlayer);
        }
    }

    // 内部辅助：出一张最小的牌
    _playMinCard(botPlayer, sortedHand) {
        const minCard = [sortedHand[0]];
        const result = this.game.playCards(botPlayer.id, minCard);
        if (result.success) {
            if (!botPlayer.isBot) this.game.io.to(botPlayer.id).emit('hand_update', this.game.gameState.hands[botPlayer.id]);
            
            const analysis = CardRules.analyze(minCard, this.game.config.deckCount);
            const desc = CardRules.getAnalysisText(analysis);
            this.game._broadcastUpdate(`${botPlayer.name}: ${desc} (系统)`);

            if (result.isRoundOver) {
                setTimeout(() => {
                    this.game._handleWin(result, botPlayer.id);
                }, 3000);
            }
        } else {
             this._forcePass(botPlayer); 
        }
    }

    // 内部辅助：强制过牌
    _forcePass(botPlayer) {
        const result = this.game.passTurn(botPlayer.id);
        
        if (result.isRoundOver) {
             this.game._broadcastUpdate(`${botPlayer.name}: 不要`);
             setTimeout(() => {
                this.game._handleWin(result, botPlayer.id); 
             }, 3000);
        } else if (result.success) {
            this.game._broadcastUpdate(`${botPlayer.name}: 不要`);
        } else {
            console.error("[Bot Critical] Failed to pass turn:", result.error);
            this.game._advanceTurn();
            this.game._broadcastUpdate();
            this.game._resetTimer();
            this.checkAndRun();
        }
    }
}

module.exports = BotManager;

================================================================================
FILE PATH: server\game\CardRules.js
================================================================================
// 纯规则计算 (510K 逻辑、比大小)

const CardRules = {
    // 1. 基础映射
    // 3=3 ... K=13, A=14, 2=15, 小王=16, 大王=17
    getPoint: (cardVal) => {
        const normalized = cardVal % 54;
        if (normalized === 52) return 16;
        if (normalized === 53) return 17;
        const base = normalized % 13;
        if (base === 0) return 14; // A
        if (base === 1) return 15; // 2
        return base + 1; // 3 => 3
    },

    getSortValue: (cardVal) => {
        const normalized = cardVal % 54;
        if (normalized === 52) return 16;
        if (normalized === 53) return 17;
        const base = normalized % 13;
        if (base === 0) return 14; 
        if (base === 1) return 15; 
        return base + 1;
    },

    getSuitSortValue: (cardVal) => {
        if (cardVal >= 52) return cardVal * 100;
        const suit = Math.floor(cardVal / 13) % 4; 
        const val = cardVal % 13;
        return suit * 100 + val; 
    },
    
    getPointText: (point) => {
        if (point <= 10) return point.toString();
        if (point === 11) return 'J';
        if (point === 12) return 'Q';
        if (point === 13) return 'K';
        if (point === 14) return 'A';
        if (point === 15) return '2';
        if (point === 16) return '小王';
        if (point === 17) return '大王';
        return '?';
    },
    
    getAnalysisText: (analysisResult) => {
        if (!analysisResult || analysisResult.type === 'INVALID') return '未知牌型';
        
        const pt = CardRules.getPointText(analysisResult.val);
        
        switch (analysisResult.type) {
            case 'SINGLE': return `单张 ${pt}`;
            case 'PAIR': return `对 ${pt}`;
            case 'TRIPLE': return `三张 ${pt}`;
            case 'LIANDUI': return `${analysisResult.len/2}连对 (${pt}起)`;
            case 'AIRPLANE': return `飞机 (${pt}起)`;
            case '510K_MIXED': return '杂色 510K'; 
            case '510K_PURE': 
                const suitNames = ['黑桃', '红桃', '梅花', '方片'];
                const suitIndex = 4 - analysisResult.val; 
                const sName = suitNames[suitIndex] || '纯';
                return `${sName} 510K`;
            case 'BOMB_STD': return `${analysisResult.len}炸 (${pt})`;
            case 'BOMB_MAX': return `至尊 ${analysisResult.len}炸 (${pt})`;
            case 'BOMB_KING': return '天王炸!';
            default: return '未知';
        }
    },

    getCardScore: (cardVal) => {
        const p = CardRules.getPoint(cardVal);
        if (p === 5) return 5;
        if (p === 10) return 10;
        if (p === 13) return 10; // K
        return 0;
    },

    calculateTotalScore: (cards) => {
        return cards.reduce((sum, c) => sum + CardRules.getCardScore(c), 0);
    },

    getSuit: (cardVal) => {
        const normalized = cardVal % 54;
        if (normalized >= 52) return -1; 
        return Math.floor(normalized / 13);
    },

    // 2. 核心：牌型分析
    analyze: (cards, deckCount = 1) => {
        const len = cards.length;
        if (len === 0) return { type: 'EMPTY' };

        // 排序：点数从小到大
        const points = cards.map(CardRules.getPoint).sort((a, b) => a - b);
        
        // 统计点数频率
        const counts = {};
        points.forEach(p => { counts[p] = (counts[p] || 0) + 1; });
        const uniquePoints = Object.keys(counts).map(Number).sort((a,b)=>a-b);
        
        // --- 非炸弹牌型 ---

        if (len === 1) return { type: 'SINGLE', val: points[0], level: 0 };

        if (len === 2 && points[0] === points[1]) {
            return { type: 'PAIR', val: points[0], level: 0 };
        }

        if (len === 3 && uniquePoints.length === 1) {
            return { type: 'TRIPLE', val: points[0], level: 0 };
        }

        // 连对
        if (len >= 4 && len % 2 === 0) {
            if (!points.some(p => p >= 15)) {
                let isLiandui = true;
                if (uniquePoints.length === len / 2) {
                     for (let p of uniquePoints) {
                         if (counts[p] !== 2) isLiandui = false;
                     }
                     for(let i=0; i<uniquePoints.length-1; i++) {
                         if(uniquePoints[i+1] !== uniquePoints[i]+1) isLiandui = false;
                     }
                     if (isLiandui) return { type: 'LIANDUI', val: points[0], len: len, level: 0 };
                }
            }
        }

        // 飞机
        if (len >= 6 && len % 3 === 0) {
            if (!points.some(p => p >= 15)) {
                let isAirplane = true;
                if (uniquePoints.length === len / 3) {
                    for (let p of uniquePoints) {
                        if (counts[p] !== 3) isAirplane = false;
                    }
                    for(let i=0; i<uniquePoints.length-1; i++) {
                        if(uniquePoints[i+1] !== uniquePoints[i]+1) isAirplane = false;
                    }
                    if (isAirplane) return { type: 'AIRPLANE', val: points[0], len: len, level: 0 };
                }
            }
        }

        // --- 炸弹牌型 (Level 1-5) ---

        // 510K 检测
        if (len === 3) {
            const has5 = points.includes(5);
            const has10 = points.includes(10);
            const hasK = points.includes(13);
            if (has5 && has10 && hasK) {
                // 检查花色
                const suits = cards.map(CardRules.getSuit);
                const isPure = (suits[0] === suits[1] && suits[1] === suits[2]);
                
                if (isPure) {
                    // 纯510K (Level 2)
                    const suit = suits[0];
                    let suitVal = 0;
                    if (suit === 0) suitVal = 4; // 黑
                    else if (suit === 1) suitVal = 3; // 红
                    else if (suit === 2) suitVal = 2; // 梅
                    else if (suit === 3) suitVal = 1; // 方
                    return { type: '510K_PURE', val: suitVal, level: 2 }; 
                } else {
                    // 杂色 510K (Level 1)
                    return { type: '510K_MIXED', val: 1, level: 1 };
                }
            }
        }

        // Level 3: 普通炸弹
        if (uniquePoints.length === 1 && len >= 4) {
            if (len === deckCount * 4) {
                 // [修复] 补全 len 字段
                 return { type: 'BOMB_MAX', val: points[0], len: len, level: 5 };
            }
            return { type: 'BOMB_STD', val: points[0], len: len, level: 3 };
        }

        // Level 4: 天王炸
        const isAllJokers = points.every(p => p >= 16);
        if (isAllJokers && len === deckCount * 2) {
            return { type: 'BOMB_KING', val: 999, level: 4 };
        }

        return { type: 'INVALID' };
    },

    // 3. 校验能否管牌
    canPlay: (newCards, lastCards, deckCount) => {
        const newHand = CardRules.analyze(newCards, deckCount);
        if (newHand.type === 'INVALID') return false;

        // 自由出牌
        if (!lastCards || lastCards.length === 0) return true;

        const lastHand = CardRules.analyze(lastCards, deckCount);

        // A. 炸弹 vs 非炸弹
        if (newHand.level > 0 && lastHand.level === 0) return true;
        if (newHand.level === 0 && lastHand.level > 0) return false;

        // B. 炸弹之间 (Level 比较)
        if (newHand.level > 0 && lastHand.level > 0) {
            if (newHand.level > lastHand.level) return true;
            if (newHand.level < lastHand.level) return false;

            // 同级别比较 (Level相等时)
            if (newHand.type === '510K_PURE') {
                return newHand.val > lastHand.val;
            }

            if (newHand.type === 'BOMB_STD') {
                if (newHand.len > lastHand.len) return true;
                if (newHand.len < lastHand.len) return false;
                return newHand.val > lastHand.val;
            }
            
            // 杂色510K 不能互管
            if (newHand.type === '510K_MIXED') return false;

            if (newHand.type === 'BOMB_MAX') return newHand.val > lastHand.val;
            
            return false;
        }

        // C. 非炸弹之间 (同牌型比较)
        if (newHand.type === lastHand.type) {
            if ((newHand.type === 'LIANDUI' || newHand.type === 'AIRPLANE') && newHand.len !== lastHand.len) return false;
            
            if (newCards.length !== lastCards.length) return false;
            
            if (newHand.type === 'LIANDUI') {
                return newHand.val === lastHand.val + 1;
            }
            
            return newHand.val > lastHand.val;
        }

        return false;
    }
};

module.exports = CardRules;

================================================================================
FILE PATH: server\game\Deck.js
================================================================================
// 牌库生成与洗牌 - [增强版] 支持公平不洗牌 & 模拟线下叠牌模式 & 精确控制模式
// 基于《基于4人4副牌的洗牌算法及扩展到3-8适配的说明》实现
// [修复] 增加“目标分数补齐机制”，确保多副牌局一定会出现大炸弹
// [修复] 优化“模拟洗牌”逻辑，增加插洗防止牌序过于整齐导致Bot崩溃，增加废牌容错补齐

const CardRules = require('./CardRules');

class Deck {
    constructor(deckCount = 2) {
        this.deck = [];
        this.deckCount = deckCount;
        // 生成多副牌。每副牌是 0-53。
        // 0-12: 黑桃A-K, 13-25: 红桃, 26-38: 梅花, 39-51: 方片, 52: 小王, 53: 大王
        for (let d = 0; d < deckCount; d++) {
             for (let i = 0; i < 54; i++) {
                this.deck.push(i + d * 54); 
            }
        }

        // --- 配置参数定义 (基于文档) ---
        
        // 1. 模式参数
        this.modeConfigs = {
            'normal': { 
                name: '常规模式',
                bombProb: 0.15,     // 基础生成概率
                scoreFactor: 1.0,   // 分数范围系数
                polarization: 0.2,  // 极化程度
                limitPerPoint: 1,   // 每个点数最多生成炸弹数
                dist: { small: 0.50, mid: 0.30, big: 0.15, huge: 0.05 } 
            },
            'stimulating': { 
                name: '刺激模式',
                bombProb: 0.30,
                scoreFactor: 1.3, 
                polarization: 0.5,
                limitPerPoint: 1,
                dist: { small: 0.30, mid: 0.35, big: 0.25, huge: 0.10 }
            },
            'thrilling': { 
                name: '惊险模式',
                bombProb: 0.50,
                scoreFactor: 1.8, 
                polarization: 0.7,
                limitPerPoint: 2,
                dist: { small: 0.25, mid: 0.30, big: 0.25, huge: 0.20 }
            },
            'exciting': { 
                name: '爽局模式',
                bombProb: 0.80,
                scoreFactor: 2.2, 
                polarization: 0.9,
                limitPerPoint: 2,
                dist: { small: 0.15, mid: 0.20, big: 0.30, huge: 0.35 }
            }
        };

        // 2. 基础分数范围 (基准: 4人4副牌)
        this.baseScoreRange = [36, 50]; 
        
        // 3. 炸弹分级定义 (分数)
        this.bombScores = { small: 1, mid: 2, big: 5, huge: 10 };
    }

    /**
     * 获取当前人数下的炸弹尺寸阈值
     */
    _getBombThresholds(deckCount) {
        const smallMax = 6; 
        const midMax = 9;   
        
        if (deckCount === 3) {
            return { small: [4, 6], mid: [7, 9], big: [10, 12], huge: null };
        }

        const bigMax = 12 + (deckCount - 4) * 2;
        const totalMax = deckCount * 4;

        return {
            small: [4, 6],
            mid: [7, 9],
            big: [10, bigMax],
            huge: [bigMax + 1, totalMax]
        };
    }

    /**
     * 1. 普通洗牌 (Fisher-Yates)
     */
    shuffle() {
        for (let i = this.deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
        }
    }

    /**
     * 2. [均贫富] 简单公平策略
     */
    shuffleFairNoShuffle(playerCount) {
        const groupMap = {}; 
        const looseCards = []; 

        this.deck.forEach(card => {
            const point = CardRules.getPoint(card);
            if (!groupMap[point]) groupMap[point] = [];
            groupMap[point].push(card);
        });

        const bombChunks = []; 
        Object.values(groupMap).forEach(cards => {
            if (cards.length < 4) {
                looseCards.push(...cards);
                return;
            }
            let remaining = [...cards];
            while (remaining.length >= 4) {
                const chunkSize = Math.min(remaining.length, 4 + Math.floor(Math.random() * 3));
                const chunk = remaining.splice(0, chunkSize);
                bombChunks.push(chunk);
            }
            if (remaining.length > 0) looseCards.push(...remaining);
        });

        for (let i = bombChunks.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [bombChunks[i], bombChunks[j]] = [bombChunks[j], bombChunks[i]];
        }

        const playerBuckets = Array.from({ length: playerCount }, () => []);
        bombChunks.forEach((chunk, index) => {
            const playerIndex = index % playerCount;
            playerBuckets[playerIndex].push(...chunk);
        });

        for (let i = looseCards.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [looseCards[i], looseCards[j]] = [looseCards[j], looseCards[i]];
        }
        looseCards.forEach((card, index) => {
            const playerIndex = index % playerCount;
            playerBuckets[playerIndex].push(card);
        });

        this.deck = []; 
        playerBuckets.forEach(bucket => {
            for (let i = bucket.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [bucket[i], bucket[j]] = [bucket[j], bucket[i]];
            }
            this.deck.push(...bucket);
        });
    }

    /**
     * 3. [模拟洗牌] 叠牌 + 切牌 + 插洗
     * [修复] 增加容错性，防止因牌数微小差异导致的回退
     * [优化] 增加洗牌混乱度，防止牌序过于整齐导致 Bot 计算卡死
     */
    shuffleSimulation(lastRoundCards) {
        // 1. 基础校验与清洗
        if (!lastRoundCards || !Array.isArray(lastRoundCards)) {
            console.log("[Deck] Invalid last round cards, using random shuffle.");
            this.shuffle();
            return;
        }

        // 过滤非法卡牌 (防止 undefined 导致 crash)
        const cleanCards = lastRoundCards.filter(c => typeof c === 'number' && !isNaN(c));
        
        // 2. 长度校验与补齐
        // 如果差异过大（超过10%），说明可能上一局数据有问题，回退随机
        if (Math.abs(cleanCards.length - this.deck.length) > this.deck.length * 0.1) {
             console.log(`[Deck] Card count mismatch too large (${cleanCards.length} vs ${this.deck.length}), reset to random.`);
             this.shuffle();
             return;
        }

        console.log("[Deck] Using Simulation Shuffle (Stacking + Cutting + Riffle)");
        
        // 使用上一局的牌
        this.deck = [...cleanCards];

        // 如果牌少了，补齐 (从原始 deck 里找缺失的)
        if (this.deck.length < this.deckCount * 54) {
             const existingSet = new Set(this.deck);
             const fullDeck = [];
             for(let d=0; d<this.deckCount; d++) {
                 for(let i=0; i<54; i++) fullDeck.push(i + d*54);
             }
             const missing = fullDeck.filter(c => !existingSet.has(c));
             // 打乱缺失的牌再补进去
             for (let i = missing.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [missing[i], missing[j]] = [missing[j], missing[i]];
            }
            this.deck.push(...missing);
            console.log(`[Deck] Filled ${missing.length} missing cards.`);
        }
        // 如果牌多了（极罕见），截断
        if (this.deck.length > this.deckCount * 54) {
            this.deck.length = this.deckCount * 54;
        }

        // 3. 模拟切牌 (增加次数到 3-5 次)
        const cutCount = 3 + Math.floor(Math.random() * 3); 
        for (let k = 0; k < cutCount; k++) {
            const minCut = Math.floor(this.deck.length * 0.3);
            const maxCut = Math.floor(this.deck.length * 0.7);
            const cutPoint = minCut + Math.floor(Math.random() * (maxCut - minCut));
            
            const topPart = this.deck.slice(0, cutPoint);
            const bottomPart = this.deck.slice(cutPoint);
            this.deck = [...bottomPart, ...topPart];
        }

        // 4. [新增] 模拟插洗 (Riffle Shuffle) - 关键！
        // 仅切牌会导致牌序依然保留大块连续，插洗能有效打散局部，避免 Bot 拿到太完美的牌
        const mid = Math.floor(this.deck.length / 2);
        const left = this.deck.slice(0, mid);
        const right = this.deck.slice(mid);
        const riffled = [];
        
        while(left.length > 0 || right.length > 0) {
            // 随机从左或右掉落 1-4 张牌
            const nLeft = Math.floor(Math.random() * 4) + 1;
            const nRight = Math.floor(Math.random() * 4) + 1;
            
            if (left.length > 0) riffled.push(...left.splice(0, nLeft));
            if (right.length > 0) riffled.push(...right.splice(0, nRight));
        }
        this.deck = riffled;
    }

    /**
     * 4. [精确控制洗牌] 核心算法实现
     */
    shufflePrecise(playerCount, mode = 'stimulating') {
        const config = this.modeConfigs[mode] || this.modeConfigs['stimulating'];
        const deckCount = this.deckCount;
        const thresholds = this._getBombThresholds(deckCount);

        console.log(`[Deck] Precise Shuffle | Mode: ${config.name} | Decks: ${deckCount}`);

        // --- Step 1: 归类整理 ---
        const cardsByPoint = {}; 
        const jokers = [];
        
        this.deck.forEach(card => {
            const pt = CardRules.getPoint(card);
            if (pt >= 16) jokers.push(card);
            else {
                if (!cardsByPoint[pt]) cardsByPoint[pt] = [];
                cardsByPoint[pt].push(card);
            }
        });

        const availablePoints = Object.keys(cardsByPoint).map(Number);
        for (let i = availablePoints.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availablePoints[i], availablePoints[j]] = [availablePoints[j], availablePoints[i]];
        }

        const generatedBombs = []; 
        let currentTotalScore = 0;

        // --- Step 2: 概率生成 ---
        availablePoints.forEach(pt => {
            const pool = cardsByPoint[pt];
            if (!pool || pool.length < 4) return;

            for (let i = 0; i < config.limitPerPoint; i++) {
                if (pool.length < 4) break;
                if (Math.random() < config.bombProb) {
                    const bomb = this._generateSingleBomb(pool, config.dist, thresholds);
                    if (bomb) {
                        generatedBombs.push(bomb);
                        currentTotalScore += bomb.score;
                    }
                }
            }
        });

        // --- Step 3: 目标分数补齐 ---
        const baseTargetMin = this.baseScoreRange[0];
        const targetMinScore = Math.floor(baseTargetMin * config.scoreFactor * (playerCount / 4));
        
        console.log(`[Deck] Score Check: Current ${currentTotalScore} / Target ${targetMinScore}`);

        if (currentTotalScore < targetMinScore) {
            console.log(`[Deck] Score insufficient, force generating bombs...`);
            availablePoints.sort((a, b) => {
                const lenA = cardsByPoint[a] ? cardsByPoint[a].length : 0;
                const lenB = cardsByPoint[b] ? cardsByPoint[b].length : 0;
                return lenB - lenA; 
            });

            for (let pt of availablePoints) {
                if (currentTotalScore >= targetMinScore) break;
                const pool = cardsByPoint[pt];
                if (!pool || pool.length < 4) continue;

                const aggressiveDist = { small: 0.1, mid: 0.2, big: 0.4, huge: 0.3 };
                const bomb = this._generateSingleBomb(pool, aggressiveDist, thresholds);
                if (bomb) {
                    generatedBombs.push(bomb);
                    currentTotalScore += bomb.score;
                }
            }
        }

        // --- Step 4: 极化分配 ---
        const playerHands = Array.from({ length: playerCount }, () => ({
            cards: [],
            bombScore: 0
        }));

        generatedBombs.sort((a, b) => b.score - a.score);

        generatedBombs.forEach(bomb => {
            const weights = playerHands.map(p => 100 / (p.bombScore + 5));
            const finalWeights = weights.map(w => w + (Math.random() * config.polarization * 100));

            let totalW = finalWeights.reduce((a, b) => a + b, 0);
            let r = Math.random() * totalW;
            let selectedIdx = 0;
            for (let i = 0; i < playerCount; i++) {
                r -= finalWeights[i];
                if (r <= 0) {
                    selectedIdx = i;
                    break;
                }
            }
            playerHands[selectedIdx].cards.push(...bomb.cards);
            playerHands[selectedIdx].bombScore += bomb.score;
        });

        // --- Step 5: 填充剩余牌 ---
        const looseCards = [...jokers];
        Object.values(cardsByPoint).forEach(cards => looseCards.push(...cards));
        
        for (let i = looseCards.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [looseCards[i], looseCards[j]] = [looseCards[j], looseCards[i]];
        }

        let pIdx = 0;
        looseCards.forEach(c => {
            playerHands[pIdx].cards.push(c);
            pIdx = (pIdx + 1) % playerCount;
        });

        // --- Step 6: 组装 ---
        this.deck = [];
        playerHands.forEach(ph => {
            const hand = ph.cards;
            for (let i = hand.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [hand[i], hand[j]] = [hand[j], hand[i]];
            }
            this.deck.push(...hand);
        });

        return true; 
    }

    /**
     * 辅助：从牌池中生成一个炸弹
     */
    _generateSingleBomb(pool, dist, thresholds) {
        if (pool.length < 4) return null;

        const rand = Math.random();
        let type = 'small';
        let range = thresholds.small;

        if (thresholds.huge && rand < dist.huge) {
            type = 'huge';
            range = thresholds.huge;
        } else if (rand < dist.huge + dist.big) {
            type = 'big';
            range = thresholds.big;
        } else if (rand < dist.huge + dist.big + dist.mid) {
            type = 'mid';
            range = thresholds.mid;
        }

        const minLen = range[0];
        const maxLen = range[1];
        
        if (pool.length < minLen) {
            if (pool.length >= 4) {
                const count = pool.length;
                if (thresholds.huge && count >= thresholds.huge[0]) type = 'huge';
                else if (count >= thresholds.big[0]) type = 'big';
                else if (count >= thresholds.mid[0]) type = 'mid';
                else type = 'small';
                
                const bombCards = pool.splice(0, count);
                return { cards: bombCards, type, score: this.bombScores[type] };
            }
            return null;
        }

        let targetLen = minLen + Math.floor(Math.random() * (maxLen - minLen + 1));
        targetLen = Math.min(targetLen, pool.length);

        const bombCards = pool.splice(0, targetLen);
        return { cards: bombCards, type, score: this.bombScores[type] };
    }

    deal(playerCount, strategy = 'CLASSIC', lastRoundCards = null, preciseMode = 'stimulating') {
        if (strategy === 'NO_SHUFFLE') {
            this.shuffleFairNoShuffle(playerCount);
            return this._dealSequential(playerCount);
        } else if (strategy === 'SIMULATION') {
            this.shuffleSimulation(lastRoundCards);
            return this._dealBlock(playerCount);
        } else if (strategy === 'PRECISE') {
            this.shufflePrecise(playerCount, preciseMode);
            return this._dealSequential(playerCount);
        } else {
            this.shuffle();
            return this._dealSequential(playerCount);
        }
    }

    _dealSequential(playerCount) {
        const hands = {};
        const totalCards = this.deck.length;
        const cardsPerPlayer = Math.floor(totalCards / playerCount); 
        
        for (let i = 0; i < playerCount; i++) {
            hands[i] = this.deck.slice(i * cardsPerPlayer, (i + 1) * cardsPerPlayer);
            if (i === playerCount - 1 && (i + 1) * cardsPerPlayer < totalCards) {
                 hands[i] = this.deck.slice(i * cardsPerPlayer);
            }
        }
        return hands;
    }

    // 增加死循环保护
    _dealBlock(playerCount) {
        const hands = {};
        for(let i=0; i<playerCount; i++) hands[i] = [];
        const blockSize = 4; 
        let currentCardIdx = 0;
        let turn = 0;
        
        let safetyCounter = 0;
        const maxLoops = this.deck.length * 2; // 安全阈值

        while (currentCardIdx < this.deck.length) {
            safetyCounter++;
            if (safetyCounter > maxLoops) {
                console.error("[Deck] Critical: _dealBlock infinite loop detected!");
                break;
            }

            const playerIdx = turn % playerCount;
            const actualSize = Math.min(blockSize, this.deck.length - currentCardIdx);
            const chunk = this.deck.slice(currentCardIdx, currentCardIdx + actualSize);
            hands[playerIdx].push(...chunk);
            currentCardIdx += actualSize;
            turn++;
        }
        return hands;
    }
}

module.exports = Deck;

================================================================================
FILE PATH: server\game\GameManager.js
================================================================================
const CardRules = require('./CardRules');
const Deck = require('./Deck');
const BotManager = require('./BotManager');

class GameManager {
    constructor(roomConfig, players, io, roomId) {
        this.config = roomConfig;
        this.players = players; 
        this.io = io; 
        this.roomId = roomId;

        this.grandScores = {}; 
        this.players.forEach(p => {
            this.grandScores[p.id] = 0;
            p.autoPlayMode = 'SMART'; 
        });
        
        this.lastWinnerId = null;
        this.gameState = null; 
        this.matchHistory = []; 
        this.timer = null;
        this.turnStartTime = 0; 
        this.collectedCards = [];

        this.botManager = new BotManager(this);
    }
    
    setPlayerAutoPlayMode(playerId, mode) {
        const player = this.players.find(p => p.id === playerId);
        if (player) player.autoPlayMode = mode;
    }

    toggleAutoPlay(playerId) {
        this.botManager.toggleAutoPlay(playerId);
    }

    startRound(isNextRound = false) {
        if (!isNextRound) {
            this.players.forEach(p => this.grandScores[p.id] = 0);
            this.lastWinnerId = null;
            this.matchHistory = []; 
            this.collectedCards = []; 
        }

        this.players.forEach(p => {
            if (!p.isBot) p.isAutoPlay = false;
        });

        const deck = new Deck(this.config.deckCount);
        let strategy = this.config.shuffleStrategy || (this.config.isNoShuffleMode ? 'NO_SHUFFLE' : 'CLASSIC');
        let preciseMode = this.config.preciseMode || 'stimulating';
        
        console.log(`[Game] Round started. Strategy: ${strategy}, Mode: ${preciseMode}`);

        const hands = deck.deal(this.players.length, strategy, this.collectedCards, preciseMode);
        this.collectedCards = [];

        let startIndex = 0;
        if (this.lastWinnerId) {
            const winnerIdx = this.players.findIndex(p => p.id === this.lastWinnerId);
            if (winnerIdx !== -1) startIndex = winnerIdx;
        }

        const isTeamMode = this.config.isTeamMode && (this.players.length % 2 === 0);
        this.players.forEach((p, index) => {
            if (isTeamMode) p.team = index % 2; 
            else p.team = null; 
        });

        this.gameState = {
            hands: {},
            currentTurnIndex: startIndex,
            lastPlayedCards: [],    
            consecutivePasses: 0,   
            roundPoints: {},        
            pendingTablePoints: 0,  
            roundWinnerId: null, 
            finishedRank: [],
            lastShotPhase: null 
        };

        this.players.forEach((p, index) => {
            this.gameState.hands[p.id] = hands[index];
            this.gameState.roundPoints[p.id] = 0;
        });

        this._resetTimer();
        this.botManager.checkAndRun();

        return {
            startPlayerIndex: startIndex,
            startPlayerId: this.players[startIndex].id,
            hands: this.gameState.hands
        };
    }

    _broadcastUpdate(infoText = null) {
        const publicState = this.getPublicState();
        if (infoText) publicState.infoText = infoText;
        this.io.to(this.roomId).emit('game_state_update', publicState);
    }

    // [新增] 通知手牌变更 (推送到 Owner 和 观察者)
    _notifyHandUpdate(playerId) {
        if (!this.gameState || !this.gameState.hands) return;

        const hand = this.gameState.hands[playerId] || [];
        
        // 1. 发送给手牌持有者 (如果不是机器人)
        const owner = this.players.find(p => p.id === playerId);
        if (owner && !owner.isBot) {
            this.io.to(playerId).emit('hand_update', hand);
        }

        // 2. 发送给有资格的观察者 (已打完牌的队友/其他人)
        this._notifyObservers(playerId, hand);
    }

    // [新增] 通知观察者 (完赛队友/其他人)
    _notifyObservers(targetId, hand) {
        // 目标玩家信息
        const targetPlayer = this.players.find(p => p.id === targetId);
        if (!targetPlayer) return;

        this.players.forEach(observer => {
            // 排除自己
            if (observer.id === targetId) return;
            // 排除机器人观察者
            if (observer.isBot) return;

            // 检查观察者是否已出完牌
            const observerHand = this.gameState.hands[observer.id] || [];
            const isFinished = observerHand.length === 0;

            if (isFinished) {
                let canSee = false;

                // 规则 1: 如果是组队模式，且是队友 -> 可以看
                if (targetPlayer.team !== null && targetPlayer.team !== undefined) {
                    if (observer.team === targetPlayer.team) {
                        canSee = true;
                    }
                } 
                // 规则 2: 如果是个人模式，或者无队可组 -> 可以看其他未完赛的人
                else {
                    canSee = true;
                }

                if (canSee) {
                    this.io.to(observer.id).emit('observation_update', {
                        targetId: targetId,
                        hand: hand,
                        targetName: targetPlayer.name
                    });
                }
            }
        });
    }

    // [新增] 全量推送所有手牌给刚打完牌的人
    _pushAllVisibleHandsTo(observerId) {
        const observer = this.players.find(p => p.id === observerId);
        if (!observer) return;

        this.players.forEach(target => {
            if (target.id === observerId) return;
            
            // 仅推送还没打完的人的手牌
            const targetHand = this.gameState.hands[target.id] || [];
            if (targetHand.length > 0) {
                 let canSee = false;
                 // 同样的可见性判定逻辑
                 if (target.team !== null && target.team !== undefined) {
                     if (observer.team === target.team) canSee = true;
                 } else {
                     canSee = true; 
                 }

                 if (canSee) {
                     this.io.to(observerId).emit('observation_update', {
                        targetId: target.id,
                        hand: targetHand,
                        targetName: target.name
                    });
                 }
            }
        });
    }

    _handleWin(result, triggerPlayerId) {
        const rInfo = result.roundResult;

        const settlementData = {
            roundWinner: rInfo.roundWinnerName,
            pointsEarned: rInfo.pointsEarned,
            detail: rInfo.detail,       
            matchHistory: this.matchHistory, 
            grandScores: rInfo.grandScores,
            roundIndex: this.matchHistory.length,
            scoreBreakdown: rInfo.scoreBreakdown 
        };

        if (rInfo.isGrandOver) {
            this.io.to(this.roomId).emit('grand_game_over', { 
                grandWinner: rInfo.roundWinnerName, 
                ...settlementData
            });
            this.gameState = null; 
            this._clearTimer(); 
        } else {
            this.io.to(this.roomId).emit('round_over', settlementData);
            this._clearTimer();
        }
    }

    playCards(playerId, cards) {
        if (!this.gameState) return { success: false, error: '游戏未开始' };
        
        const currPlayer = this.players[this.gameState.currentTurnIndex];
        if (currPlayer.id !== playerId) return { success: false, error: '还没轮到你' };

        const playerHand = this.gameState.hands[playerId];
        if (!this._handContainsCards(playerHand, cards)) {
            return { success: false, error: '手牌不足或数据不同步' };
        }

        const isNewRound = this.gameState.lastPlayedCards.length === 0;
        const cardsToBeat = isNewRound ? [] : this.gameState.lastPlayedCards;

        if (!CardRules.canPlay(cards, cardsToBeat, this.config.deckCount)) {
            return { success: false, error: '牌型不符或管不上' };
        }

        this._removeCardsFromHand(playerId, cards);
        this.collectedCards.push(...cards);
        this.gameState.pendingTablePoints += CardRules.calculateTotalScore(cards);

        const analysis = CardRules.analyze(cards, this.config.deckCount);
        if (analysis.type === 'BOMB_KING') {
            this.gameState.pendingTablePoints += (this.config.deckCount * 100);
        }

        this.gameState.lastPlayedCards = cards;
        this.gameState.consecutivePasses = 0;
        this.gameState.roundWinnerId = playerId;

        const isFinished = this.gameState.hands[playerId].length === 0;
        if (isFinished) {
            if (!this.gameState.finishedRank.includes(playerId)) {
                this.gameState.finishedRank.push(playerId);
            }
            // [新增] 玩家打完牌了，立即把其他人的牌推送给他看
            this._pushAllVisibleHandsTo(playerId);
        }

        const cardDesc = CardRules.getAnalysisText(analysis);
        let logText = `${currPlayer.name}: ${cardDesc}`;
        if (analysis.type === 'BOMB_KING') logText += ` (+${this.config.deckCount * 100}分)`;
        if (isFinished) logText += ` (牌出完了!)`;

        // [修改] 使用统一的通知方法
        this._notifyHandUpdate(playerId);

        // --- 结束判断逻辑 ---
        const isTeamMode = this.config.isTeamMode && (this.players.length % 2 === 0);
        let shouldEndGame = false;

        if (isTeamMode) {
            const activeTeams = new Set();
            this.players.forEach(p => {
                if (this.gameState.hands[p.id] && this.gameState.hands[p.id].length > 0) {
                    if (p.team !== undefined && p.team !== null) activeTeams.add(p.team);
                }
            });
            if (activeTeams.size <= 1) shouldEndGame = true;
        } else {
            let activeCount = 0;
            this.players.forEach(p => {
                if (this.gameState.hands[p.id] && this.gameState.hands[p.id].length > 0) activeCount++;
            });
            if (activeCount <= 1) shouldEndGame = true;
        }

        if (shouldEndGame) {
            // 先结算，再结束
            const activeCount = this._getActivePlayerCount();
            if (activeCount === 0) {
                this.gameState.roundPoints[playerId] = (this.gameState.roundPoints[playerId] || 0) + this.gameState.pendingTablePoints;
                this.gameState.pendingTablePoints = 0;
                this._clearTimer();
                const roundResult = this._concludeRound();
                return { success: true, isRoundOver: true, roundResult, cardsPlayed: cards, pendingPoints: 0, logText: logText + " - 游戏结束" };
            }

            if (this.gameState.lastShotPhase) {
                this.gameState.roundPoints[playerId] = (this.gameState.roundPoints[playerId] || 0) + this.gameState.pendingTablePoints;
                this.gameState.pendingTablePoints = 0;
                this._clearTimer();
                const roundResult = this._concludeRound();
                return { success: true, isRoundOver: true, roundResult, cardsPlayed: cards, pendingPoints: 0, logText: logText + " - 最后一手结束" };
            }

            this.gameState.lastShotPhase = true;
            this._advanceTurn();
            this._resetTimer();
            this.botManager.checkAndRun();
            return { success: true, isRoundOver: false, cardsPlayed: cards, pendingPoints: this.gameState.pendingTablePoints, logText: logText + " (最后一手)" };
        }

        this._advanceTurn();
        this._resetTimer();
        this.botManager.checkAndRun();

        return { success: true, isRoundOver: false, cardsPlayed: cards, pendingPoints: this.gameState.pendingTablePoints, logText };
    }

    passTurn(playerId) {
        if (!this.gameState) return { success: false, error: '游戏未开始' };

        const currPlayer = this.players[this.gameState.currentTurnIndex];
        if (currPlayer.id !== playerId) return { success: false, error: '还没轮到你' };

        if (this.gameState.lastPlayedCards.length === 0) {
            return { success: false, error: '必须出牌' };
        }

        this.gameState.consecutivePasses++;
        this._advanceTurn();

        const activeCount = this._getActivePlayerCount();
        const winnerId = this.gameState.roundWinnerId;
        const winnerHand = this.gameState.hands[winnerId];
        const winnerIsActive = winnerHand && winnerHand.length > 0;
        
        const passesNeeded = winnerIsActive ? (activeCount - 1) : activeCount;

        let turnCleared = false;
        let infoMessage = `${currPlayer.name}: 不要`;

        if (this.gameState.consecutivePasses >= passesNeeded) {
            const wId = this.gameState.roundWinnerId;
            if (wId) {
                this.gameState.roundPoints[wId] = (this.gameState.roundPoints[wId] || 0) + this.gameState.pendingTablePoints;
                this.gameState.pendingTablePoints = 0;

                // 接风逻辑
                if (this.gameState.hands[wId] && this.gameState.hands[wId].length > 0) {
                     const wIdx = this.players.findIndex(p => p.id === wId);
                     this.gameState.currentTurnIndex = wIdx;
                } else {
                    const winnerPlayer = this.players.find(p => p.id === wId);
                    if (!winnerPlayer) {
                         infoMessage = `${currPlayer.name}: 不要 (上家已离线)`;
                    } else {
                        const isTeamMode = this.config.isTeamMode && (this.players.length % 2 === 0);
                        if (isTeamMode && winnerPlayer.team !== undefined && winnerPlayer.team !== null) {
                            const wIdx = this.players.findIndex(p => p.id === wId);
                            const pCount = this.players.length;
                            let foundTeammate = false;
                            for (let i = 1; i < pCount; i++) {
                                const tIdx = (wIdx + i) % pCount; 
                                const potentialTeammate = this.players[tIdx];
                                if (potentialTeammate.team === winnerPlayer.team && 
                                    this.gameState.hands[potentialTeammate.id] && 
                                    this.gameState.hands[potentialTeammate.id].length > 0) {
                                    this.gameState.currentTurnIndex = tIdx;
                                    infoMessage = `${currPlayer.name}: 不要 (队友接风)`;
                                    this._broadcastUpdate(`${winnerPlayer.name} 已逃出，队友 ${potentialTeammate.name} 接风`);
                                    foundTeammate = true;
                                    break;
                                }
                            }
                            if (!foundTeammate) this._advanceTurn(); 
                        } else {
                            const wIdx = this.players.findIndex(p => p.id === wId);
                            let nextActiveIdx = wIdx;
                            let found = false;
                            for(let i=1; i<this.players.length; i++) {
                                let idx = (wIdx + i) % this.players.length;
                                if (this.gameState.hands[this.players[idx].id].length > 0) {
                                    nextActiveIdx = idx;
                                    found = true;
                                    break;
                                }
                            }
                            if (found) {
                                this.gameState.currentTurnIndex = nextActiveIdx;
                                infoMessage = `${currPlayer.name}: 不要 (${this.players[nextActiveIdx].name} 接风)`;
                                this._broadcastUpdate(`${winnerPlayer.name} 已逃出，下家 ${this.players[nextActiveIdx].name} 接风`);
                            }
                        }
                    }
                }
            }
            
            turnCleared = true;
            if (this.gameState.lastShotPhase) {
                const roundResult = this._concludeRound();
                return { success: true, isRoundOver: true, roundResult, turnCleared: true, logText: infoMessage + " - 无人接风，结束" };
            }

            this.gameState.lastPlayedCards = [];
            this.gameState.consecutivePasses = 0;
        }

        this._resetTimer(); 
        this.botManager.checkAndRun();

        return { success: true, turnCleared, logText: infoMessage };
    }

    _clearTimer() {
        if (this.timer) clearTimeout(this.timer);
        if (this.botManager) this.botManager.clearTimer();
        this.timer = null;
    }

    _resetTimer() {
        this._clearTimer();
        if (this.gameState && this._getActivePlayerCount() > 0) {
            this.turnStartTime = Date.now();
            const timeLimit = this.config.turnTimeout || 60000;
            this.timer = setTimeout(() => {
                this._handleTimeout();
            }, timeLimit);
        }
    }

    _handleTimeout() {
        if (!this.gameState) return;
        const currIdx = this.gameState.currentTurnIndex;
        const currPlayer = this.players[currIdx];
        
        const isNewRound = this.gameState.lastPlayedCards.length === 0;

        if (isNewRound) {
            const hand = this.gameState.hands[currPlayer.id];
            if (!hand || hand.length === 0) { 
                this._advanceTurn(); 
                this._resetTimer(); 
                this.botManager.checkAndRun();
                return; 
            }

            const sorted = hand.map(c => ({ id: c, val: CardRules.getPoint(c) })).sort((a, b) => a.val - b.val);
            const cardToPlay = [sorted[0].id]; 
            const result = this.playCards(currPlayer.id, cardToPlay);
            if (result.success) {
                this._notifyHandUpdate(currPlayer.id);
                const logText = result.logText || `${currPlayer.name} 超时出牌`;
                this._broadcastUpdate(logText);
                if (result.isRoundOver) {
                      setTimeout(() => {
                         this._handleWin(result, currPlayer.id);
                      }, 3000);
                }
            }
        } else {
            const result = this.passTurn(currPlayer.id);
            if (result.success) {
                if (result.isRoundOver) {
                      this._broadcastUpdate(`${currPlayer.name}: 超时过牌`);
                      setTimeout(() => {
                         this._handleWin(result, currPlayer.id);
                      }, 3000);
                } else {
                    this._broadcastUpdate(`${currPlayer.name}: 超时过牌`);
                }
            }
        }
    }

    _getActivePlayerCount() {
        if (!this.gameState) return 0;
        let count = 0;
        for (const p of this.players) {
            if (this.gameState.hands[p.id] && this.gameState.hands[p.id].length > 0) {
                count++;
            }
        }
        return count;
    }

    _advanceTurn() {
        const playerCount = this.players.length;
        let nextIndex = this.gameState.currentTurnIndex;
        let attempts = 0;
        do {
            nextIndex = (nextIndex + 1) % playerCount; 
            attempts++;
        } while (
            (this.gameState.hands[this.players[nextIndex].id] || []).length === 0 && 
            attempts < playerCount 
        );
        this.gameState.currentTurnIndex = nextIndex;
    }

    getPublicState() {
        if (!this.gameState) return null;
        
        const currentScoresDisplay = {};
        const roundPointsDisplay = {}; 
        const playersInfo = {};
        const handCounts = {};

        this.players.forEach(p => {
            const grand = this.grandScores[p.id] || 0;
            const round = this.gameState.roundPoints[p.id] || 0;
            currentScoresDisplay[p.id] = grand + round;
            roundPointsDisplay[p.id] = round; 
            
            playersInfo[p.id] = { 
                isBot: p.isBot, 
                isAutoPlay: p.isAutoPlay,
                team: p.team,
                autoPlayMode: p.autoPlayMode 
            };
            handCounts[p.id] = this.gameState.hands[p.id] ? this.gameState.hands[p.id].length : 0;
        });

        const winnerObj = this.players.find(p => p.id === this.gameState.roundWinnerId);

        let remainingSeconds = 0;
        if (this.turnStartTime) {
            const timeLimit = this.config.turnTimeout || 60000;
            const elapsed = Date.now() - this.turnStartTime;
            remainingSeconds = Math.max(0, Math.ceil((timeLimit - elapsed) / 1000));
        }
        
        return {
            turnIndex: this.gameState.currentTurnIndex,
            currentTurnId: this.players[this.gameState.currentTurnIndex].id,
            turnRemaining: remainingSeconds, 
            lastPlayed: this.gameState.lastPlayedCards,
            lastPlayerName: winnerObj ? winnerObj.name : '',
            scores: currentScoresDisplay,
            roundPoints: roundPointsDisplay, 
            pendingPoints: this.gameState.pendingTablePoints,
            finishedRank: this.gameState.finishedRank,
            playersInfo: playersInfo,
            handCounts: handCounts 
        };
    }

    reconnectPlayer(oldId, newId) {
        if (this.grandScores[oldId] !== undefined) {
            this.grandScores[newId] = this.grandScores[oldId];
            delete this.grandScores[oldId];
        }

        if (this.lastWinnerId === oldId) this.lastWinnerId = newId;

        let player = this.players.find(p => p.id === newId);
        if (!player) {
            player = this.players.find(p => p.id === oldId);
            if (player) player.id = newId;
        }

        if (player) {
             player.isAutoPlay = false; 
        }

        if (this.gameState) {
            if (this.gameState.hands && this.gameState.hands[oldId]) {
                this.gameState.hands[newId] = this.gameState.hands[oldId];
                delete this.gameState.hands[oldId];
            } else if (this.gameState.hands) {
                this.gameState.hands[newId] = [];
            }

            if (this.gameState.roundPoints[oldId] !== undefined) {
                this.gameState.roundPoints[newId] = this.gameState.roundPoints[oldId];
                delete this.gameState.roundPoints[oldId];
            }
            if (this.gameState.roundWinnerId === oldId) this.gameState.roundWinnerId = newId;
            
            const rankIdx = this.gameState.finishedRank.indexOf(oldId);
            if (rankIdx !== -1) {
                this.gameState.finishedRank[rankIdx] = newId;
            }
        }

        this.matchHistory.forEach(match => {
            if (match.scores[oldId] !== undefined) {
                match.scores[newId] = match.scores[oldId];
                delete match.scores[oldId];
            }
        });

        return true;
    }

    _handContainsCards(hand, cardsToPlay) {
        if (!hand) return false;
        const tempHand = [...hand];
        for (let c of cardsToPlay) {
            const idx = tempHand.indexOf(c);
            if (idx === -1) return false;
            tempHand.splice(idx, 1);
        }
        return true;
    }

    _removeCardsFromHand(playerId, cards) {
        if (!this.gameState.hands[playerId]) return;
        const newHand = [...this.gameState.hands[playerId]];
        for (let c of cards) {
            const idx = newHand.indexOf(c);
            if (idx !== -1) newHand.splice(idx, 1);
        }
        this.gameState.hands[playerId] = newHand;
    }

    _concludeRound() {
        const fullRankIds = [...this.gameState.finishedRank];
        this.players.forEach(p => {
            if (!fullRankIds.includes(p.id)) fullRankIds.push(p.id);
        });

        const firstWinnerId = fullRankIds[0];
        this.lastWinnerId = firstWinnerId;

        let logLines = []; 
        let penaltyDetails = []; 

        let currentRoundScores = {};
        this.players.forEach(p => {
            currentRoundScores[p.id] = (this.gameState.roundPoints[p.id] || 0);
        });

        const scoreBreakdown = {};
        this.players.forEach(p => {
             scoreBreakdown[p.id] = {
                 id: p.id,
                 name: p.name,
                 team: p.team,
                 tablePoints: this.gameState.roundPoints[p.id] || 0,
                 handCount: (this.gameState.hands[p.id] || []).length,
                 handScore: CardRules.calculateTotalScore(this.gameState.hands[p.id] || []),
                 penalty: 0,
                 final: 0,
                 finishRank: fullRankIds.indexOf(p.id) + 1
             };
        });

        let totalCardPenalty = 0;
        let penaltySources = [];
        
        this.players.forEach(p => {
            const h = this.gameState.hands[p.id] || [];
            const handPts = CardRules.calculateTotalScore(h);
            if (handPts > 0) {
                totalCardPenalty += handPts;
                penaltySources.push(`${p.name}(${handPts})`);
            }
        });

        if (firstWinnerId && totalCardPenalty > 0) {
            currentRoundScores[firstWinnerId] += totalCardPenalty;
            scoreBreakdown[firstWinnerId].penalty += totalCardPenalty;

            const winnerName = this.players.find(p=>p.id===firstWinnerId)?.name;
            logLines.push(`[手牌罚分] 输家剩余手牌分 (${penaltySources.join(', ')}) 共 ${totalCardPenalty} 分，归头游 ${winnerName}。`);
            penaltyDetails.push(`头游 ${winnerName} 收取手牌分 ${totalCardPenalty}`);
        }

        if (this.config.enableRankPenalty && this.config.rankPenaltyScores && this.config.rankPenaltyScores.length > 0) {
            const penaltyConfig = this.config.rankPenaltyScores;
            const playerCount = fullRankIds.length;
            
            penaltyConfig.forEach((score, index) => {
                const winnerIndex = index; 
                const loserIndex = playerCount - 1 - index; 

                if (winnerIndex < loserIndex) {
                    const winnerId = fullRankIds[winnerIndex];
                    const loserId = fullRankIds[loserIndex];
                    
                    if (winnerId && loserId) {
                        const winner = this.players.find(p=>p.id===winnerId);
                        const loser = this.players.find(p=>p.id===loserId);
                        
                        if (winner && loser) {
                            if (winner.team !== null && winner.team !== undefined && winner.team === loser.team) {
                                logLines.push(`[🛡️队友保护] 第${winnerIndex+1}名(${winner.name}) 与 倒数第${index+1}名(${loser.name}) 是队友，${score}分 免罚！`);
                                penaltyDetails.push(`[队友保护] ${winner.name} 免收 ${loser.name} ${score} 分`);
                            } else {
                                currentRoundScores[winnerId] += score;
                                currentRoundScores[loserId] -= score;
                                
                                scoreBreakdown[winnerId].penalty += score;
                                scoreBreakdown[loserId].penalty -= score;

                                logLines.push(`[排名赏罚] 第${winnerIndex+1}名 ${winner.name} 收取 倒数第${index+1}名 ${loser.name} ${score} 分。`);
                                penaltyDetails.push(`${loser.name} 排名进贡 ${winner.name} ${score} 分`);
                            }
                        }
                    }
                }
            });
        }

        this.players.forEach(p => {
            this.grandScores[p.id] += currentRoundScores[p.id];
            scoreBreakdown[p.id].final = currentRoundScores[p.id];
            
            if (this.gameState && this.gameState.roundPoints) {
                this.gameState.roundPoints[p.id] = 0;
            }
        });

        this.matchHistory.push({
            roundIndex: this.matchHistory.length + 1,
            scores: {...currentRoundScores}, 
            winnerId: firstWinnerId,
            details: penaltyDetails
        });

        const firstWinnerName = this.players.find(p => p.id === firstWinnerId)?.name || '未知';

        let isGrandOver = false;
        const targetScore = this.config.targetScore;
        const isTeamMode = this.config.isTeamMode && (this.players.length % 2 === 0);

        if (isTeamMode) {
            let redTotal = 0;
            let blueTotal = 0;
            this.players.forEach(p => {
                const s = this.grandScores[p.id] || 0;
                if (p.team === 0) redTotal += s;
                else if (p.team === 1) blueTotal += s;
            });
            
            if (redTotal >= targetScore || blueTotal >= targetScore) {
                isGrandOver = true;
            }
        } else {
            const maxScore = Math.max(...Object.values(this.grandScores));
            if (maxScore >= targetScore) {
                isGrandOver = true;
            }
        }

        const totalPointsEarned = currentRoundScores[firstWinnerId];

        return {
            roundWinnerName: firstWinnerName,
            pointsEarned: totalPointsEarned, 
            detail: logLines.join('\n') || '完美结束，未设置额外罚分', 
            grandScores: this.grandScores,
            isGrandOver,
            scoreBreakdown
        };
    }
    
    getPlayerHand(playerId) {
        if (!this.gameState || !this.gameState.hands) return [];
        return this.gameState.hands[playerId] || [];
    }
}

module.exports = GameManager;

================================================================================
FILE PATH: server\game\SeatManager.js
================================================================================
const CardRules = require('./CardRules');
const Deck = require('./Deck');

class SeatManager {
    constructor(io, roomId, players, isTeamMode) {
        this.io = io;
        this.roomId = roomId;
        this.players = players; 
        this.isTeamMode = isTeamMode; 

        // 生成一副牌，洗牌
        const deck = new Deck(1);
        deck.shuffle();
        
        // [修改] 优化抽牌池生成逻辑：优先保证点数不重复
        // 这样玩家抽到的牌大概率是 3, 5, K, A 这种纯数字大小比较，不用比花色
        const distinctCards = [];
        const seenPoints = new Set();
        const leftovers = [];

        for (let card of deck.deck) {
            const p = CardRules.getPoint(card);
            if (!seenPoints.has(p)) {
                seenPoints.add(p);
                distinctCards.push(card);
            } else {
                leftovers.push(card);
            }
        }

        // 优先用不重复的牌，如果不够（极少情况）再用剩下的补
        const pool = [...distinctCards, ...leftovers];
        
        // 取出等于玩家数量的牌作为“签”
        this.availableCards = pool.slice(0, players.length);
        
        // 记录谁抽了什么 { playerId: cardVal }
        this.drawResults = {};
        
        // 记录当前还剩哪些位置的牌没被翻开
        this.pendingIndices = this.availableCards.map((_, i) => i);
    }

    reconnectPlayer(oldId, newId) {
        if (this.drawResults[oldId] !== undefined) {
            this.drawResults[newId] = this.drawResults[oldId];
            delete this.drawResults[oldId];
            console.log(`[SeatManager] Player reconnected: ${oldId} -> ${newId}, restored draw result.`);
        }
    }

    playerDraw(playerId, cardIndex) {
        if (this.drawResults[playerId] !== undefined) return { success: false, msg: '你已经抽过牌了' };

        const idxInPending = this.pendingIndices.indexOf(cardIndex);
        if (idxInPending === -1) return { success: false, msg: '这张牌已经被被人抽走了' };

        this.pendingIndices.splice(idxInPending, 1);

        const cardVal = this.availableCards[cardIndex];
        this.drawResults[playerId] = cardVal;

        const isFinished = Object.keys(this.drawResults).length === this.players.length;

        return { 
            success: true, 
            cardVal, 
            cardIndex, 
            isFinished 
        };
    }

    finalizeSeats() {
        const results = this.players.map(p => {
            const card = this.drawResults[p.id];
            
            // [安全保护] 如果玩家数据异常，提供默认值防止崩溃
            if (card === undefined) {
                console.error(`[SeatManager] Critical Error: Player ${p.name} (${p.id}) missing draw card!`);
                return { ...p, drawCard: 0, sortVal: 0 };
            }

            return {
                ...p,
                drawCard: card,
                sortVal: CardRules.getSortValue(card) 
            };
        });

        results.sort((a, b) => {
            if (b.sortVal !== a.sortVal) return b.sortVal - a.sortVal;
            return CardRules.getSuitSortValue(b.drawCard) - CardRules.getSuitSortValue(a.drawCard);
        });

        let newOrder = [];

        if (this.isTeamMode) {
            const mid = Math.ceil(results.length / 2);
            const bigTeam = results.slice(0, mid); 
            const smallTeam = results.slice(mid);  

            const maxLen = Math.max(bigTeam.length, smallTeam.length);
            for (let i = 0; i < maxLen; i++) {
                if (bigTeam[i]) newOrder.push(bigTeam[i]); 
                if (smallTeam[i]) newOrder.push(smallTeam[i]); 
            }
        } else {
            newOrder = results;
        }

        return {
            newPlayers: newOrder,
            drawDetails: this.drawResults 
        };
    }
}

module.exports = SeatManager;

================================================================================
FILE PATH: server\handlers\gameHandler.js
================================================================================
const SeatManager = require('../game/SeatManager');
const GameManager = require('../game/GameManager');

module.exports = (io, socket, rooms) => {

    // 辅助函数：广播游戏状态
    const broadcastGameState = (roomId, room, infoText = null) => {
        if (!room.gameManager) return;
        const publicState = room.gameManager.getPublicState();
        if (!publicState) return;
        if (infoText) publicState.infoText = infoText;
        io.to(roomId).emit('game_state_update', publicState);
    };

    // 辅助函数：广播房间信息（用于大厅/房间等待阶段）
    const broadcastRoomInfo = (roomId, room) => {
        const currentGrandScores = room.gameManager ? room.gameManager.grandScores : {};
        // 确保所有玩家都有大分记录
        if (Object.keys(currentGrandScores).length === 0) {
            room.players.forEach(p => {
                if (currentGrandScores[p.id] === undefined) currentGrandScores[p.id] = 0;
            });
        }
        
        const spectatorCount = room.spectators ? room.spectators.length : 0;

        io.to(roomId).emit('room_info', { 
            roomId, 
            config: room.config, 
            players: room.players, 
            grandScores: currentGrandScores,
            spectatorCount
        });
    };

    // 处理游戏开始逻辑
    const handleGameStart = (roomId, isNextRound) => {
        const room = rooms[roomId];
        if (!room) return;

        // 如果是新一局或没有管理器，重新实例化
        if (!isNextRound || !room.gameManager) {
            room.gameManager = new GameManager(room.config, room.players, io, roomId);
        }

        const startInfo = room.gameManager.startRound(isNextRound);

        // 给每个非机器人玩家发送手牌
        room.players.forEach((p) => {
            if (!p.isBot) { 
                const hand = startInfo.hands[p.id];
                io.to(p.id).emit('game_started', { 
                    hand: hand, 
                    grandScores: room.gameManager.grandScores,
                    handCounts: room.gameManager.getPublicState().handCounts
                });
            }
        });

        // [新增] 向观众发送游戏开始信号
        if (room.spectators) {
            room.spectators.forEach(s => {
                io.to(s.id).emit('game_started', {
                    hand: [],
                    startPlayerId: startInfo.startPlayerId,
                    grandScores: room.gameManager.grandScores,
                    handCounts: room.gameManager.getPublicState().handCounts,
                    isSpectator: true
                });
            });
        }

        const startPlayerName = room.players[startInfo.startPlayerIndex].name;
        const msg = isNextRound 
            ? `新一轮开始！由 ${startPlayerName} 先出` 
            : `游戏开始！目标 ${room.config.targetScore} 分`;
        
        broadcastGameState(roomId, room, msg);
    };

    // --- 事件监听 (仅保留游戏相关) ---

    // 1. 开始游戏 (抽牌/直接开始)
    socket.on('start_game', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room) return;
        
        const player = room.players.find(p => p.id === socket.id);
        if (!player || !player.isHost) return socket.emit('error_msg', '只有房主可以开始游戏');
        if (room.players.length < 2) return socket.emit('error_msg', '人数不足');

        // 清理旧的游戏管理器
        if (room.gameManager) {
            if (room.gameManager._clearTimer) room.gameManager._clearTimer();
            room.gameManager = null;
        }
        
        // 组队模式人数检查
        if (room.config.isTeamMode && room.players.length % 2 !== 0) {
            room.config.isTeamMode = false;
            io.to(roomId).emit('error_msg', '人数为奇数，已自动关闭组队模式');
            broadcastRoomInfo(roomId, room);
        }

        const isTeamMode = room.config.isTeamMode && (room.players.length % 2 === 0);
        
        // 初始化座位管理器 (用于抽牌选座)
        room.seatManager = new SeatManager(io, roomId, room.players, isTeamMode);
        
        // 通知前端进入抽牌阶段
        io.to(roomId).emit('enter_draw_phase', { totalCards: room.players.length });
        
        // 机器人自动抽牌逻辑
        const bots = room.players.filter(p => p.isBot);
        bots.forEach((bot, i) => {
            setTimeout(() => {
                if (!rooms[roomId]) return; 

                if(room.seatManager) {
                    const availableIdx = room.seatManager.pendingIndices[0];
                    if (availableIdx !== undefined) {
                        const res = room.seatManager.playerDraw(bot.id, availableIdx);
                        if(res.success) {
                            io.to(roomId).emit('seat_draw_update', {
                                index: res.cardIndex,
                                val: res.cardVal,
                                playerId: bot.id,
                                name: bot.name
                            });
                            // 检查是否所有人都抽完了
                            if (res.isFinished) {
                                setTimeout(() => {
                                    if (!rooms[roomId]) return;
                                    const { newPlayers } = room.seatManager.finalizeSeats();
                                    room.players = newPlayers;
                                    room.seatManager = null;
                                    io.to(roomId).emit('seat_draw_finished', { players: newPlayers });
                                    setTimeout(() => handleGameStart(roomId, false), 3000);
                                }, 1000);
                            }
                        }
                    }
                }
            }, 1000 + i * 1500); 
        });
    });

    // 2. 玩家抽座次牌
    socket.on('draw_seat_card', ({ roomId, cardIndex }) => {
        const room = rooms[roomId];
        if (!room || !room.seatManager) return;

        const result = room.seatManager.playerDraw(socket.id, cardIndex);
        if (!result.success) return socket.emit('error_msg', result.msg);

        const player = room.players.find(p => p.id === socket.id);
        io.to(roomId).emit('seat_draw_update', {
            index: cardIndex,
            val: result.cardVal,
            playerId: socket.id,
            name: player ? player.name : '未知'
        });

        if (result.isFinished) {
            setTimeout(() => {
                if (!rooms[roomId]) return; 

                const { newPlayers, drawDetails } = room.seatManager.finalizeSeats();
                room.players = newPlayers;
                room.seatManager = null; 

                io.to(roomId).emit('seat_draw_finished', {
                    players: newPlayers,
                    details: drawDetails
                });

                setTimeout(() => handleGameStart(roomId, false), 3000);
            }, 1000); 
        }
    });

    // 3. 下一局
    socket.on('next_round', ({ roomId }) => handleGameStart(roomId, true));

    // 4. 出牌
    socket.on('play_cards', ({ roomId, cards }) => {
        const room = rooms[roomId];
        if (!room || !room.gameManager) return;
        
        const result = room.gameManager.playCards(socket.id, cards);

        if (!result.success) return socket.emit('play_error', result.error);

        const currentHand = room.gameManager.gameState.hands[socket.id];
        io.to(socket.id).emit('hand_update', currentHand);

        if (result.isRoundOver) { 
            if (result.cardsPlayed && result.cardsPlayed.length > 0) {
                 broadcastGameState(roomId, room, result.logText);
            }

            setTimeout(() => {
                if (!rooms[roomId]) return;
                room.gameManager._handleWin(result, socket.id);

                // 如果大局结束，清理 GameManager
                if (result.roundResult.isGrandOver) {
                    room.gameManager = null; 
                }
            }, 3000); 
        } else {
            broadcastGameState(roomId, room, result.logText);
        }
    });

    // 5. 不要/过牌
    socket.on('pass_turn', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room || !room.gameManager) return;

        const result = room.gameManager.passTurn(socket.id);
        if (!result.success) return socket.emit('play_error', result.error);

        if (result.isRoundOver) {
            broadcastGameState(roomId, room, result.logText);
            
            setTimeout(() => {
                if (!rooms[roomId]) return;
                room.gameManager._handleWin(result, socket.id);
                
                if (result.roundResult && result.roundResult.isGrandOver) {
                    room.gameManager = null;
                }
            }, 3000);
        } else {
            broadcastGameState(roomId, room, result.logText || "PASS");
        }
    });

    // 6. 切换托管开关
    socket.on('toggle_auto_play', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room || !room.gameManager) return;

        room.gameManager.toggleAutoPlay(socket.id);
        broadcastGameState(roomId, room);
    });

    // 7. 切换托管模式 (智能/省钱/躺平)
    socket.on('switch_autoplay_mode', ({ roomId, mode }) => {
        const room = rooms[roomId];
        if (!room || !room.gameManager) return;

        room.gameManager.setPlayerAutoPlayMode(socket.id, mode);
        broadcastGameState(roomId, room);
    });

    // 8. 请求提示
    socket.on('request_hint', ({ roomId }) => {
        const room = rooms[roomId];
        if (room && room.gameManager) {
            const cards = room.gameManager.getHint(socket.id);
            socket.emit('hint_response', cards);
        }
    });
};

================================================================================
FILE PATH: server\handlers\roomHandler.js
================================================================================
module.exports = (io, socket, rooms) => {
    
    // --- 基础连接检测 ---
    socket.on('ping', (callback) => {
        if (typeof callback === 'function') {
            callback();
        }
    });

    // --- 辅助函数：广播房间信息 ---
    const broadcastRoomInfo = (roomId) => {
        const room = rooms[roomId];
        if (!room) return;
        
        const currentGrandScores = room.gameManager ? room.gameManager.grandScores : {};
        // 如果没有积分数据，初始化为0
        if (Object.keys(currentGrandScores).length === 0) {
            room.players.forEach(p => currentGrandScores[p.id] = 0);
        }

        // 广播时带上观众人数
        const spectatorCount = room.spectators ? room.spectators.length : 0;

        const data = { 
            roomId, 
            config: room.config, 
            players: room.players, 
            grandScores: currentGrandScores,
            spectatorCount 
        };
        io.to(roomId).emit('room_info', data);
    };

    // --- 辅助函数：广播游戏状态 ---
    const broadcastGameState = (roomId, room, infoText = null) => {
        if (!room.gameManager) return;
        const publicState = room.gameManager.getPublicState();
        if (!publicState) return;
        if (infoText) publicState.infoText = infoText;
        io.to(roomId).emit('game_state_update', publicState);
    };

    // ==========================================
    //               房间管理事件
    // ==========================================

    socket.on('create_room', ({ roomId, username, config }) => {
        // [修改] 智能房间覆盖逻辑 (实现“顶替”)
        if (rooms[roomId]) {
            const room = rooms[roomId];
            
            if (room.isPermanent) {
                 return socket.emit('error_msg', '常驻房间已存在，请直接加入');
            }

            // 检查是否有真人在线 (排除 Bot)
            const hasOnlineRealPlayers = room.players.some(p => !p.isBot && p.online);

            // 核心逻辑：如果房间存在，但没有真人在线（所有人已离开或断线），视为“僵尸房间”
            // 此时用户显式点击“创建”，说明意图是“开新局”，因此直接销毁旧房间
            if (!hasOnlineRealPlayers) {
                console.log(`[Room] Overwriting empty zombie room ${roomId}`);
                // 清理旧定时器
                if (room.destroyTimer) clearTimeout(room.destroyTimer);
                // 彻底删除旧房间数据，后续代码会重新创建全新的
                delete rooms[roomId];
            } else {
                // 如果还有人在线，才报“已存在”
                return socket.emit('error_msg', '房间已存在且有人在线，请更换房间号');
            }
        }
        
        const cleanName = String(username || '').trim();
        if (!cleanName) return socket.emit('error_msg', '用户名不能为空');

        const roomConfig = { 
            deckCount: 1, 
            maxPlayers: 3, 
            targetScore: 500, 
            shuffleStrategy: 'CLASSIC',
            ...config 
        };
        
        rooms[roomId] = {
            config: roomConfig,
            players: [],
            spectators: [], // 观众列表
            gameManager: null,
            seatManager: null, 
            destroyTimer: null 
        };
        
        socket.join(roomId);
        rooms[roomId].players.push({ id: socket.id, name: cleanName, isHost: true, online: true });
        
        broadcastRoomInfo(roomId);
    });

    // 加入房间逻辑 (支持观战)
    socket.on('join_room', ({ roomId, username }) => {
        const room = rooms[roomId];
        if (!room) return socket.emit('error_msg', '房间不存在');

        const cleanName = String(username || '').trim();
        if (!cleanName) return socket.emit('error_msg', '用户名不能为空');

        const existingPlayerIndex = room.players.findIndex(p => p.name === cleanName);
        let isReconnect = false;
        let oldSocketId = null;

        if (existingPlayerIndex !== -1) {
            // --- 重连逻辑 ---
            const existingPlayer = room.players[existingPlayerIndex];
            
            if (existingPlayer.online && existingPlayer.id !== socket.id) {
                 const oldSocket = io.sockets.sockets.get(existingPlayer.id);
                 if (oldSocket) {
                     oldSocket.emit('error_msg', '您的账号已在其他页面登录');
                     oldSocket.disconnect(); 
                 }
            }

            isReconnect = true;
            oldSocketId = existingPlayer.id;
            existingPlayer.id = socket.id;
            existingPlayer.online = true; 

            // 既然有人重连回来了，取消销毁定时器
            if (room.destroyTimer) {
                clearTimeout(room.destroyTimer);
                room.destroyTimer = null;
            }

            if (room.gameManager) room.gameManager.reconnectPlayer(oldSocketId, socket.id);
            if (room.seatManager) room.seatManager.reconnectPlayer(oldSocketId, socket.id);

            socket.join(roomId);
        } else {
            // --- 新玩家或观众逻辑 ---
            const isFull = room.players.length >= room.config.maxPlayers;
            const isGameRunning = room.gameManager && room.gameManager.gameState;

            if (isFull || isGameRunning) {
                // 进入观战模式
                socket.join(roomId);
                if (!room.spectators) room.spectators = [];
                const existingSpec = room.spectators.find(s => s.id === socket.id);
                if (!existingSpec) {
                    room.spectators.push({ id: socket.id, name: cleanName });
                }
                socket.emit('spectator_join', { message: '房间已满或游戏中，您已进入观战模式' });
            } else {
                // 正常加入
                socket.join(roomId);
                if (!room.players.find(u => u.id === socket.id)) {
                    const hasHost = room.players.some(p => p.isHost && p.online);
                    const isHost = !hasHost;
                    room.players.push({ id: socket.id, name: cleanName, isHost: isHost, online: true });
                }
            }
        }

        broadcastRoomInfo(roomId);

        // 如果游戏进行中，发送状态
        if (room.gameManager && room.gameManager.gameState) {
            if (isReconnect) {
                const hand = room.gameManager.getPlayerHand(socket.id);
                socket.emit('game_started', { 
                    hand: hand, 
                    grandScores: room.gameManager.grandScores,
                    handCounts: room.gameManager.getPublicState().handCounts
                });
            } else {
                // 观众或新加入者
                socket.emit('game_started', { 
                    hand: [], 
                    grandScores: room.gameManager.grandScores,
                    handCounts: room.gameManager.getPublicState().handCounts,
                    isSpectator: true 
                });
            }
            broadcastGameState(roomId, room);
        }
        
        // 抓牌阶段同步 (如果存在 SeatManager)
        if (room.seatManager && room.seatManager.drawResults) {
             socket.emit('enter_draw_phase', { totalCards: room.players.length });
             Object.entries(room.seatManager.drawResults).forEach(([pid, val]) => {
                 const pName = room.players.find(p=>p.id===pid)?.name || '未知';
                 let cardIndex = -1;
                 room.seatManager.availableCards.forEach((c, idx) => { if (c === val) cardIndex = idx; });
                 socket.emit('seat_draw_update', { index: cardIndex, val: val, playerId: pid, name: pName });
             });
        }
    });

    socket.on('update_room_config', ({ roomId, config }) => {
        const room = rooms[roomId];
        if (!room) return;
        const player = room.players.find(p => p.id === socket.id);
        if (!player || !player.isHost) return socket.emit('error_msg', '只有房主可以修改规则');
        if (room.gameManager || room.seatManager) return socket.emit('error_msg', '游戏进行中无法修改规则');

        if (config.isNoShuffleMode !== undefined) room.config.shuffleStrategy = config.isNoShuffleMode ? 'NO_SHUFFLE' : 'CLASSIC';
        if (config.shuffleStrategy) room.config.shuffleStrategy = config.shuffleStrategy;

        room.config = { ...room.config, ...config };
        broadcastRoomInfo(roomId);
    });

    socket.on('add_bot', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room) return;
        if (room.players.length >= room.config.maxPlayers) return socket.emit('error_msg', '房间已满');
        
        const botId = `bot_${Date.now()}_${Math.floor(Math.random()*1000)}`;
        let botName = `Bot_${Date.now().toString().slice(-4)}`;
        room.players.push({ id: botId, name: botName, isHost: false, online: true, isBot: true });
        broadcastRoomInfo(roomId);
    });

    socket.on('kick_player', ({ roomId, targetId }) => {
        const room = rooms[roomId];
        if (!room) return;
        const sender = room.players.find(p => p.id === socket.id);
        if (!sender || !sender.isHost) return socket.emit('error_msg', '只有房主可以踢人');
        if (room.gameManager || room.seatManager) return socket.emit('error_msg', '游戏进行中无法踢人');

        const targetIndex = room.players.findIndex(p => p.id === targetId);
        if (targetIndex === -1) return;
        const targetPlayer = room.players[targetIndex];
        if (targetPlayer.id === socket.id) return;

        room.players.splice(targetIndex, 1);
        if (!targetPlayer.isBot) {
            io.to(targetPlayer.id).emit('kicked', '你已被房主移出房间');
            const targetSocket = io.sockets.sockets.get(targetPlayer.id);
            if (targetSocket) targetSocket.leave(roomId);
        }
        broadcastRoomInfo(roomId);
    });

    socket.on('switch_seat', ({ roomId, index1, index2 }) => {
        const room = rooms[roomId];
        if (!room) return;
        const requestPlayer = room.players.find(p => p.id === socket.id);
        if (!requestPlayer || !requestPlayer.isHost) return socket.emit('error_msg', '只有房主可以调整座位');
        if (room.gameManager && room.gameManager.gameState) return socket.emit('error_msg', '游戏中无法调整座位');
        if (index1 < 0 || index1 >= room.players.length || index2 < 0 || index2 >= room.players.length) return;

        const temp = room.players[index1];
        room.players[index1] = room.players[index2];
        room.players[index2] = temp;
        broadcastRoomInfo(roomId);
    });

    // ==========================================
    //          断开连接处理 (智能销毁逻辑)
    // ==========================================
    
    socket.on('disconnecting', () => {
        const roomsToLeave = [...socket.rooms];
        roomsToLeave.forEach(roomId => {
            const room = rooms[roomId];
            if (room) {
                // 1. 处理观众离开
                if (room.spectators) {
                    const specIndex = room.spectators.findIndex(s => s.id === socket.id);
                    if (specIndex !== -1) {
                        console.log(`[Spectator] Left: ${room.spectators[specIndex].name}`);
                        room.spectators.splice(specIndex, 1);
                        broadcastRoomInfo(roomId);
                        return; // 如果是观众，处理完就退出，不涉及玩家逻辑
                    }
                }

                // 2. 处理正式玩家离开
                const player = room.players.find(p => p.id === socket.id);
                if (player) {
                    console.log(`[Disconnect] Player ${player.name} (${player.id}) disconnected from room ${roomId}`);
                    
                    if (room.gameManager && room.gameManager.gameState) {
                        // 游戏进行中：标记离线，不移除
                        player.online = false;
                        broadcastRoomInfo(roomId);
                        // 如果开启了托管，自动接管
                        if (!player.isAutoPlay && !player.isBot) {
                            player.isAutoPlay = true;
                            room.gameManager.botManager.checkAndRun();
                            broadcastGameState(roomId, room, `${player.name} 断线，自动托管`);
                        }
                    } else {
                        // 游戏未开始：直接移除
                        room.players = room.players.filter(p => p.id !== socket.id);
                        
                        // 移交房主权限
                        if (player.isHost && room.players.length > 0) {
                            const nextHost = room.players.find(p => !p.isBot && p.online) || room.players[0];
                            nextHost.isHost = true;
                        }
                        
                        broadcastRoomInfo(roomId);
                    }

                    // 检查是否空房间 (全是 Bot 或无人)
                    const realPlayers = room.players.filter(p => !p.isBot);
                    const onlineRealPlayers = realPlayers.filter(p => p.online);

                    // 房间变空了，开始销毁倒计时
                    if (onlineRealPlayers.length === 0) {
                        if (!room.isPermanent) {
                             if (room.destroyTimer) clearTimeout(room.destroyTimer);
                             
                             // [关键逻辑] 智能判断销毁延迟：
                             // 1. 如果游戏从未开始（gameManager 为空） -> 纯大厅空置 -> 2秒销毁
                             // 2. 如果游戏已开始或已结束（gameManager 存在） -> 保留 5分钟（允许断线重连或查看战绩）
                             
                             const hasGameData = !!room.gameManager; 
                             const destroyDelay = hasGameData ? 300000 : 2000; // 5分钟 vs 2秒
                             
                             room.destroyTimer = setTimeout(() => {
                                 console.log(`[Room] Destroying empty room ${roomId} (Delay: ${destroyDelay}ms)`);
                                 delete rooms[roomId];
                             }, destroyDelay); 
                        }
                    }
                }
            }
        });
    });
};

================================================================================
FILE PATH: server\index.js
================================================================================
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const cors = require('cors');
const path = require('path');

// [修复] 引入配置文件和逻辑处理器
const { PERMANENT_ROOMS, GLOBAL_CONFIG } = require('./config/constants');
const registerRoomHandlers = require('./handlers/roomHandler');
const registerGameHandlers = require('./handlers/gameHandler');

const app = express();
app.use(cors());

const server = http.createServer(app);
const io = new Server(server, {
    cors: {
        origin: "*", 
        methods: ["GET", "POST"]
    }
});

// 全局房间数据存储
const rooms = {};

// [修复] 初始化常驻房间 (根据 constants.js 配置)
if (PERMANENT_ROOMS) {
    Object.entries(PERMANENT_ROOMS).forEach(([id, config]) => {
        rooms[id] = {
            config: config,
            players: [],
            gameManager: null,
            seatManager: null,
            isPermanent: true
        };
        console.log(`[Init] Permanent room ${id} created.`);
    });
}

io.on('connection', (socket) => {
    console.log(`User Connected: ${socket.id}`);
    registerRoomHandlers(io, socket, rooms);
    registerGameHandlers(io, socket, rooms);

    // 断开连接处理
    socket.on('disconnect', () => {
        console.log('User Disconnected', socket.id);
        
        // 遍历房间，标记玩家离线
        for (const roomId in rooms) {
            const room = rooms[roomId];
            const player = room.players.find(p => p.id === socket.id);
            
            if (player) {
                player.online = false;
                // 如果在游戏中，可能需要通知其他人 (gameHandler 中通常会有更细致的处理，这里仅做基础标记)
                // 广播房间最新信息，让前端看到灰头像
                const currentGrandScores = room.gameManager ? room.gameManager.grandScores : {};
                if (Object.keys(currentGrandScores).length === 0 && room.players.length > 0) {
                     room.players.forEach(p => currentGrandScores[p.id] = (room.gameManager?.grandScores?.[p.id] || 0));
                }

                io.to(roomId).emit('room_info', { 
                    roomId, 
                    config: room.config, 
                    players: room.players, 
                    grandScores: currentGrandScores 
                });
                
                // 如果是临时房间且空了，可以在这里加清理逻辑（目前为了断线重连保留房间）
            }
        }
    });
});

// 错误处理
process.on('uncaughtException', (err) => {
    console.error('[FATAL ERROR] Uncaught Exception:', err);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('[FATAL ERROR] Unhandled Rejection at:', promise, 'reason:', reason);
});

// 生产环境静态文件服务
if (process.env.NODE_ENV === 'production') {
    const buildPath = path.join(__dirname, '../client/dist');
    app.use(express.static(buildPath));
    app.get(/(.*)/, (req, res) => {
        res.sendFile(path.join(__dirname, '../client/dist', 'index.html'));
    });
}

const PORT = process.env.PORT || GLOBAL_CONFIG.SERVER_PORT || 3001;
server.listen(PORT, () => {
    console.log(`>>> Server Running on port ${PORT}`);
});

================================================================================
FILE PATH: server\package.json
================================================================================
{
  "name": "server",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^5.2.1",
    "nodemon": "^3.1.11",
    "socket.io": "^4.8.1"
  }
}


================================================================================
FILE PATH: server\utils\socketAuth.js
================================================================================
// (可选) 身份验证工具
