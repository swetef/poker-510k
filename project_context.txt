Project Context Generated at 2025/12/18 17:35:10


================================================================================
FILE PATH: client\eslint.config.js
================================================================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])


================================================================================
FILE PATH: client\index.html
================================================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    
    <!-- [å…³é”®ä¿®æ”¹] å¢åŠ  viewport-fit=cover è§£å†³é¡¶éƒ¨é»‘è¾¹é—®é¢˜ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    
    <link rel="manifest" href="/manifest.json">
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="510Kå¯¹æˆ˜">
    
    <title>client</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

================================================================================
FILE PATH: client\package.json
================================================================================
{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "lucide-react": "^0.559.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "socket.io-client": "^4.8.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "vite": "npm:rolldown-vite@7.2.5"
  },
  "overrides": {
    "vite": "npm:rolldown-vite@7.2.5"
  }
}


================================================================================
FILE PATH: client\src\App.css
================================================================================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}


================================================================================
FILE PATH: client\src\App.jsx
================================================================================
import React from 'react';
import { RefreshCw, AlertCircle } from 'lucide-react'; 
// [ä¿®æ”¹] å¼•å…¥ useGame
import { useGame } from './context/GameContext.jsx';

import { LoginScreen } from './screens/LoginScreen.jsx';
import { LobbyScreen } from './screens/LobbyScreen.jsx';
import { GameScreen } from './screens/GameScreen.jsx';
import { DrawSeatScreen } from './screens/DrawSeatScreen.jsx';

export default function App() {
  // [ä¿®æ”¹] ç›´æ¥ä» Context è·å–éœ€è¦çš„çŠ¶æ€
  const { gameState, isConnected } = useGame();

  const renderLandscapeHint = () => (
      <div className="landscape-hint">
          <div className="phone-rotate-icon"></div>
          <h3 style={{marginBottom: 10, fontSize: 18}}>å»ºè®®ä½¿ç”¨æ¨ªå±æ¸¸ç©</h3>
          <p style={{fontSize: 14, opacity: 0.8, maxWidth: 250}}>
              510K éœ€è¦è¾ƒå¤§çš„å±•ç¤ºç©ºé—´ã€‚<br/>
              è¯·æ—‹è½¬æ‚¨çš„æ‰‹æœºä»¥è·å¾—æœ€ä½³ä½“éªŒã€‚
          </p>
          <button 
            style={{marginTop: 20, padding: '8px 20px', background: 'rgba(255,255,255,0.2)', color:'white', border:'1px solid white'}}
            onClick={(e) => { e.currentTarget.parentElement.style.display = 'none'; }}
          >
              æˆ‘éè¦ç«–å±ç©
          </button>
      </div>
  );

  const renderDisconnectAlert = () => (
      !isConnected && (
          <div style={{
              position: 'fixed', top: 0, left: 0, right: 0, zIndex: 9999,
              background: '#e74c3c', color: 'white', padding: '10px',
              display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 10,
              boxShadow: '0 2px 10px rgba(0,0,0,0.2)'
          }}>
              <AlertCircle size={20} />
              <span style={{fontWeight: 'bold'}}>è¿æ¥å·²æ–­å¼€ï¼Œæ­£åœ¨å°è¯•é‡è¿...</span>
              <button 
                onClick={() => window.location.reload()} 
                style={{
                    background: 'white', color: '#e74c3c', border: 'none', 
                    borderRadius: 20, padding: '4px 12px', fontSize: 12, fontWeight: 'bold',
                    cursor: 'pointer', display: 'flex', alignItems: 'center', gap: 4
                }}
              >
                  <RefreshCw size={12} /> åˆ·æ–°é‡è¿
              </button>
          </div>
      )
  );

  return (
    <>
      {renderDisconnectAlert()}
      {renderLandscapeHint()}
      
      {/* [ä¿®æ”¹] å­ç»„ä»¶ä¸å†éœ€è¦ä¼ å‚ï¼Œå®ƒä»¬ä¼šè‡ªå·±å» Context é‡Œæ‹¿æ•°æ® */}
      {gameState === 'LOGIN' && <LoginScreen />}
      
      {gameState === 'LOBBY' && <LobbyScreen />}
      
      {gameState === 'DRAW_SEATS' && <DrawSeatScreen />}
      
      {gameState === 'GAME' && <GameScreen />}
    </>
  );
}

================================================================================
FILE PATH: client\src\components\BaseUI.jsx
================================================================================
import React, { useEffect, useRef, useState } from 'react'; 
import { Coins, History, Trophy, Flag, ChevronDown, ChevronUp, Shield } from 'lucide-react'; 
import { getCardDisplay } from '../utils/cardLogic.js';
import { styles } from '../styles.js';
import CountDownTimer from './CountDownTimer.jsx'; 

export const GameLogPanel = ({ logs }) => {
    const [isCollapsed, setIsCollapsed] = useState(false); 
    const endRef = useRef(null);

    useEffect(() => {
        if (!isCollapsed) {
            endRef.current?.scrollIntoView({ behavior: 'smooth' });
        }
    }, [logs, isCollapsed]);

    return (
        <div 
            style={{
                ...styles.gameLogPanel,
                zIndex: 1000,
                height: isCollapsed ? 36 : 140, 
                background: 'transparent', 
                backdropFilter: 'none',
                border: isCollapsed ? 'none' : '1px solid rgba(255, 255, 255, 0.1)',
                boxShadow: 'none',
                cursor: 'pointer',
                textShadow: '1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 0 2px 4px rgba(0,0,0,0.8)'
            }}
            onClick={() => setIsCollapsed(!isCollapsed)} 
        >
            <div style={styles.logHeader}>
                <History size={14} color="#f1c40f" style={{filter: 'drop-shadow(0 1px 2px rgba(0,0,0,0.8))'}}/> 
                <span style={{color:'#fff', fontWeight:'bold', flex: 1}}>
                    å¯¹å±€è®°å½•
                </span>
                {isCollapsed ? <ChevronDown size={14} color="#ccc" style={{filter: 'drop-shadow(0 1px 2px rgba(0,0,0,0.8))'}}/> : <ChevronUp size={14} color="#ccc" style={{filter: 'drop-shadow(0 1px 2px rgba(0,0,0,0.8))'}}/>}
            </div>
            
            <div style={{
                ...styles.logList, 
                opacity: isCollapsed ? 0 : 1,
                pointerEvents: isCollapsed ? 'none' : 'auto'
            }}>
                {logs.map((log, i) => (
                    <div key={i} style={styles.logItem}>
                        <span style={styles.logTime}>[{log.time.split(' ')[0]}]</span>
                        <span style={{color: '#eee'}}>{log.text}</span>
                    </div>
                ))}
                <div ref={endRef} />
            </div>
        </div>
    );
};

export const Card = ({ cardVal, index, isSelected, onClick, onMouseEnter, spacing }) => {
    const { suit, text, color, isScore } = getCardDisplay(cardVal);
    
    const handlePointerDown = (e) => {
        if (e.pointerType === 'touch') return;
        if (e.button !== 0 && e.pointerType === 'mouse') return;
        e.stopPropagation();
        onClick(cardVal);
    };

    return (
        <div 
            onPointerDown={handlePointerDown}
            onMouseEnter={(e) => {
                if (e.pointerType === 'mouse') {
                     onMouseEnter(cardVal);
                }
            }}
            style={{
                ...styles.card, 
                color, 
                left: index * spacing, 
                zIndex: index,
                transform: isSelected ? 'translateY(-35px)' : 'translateY(0)',
                borderColor: isSelected ? '#3498db' : (isScore ? '#f1c40f' : '#bdc3c7'),
                boxShadow: isSelected ? '0 0 15px rgba(52, 152, 219, 0.6)' : (isScore ? '0 0 8px rgba(241, 196, 15, 0.4)' : '0 -2px 5px rgba(0,0,0,0.1)'),
                touchAction: 'none' 
            }}
        >
            <div style={{position: 'absolute', top: 0, left: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', lineHeight: 0.9}}>
                <div style={{fontSize: 16, fontWeight: '900', letterSpacing: -1}}>{text}</div>
                <div style={{fontSize: 14, marginTop: -1}}>{suit}</div>
            </div>
            {isScore && <div style={{position:'absolute', bottom:1, right:2, fontSize:10, color:'#f1c40f'}}>â˜…</div>}
        </div>
    );
};
export const MiniCard = ({ cardVal, index }) => {
    const { text, suit, color, isScore } = getCardDisplay(cardVal);
    return (
        <div style={{
            ...styles.miniCard, color,
            border: isScore ? '2px solid #f1c40f' : '1px solid #ccc',
            transform: isScore ? 'scale(1.1) translateY(-10px)' : 'scale(1)',
            zIndex: index
        }}>
            {suit}{text}
        </div>
    );
};

// [ä¿®æ”¹] å¢åŠ  roundScore å‚æ•°
export const PlayerAvatar = ({ player, isTurn, score, roundScore = 0, targetScore, isMySocket, remainingSeconds, rank, timerPosition, hideTimer, cardCount, showCardCountMode, team }) => {
    const progress = Math.min((score / targetScore) * 100, 100);
    const containerOpacity = rank ? 0.75 : 1; 

    let showBadge = false;
    if (showCardCountMode === 2) showBadge = true;
    if (showCardCountMode === 1 && cardCount <= 3 && cardCount > 0) showBadge = true;
    if (rank) showBadge = false;

    const isTeamMode = team !== undefined && team !== null;
    const teamColor = team === 0 ? '#e74c3c' : '#3498db'; 
    const teamName = team === 0 ? 'çº¢' : 'è“';
    
    let borderColor = 'rgba(255,255,255,0.1)';
    if (isTeamMode) borderColor = teamColor;
    if (isTurn) borderColor = '#f1c40f'; 

    let bgColor = isTurn ? 'rgba(44, 62, 80, 0.9)' : 'rgba(44, 62, 80, 0.6)';
    if (isTeamMode && !isTurn) {
        bgColor = team === 0 ? 'rgba(231, 76, 60, 0.2)' : 'rgba(52, 152, 219, 0.2)';
    }

    return (
        <div style={{
            ...styles.playerBox,
            borderColor: borderColor,
            borderWidth: isTeamMode ? 2 : 1, 
            transform: isTurn ? 'scale(1.1)' : 'scale(1)',
            boxShadow: isTurn ? '0 0 25px rgba(241, 196, 15, 0.5)' : 'none',
            background: bgColor,
            position: 'relative',
            opacity: containerOpacity
        }}>
            {showBadge && (
                <div style={styles.cardCountBadge}>
                    {cardCount}
                </div>
            )}

            {isTeamMode && (
                <div style={{
                    position: 'absolute', 
                    top: -10, 
                    right: -8, 
                    background: teamColor, color: 'white',
                    fontSize: 9, padding: '1px 4px', borderRadius: 4,
                    display: 'flex', alignItems: 'center', gap: 2,
                    boxShadow: '0 2px 4px rgba(0,0,0,0.3)',
                    zIndex: 25
                }}>
                    <Shield size={8} fill="currentColor"/> {teamName}é˜Ÿ
                </div>
            )}

            {rank && (
                <div style={{
                    position: 'absolute',
                    top: -16, 
                    left: '50%',
                    transform: 'translateX(-50%)',
                    background: rank === 1 ? '#f1c40f' : (rank === 2 ? '#bdc3c7' : '#e67e22'), 
                    color: '#fff',
                    padding: '2px 8px',
                    borderRadius: 20,
                    fontSize: 11,
                    fontWeight: 'bold',
                    boxShadow: '0 2px 5px rgba(0,0,0,0.4)',
                    zIndex: 30, 
                    display: 'flex',
                    alignItems: 'center',
                    gap: 3,
                    whiteSpace: 'nowrap',
                    border: '1px solid white'
                }}>
                    {rank === 1 ? <Trophy size={10} fill="white" /> : <Flag size={10} fill="white"/>}
                    {rank === 1 ? 'NO.1' : `NO.${rank}`}
                </div>
            )}

            <div style={{...styles.avatar, borderColor: isTeamMode ? teamColor : 'rgba(255,255,255,0.3)'}}>
                {player.name[0]}
            </div>
            
            <div style={styles.playerName}>
                {player.name} {isMySocket && '(æˆ‘)'}
            </div>
            
            <div style={styles.scoreBarBg}>
                <div style={{...styles.scoreBarFill, width:`${progress}%`, background: progress>=100?'#e74c3c':'#2ecc71'}}></div>
            </div>
            
            {/* [æ ¸å¿ƒä¿®æ”¹] åˆ†æ•°æ˜¾ç¤ºä¼˜åŒ– */}
            <div style={styles.playerScore}>
                <Coins size={10} color="#f1c40f"/> 
                {score}
                {roundScore > 0 && (
                    <span style={{color: '#f1c40f', fontSize: 9, marginLeft: 2, fontWeight: 900}}>(+{roundScore})</span>
                )}
            </div>
            
            {isTurn && !rank && !hideTimer && (
                <CountDownTimer 
                    initialSeconds={remainingSeconds} 
                    totalSeconds={60} 
                    position={timerPosition}
                />
            )}
        </div>
    );
};

================================================================================
FILE PATH: client\src\components\CountDownTimer.jsx
================================================================================
import React, { useState, useEffect, useRef } from 'react';
import { Clock } from 'lucide-react';

const CountDownTimer = ({ initialSeconds, totalSeconds = 60, position = 'top' }) => {
    const [seconds, setSeconds] = useState(initialSeconds);
    const intervalRef = useRef(null);

    // [ä¼˜åŒ–] åªåœ¨ initialSeconds å‘ç”Ÿæ˜¾è‘—å˜åŒ–ï¼ˆä¾‹å¦‚æ–°çš„ä¸€è½®å¼€å§‹ï¼‰æ—¶é‡ç½®
    // è¿™é‡Œæˆ‘ä»¬å‡è®¾çˆ¶ç»„ä»¶ä¼šä¼ é€’æ­£ç¡®çš„ initialSeconds
    // å¦‚æœæœåŠ¡å™¨ä¸é¢‘ç¹æ¨é€ï¼Œè¿™é‡Œçš„ useEffect ä¹Ÿå°±ä¸ä¼šé¢‘ç¹è§¦å‘
    useEffect(() => {
        setSeconds(initialSeconds);
    }, [initialSeconds]);

    useEffect(() => {
        // æ¸…é™¤æ—§çš„
        if (intervalRef.current) clearInterval(intervalRef.current);

        // å¦‚æœå·²ç»ç»“æŸï¼Œä¸å¯åŠ¨
        if (seconds <= 0) return;

        // å¯åŠ¨æ–°çš„è®¡æ—¶å™¨
        intervalRef.current = setInterval(() => {
            setSeconds((prev) => {
                if (prev <= 1) {
                    clearInterval(intervalRef.current);
                    return 0;
                }
                return prev - 1;
            });
        }, 1000);

        return () => {
            if (intervalRef.current) clearInterval(intervalRef.current);
        };
    }, [initialSeconds]); // ä¾èµ–é¡¹æ”¹ä¸º initialSecondsï¼Œè€Œä¸æ˜¯ secondsï¼Œè¿™æ ·ä¸ä¼šæ¯ç§’é‡ç½® interval

    const isUrgent = seconds <= 10;
    const color = isUrgent ? '#ff4d4d' : '#ffffff';
    const bgColor = isUrgent ? 'rgba(231, 76, 60, 0.9)' : 'rgba(0, 0, 0, 0.7)';

    let posStyle = {};
    // ... (ä½ç½®æ ·å¼é€»è¾‘ä¿æŒä¸å˜) ...
    switch (position) {
        case 'bottom':
            posStyle = { top: '100%', left: '50%', transform: 'translateX(-50%)', marginTop: 5 };
            break;
        case 'left':
            posStyle = { right: '100%', top: '50%', transform: 'translateY(-50%)', marginRight: 8 };
            break;
        case 'right':
            posStyle = { left: '100%', top: '50%', transform: 'translateY(-50%)', marginLeft: 8 };
            break;
        case 'top-right': 
            posStyle = { left: '100%', top: -20, marginLeft: 5 };
            break;
        case 'inline': 
             // [æ–°å¢] å†…è”æ¨¡å¼ï¼Œç”¨äºæ“ä½œæ 
            posStyle = { position: 'static', margin: '0 10px' };
            break;
        case 'top':
        default:
            posStyle = { bottom: '100%', left: '50%', transform: 'translateX(-50%)', marginBottom: 5 };
            break;
    }

    // å†…è”æ¨¡å¼ä¸‹ç§»é™¤ absolute
    const containerStyle = position === 'inline' ? {
        ...posStyle,
        background: bgColor,
        padding: '4px 10px',
        borderRadius: 20,
        display: 'flex',
        alignItems: 'center',
        gap: 5,
        border: '1px solid rgba(255,255,255,0.2)',
        transition: 'all 0.3s'
    } : {
        position: 'absolute',
        ...posStyle,
        background: bgColor,
        padding: '2px 8px',
        borderRadius: 20,
        display: 'flex',
        alignItems: 'center',
        gap: 3,
        whiteSpace: 'nowrap',
        boxShadow: '0 4px 10px rgba(0,0,0,0.3)',
        border: '1px solid rgba(255,255,255,0.2)',
        zIndex: 30,
        transition: 'all 0.3s'
    };

    return (
        <div style={containerStyle}>
            <Clock size={12} color={color} className={isUrgent ? 'spin' : ''} />
            <span style={{ 
                color: color, 
                fontWeight: 'bold', 
                fontSize: 12,
                fontFamily: 'monospace'
            }}>
                {seconds}s
            </span>
            <style>{`.spin { animation: spin 1s linear infinite; }`}</style>
        </div>
    );
};

export default CountDownTimer;

================================================================================
FILE PATH: client\src\components\ScoreTable.jsx
================================================================================
import React from 'react';
import { Trophy, Shield, Medal, ScrollText } from 'lucide-react';

export const ScoreTable = ({ 
    players, 
    matchHistory = [], 
    currentScores,     
    roomConfig,
    grandResult
}) => {
    const isTeamMode = roomConfig.isTeamMode && (players.length % 2 === 0);

    const sortedPlayers = [...players].sort((a, b) => {
        const scoreA = currentScores[a.id] || 0;
        const scoreB = currentScores[b.id] || 0;
        return scoreB - scoreA; 
    });

    let redTeamHistory = [];
    let blueTeamHistory = [];
    let redTotal = 0;
    let blueTotal = 0;

    if (isTeamMode) {
        matchHistory.forEach((match, idx) => {
            let r = 0, b = 0;
            players.forEach(p => {
                const s = match.scores[p.id] || 0;
                if (p.team === 0) r += s;
                else if (p.team === 1) b += s;
            });
            redTeamHistory[idx] = r;
            blueTeamHistory[idx] = b;
        });
        
        players.forEach(p => {
            const s = currentScores[p.id] || 0;
            if (p.team === 0) redTotal += s;
            else if (p.team === 1) blueTotal += s;
        });
    }

    const renderHeader = () => (
        <div style={{display: 'flex', background: '#2c3e50', color: 'white', padding: '10px', borderRadius: '8px 8px 0 0', fontWeight: 'bold', fontSize: 13}}>
            <div style={{flex: 2, textAlign: 'left', paddingLeft: 10}}>ç©å®¶/é˜Ÿä¼</div>
            {matchHistory.map((_, i) => (
                <div key={i} style={{flex: 1, textAlign: 'center'}}>R{i + 1}</div>
            ))}
            <div style={{flex: 1.2, textAlign: 'center', color: '#f1c40f'}}>æ€»åˆ†</div>
            <div style={{flex: 0.8, textAlign: 'center'}}>æ’å</div>
        </div>
    );

    const renderTeamRow = (teamIndex, totalScore, historyScores) => {
        const color = teamIndex === 0 ? '#e74c3c' : '#3498db';
        const bg = teamIndex === 0 ? 'rgba(231, 76, 60, 0.1)' : 'rgba(52, 152, 219, 0.1)';
        const name = teamIndex === 0 ? 'çº¢é˜Ÿ (RED)' : 'è“é˜Ÿ (BLUE)';
        
        return (
            <div style={{display: 'flex', background: bg, padding: '8px 10px', borderBottom: '1px solid rgba(0,0,0,0.05)', alignItems:'center', fontSize: 13}}>
                <div style={{flex: 2, textAlign: 'left', color: color, fontWeight: 'bold', display:'flex', alignItems:'center', gap:5}}>
                    <Shield size={14} fill={color} /> {name}
                </div>
                {matchHistory.map((_, i) => (
                    <div key={i} style={{flex: 1, textAlign: 'center', color: historyScores[i] > 0 ? color : '#999', fontWeight:'bold'}}>
                        {historyScores[i] > 0 ? `+${historyScores[i]}` : historyScores[i]}
                    </div>
                ))}
                <div style={{flex: 1.2, textAlign: 'center', color: color, fontWeight: '900', fontSize: 14}}>{totalScore}</div>
                <div style={{flex: 0.8}}></div>
            </div>
        );
    };

    const renderPlayerRow = (player, rank) => {
        const score = currentScores[player.id] || 0;
        
        let rankIcon = null;
        if (rank === 1) rankIcon = <Trophy size={16} color="#f1c40f" fill="#f1c40f"/>;
        else if (rank === 2) rankIcon = <Medal size={16} color="#bdc3c7" fill="#bdc3c7"/>;
        else if (rank === 3) rankIcon = <Medal size={16} color="#e67e22" fill="#e67e22"/>;
        else rankIcon = <span style={{color:'#999', fontSize:12}}>{rank}</span>;

        return (
            <div key={player.id} style={{
                display: 'flex', 
                padding: '10px', 
                background: 'white', 
                borderBottom: '1px solid #eee',
                alignItems: 'center',
                fontSize: 13
            }}>
                <div style={{flex: 2, textAlign: 'left', display: 'flex', alignItems: 'center', gap: 8, overflow:'hidden'}}>
                    <div style={{
                        width: 24, height: 24, borderRadius: '50%', background: '#ecf0f1', 
                        display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: 12, fontWeight: 'bold',
                        border: player.team !== null ? `2px solid ${player.team===0?'#e74c3c':'#3498db'}` : 'none'
                    }}>
                        {player.name[0]}
                    </div>
                    <span style={{fontWeight: 'bold', color: '#2c3e50', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis'}}>
                        {player.name}
                    </span>
                </div>

                {matchHistory.map((match, i) => {
                    const s = match.scores[player.id] || 0;
                    return (
                        <div key={i} style={{flex: 1, textAlign: 'center', color: s > 0 ? '#e67e22' : (s < 0 ? '#7f8c8d' : '#bdc3c7'), fontWeight: s!==0?'bold':'normal'}}>
                            {s > 0 ? `+${s}` : s}
                        </div>
                    );
                })}

                <div style={{flex: 1.2, textAlign: 'center', fontWeight: 'bold', color: score >= 0 ? '#27ae60' : '#c0392b', fontSize: 14}}>
                    {score}
                </div>

                <div style={{flex: 0.8, textAlign: 'center', display:'flex', justifyContent:'center'}}>
                    {rankIcon}
                </div>
            </div>
        );
    };

    return (
        <div style={{width: '100%', display: 'flex', flexDirection: 'column', gap: 0, borderRadius: 8, overflow: 'hidden', border: '1px solid #ddd'}}>
            {renderHeader()}
            
            {isTeamMode && renderTeamRow(0, redTotal, redTeamHistory)}
            {isTeamMode && renderTeamRow(1, blueTotal, blueTeamHistory)}
            
            <div style={{maxHeight: 300, overflowY: 'auto'}}>
                {sortedPlayers.map((p, i) => renderPlayerRow(p, i + 1))}
            </div>

            <div style={{background: '#f8f9fa', padding: 10, borderTop: '1px solid #ddd'}}>
                <div style={{display:'flex', alignItems:'center', gap:5, fontSize: 12, color: '#7f8c8d', marginBottom: 5, fontWeight:'bold'}}>
                    <ScrollText size={12}/> èµç½šæ—¥å¿—è¯¦æƒ…
                </div>
                <div style={{fontSize: 11, color: '#666', lineHeight: '1.6', maxHeight: 100, overflowY: 'auto', textAlign:'left'}}>
                    {matchHistory.length > 0 ? (
                        matchHistory.slice().reverse().map((match, i) => (
                            <div key={i} style={{marginBottom: 4}}>
                                <span style={{fontWeight:'bold', color:'#333'}}>R{matchHistory.length - i}: </span>
                                {match.details && match.details.length > 0 ? match.details.join('; ') : 'æ— ç‰¹æ®Šèµç½š'}
                            </div>
                        ))
                    ) : (
                        <div>æš‚æ— è®°å½•</div>
                    )}
                </div>
            </div>
        </div>
    );
};

================================================================================
FILE PATH: client\src\context\GameContext.jsx
================================================================================
import React, { createContext, useContext } from 'react';
import { useGameSocket } from '../hooks/useGameSocket.js';

// åˆ›å»º Context å¯¹è±¡
const GameContext = createContext(null);

// Provider ç»„ä»¶ï¼šè´Ÿè´£æŒæœ‰çŠ¶æ€å¹¶å‘ä¸‹ä¼ é€’
export const GameProvider = ({ children }) => {
  // è¿™é‡Œè°ƒç”¨ä½ åŸæœ¬çš„å·¨å‹ Hookï¼Œè·å–æ‰€æœ‰æ•°æ®å’Œæ–¹æ³•
  const gameData = useGameSocket();

  return (
    <GameContext.Provider value={gameData}>
      {children}
    </GameContext.Provider>
  );
};

// è‡ªå®šä¹‰ Hookï¼šæ–¹ä¾¿å­ç»„ä»¶ç›´æ¥è·å–æ•°æ®
export const useGame = () => {
  const context = useContext(GameContext);
  if (!context) {
    throw new Error('useGame must be used within a GameProvider');
  }
  return context;
};

================================================================================
FILE PATH: client\src\hooks\useGameSocket.js
================================================================================
import { useState, useEffect, useRef } from 'react';
import { sortHand } from '../utils/cardLogic.js';
import SoundManager from '../utils/SoundManager.js';
// [æ–°å¢] å¼•å…¥è¿æ¥ Hook
import { useSocketConnection } from './useSocketConnection.js';

export const useGameSocket = () => {
    // 1. è·å–åŸºç¡€è¿æ¥èƒ½åŠ›
    const { socket, isConnected, mySocketId } = useSocketConnection();

    // [è°ƒè¯•] ç›‘å¬ Socket æ³¨å…¥çŠ¶æ€ï¼Œæ–¹ä¾¿æ’æŸ¥é—®é¢˜
    useEffect(() => {
        if (!socket) {
            console.log("[GameSocket] ç­‰å¾… Socket åˆå§‹åŒ–...");
        } else {
            console.log(`[GameSocket] Socket å°±ç»ª, ID: ${mySocketId}, å·²è¿æ¥: ${isConnected}`);
        }
    }, [socket, isConnected, mySocketId]);

    // --- æ¸¸æˆçŠ¶æ€å®šä¹‰ (ä¿æŒä¸å˜) ---
    const [gameState, setGameState] = useState('LOGIN'); 
    const [username, setUsername] = useState('');
    const [roomId, setRoomId] = useState('');
    
    const [roomConfig, setRoomConfig] = useState({ 
        deckCount: 2,          
        maxPlayers: 4,         
        targetScore: 1000,     
        turnTimeout: 60000,
        enableRankPenalty: false,    
        rankPenaltyScores: [30, 15],
        showCardCountMode: 1, 
        isTeamMode: false,
        enableDrawSeat: false 
    });
    
    const [isCreatorMode, setIsCreatorMode] = useState(false); 
    const [players, setPlayers] = useState([]);     
    const [myHand, setMyHand] = useState([]);       
    const [selectedCards, setSelectedCards] = useState([]); 
    const [lastPlayed, setLastPlayed] = useState([]); 
    const [currentTurnId, setCurrentTurnId] = useState(null); 
    const [lastPlayerName, setLastPlayerName] = useState(''); 
    const [infoMessage, setInfoMessage] = useState(''); 
    
    const [roundResult, setRoundResult] = useState(null); 
    const [grandResult, setGrandResult] = useState(null); 
    const [playerScores, setPlayerScores] = useState({});
    const [roundPoints, setRoundPoints] = useState({});

    const [playersInfo, setPlayersInfo] = useState({});
    const [finishedRank, setFinishedRank] = useState([]); 
    
    const [pendingPoints, setPendingPoints] = useState(0);
    const [gameLogs, setGameLogs] = useState([]);

    const [sortMode, setSortMode] = useState('POINT'); 
    const [isLoading, setIsLoading] = useState(false);

    const [turnRemaining, setTurnRemaining] = useState(60); 
    const [handCounts, setHandCounts] = useState({});

    const [drawState, setDrawState] = useState(null); 

    // æç¤ºç¼“å­˜çŠ¶æ€
    const [availableHints, setAvailableHints] = useState([]); 
    const [hintIndex, setHintIndex] = useState(0);            
    const lastHintRef = useRef({ turnId: null, lastPlayed: [] }); 

    // --- Refs ---
    const isDragging = useRef(false); 
    const dragStartMode = useRef(true); 
    const sortModeRef = useRef('POINT');
    const usernameRef = useRef(username); 
    const mySocketIdRef = useRef(mySocketId); // Sync with prop
    const roomIdRef = useRef(roomId);
    
    const lastPlayedRef = useRef(lastPlayed); 
    const backupHandRef = useRef([]);

    // --- ç›‘å¬ Effect ---
    useEffect(() => { usernameRef.current = username; }, [username]);
    useEffect(() => { mySocketIdRef.current = mySocketId; }, [mySocketId]);
    useEffect(() => { roomIdRef.current = roomId; }, [roomId]);
    useEffect(() => { lastPlayedRef.current = lastPlayed; }, [lastPlayed]); 
    
    useEffect(() => {
        sortModeRef.current = sortMode;
        if (myHand.length > 0) setMyHand(prev => sortHand(prev, sortMode));
    }, [sortMode]);

    // [é‡æ„] è‡ªåŠ¨é‡è¿é€»è¾‘ï¼šå½“è¿æ¥æ¢å¤æ—¶ï¼Œå°è¯•é‡æ–°åŠ å…¥æˆ¿é—´
    useEffect(() => {
        if (isConnected && socket && roomIdRef.current && usernameRef.current) {
            console.log(`[Auto-Rejoin] è‡ªåŠ¨æ¢å¤èº«ä»½: ${usernameRef.current} @ Room ${roomIdRef.current}`);
            socket.emit('join_room', { 
                roomId: roomIdRef.current, 
                username: usernameRef.current 
            });
        }
    }, [isConnected, socket]); // ä¾èµ– isConnected å˜åŒ–

    // --- æ¸¸æˆä¸šåŠ¡äº‹ä»¶ç›‘å¬ ---
    useEffect(() => {
        if (!socket) return;

        // å®šä¹‰æ‰€æœ‰å¤„ç†å‡½æ•°
        const onErrorMsg = (msg) => { setIsLoading(false); alert(msg); };

        const onRoomInfo = (data) => {
            setRoomId(data.roomId);
            setRoomConfig(data.config);
            setPlayers(data.players);
            
            if (gameState !== 'GAME' && gameState !== 'DRAW_SEATS') {
                setGameState('LOBBY'); 
            }
            setIsLoading(false);
        };

        const onEnterDrawPhase = (data) => {
            setDrawState({ totalCards: data.totalCards, history: [] });
            setGameState('DRAW_SEATS');
            SoundManager.play('deal');
        };

        const onSeatDrawUpdate = (data) => {
            setDrawState(prev => ({ ...prev, history: [...prev.history, data] }));
            SoundManager.play('deal'); 
        };

        const onSeatDrawFinished = (data) => {
            setPlayers(data.players); 
        };

        const onGameStarted = (data) => {
            if (data.hand) {
                setMyHand(sortHand(data.hand, sortModeRef.current));
            }
            setLastPlayed([]);
            setRoundResult(null);
            setGrandResult(null);
            setPendingPoints(0);
            setFinishedRank([]); 
            if (data.grandScores) setPlayerScores(data.grandScores);
            setRoundPoints({});

            setGameLogs(prev => [...prev, { time: new Date().toLocaleTimeString(), text: 'ğŸ æ–°ä¸€å±€å¼€å§‹ï¼' }]); 
            setGameState('GAME');
            setTurnRemaining(60);
            setPlayersInfo({});
            if (data.handCounts) setHandCounts(data.handCounts);
            
            setAvailableHints([]);
            setHintIndex(0);

            SoundManager.play('deal');
            backupHandRef.current = []; 
        };

        const onGameStateUpdate = (data) => {
            setCurrentTurnId(data.currentTurnId);
            
            if (data.turnRemaining !== undefined) {
                setTurnRemaining(data.turnRemaining);
            }

            if (data.lastPlayed && data.lastPlayed.length > 0) {
                if (data.lastPlayerName !== usernameRef.current) {
                    SoundManager.play('play'); 
                }
            }

            // ç¼“å­˜å¤±æ•ˆæ£€æµ‹
            if (data.lastPlayed) {
                const newPlayedStr = JSON.stringify(data.lastPlayed);
                const oldPlayedStr = JSON.stringify(lastHintRef.current.lastPlayed);
                if (newPlayedStr !== oldPlayedStr) {
                    setAvailableHints([]);
                    setHintIndex(0);
                }
            } else if (data.lastPlayed === null || (Array.isArray(data.lastPlayed) && data.lastPlayed.length === 0)) {
                if (lastHintRef.current.lastPlayed.length > 0) {
                    setAvailableHints([]);
                    setHintIndex(0);
                }
            }

            if (data.lastPlayed) setLastPlayed(sortHand(data.lastPlayed, sortModeRef.current));
            setLastPlayerName(data.lastPlayerName || '');
            
            if (data.infoText && data.infoText !== 'PASS') {
                setInfoMessage(data.infoText); setTimeout(()=>setInfoMessage(''), 2000);
                setGameLogs(prev => [...prev, { time: new Date().toLocaleTimeString(), text: data.infoText }]);
            }
            if (data.scores) setPlayerScores(data.scores);
            if (data.roundPoints) setRoundPoints(data.roundPoints);

            if (data.playersInfo) setPlayersInfo(data.playersInfo);
            if (data.handCounts) setHandCounts(data.handCounts);
            if (data.finishedRank) setFinishedRank(data.finishedRank);
            if (data.pendingPoints !== undefined) setPendingPoints(data.pendingPoints);

            if (data.currentTurnId === mySocketIdRef.current) {
                SoundManager.play('alert');
            }
        };

        const onHandUpdate = (newHand) => {
            setMyHand(sortHand(newHand, sortModeRef.current)); 
            setSelectedCards([]);
            setAvailableHints([]);
            setHintIndex(0);
            backupHandRef.current = [];
        };

        const onPlayError = (msg) => { 
            setInfoMessage(msg); 
            setTimeout(()=>setInfoMessage(''), 2000); 
            SoundManager.play('lose'); 
            
            if (backupHandRef.current.length > 0) {
                setMyHand(backupHandRef.current);
                backupHandRef.current = [];
                setInfoMessage("å‡ºç‰Œæ— æ•ˆï¼Œæ‰‹ç‰Œå·²å›æ»š");
            }
        }; 
        
        const onRoundOver = (data) => {
            setRoundResult(data);
            if (data.grandScores) setPlayerScores(data.grandScores);
            const amIWinner = data.roundWinner === usernameRef.current;
            SoundManager.play(amIWinner ? 'win' : 'lose');
        };

        const onGrandGameOver = (data) => {
            setGrandResult(data);
            SoundManager.play('win'); 
        };

        const onHintResponse = (hints) => {
            if (hints && hints.length > 0) {
                setAvailableHints(hints);
                setHintIndex(0);
                setSelectedCards(hints[0]);
                lastHintRef.current = {
                    turnId: mySocketIdRef.current, 
                    lastPlayed: [...lastPlayedRef.current] 
                };
            } else {
                setInfoMessage('æ²¡æœ‰æ‰“å¾—è¿‡çš„ç‰Œ');
                setTimeout(()=>setInfoMessage(''), 1000);
            }
        };

        // ç»‘å®šäº‹ä»¶
        socket.on('error_msg', onErrorMsg);
        socket.on('room_info', onRoomInfo);
        socket.on('enter_draw_phase', onEnterDrawPhase);
        socket.on('seat_draw_update', onSeatDrawUpdate);
        socket.on('seat_draw_finished', onSeatDrawFinished);
        socket.on('game_started', onGameStarted);
        socket.on('game_state_update', onGameStateUpdate);
        socket.on('hand_update', onHandUpdate);
        socket.on('play_error', onPlayError);
        socket.on('round_over', onRoundOver);
        socket.on('grand_game_over', onGrandGameOver);
        socket.on('hint_response', onHintResponse);

        return () => {
            // è§£ç»‘äº‹ä»¶
            socket.off('error_msg', onErrorMsg);
            socket.off('room_info', onRoomInfo);
            socket.off('enter_draw_phase', onEnterDrawPhase);
            socket.off('seat_draw_update', onSeatDrawUpdate);
            socket.off('seat_draw_finished', onSeatDrawFinished);
            socket.off('game_started', onGameStarted);
            socket.off('game_state_update', onGameStateUpdate);
            socket.off('hand_update', onHandUpdate);
            socket.off('play_error', onPlayError);
            socket.off('round_over', onRoundOver);
            socket.off('grand_game_over', onGrandGameOver);
            socket.off('hint_response', onHintResponse);
        };
    }, [socket, gameState]); // ä¾èµ– socket å’Œ gameState å˜åŒ–é‡æ–°ç»‘å®š

    // --- åˆå§‹åŒ– Effect ---
    useEffect(() => {
        const initAudio = () => {
            SoundManager.init();
            window.removeEventListener('click', initAudio);
        };
        window.addEventListener('click', initAudio);

        const handleGlobalMouseUp = () => { isDragging.current = false; };
        window.addEventListener('mouseup', handleGlobalMouseUp);
        
        return () => { 
            window.removeEventListener('mouseup', handleGlobalMouseUp); 
        };
    }, []);

    // --- äº¤äº’å¤„ç†å‡½æ•° ---
    const toggleSort = () => setSortMode(prev => prev === 'POINT' ? 'ARRANGE' : 'POINT');

    const handleRoomAction = () => {
        if (!isConnected) return; 
        if (!username || !roomId) return alert("è¯·è¾“å…¥æ˜µç§°å’Œæˆ¿é—´å·");
        setIsLoading(true);
        const event = isCreatorMode ? 'create_room' : 'join_room';
        const payload = isCreatorMode ? { roomId, username, config: roomConfig } : { roomId, username };
        socket.emit(event, payload);
    };
    
    const handleStartGame = () => socket.emit('start_game', { roomId });
    const handleNextRound = () => socket.emit('next_round', { roomId });
    const handleAddBot = () => socket.emit('add_bot', { roomId });
    const handleToggleAutoPlay = () => socket.emit('toggle_auto_play', { roomId });

    const handleSwitchSeat = (index1, index2) => {
        if (!isCreatorMode && !players.find(p=>p.id===mySocketId)?.isHost) return;
        socket.emit('switch_seat', { roomId, index1, index2 });
    };
    
    const handleDrawCard = (index) => {
        socket.emit('draw_seat_card', { roomId, cardIndex: index });
    };

    const handleUpdateConfig = (newConfig) => {
        socket.emit('update_room_config', { roomId, config: newConfig });
    };

    const updateSelection = (cardVal, forceSelect = null) => {
        setSelectedCards(prev => {
            const isSelected = prev.includes(cardVal);
            if (forceSelect !== null) return forceSelect && !isSelected ? [...prev, cardVal] : (!forceSelect && isSelected ? prev.filter(c => c !== cardVal) : prev);
            return isSelected ? prev.filter(c => c !== cardVal) : [...prev, cardVal];
        });
    };

    const handleClearSelection = () => {
        setSelectedCards([]);
    };

    const handleMouseDown = (cardVal) => {
        isDragging.current = true;
        dragStartMode.current = !selectedCards.includes(cardVal); 
        updateSelection(cardVal, dragStartMode.current);
        SoundManager.play('deal'); 
    };
    
    const handleMouseEnter = (cardVal) => {
        if (isDragging.current) {
            updateSelection(cardVal, dragStartMode.current);
        }
    };

    const handlePlayCards = () => {
        if (selectedCards.length === 0) return alert("è¯·å…ˆé€‰ç‰Œ");
        const cardsToPlay = [...selectedCards];
        backupHandRef.current = [...myHand];
        const nextHand = myHand.filter(c => !cardsToPlay.includes(c));
        setMyHand(nextHand);
        setLastPlayed(sortHand(cardsToPlay, sortModeRef.current));
        setLastPlayerName(username); 
        setSelectedCards([]); 
        SoundManager.play('play');
        socket.emit('play_cards', { roomId, cards: cardsToPlay });
    };
    
    const handlePass = () => {
        socket.emit('pass_turn', { roomId });
        setSelectedCards([]);
    };
    
    const handleKickPlayer = (targetId) => {
        if (socket) {
            socket.emit('kick_player', { roomId, targetId });
        }
    };

    const handleRequestHint = () => {
        const isCacheValid = 
            availableHints.length > 0 && 
            currentTurnId === mySocketIdRef.current &&
            JSON.stringify(lastPlayed) === JSON.stringify(lastHintRef.current.lastPlayed);

        if (isCacheValid) {
            const nextIndex = (hintIndex + 1) % availableHints.length;
            setHintIndex(nextIndex);
            setSelectedCards(availableHints[nextIndex]);
        } else {
            setAvailableHints([]);
            socket.emit('request_hint', { roomId });
        }
    };

    return {
        // State
        gameState, username, roomId, roomConfig, isCreatorMode,
        players, myHand, selectedCards, lastPlayed,
        currentTurnId, lastPlayerName, infoMessage,
        roundResult, grandResult, playerScores, roundPoints,
        playersInfo, finishedRank, pendingPoints, gameLogs,
        sortMode, isConnected, mySocketId, isLoading,
        turnRemaining, handCounts, drawState,

        // Setters
        setUsername, setRoomId, setRoomConfig, setIsCreatorMode,

        // Actions
        toggleSort, handleRoomAction, handleStartGame, handleNextRound,
        handleAddBot, handleToggleAutoPlay, handleSwitchSeat, handleDrawCard,
        handleUpdateConfig, handleClearSelection, handleMouseDown,
        handleMouseEnter, handlePlayCards, handlePass, handleKickPlayer, handleRequestHint
    };
};

================================================================================
FILE PATH: client\src\hooks\useSocketConnection.js
================================================================================
import { useState, useEffect } from 'react';
import io from 'socket.io-client';

// è¿æ¥åœ°å€åˆ¤æ–­é€»è¾‘
const getSocketUrl = () => {
    const { hostname, protocol, port } = window.location;
    if (protocol === 'https:') { return '/'; }
    if (hostname === 'localhost' || hostname === '127.0.0.1') {
        if (port !== '3001') { return `${protocol}//${hostname}:3001`; }
    }
    if (hostname.startsWith('192.168.') || hostname.startsWith('10.')) {
        if (port !== '3001') { return `${protocol}//${hostname}:3001`; }
    }
    return '/';
};

const SOCKET_URL = getSocketUrl();

export const useSocketConnection = () => {
    // [å…³é”®ä¿®å¤] æ”¹ç”¨ useStateï¼Œç¡®ä¿ Socket åˆ›å»ºåèƒ½è§¦å‘ç»„ä»¶é‡æ¸²æŸ“
    const [socket, setSocket] = useState(null);
    const [isConnected, setIsConnected] = useState(false);
    const [mySocketId, setMySocketId] = useState(null);

    useEffect(() => {
        console.log(`æ­£åœ¨è¿æ¥æœåŠ¡å™¨: ${SOCKET_URL}`);
        
        const newSocket = io(SOCKET_URL, { 
            reconnectionAttempts: 20,   
            reconnectionDelay: 2000,    
            timeout: 20000,
            autoConnect: true
        });
        
        // ä¿å­˜å®ä¾‹ï¼Œè§¦å‘æ›´æ–°
        setSocket(newSocket);

        const onConnect = () => {
            console.log("Socket è¿æ¥æˆåŠŸ!");
            setIsConnected(true);
        };

        const onDisconnect = () => {
            console.log("Socket æ–­å¼€è¿æ¥");
            setIsConnected(false);
        };

        const onConnectError = (err) => {
            console.warn("è¿æ¥é”™è¯¯ (è¯¦ç»†):", err.message);
        };

        const onYourId = (id) => {
            setMySocketId(id);
        };

        // ç»‘å®šåŸºç¡€äº‹ä»¶
        newSocket.on('connect', onConnect);
        newSocket.on('disconnect', onDisconnect);
        newSocket.on('connect_error', onConnectError);
        newSocket.on('your_id', onYourId);

        return () => {
            newSocket.off('connect', onConnect);
            newSocket.off('disconnect', onDisconnect);
            newSocket.off('connect_error', onConnectError);
            newSocket.off('your_id', onYourId);
            // newSocket.disconnect(); // ä¿æŒé•¿è¿æ¥ï¼Œç»„ä»¶å¸è½½æ—¶ä¸å¼ºåˆ¶æ–­å¼€ï¼Œé™¤éå½»åº•é€€å‡º
        };
    }, []);

    return { 
        socket, 
        isConnected, 
        mySocketId 
    };
};

================================================================================
FILE PATH: client\src\index.css
================================================================================
/* =========================================
   å…¨å±€åŸºç¡€æ ·å¼ (Base & Reset)
   ========================================= */
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  /* é…è‰²æ–¹æ¡ˆ */
  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  /* å­—ä½“æ¸²æŸ“ä¼˜åŒ– */
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  
  /* [ä¼˜åŒ–] ç¦æ­¢ç§»åŠ¨ç«¯ç‚¹å‡»é«˜äº® */
  -webkit-tap-highlight-color: transparent;
}

/* [å…³é”®ä¿®å¤ 0] å…¨å±€ç›’æ¨¡å‹é‡ç½® */
*, *::before, *::after {
  box-sizing: border-box;
}

/* é“¾æ¥æ ·å¼ */
a { font-weight: 500; color: #646cff; text-decoration: inherit; }
a:hover { color: #535bf2; }

/* Body åŸºç¡€è®¾ç½® */
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  /* [å…³é”®ä¿®å¤] å½»åº•ç¦æ­¢æµè§ˆå™¨çš„ä¸‹æ‹‰åˆ·æ–°å’Œå›å¼¹æ•ˆæœ */
  overscroll-behavior: none;
  overflow: hidden; /* é”æ­» Body æ»šåŠ¨ï¼Œåªå…è®¸å†…éƒ¨å…ƒç´ æ»šåŠ¨ */
  position: fixed; /* å¼ºåˆ¶å›ºå®šï¼Œé˜²æ­¢ iOS Safari åœ°å€æ å› ä¸ºé¡µé¢æ»šåŠ¨è€Œå¿½éšå¿½ç° */
}

body {
  display: flex;
  place-items: center;
  min-width: 320px;
}

/* [ä¼˜åŒ–] é’ˆå¯¹æ ¹å®¹å™¨ä¼˜åŒ–è§¦æ‘¸ä½“éªŒ */
#root, .App {
  width: 100%;
  height: 100%;
  overflow-x: hidden;
  /* å…è®¸å†…éƒ¨æ­£å¸¸çš„ç‚¹å‡»å’Œæ»šåŠ¨ */
  touch-action: manipulation;
}

h1 { font-size: 3.2em; line-height: 1.1; }

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover { border-color: #646cff; }
button:focus, button:focus-visible { outline: 4px auto -webkit-focus-ring-color; }

@media (prefers-color-scheme: light) {
  :root { color: #213547; background-color: #ffffff; }
  a:hover { color: #747bff; }
  button { background-color: #f9f9f9; }
}


/* =========================================
   ç§»åŠ¨ç«¯é€‚é…æ ¸å¿ƒåŒº (Mobile Overrides)
   ========================================= */

/* --- 1. æ¨ªå±å¼•å¯¼é®ç½© --- */
.landscape-hint {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(30, 39, 46, 0.95);
    z-index: 9999; 
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
    text-align: center;
    backdrop-filter: blur(10px);
    touch-action: none; 
}

.phone-rotate-icon {
    width: 60px;
    height: 100px; 
    border: 3px solid white; border-radius: 10px; margin-bottom: 20px;
    animation: rotate-phone 2s infinite ease-in-out;
}
@keyframes rotate-phone {
    0% { transform: rotate(0deg); }
    50% { transform: rotate(90deg); }
    100% { transform: rotate(0deg); }
}


/* --- 2. ç§»åŠ¨ç«¯ç«–å±å¸ƒå±€ä¼˜åŒ– (Portrait Core) --- */

@media (max-width: 768px) {
  
  ::-webkit-scrollbar { width: 0px; background: transparent; }

  /* é€šç”¨åˆ—å®¹å™¨ */
  .mobile-layout-column {
    display: flex !important;
    flex-direction: column !important;
    width: 95% !important;     
    max-width: none !important; 
    height: auto !important;
    
    /* ä½¿ç”¨ dvh é€‚é…åŠ¨æ€åœ°å€æ  */
    min-height: 85vh !important;
    min-height: 85dvh !important; 
    
    max-height: 95dvh !important; 
    margin: 10px auto !important; 
    overflow: hidden !important; 
    padding: 0 !important;
  }

  /* --- 2.1 ç™»å½•é¡µ (Login) --- */
  .mobile-login-left {
    flex: 0 0 auto !important;
    width: 100% !important;
    padding: 30px 20px !important; 
    border-radius: 0 0 24px 24px !important; 
    background-color: #242424; 
    min-height: auto !important;
    align-items: center !important; 
    text-align: center !important;
    padding-top: max(30px, env(safe-area-inset-top)) !important;
  }
  
  .mobile-login-left h1 { font-size: 2.5em !important; margin-bottom: 10px !important; }
  .mobile-login-left .logoCircle { width: 70px !important; height: 70px !important; margin-bottom: 15px !important; }
  .mobile-login-left .logoText { font-size: 22px !important; }

  .mobile-login-right {
    flex: 1 !important;
    width: 100% !important;
    padding: 30px 20px !important;
    background: white;
    border-radius: 24px 24px 0 0 !important; 
    margin-top: -20px; 
    position: relative;
    z-index: 2;
    overflow-y: auto !important;
    display: flex !important;
    flex-direction: column !important;
    padding-bottom: max(30px, env(safe-area-inset-bottom)) !important;
  }
  
  .hide-on-mobile { display: none !important; }


  /* --- 2.2 å¤§å…é¡µ (Lobby) --- */
  .lobbyCard.mobile-layout-column {
      height: 92dvh !important;
      position: relative;
      background: white !important;
  }

  .mobile-lobby-content {
      display: flex !important;
      flex-direction: column !important;
      height: 100% !important;
      width: 100%;
      overflow: hidden !important;
  }
  
  .lobbyHeader { 
      flex: 0 0 auto;
      padding: 15px !important;
      padding-top: calc(15px + env(safe-area-inset-top)) !important; 
      background: #f8f9fa; 
  }
  .lobbyHeader h2 { font-size: 20px !important; margin: 0 !important; }

  .mobile-lobby-grid {
      flex: 1 !important; 
      overflow-y: auto !important;
      padding: 10px !important;
      display: grid !important;
      grid-template-columns: repeat(2, 1fr) !important; 
      align-content: start !important;
      gap: 10px !important;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 10px !important;
  }
  
  .mobile-lobby-grid > div { padding: 15px !important; gap: 10px !important; }
  .mobile-lobby-grid .avatar-large { width: 50px !important; height: 50px !important; font-size: 20px !important; }

  .mobile-lobby-footer {
      flex: 0 0 auto !important;
      padding: 12px !important;
      background: white;
      border-top: 1px solid #eee;
      z-index: 10;
      padding-bottom: calc(12px + env(safe-area-inset-bottom)) !important;
      position: static !important; 
      margin-top: auto !important;
      display: flex !important;
      justify-content: space-around !important;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
  }
  
  .mobile-lobby-footer button {
      width: 45% !important;
      padding: 0 !important;
      height: 44px !important; 
      font-size: 14px !important;
      margin: 0 !important;
  }
}


/* --- 3. ç§»åŠ¨ç«¯æ¨ªå±é€‚é… (Landscape Overrides) --- */
@media (max-width: 896px) and (orientation: landscape) {
    
    /* [ç»ˆæä¿®å¤ 1] å¼ºåˆ¶é“ºæ»¡å±å¹•ï¼Œæ— è§†ä»»ä½• marginï¼Œç›´æ¥è¦†ç›– */
    /* [å…³é”® Fix] å¿…é¡»å¼ºåˆ¶é‡ç½® min-height ä¸º 0ï¼Œå¦åˆ™ JS é‡Œçš„ 600px ä¼šæ’‘ç ´å±å¹• */
    .mobile-layout-column {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        min-height: 0 !important; /* æ ¸å¿ƒä¿®å¤ï¼šè§£å†³åº•éƒ¨çœ‹ä¸è§çš„é—®é¢˜ */
        max-height: none !important;
        margin: 0 !important;
        padding: 0 !important;
        flex-direction: row !important;
        z-index: 10;
    }

    /* --- [å…³é”®ä¼˜åŒ–] ç™»å½•é¡µ (Login) --- */
    
    .mobile-login-left {
        display: none !important;
    }

    .mobile-login-right {
        width: 100% !important;
        height: 100% !important;
        flex: 1 !important;
        border-radius: 0 !important;
        margin: 0 !important;
        
        /* é¡¶éƒ¨å¯¹é½ï¼Œé˜²æ­¢è¢«åˆ‡ */
        justify-content: flex-start !important;
        padding-top: max(10px, env(safe-area-inset-top)) !important;
        
        /* [ä¿®å¤] åº•éƒ¨å¢åŠ å¤§å¹…åº¦ Paddingï¼Œç¡®ä¿æ»šåŠ¨åˆ°åº•éƒ¨æ—¶ï¼Œæœ€ä¸‹é¢çš„æŒ‰é’®èƒ½å®Œæ•´éœ²å‡º */
        padding-bottom: max(40px, env(safe-area-inset-bottom)) !important;
        padding-left: max(40px, env(safe-area-inset-left)) !important;
        padding-right: max(40px, env(safe-area-inset-right)) !important; 
        
        overflow-y: auto !important;
        display: flex !important;
        flex-direction: column !important;
    }
    
    .mobile-login-right .formContent {
        max-width: 600px;
        margin: 0 auto;
        width: 100%;
        /* ç¡®ä¿åº•éƒ¨æŒ‰é’®èƒ½å®Œæ•´éœ²å‡º */
        padding-bottom: 20px !important;
    }


    /* --- [å…³é”®ä¼˜åŒ–] å¤§å…é¡µ (Lobby) --- */

    /* [å…³é”®ä¿®å¤ 2] å½»åº•é‡æ„ Lobby å¸ƒå±€ */
    .lobbyCard.mobile-layout-column {
        background: transparent !important;
        border: none !important;
    }
    
    .mobile-lobby-content {
        background: white !important;
        border-radius: 0 !important; 
        height: 100% !important;
        width: 100% !important;
        border: none !important;
        box-shadow: none !important;
        /* ä½¿ç”¨ Flex Column å¸ƒå±€ */
        display: flex !important;
        flex-direction: column !important;
    }

    .lobbyHeader {
        flex: 0 0 auto !important; /* å¤´éƒ¨å›ºå®šé«˜åº¦ï¼Œä¸è®¸ä¼¸ç¼© */
        padding: 8px 20px !important; 
        padding-top: max(10px, env(safe-area-inset-top)) !important;
        background: #f8f9fa;
        z-index: 20;
        border-bottom: 1px solid #eee;
    }
    /* ç¼©å°æ¨ªå±ä¸‹çš„æ ‡é¢˜å­—å· */
    .lobbyHeader h2 { font-size: 18px !important; }

    /* ç©å®¶åˆ—è¡¨ Grid */
    .mobile-lobby-grid {
        /* [æ ¸å¿ƒä¿®å¤] ä¸­é—´åŒºåŸŸè‡ªé€‚åº”ï¼Œå…è®¸æ”¶ç¼©ï¼Œå…è®¸æ»šåŠ¨ */
        flex: 1 1 0% !important; /* å…³é”®ï¼è®¾ä¸º 0% å¼ºåˆ¶è®©å®ƒå»é€‚åº”å‰©ä½™ç©ºé—´ï¼Œè€Œä¸æ˜¯è¢«å†…å®¹æ’‘å¤§ */
        min-height: 0 !important; 
        
        overflow-y: auto !important;
        display: grid !important;
        grid-template-columns: repeat(4, 1fr) !important; 
        gap: 10px !important;
        padding: 10px 20px !important;
        padding-left: max(30px, env(safe-area-inset-left)) !important;
        padding-right: max(30px, env(safe-area-inset-right)) !important;
        align-content: start !important;
    }
    
    @media (max-width: 600px) {
        .mobile-lobby-grid {
            grid-template-columns: repeat(3, 1fr) !important;
        }
    }

    .mobile-lobby-grid > div {
        padding: 6px !important;
        gap: 5px !important;
    }
    
    .mobile-lobby-grid .avatar-large {
        width: 36px !important;
        height: 36px !important;
        font-size: 14px !important;
    }

    /* Footer ä¼˜åŒ– */
    .mobile-lobby-footer {
        flex: 0 0 auto !important; /* åº•éƒ¨å›ºå®šé«˜åº¦ï¼Œä¸è®¸è¢«æŒ¤å‹ */
        position: relative !important;
        z-index: 100 !important;
        
        background: #f8f9fa !important;
        border-top: 1px solid #ddd !important;
        
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        /* [æ ¸å¿ƒä¿®å¤] ç»™åº•éƒ¨ç•™å‡ºè¶³å¤Ÿçš„å®‰å…¨è·ç¦»ï¼Œé˜²æ­¢è¢«æ‰‹åŠ¿æ¡é®æŒ¡æŒ‰ä¸åˆ° */
        padding-top: 8px !important;
        padding-bottom: max(15px, env(safe-area-inset-bottom)) !important;
        padding-left: max(20px, env(safe-area-inset-left)) !important;
        padding-right: max(20px, env(safe-area-inset-right)) !important;
        margin-top: 0 !important; /* æ¸…é™¤ marginTop auto */
    }
    
    .mobile-lobby-footer button {
        height: 40px !important; /* ç¨å¾®è°ƒçŸ®æŒ‰é’® */
        font-size: 14px !important;
    }
}

================================================================================
FILE PATH: client\src\main.jsx
================================================================================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'
// [æ–°å¢] å¼•å…¥ Provider
import { GameProvider } from './context/GameContext.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    {/* [ä¿®æ”¹] ç”¨ GameProvider åŒ…è£¹ App */}
    <GameProvider>
      <App />
    </GameProvider>
  </StrictMode>,
)

================================================================================
FILE PATH: client\src\screens\DrawSeatScreen.jsx
================================================================================
import React, { useState, useEffect } from 'react';
import { styles } from '../styles.js';
import { Card } from '../components/BaseUI.jsx'; 
import { Shuffle } from 'lucide-react';
// [æ–°å¢] å¼•å…¥ useGame
import { useGame } from '../context/GameContext.jsx';

// [ä¿®æ”¹] ç§»é™¤ Props å‚æ•°
export const DrawSeatScreen = () => {

    // [æ–°å¢] ä» Context è·å–æ•°æ®
    const { 
        roomId, players, mySocketId, 
        drawState, // { totalCards, history: [...] }
        handleDrawCard,
        roomConfig // æ¥æ”¶é…ç½®ï¼Œç”¨äºåˆ¤æ–­æ˜¾ç¤ºä»€ä¹ˆæ–‡æ¡ˆ
    } = useGame();

    // æœ¬åœ°çŠ¶æ€ç”¨äºåŠ¨ç”»å±•ç¤º
    const [flippedCards, setFlippedCards] = useState({}); // { index: { val: 54, playerName: 'xxx' } }
    const [infoText, setInfoText] = useState("è¯·ç‚¹å‡»ä¸€å¼ å¡èƒŒè¿›è¡ŒæŠ½ç­¾");

    // ç›‘å¬æœåŠ¡å™¨æ•°æ®æ›´æ–°
    useEffect(() => {
        if (drawState && drawState.history) {
            const newFlipped = {};
            drawState.history.forEach(item => {
                newFlipped[item.index] = { val: item.val, playerName: item.name };
            });
            setFlippedCards(newFlipped);

            // æ£€æŸ¥è‡ªå·±æ˜¯å¦æŠ½äº†
            const myLog = drawState.history.find(h => h.playerId === mySocketId);
            if (myLog) {
                setInfoText(`ç­‰å¾…å…¶ä»–ç©å®¶å®ŒæˆæŠ½ç­¾...`);
            }
        }
    }, [drawState, mySocketId]);

    const onCardClick = (index) => {
        if (flippedCards[index]) return; // å·²ç»ç¿»å¼€äº†
        
        // æ£€æŸ¥è‡ªå·±æ˜¯å¦å·²ç»æŠ½è¿‡
        const myName = players.find(p=>p.id===mySocketId)?.name;
        if (Object.values(flippedCards).some(c => c.playerName === myName)) {
             return; 
        }
        
        handleDrawCard(index);
    };

    // åˆ¤æ–­æ˜¯å¦æ˜¯çœŸæ­£çš„ç»„é˜Ÿæ¨¡å¼ (å¼€å¯äº†å¼€å…³ ä¸” äººæ•°æ˜¯å¶æ•°)
    const isTeamMode = roomConfig && roomConfig.isTeamMode && (players.length % 2 === 0);

    return (
        <div style={styles.gameTable}>
            {/* [ä¿®å¤è¯´æ˜] styles.gameSafeArea é»˜è®¤å¸¦æœ‰ pointerEvents: 'none'ã€‚
               è¿™ä¼šå¯¼è‡´å…¶å­å…ƒç´ æ— æ³•æ¥æ”¶ç‚¹å‡»äº‹ä»¶ã€‚ä¸‹é¢çš„å¡ç‰‡å…ƒç´ é€šè¿‡ pointerEvents: 'auto' é‡æ–°å¼€å¯äº†äº¤äº’ã€‚
            */}
            <div style={{...styles.gameSafeArea, display:'flex', flexDirection:'column', alignItems:'center', justifyContent:'center'}}>
                
                <div style={{
                    background: 'rgba(0,0,0,0.6)', padding: '20px 30px', borderRadius: 20, 
                    marginBottom: 40, backdropFilter: 'blur(10px)', border: '1px solid rgba(255,255,255,0.1)',
                    textAlign: 'center', color: 'white'
                }}>
                    <h2 style={{margin: '0 0 10px 0', fontSize: 24, display:'flex', alignItems:'center', justifyContent:'center', gap:10}}>
                        <Shuffle size={24} color="#f1c40f"/> èµ›å‰æŠ½å¡å®šåº§
                    </h2>
                    
                    <div style={{fontSize: 14, color: '#bdc3c7', maxWidth: 400, lineHeight: '1.6'}}>
                        {isTeamMode ? (
                            <>
                                ç‚¹æ•°<span style={{color:'#e74c3c', fontWeight:'bold'}}>å¤§</span>çš„åŠæ•°ç©å®¶ â†’ <span style={{color:'#e74c3c'}}>çº¢é˜Ÿ</span> (1, 3, 5å·ä½)<br/>
                                ç‚¹æ•°<span style={{color:'#3498db', fontWeight:'bold'}}>å°</span>çš„åŠæ•°ç©å®¶ â†’ <span style={{color:'#3498db'}}>è“é˜Ÿ</span> (2, 4, 6å·ä½)
                            </>
                        ) : (
                            <>
                                æŠ½ç­¾å†³å®šåº§ä½é¡ºåº<br/>
                                <span style={{color:'#f1c40f'}}>ç‚¹æ•°è¶Šå¤§ï¼Œåº§ä½è¶Šé å‰ (1å·ä½èµ·)</span>
                            </>
                        )}
                        <br/>
                        <span style={{fontSize: 12, opacity: 0.8, marginTop: 5, display:'block'}}>(2 &gt; A &gt; K &gt; ... &gt; 3)</span>
                    </div>
                </div>

                <div style={{
                    display: 'flex', gap: 15, flexWrap: 'wrap', justifyContent: 'center', 
                    maxWidth: 800, padding: 10
                }}>
                    {Array.from({ length: players.length }).map((_, index) => {
                        const flipData = flippedCards[index];
                        const isFlipped = !!flipData;
                        const isMine = isFlipped && flipData.playerName === players.find(p=>p.id===mySocketId)?.name;

                        return (
                            <div key={index} style={{position: 'relative', width: 80, height: 110, display:'flex', flexDirection:'column', alignItems:'center'}}>
                                {/* ç©å®¶åå­—æ ‡ç­¾ - [ä¿®æ”¹] ç¨å¾®è°ƒé«˜ top é¿å…è§†è§‰æ‹¥æŒ¤ */}
                                {isFlipped && (
                                    <div style={{
                                        position: 'absolute', top: -28, width: 120, textAlign: 'center',
                                        fontSize: 12, color: isMine ? '#f1c40f' : 'white', fontWeight: 'bold',
                                        textShadow: '0 1px 2px black', whiteSpace:'nowrap',
                                        zIndex: 10 // ç¡®ä¿åå­—åœ¨æœ€ä¸Šå±‚
                                    }}>
                                        {flipData.playerName}
                                    </div>
                                )}

                                {isFlipped ? (
                                    // ç¿»å¼€åçš„ç‰Œ
                                    <div style={{
                                        transform: isMine ? 'scale(1.1)' : 'scale(1)', 
                                        transition: 'all 0.3s',
                                        pointerEvents: 'auto',
                                        // [ä¿®æ”¹] å¦‚æœæ˜¯æˆ‘çš„ç‰Œï¼Œåœ¨å¤–å±‚åŠ å…‰æ™•ï¼Œè€Œä¸æ˜¯è®© Card ç»„ä»¶è‡ªå·±å¼¹èµ·
                                        boxShadow: isMine ? '0 0 20px rgba(241, 196, 15, 0.6)' : 'none',
                                        borderRadius: 6
                                    }}>
                                        <Card 
                                            cardVal={flipData.val} 
                                            index={0} 
                                            // [ä¿®æ”¹] å¼ºåˆ¶è®¾ä¸º falseï¼Œé˜²æ­¢ Card ç»„ä»¶å†…éƒ¨æ‰§è¡Œ translateY(-35px) å¯¼è‡´é®æŒ¡åå­—
                                            isSelected={false} 
                                            onClick={()=>{}} 
                                            onMouseEnter={()=>{}} 
                                            spacing={0}
                                        />
                                    </div>
                                ) : (
                                    // å¡èƒŒ
                                    <div 
                                        onClick={() => onCardClick(index)}
                                        style={{
                                            width: 55, height: 70, 
                                            background: 'linear-gradient(135deg, #2c3e50 0%, #34495e 100%)',
                                            borderRadius: 6,
                                            border: '2px solid #bdc3c7',
                                            display: 'flex', alignItems: 'center', justifyContent: 'center',
                                            cursor: 'pointer',
                                            boxShadow: '0 4px 8px rgba(0,0,0,0.3)',
                                            transition: 'transform 0.2s',
                                            pointerEvents: 'auto'
                                        }}
                                        onMouseDown={(e) => e.currentTarget.style.transform = 'scale(0.95)'}
                                        onMouseUp={(e) => e.currentTarget.style.transform = 'scale(1.05)'}
                                    >
                                        <div style={{
                                            width: 40, height: 55, border: '1px dashed rgba(255,255,255,0.3)', 
                                            borderRadius: 4, display:'flex', alignItems:'center', justifyContent:'center'
                                        }}>
                                            <span style={{fontSize: 20, opacity: 0.5, color: 'white'}}>?</span>
                                        </div>
                                    </div>
                                )}
                            </div>
                        );
                    })}
                </div>

                <div style={{marginTop: 40, color: '#f1c40f', fontSize: 18, fontWeight: 'bold', textShadow: '0 2px 4px rgba(0,0,0,0.5)', height: 30}}>
                    {infoText}
                </div>

            </div>
        </div>
    );
};

================================================================================
FILE PATH: client\src\screens\GameScreen.jsx
================================================================================
import React, { useState, useRef, useEffect } from 'react';
// [ä¿®æ”¹] å¼•å…¥ Lightbulb
import { Coins, Layers, Crown, Clock, Bot, Zap, Maximize, Minimize, Shield, RotateCcw, ChevronDown, ChevronUp, Lightbulb } from 'lucide-react';
import { styles } from '../styles.js'; 
import { Card, MiniCard, PlayerAvatar, GameLogPanel } from '../components/BaseUI.jsx';
import { ScoreTable } from '../components/ScoreTable.jsx'; 
import TimerComponent from '../components/CountDownTimer.jsx'; 
import { calculateCardSpacing, getCardIndexFromTouch } from '../utils/cardLogic.js'; 

// [æ–°å¢] å¼•å…¥ useGame
import { useGame } from '../context/GameContext.jsx';

// [ä¿®æ”¹] ç§»é™¤ Props å‚æ•°
export const GameScreen = () => {

    // [æ–°å¢] ä» Context è·å–æ‰€æœ‰æ•°æ®
    const { 
        roomId, players, myHand, selectedCards, lastPlayed, lastPlayerName, currentTurnId, 
        infoMessage: serverInfoMessage, winner, 
        playerScores, // æ€»åˆ† (Grand + Round)
        roundPoints, // æœ¬å±€å¾—åˆ†
        playersInfo = {}, 
        pendingPoints, gameLogs, sortMode,
        mySocketId, roundResult, grandResult, roomConfig,
        turnRemaining, finishedRank = [], 
        handCounts = {}, 
        toggleSort, handleMouseDown, handleMouseEnter, handlePlayCards, handlePass, handleNextRound, handleStartGame,
        handleToggleAutoPlay, handleClearSelection, handleRequestHint 
    } = useGame();

    // èº«ä»½åŒæ­¥ä¿æŠ¤
    const myPlayerExists = players.some(p => p.id === mySocketId);
    if (!myPlayerExists && players.length > 0) {
        return <div style={{...styles.gameTable, color:'white', display:'flex', justifyContent:'center', alignItems:'center'}}>æ­£åœ¨åŒæ­¥æ•°æ®...</div>;
    }

    const isMyTurn = currentTurnId === mySocketId;
    const amIHost = players.find(p => p.id === mySocketId)?.isHost;
    
    // --- å±å¹•å°ºå¯¸ ---
    const [dimensions, setDimensions] = useState({ width: window.innerWidth, height: window.innerHeight });
    useEffect(() => {
        const handleResize = () => setDimensions({ width: window.innerWidth, height: window.innerHeight });
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, []);

    const handAreaWidth = dimensions.width; 
    const cardSpacing = calculateCardSpacing(myHand.length, handAreaWidth);
    
    const myInfo = (playersInfo && playersInfo[mySocketId]) || {};
    const amIAutoPlay = myInfo.isAutoPlay;

    const isCrowded = players.length > 6;
    const avatarScale = isCrowded ? 0.85 : 1;
    const avatarStyleOverride = isCrowded ? { transform: `scale(${avatarScale})`, margin: -5 } : {};

    const [localInfo, setLocalInfo] = useState('');
    const displayMessage = localInfo || serverInfoMessage;

    const [isFullScreen, setIsFullScreen] = useState(false);
    // [ä¿®æ”¹] é»˜è®¤æ”¶èµ·çŠ¶æ€
    const [isScoreBoardCollapsed, setIsScoreBoardCollapsed] = useState(true);

    const currentTurnPlayer = players.find(p => p.id === currentTurnId);
    const waitingText = currentTurnPlayer ? `ç­‰å¾… ${currentTurnPlayer.name}...` : 'ç­‰å¾…ä¸­...';

    // è®¡ç®—é˜Ÿä¼åˆ†æ•°
    const getTeamScores = () => {
        let redScore = 0;
        let blueScore = 0;
        let hasTeams = false;

        players.forEach(p => {
            const pInfo = playersInfo[p.id];
            const score = playerScores[p.id] || 0;
            if (pInfo && pInfo.team !== undefined && pInfo.team !== null) {
                hasTeams = true;
                if (pInfo.team === 0) redScore += score;
                else if (pInfo.team === 1) blueScore += score;
            }
        });

        return { hasTeams, redScore, blueScore };
    };

    const { hasTeams, redScore, blueScore } = getTeamScores();

    // [å…³é”®ä¿®å¤] é¢„å¤„ç† Players æ•°æ®ï¼Œåˆå¹¶ Team ä¿¡æ¯
    // ScoreTable ç»„ä»¶ä¾èµ– player.team æ¥ç»Ÿè®¡é˜Ÿä¼æ€»åˆ†ï¼Œä½†åŸå§‹ players æ•°ç»„å¯èƒ½æ²¡æœ‰ team å­—æ®µï¼ˆå› ä¸ºå®ƒå­˜åœ¨äº playersInfo ä¸­ï¼‰
    const playersWithTeamInfo = players.map(p => ({
        ...p,
        team: (playersInfo[p.id] && playersInfo[p.id].team !== undefined) ? playersInfo[p.id].team : p.team
    }));

    // --- è§¦æ‘¸é€»è¾‘ ---
    const handContainerRef = useRef(null);
    const lastTouchedIndex = useRef(null);
    const isDragging = useRef(false);
    const dragStartMode = useRef(true); 

    const stateRef = useRef({ myHand, selectedCards, cardSpacing, handleMouseDown });
    useEffect(() => {
        stateRef.current = { myHand, selectedCards, cardSpacing, handleMouseDown };
    }, [myHand, selectedCards, cardSpacing, handleMouseDown]);

    const onTouchStartLogic = (e) => {
        if (e.cancelable) e.preventDefault();
        const touch = e.touches[0];
        const container = handContainerRef.current;
        if (!container) return;
        const rect = container.getBoundingClientRect();
        const { myHand: currHand, selectedCards: currSelection, cardSpacing: currSpacing, handleMouseDown: currToggle } = stateRef.current;
        const index = getCardIndexFromTouch(touch.clientX, rect.left, currSpacing, currHand.length);
        const cardVal = currHand[index];
        if (cardVal === undefined) return;

        const isSelected = currSelection.includes(cardVal);
        const CARD_HEIGHT = 70;    
        const POP_HEIGHT = 35;     
        const TOLERANCE = 10;      
        const validVisualHeight = isSelected ? CARD_HEIGHT + POP_HEIGHT + TOLERANCE : CARD_HEIGHT + TOLERANCE;
        const distanceFromBottom = rect.bottom - touch.clientY;

        if (distanceFromBottom > validVisualHeight || distanceFromBottom < -10) {
            isDragging.current = false;
            return;
        }

        isDragging.current = true;
        dragStartMode.current = !currSelection.includes(cardVal);
        lastTouchedIndex.current = index;
        
        if (isSelected !== dragStartMode.current) {
            currToggle(cardVal); 
            if (navigator.vibrate) navigator.vibrate(5);
        }
    };

    const onTouchMoveLogic = (e) => {
        if (e.cancelable) e.preventDefault(); 
        if (!isDragging.current) return;
        const touch = e.touches[0];
        const container = handContainerRef.current;
        if (!container) return;
        const rect = container.getBoundingClientRect();
        if (touch.clientY < rect.top - 50 || touch.clientY > rect.bottom + 50) return;
        const { myHand: currHand, selectedCards: currSelection, cardSpacing: currSpacing, handleMouseDown: currToggle } = stateRef.current;
        const index = getCardIndexFromTouch(touch.clientX, rect.left, currSpacing, currHand.length);
        if (lastTouchedIndex.current !== index) {
            lastTouchedIndex.current = index;
            const cardVal = currHand[index];
            if (cardVal !== undefined) {
                const isSelected = currSelection.includes(cardVal);
                if (isSelected !== dragStartMode.current) {
                    currToggle(cardVal); 
                    if (navigator.vibrate) navigator.vibrate(5);
                }
            }
        }
    };

    const onTouchEndLogic = () => {
        isDragging.current = false;
        lastTouchedIndex.current = null;
    };

    useEffect(() => {
        const container = handContainerRef.current;
        if (!container || amIAutoPlay) return;
        const ts = (e) => onTouchStartLogic(e);
        const tm = (e) => onTouchMoveLogic(e);
        const te = (e) => onTouchEndLogic(e);
        container.addEventListener('touchstart', ts, { passive: false });
        container.addEventListener('touchmove', tm, { passive: false });
        container.addEventListener('touchend', te);
        return () => {
            container.removeEventListener('touchstart', ts);
            container.removeEventListener('touchmove', tm);
            container.removeEventListener('touchend', te);
        };
    }, [amIAutoPlay]); 

    const toggleFullScreen = () => {
        const doc = window.document;
        const docEl = doc.documentElement;
        const requestFullScreen = docEl.requestFullscreen || docEl.webkitRequestFullScreen;
        const cancelFullScreen = doc.exitFullscreen || doc.webkitExitFullscreen;
        if (!doc.fullscreenElement && !doc.webkitFullscreenElement) {
            if (requestFullScreen) requestFullScreen.call(docEl).then(()=>setIsFullScreen(true)).catch(e=>console.log(e));
        } else {
            if (cancelFullScreen) cancelFullScreen.call(doc).then(()=>setIsFullScreen(false));
        }
    };

    const renderPlayers = () => {
        const myIndex = players.findIndex(p => p.id === mySocketId);
        const safeMyIndex = myIndex;
        
        const otherPlayers = [];
        for (let i = 1; i < players.length; i++) {
            const idx = (safeMyIndex + i) % players.length;
            otherPlayers.push(players[idx]);
        }

        const layoutConfig = [];
        const total = otherPlayers.length;
        let countL = 0, countT = 0, countR = 0;

        if (total === 1) { countT = 1; }
        else if (total === 2) { countR = 1; countL = 1; } 
        else if (total === 3) { countR = 1; countT = 1; countL = 1; } 
        else if (total === 4) { countR = 1; countT = 2; countL = 1; } 
        else if (total === 5) { countR = 2; countT = 1; countL = 2; } 
        else {
            countR = 2;
            countL = 2;
            countT = total - 4;
        }

        const rightGroup = otherPlayers.slice(0, countR);
        const topGroup = otherPlayers.slice(countR, countR + countT);
        const leftGroup = otherPlayers.slice(countR + countT);

        rightGroup.forEach((p, i) => {
            const topPos = countR === 1 ? '40%' : (i === 0 ? '55%' : '35%');
            layoutConfig.push({ p, pos: { top: topPos, right: 10, transform: 'translateY(-50%)' }, timerPos: 'left' });
        });

        topGroup.forEach((p, i) => {
            let leftPos;
            if (countT === 1) {
                leftPos = '50%';
            } else {
                const start = 20; 
                const end = 80;
                const step = (end - start) / (countT - 1);
                leftPos = `${end - i * step}%`; 
            }
            layoutConfig.push({ p, pos: { top: 10, left: leftPos, transform: 'translateX(-50%)' }, timerPos: 'bottom' });
        });

        leftGroup.forEach((p, i) => {
            const topPos = countL === 1 ? '40%' : (i === 0 ? '35%' : '55%'); 
            layoutConfig.push({ p, pos: { top: topPos, left: 30, transform: 'translateY(-50%)' }, timerPos: 'right' });
        });

        const me = players[safeMyIndex];
        const allItems = [
            { p: me, pos: { bottom: 25, left: 20, zIndex: 100 }, hideTimer: true }, 
            ...layoutConfig
        ];

        return allItems.map(({ p, pos, timerPos, hideTimer }, i) => {
            const info = (playersInfo && playersInfo[p.id]) || {};
            const isBot = info.isBot || p.isBot;
            const isAuto = info.isAutoPlay;
            const rankIndex = finishedRank ? finishedRank.indexOf(p.id) : -1;
            const finishedRankVal = rankIndex !== -1 ? rankIndex + 1 : null;
            const team = info.team;
            
            // è·å– roundPoints
            const myRoundPoint = (roundPoints && roundPoints[p.id]) || 0; 

            return (
                <div key={p.id} style={{...avatarStyleOverride, position: 'absolute', ...pos}}> 
                    <PlayerAvatar 
                        player={p} 
                        isTurn={p.id === currentTurnId} 
                        score={playerScores[p.id] || 0} 
                        roundScore={myRoundPoint} 
                        targetScore={roomConfig.targetScore} 
                        isMySocket={p.id === mySocketId}
                        remainingSeconds={turnRemaining}
                        rank={finishedRankVal}
                        timerPosition={timerPos}
                        hideTimer={hideTimer} 
                        cardCount={handCounts[p.id] || 0}
                        showCardCountMode={roomConfig.showCardCountMode}
                        team={team} 
                    />
                    <div style={{position: 'absolute', top: -10, right: -10, display: 'flex', gap: 5}}>
                        {isBot && <div style={styles.statusBadgeBot}><Bot size={12}/> AI</div>}
                        {isAuto && <div style={styles.statusBadgeAuto}><Zap size={12}/> æ‰˜ç®¡</div>}
                    </div>
                </div>
            );
        });
    };

    // [ä¿®æ”¹] é¡¶éƒ¨é˜Ÿä¼æ¯”åˆ†æ¿ - é€‚é… Header å†…åµŒæ ·å¼
    const renderTopScoreBoard = () => {
        if (!hasTeams) return null;
        return (
            <div style={{ position: 'relative', marginRight: 10, zIndex: 50, pointerEvents: 'auto' }}>
                {/* æŒ‰é’®ä¸»ä½“ */}
                <div 
                    onClick={() => setIsScoreBoardCollapsed(!isScoreBoardCollapsed)}
                    style={{
                        background: 'rgba(0,0,0,0.3)', 
                        padding: '4px 10px', 
                        borderRadius: 20, 
                        display: 'flex', alignItems: 'center', gap: 8, cursor: 'pointer',
                        border: '1px solid rgba(255,255,255,0.1)',
                        transition: 'background 0.2s'
                    }}
                >
                    <div style={{color:'#e74c3c', fontWeight:'bold', display:'flex', alignItems:'center', gap:3, fontSize: 13}}>
                         <Shield size={12} fill="currentColor"/> {redScore}
                    </div>
                    <div style={{width:1, height:12, background:'rgba(255,255,255,0.2)'}}></div>
                    <div style={{color:'#3498db', fontWeight:'bold', display:'flex', alignItems:'center', gap:3, fontSize: 13}}>
                         <Shield size={12} fill="currentColor"/> {blueScore}
                    </div>
                    {isScoreBoardCollapsed ? <ChevronDown size={14} color="#ccc"/> : <ChevronUp size={14} color="#ccc"/>}
                </div>

                {/* ä¸‹æ‹‰è¯¦æƒ… */}
                {!isScoreBoardCollapsed && (
                    <div style={{
                        position: 'absolute',
                        top: '120%', 
                        right: 0, // é å³å¯¹é½
                        background: 'rgba(30, 40, 50, 0.95)', 
                        borderRadius: 8, 
                        padding: 10,
                        color: 'white', 
                        fontSize: 12, 
                        textAlign: 'center', 
                        width: 140,
                        boxShadow: '0 4px 15px rgba(0,0,0,0.5)',
                        border: '1px solid rgba(255,255,255,0.1)',
                        backdropFilter: 'blur(5px)'
                    }}>
                        <div style={{marginBottom: 5, color: '#f1c40f', fontWeight: 'bold'}}>å½“å‰æ¯”åˆ†è¯¦æƒ…</div>
                        <div style={{display:'flex', justifyContent:'space-between', marginBottom:2}}>
                            <span style={{color:'#e74c3c'}}>çº¢é˜Ÿ</span> <span>{redScore}</span>
                        </div>
                        <div style={{display:'flex', justifyContent:'space-between', marginBottom:6}}>
                            <span style={{color:'#3498db'}}>è“é˜Ÿ</span> <span>{blueScore}</span>
                        </div>
                        <div style={{height:1, background:'rgba(255,255,255,0.1)', marginBottom:6}}></div>
                        <div>ç›®æ ‡åˆ†æ•°: {roomConfig.targetScore}</div>
                    </div>
                )}
            </div>
        );
    };

    return (
        <div style={styles.gameTable} onMouseUp={() => { }}>
            <div style={styles.gameSafeArea}>
                
                <div className="gameLogPanel">
                     <GameLogPanel logs={gameLogs} />
                </div>
                
                {/* [ä¿®æ”¹] ç§»é™¤äº†ç»å¯¹å®šä½çš„ TopScoreBoardï¼Œç§»å…¥ä¸‹æ–¹ tableHeader */}

                <div style={styles.tableHeader}>
                    <div style={styles.roomBadgeContainer}>
                        <div style={styles.roomBadge}>Room {roomId}</div>
                        <button 
                            style={{
                                pointerEvents: 'auto', background: amIAutoPlay ? '#e67e22' : 'rgba(255,255,255,0.1)', 
                                border: '1px solid rgba(255,255,255,0.3)', color: '#ecf0f1', borderRadius: 15, 
                                padding: '4px 8px', display: 'flex', alignItems: 'center', justifyContent: 'center',
                                cursor: 'pointer', fontSize: 11, fontWeight: 'bold', transition: 'all 0.2s'
                            }}
                            onClick={handleToggleAutoPlay}
                        >
                            <Zap size={12} style={{marginRight: 4}} fill={amIAutoPlay ? "currentColor" : "none"}/>
                            {amIAutoPlay ? 'æ‰˜ç®¡ä¸­' : 'æ‰˜ç®¡'}
                        </button>
                    </div>

                    <div style={{display:'flex', alignItems: 'center', marginLeft: 'auto'}}>
                        
                        {/* [ä¿®æ”¹] æ¯”åˆ†æ¿æ”¾åœ¨è¿™é‡Œ (å¦‚æœæœ‰é˜Ÿä¼) */}
                        {renderTopScoreBoard()}

                        <div style={{display:'flex', gap: 10}}>
                            <button 
                                style={{...styles.glassButton, padding: '8px 12px', pointerEvents: 'auto'}} 
                                onClick={toggleFullScreen}
                            >
                                {isFullScreen ? <Minimize size={18}/> : <Maximize size={18}/>}
                            </button>

                            <button style={styles.sortButton} onClick={toggleSort}>
                                <Layers size={16} style={{marginRight:5}}/> 
                                {sortMode === 'POINT' ? 'ç‚¹æ•°' : (sortMode === 'SUIT' ? 'èŠ±è‰²' : 'ç†ç‰Œ')}
                            </button>
                        </div>
                    </div>
                </div>

                <div style={styles.scoreBoard}>
                    <div style={{fontSize: 10, opacity: 0.8, textTransform:'uppercase'}}>POINTS</div>
                    <div style={{fontSize: 24, fontWeight: 'bold', color: '#f1c40f', display:'flex', alignItems:'center', justifyContent:'center', gap:5}}>
                        <Coins size={20} /> {pendingPoints}
                    </div>
                </div>

                <div style={styles.infoMessage}>{displayMessage}</div>

                {/* ç»“ç®—å¼¹çª— - ä½¿ç”¨æ–°çš„ ScoreTable */}
                {(winner || roundResult || grandResult) && (
                    <div style={styles.modalOverlay}>
                        <div className="modal-content-wrapper" style={{...styles.modalContent, width: '95%', maxWidth: 600, padding: 0, background: 'white', overflow: 'hidden'}}>
                            {grandResult ? (
                                <div style={{padding: 20, width: '100%'}}>
                                    <Crown size={60} color="#e74c3c" style={{marginBottom: 10}} />
                                    <h2 style={{fontSize: 28, marginBottom: 5, color:'#2c3e50'}}>
                                        {grandResult.grandWinner} å¤ºå† !
                                    </h2>
                                    
                                    <div style={{margin: '15px 0'}}>
                                        <ScoreTable 
                                            // [å…³é”®ä¿®å¤] ä¼ å…¥å¸¦æœ‰ Team ä¿¡æ¯çš„ players
                                            players={playersWithTeamInfo} 
                                            matchHistory={grandResult.matchHistory}
                                            currentScores={grandResult.grandScores}
                                            roomConfig={roomConfig}
                                            grandResult={grandResult}
                                        />
                                    </div>

                                    <button style={{...styles.primaryButton, fontSize: 16, height: 50}} onClick={handleStartGame}>é‡æ–°å¼€å§‹</button>
                                </div>
                            ) : roundResult ? (
                                <div style={{padding: 20, width: '100%'}}>
                                    <div style={{display:'flex', alignItems:'center', justifyContent:'center', gap:10, marginBottom: 15}}>
                                        <Coins size={30} color="#f1c40f" />
                                        <h2 style={{fontSize: 24, margin:0}}>å°å±€ç»“ç®—</h2>
                                    </div>
                                    
                                    <div style={{margin: '10px 0'}}>
                                        <ScoreTable 
                                            // [å…³é”®ä¿®å¤] ä¼ å…¥å¸¦æœ‰ Team ä¿¡æ¯çš„ players
                                            players={playersWithTeamInfo} 
                                            matchHistory={roundResult.matchHistory} 
                                            currentScores={roundResult.grandScores}
                                            roomConfig={roomConfig}
                                        />
                                    </div>

                                    {amIHost ? <button style={styles.primaryButton} onClick={handleNextRound}>ä¸‹ä¸€å±€</button> : <div style={{color:'#999', marginTop:10}}>ç­‰å¾…æˆ¿ä¸»...</div>}
                                </div>
                            ) : null}
                        </div>
                    </div>
                )}

                <div style={styles.tableCenter}>
                    {lastPlayed.length > 0 && (
                        <div style={{animation: 'popIn 0.3s'}}>
                            <div style={styles.playerNameTag}>{lastPlayerName}</div>
                            <div style={styles.playedRow}> 
                                {lastPlayed.map((c, i) => <MiniCard key={i} cardVal={c} index={i} />)}
                            </div>
                        </div>
                    )}
                </div>

                {renderPlayers()}

                <div 
                    ref={handContainerRef}
                    style={{
                        ...styles.handArea, 
                        opacity: amIAutoPlay ? 0.6 : 1, 
                        filter: amIAutoPlay ? 'grayscale(0.6)' : 'none',
                        pointerEvents: amIAutoPlay ? 'none' : 'auto' 
                    }}
                >
                    {amIAutoPlay && (
                        <div style={{
                            position: 'absolute', top: -40, left: 20,
                            background: 'rgba(230, 126, 34, 0.9)', color: 'white', padding: '5px 10px', 
                            borderRadius: 20, fontSize: 12, fontWeight: 'bold', display: 'flex', alignItems: 'center', gap: 5,
                            boxShadow: '0 4px 10px rgba(0,0,0,0.3)', zIndex: 50
                        }}>
                            <Bot size={14} /> ç³»ç»Ÿä»£æ‰“ä¸­
                        </div>
                    )}
                    
                    {myHand.map((c, i) => (
                        <Card 
                            key={`${c}-${i}`} 
                            cardVal={c} 
                            index={i} 
                            isSelected={selectedCards.includes(c)} 
                            onClick={handleMouseDown} 
                            onMouseEnter={handleMouseEnter} 
                            spacing={cardSpacing} 
                        />
                    ))}
                </div>

                <div style={styles.actionBar}>
                    {!winner && !roundResult && !grandResult && (
                        <div style={{display:'flex', alignItems: 'center', gap: 20}}>
                            {selectedCards.length > 0 && (
                                <button 
                                    style={{...styles.passButton, background: '#95a5a6', padding: '8px 15px', display: 'flex', alignItems: 'center', gap: 5}} 
                                    onClick={handleClearSelection}
                                >
                                    <RotateCcw size={16} /> é‡é€‰
                                </button>
                            )}
                            {amIAutoPlay ? (
                                <button 
                                    style={{...styles.playButton, background: '#e74c3c', width: 180, fontSize: 16, display: 'flex', justifyContent: 'center', alignItems: 'center'}} 
                                    onClick={handleToggleAutoPlay}
                                >
                                    <Zap size={18} style={{marginRight:8}}/> å–æ¶ˆæ‰˜ç®¡
                                </button>
                            ) : (
                                <>
                                    {isMyTurn ? (
                                        <>
                                            <button style={styles.passButton} onClick={handlePass}>ä¸è¦</button>
                                            
                                            {/* [æ–°å¢] æç¤ºæŒ‰é’® */}
                                            <button 
                                                style={{...styles.passButton, background: '#8e44ad', marginRight: 0, padding:'8px 15px', display:'flex', alignItems:'center', gap:5}} 
                                                onClick={handleRequestHint}
                                            >
                                                <Lightbulb size={16} /> æç¤º
                                            </button>

                                            <TimerComponent initialSeconds={turnRemaining} totalSeconds={60} position="inline" />
                                            <button style={styles.playButton} onClick={handlePlayCards}>å‡ºç‰Œ</button>
                                        </>
                                    ) : (
                                        <div style={styles.waitingBadge}><Clock size={20} className="spin" /> {waitingText}</div>
                                    )}
                                </>
                            )}
                        </div>
                    )}
                </div>
            </div>
            <style>{`.statusBadgeBot { background: #34495e; color: white; padding: 2px 6px; borderRadius: 10px; fontSize: 10px; display: flex; align-items: center; gap: 2px; border: 1px solid rgba(255,255,255,0.3); } .statusBadgeAuto { background: #e67e22; color: white; padding: 2px 6px; borderRadius: 10px; fontSize: 10px; display: flex; align-items: center; gap: 2px; border: 1px solid rgba(255,255,255,0.3); animation: pulse 2s infinite; } @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }`}</style>
        </div>
    );
};

================================================================================
FILE PATH: client\src\screens\LobbyScreen.jsx
================================================================================
// å¤§å…é¡µ - æ”¯æŒæˆ¿ä¸»æ¢åº§ + ç»„é˜Ÿæ¨¡å¼ + æˆ¿ä¸»ä¿®æ”¹è§„åˆ™
import React, { useState } from 'react';
import { Target, Layers, User, Play, Clock, Bot, Shield, ArrowUp, ArrowDown, Settings, X, Eye, Award, Check } from 'lucide-react';
import { styles } from '../styles.js';
// [æ–°å¢] å¼•å…¥ useGame
import { useGame } from '../context/GameContext.jsx';

// [ä¿®æ”¹] ç§»é™¤ Props å‚æ•°
export const LobbyScreen = () => {
    
    // [æ–°å¢] ä» Context è·å–æ•°æ®
    const { 
        roomId, roomConfig, players, mySocketId, 
        handleStartGame, 
        handleAddBot,
        handleSwitchSeat,
        handleUpdateConfig,
        handleKickPlayer // [æ–°å¢]
    } = useGame();
    
    // åˆ¤æ–­è‡ªå·±æ˜¯ä¸æ˜¯æˆ¿ä¸»
    const amIHost = players.find(p => p.id === mySocketId)?.isHost;
    
    // åˆ¤æ–­æ˜¯å¦å¼€å¯äº†ç»„é˜Ÿæ¨¡å¼ (å¼€å…³å¼€å¯ ä¸” äººæ•°æ˜¯å¶æ•°)
    const isTeamMode = roomConfig.isTeamMode && roomConfig.maxPlayers % 2 === 0;

    // --- é…ç½®å¼¹çª—çŠ¶æ€ ---
    const [showSettings, setShowSettings] = useState(false);
    
    // æ¸²æŸ“é…ç½®æ»‘å—çš„è¾…åŠ©å‡½æ•° (å¤ç”¨è‡ª LoginScreen é£æ ¼)
    const renderConfigSlider = (icon, label, value, min, max, step, onChange, suffix = '') => (
        <div style={styles.configItem}>
            <div style={styles.configLabel}>
                <span style={{display:'flex', alignItems:'center', gap:6}}>{icon} {label}</span>
                <span style={styles.configValue}>{value}{suffix}</span>
            </div>
            <input 
                type="range" 
                style={styles.rangeInput}
                min={min} 
                max={max} 
                step={step || 1}
                value={value} 
                onChange={(e) => onChange(parseInt(e.target.value))}
            />
        </div>
    );

    // ç»Ÿä¸€æ›´æ–°å‡½æ•°
    const updateConfig = (key, value) => {
        const newConfig = { ...roomConfig, [key]: value };
        // ç«‹å³å‘é€ socket è¯·æ±‚
        handleUpdateConfig(newConfig);
    };

    // æ¸²æŸ“è®¾ç½®å¼¹çª—å†…å®¹
    const renderSettingsModal = () => (
        <div style={styles.modalOverlay}>
            <div style={{...styles.modalContent, width: '90%', maxWidth: 500, padding: 25, textAlign:'left'}}>
                <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom: 20, borderBottom:'1px solid #eee', paddingBottom:10}}>
                    <div style={{display:'flex', alignItems:'center', gap:8, fontSize:18, fontWeight:'bold', color:'#2c3e50'}}>
                        <Settings size={20}/> æˆ¿é—´è§„åˆ™è®¾ç½®
                    </div>
                    <button onClick={()=>setShowSettings(false)} style={{background:'none', border:'none', cursor:'pointer', padding:5}}>
                        <X size={20} color="#999"/>
                    </button>
                </div>

                <div style={{maxHeight: '60vh', overflowY:'auto', paddingRight: 5}}>
                    <div style={styles.configGrid}>
                        {renderConfigSlider(<UsersIcon/>, "ç©å®¶äººæ•°", roomConfig.maxPlayers, 2, 12, 1, v=>updateConfig('maxPlayers', v), 'äºº')}
                        {renderConfigSlider(<Layers size={14}/>, "ç‰Œåº“æ•°é‡", roomConfig.deckCount, 1, 8, 1, v=>updateConfig('deckCount', v), 'å‰¯')}
                        {renderConfigSlider(<Target size={14}/>, "è·èƒœç›®æ ‡", roomConfig.targetScore, 500, 5000, 500, v=>updateConfig('targetScore', v), 'åˆ†')}
                        
                        {/* ç»„é˜Ÿå¯¹æŠ—å¼€å…³ */}
                        <div style={{...styles.configItem, marginTop: 10, padding: '10px', background: roomConfig.maxPlayers % 2 !== 0 ? '#f0f0f0' : '#e8f8f5', borderRadius: 8, opacity: roomConfig.maxPlayers % 2 !== 0 ? 0.6 : 1, gridColumn: '1 / -1'}}>
                            <div style={{display:'flex', justifyContent:'space-between', alignItems:'center'}}>
                                <div style={{display:'flex', alignItems:'center', gap:6, fontWeight:'600', color: roomConfig.maxPlayers % 2 !== 0 ? '#999' : '#27ae60'}}>
                                    <Shield size={16} /> ç»„é˜Ÿå¯¹æŠ—æ¨¡å¼ (2v2, 3v3...)
                                </div>
                                <label style={{position:'relative', display:'inline-block', width:40, height:20}}>
                                    <input 
                                        type="checkbox" 
                                        style={{opacity:0, width:0, height:0}}
                                        checked={roomConfig.isTeamMode && roomConfig.maxPlayers % 2 === 0}
                                        disabled={roomConfig.maxPlayers % 2 !== 0}
                                        onChange={(e) => updateConfig('isTeamMode', e.target.checked)}
                                    />
                                    <span style={{
                                        position:'absolute', cursor: roomConfig.maxPlayers % 2 !== 0 ? 'not-allowed' : 'pointer', top:0, left:0, right:0, bottom:0, 
                                        backgroundColor: (roomConfig.isTeamMode && roomConfig.maxPlayers % 2 === 0) ? '#27ae60' : '#ccc', 
                                        transition:'.4s', borderRadius: 20
                                    }}>
                                        <span style={{
                                            position:'absolute', content:"", height:16, width:16, left:2, bottom:2, 
                                            backgroundColor:'white', transition:'.4s', borderRadius:'50%',
                                            transform: (roomConfig.isTeamMode && roomConfig.maxPlayers % 2 === 0) ? 'translateX(20px)' : 'translateX(0)'
                                        }}></span>
                                    </span>
                                </label>
                            </div>
                            <div style={{fontSize: 11, color: '#7f8c8d', marginTop: 4}}>
                                {roomConfig.maxPlayers % 2 !== 0 ? "âš ï¸ éœ€è¦å¶æ•°äººæ•° (4, 6...) æ‰èƒ½å¼€å¯" : "å¼€å¯åï¼Œé—´éš”å…¥åº§ä¸ºé˜Ÿå‹"}
                            </div>
                        </div>
                        
                        {/* å‡ºç‰Œæ—¶é™ */}
                        <div style={styles.configItem}>
                            <div style={styles.configLabel}>
                                <span style={{display:'flex', alignItems:'center', gap:6}}><Clock size={14}/> å‡ºç‰Œæ—¶é™</span>
                                <span style={styles.configValue}>{roomConfig.turnTimeout / 1000}ç§’</span>
                            </div>
                            <div style={styles.radioGroup}>
                                {[30, 60, 90, 120].map(sec => (
                                    <button 
                                        key={sec}
                                        style={roomConfig.turnTimeout === sec * 1000 ? styles.radioBtnActive : styles.radioBtn}
                                        onClick={() => updateConfig('turnTimeout', sec * 1000)}
                                    >
                                        {sec}s
                                    </button>
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* å‰©ä½™ç‰Œæ•°æ˜¾ç¤ºé…ç½® */}
                    <div style={{marginTop: 20, paddingTop: 15, borderTop: '1px solid #f0f0f0'}}>
                        <div style={{display:'flex', alignItems:'center', gap:6, color:'#7f8c8d', fontSize:14, marginBottom:10, fontWeight:600}}>
                            <Eye size={14}/> å‰©ä½™ç‰Œæ•°æ˜¾ç¤ºè§„åˆ™
                        </div>
                        <div style={styles.radioGroup}>
                            <button 
                                style={roomConfig.showCardCountMode === 0 ? styles.radioBtnActive : styles.radioBtn}
                                onClick={() => updateConfig('showCardCountMode', 0)}
                            >
                                ä¸æ˜¾ç¤º
                            </button>
                            <button 
                                style={roomConfig.showCardCountMode === 1 ? styles.radioBtnActive : styles.radioBtn}
                                onClick={() => updateConfig('showCardCountMode', 1)}
                            >
                                â‰¤3å¼ æ˜¾ç¤º
                            </button>
                            <button 
                                style={roomConfig.showCardCountMode === 2 ? styles.radioBtnActive : styles.radioBtn}
                                onClick={() => updateConfig('showCardCountMode', 2)}
                            >
                                ä¸€ç›´æ˜¾ç¤º
                            </button>
                        </div>
                    </div>

                    {/* æ’åèµç½š */}
                    <div style={{marginTop: 20, paddingTop: 20, borderTop: '1px solid #f0f0f0'}}>
                         <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom: 15}}>
                            <div style={{display:'flex', alignItems:'center', gap:8, fontWeight:'600', color:'#555', fontSize:14}}>
                                <Award size={16} /> å¯ç”¨æ’åèµç½š (è¿›è´¡/æŠ“åˆ†)
                            </div>
                            <label style={{position:'relative', display:'inline-block', width:40, height:20}}>
                                <input 
                                    type="checkbox" 
                                    style={{opacity:0, width:0, height:0}}
                                    checked={roomConfig.enableRankPenalty}
                                    onChange={(e) => updateConfig('enableRankPenalty', e.target.checked)}
                                />
                                <span style={{
                                    position:'absolute', cursor:'pointer', top:0, left:0, right:0, bottom:0, 
                                    backgroundColor: roomConfig.enableRankPenalty ? '#27ae60' : '#ccc', 
                                    transition:'.4s', borderRadius: 20
                                }}>
                                    <span style={{
                                        position:'absolute', content:"", height:16, width:16, left:2, bottom:2, 
                                        backgroundColor:'white', transition:'.4s', borderRadius:'50%',
                                        transform: roomConfig.enableRankPenalty ? 'translateX(20px)' : 'translateX(0)'
                                    }}></span>
                                </span>
                            </label>
                        </div>
                        {roomConfig.enableRankPenalty && (
                            <div style={{background:'#f9f9f9', padding: 15, borderRadius: 8, display:'flex', gap: 20, fontSize: 13}}>
                                <div style={{flex:1}}>
                                    <div style={{marginBottom:5, color:'#7f8c8d'}}>å¤´å°¾èµç½š</div>
                                    <input 
                                        type="number" style={{...styles.input, background:'white', height: 35, padding: '0 10px'}} 
                                        value={roomConfig.rankPenaltyScores[0]}
                                        onChange={e => {
                                            const val = Math.max(0, parseInt(e.target.value) || 0);
                                            updateConfig('rankPenaltyScores', [val, roomConfig.rankPenaltyScores[1]]);
                                        }}
                                    />
                                </div>
                                <div style={{flex:1}}>
                                    <div style={{marginBottom:5, color:'#7f8c8d'}}>æ¬¡çº§èµç½š</div>
                                    <input 
                                        type="number" style={{...styles.input, background:'white', height: 35, padding: '0 10px'}} 
                                        value={roomConfig.rankPenaltyScores[1]}
                                        onChange={e => {
                                            const val = Math.max(0, parseInt(e.target.value) || 0);
                                            updateConfig('rankPenaltyScores', [roomConfig.rankPenaltyScores[0], val]);
                                        }}
                                    />
                                </div>
                            </div>
                        )}
                    </div>

                </div>

                <div style={{marginTop: 20, textAlign:'center'}}>
                    <button style={{...styles.primaryButton, height: 50, fontSize: 16, marginTop:0}} onClick={() => setShowSettings(false)}>
                        <Check size={18} style={{marginRight:5}}/> å®Œæˆè®¾ç½®
                    </button>
                </div>
            </div>
        </div>
    );

    // ç®€å•å°è£… Users å›¾æ ‡
    const UsersIcon = () => <User size={14}/>;

    return (
    <div style={styles.container}>
      {showSettings && renderSettingsModal()}

      <div style={styles.lobbyCard} className="mobile-layout-column">
          
          <div className="mobile-lobby-content" style={{display:'flex', flexDirection:'column', height:'100%', width: '100%', overflow:'hidden', borderRadius: 20}}>
            
            {/* å¤´éƒ¨ä¿¡æ¯ */}
            <div style={styles.lobbyHeader}>
                <div style={{display:'flex', alignItems:'center', gap: 10}}>
                    <h2 style={{margin:0, fontSize: 24}}>æˆ¿é—´: <span style={{fontFamily:'monospace', color:'#27ae60'}}>{roomId}</span></h2>
                    {/* ç»„é˜Ÿæ¨¡å¼æ ‡ç­¾ */}
                    {isTeamMode && (
                        <span style={{background:'#27ae60', color:'white', fontSize:12, padding:'2px 8px', borderRadius:10, display:'flex', alignItems:'center', gap:4}}>
                            <Shield size={12}/> ç»„é˜Ÿæ¨¡å¼
                        </span>
                    )}
                </div>
                
                {/* å¤´éƒ¨å³ä¾§ï¼šä¿¡æ¯æ ‡ç­¾ + è®¾ç½®æŒ‰é’® */}
                <div style={{display:'flex', gap:10, alignItems:'center'}}>
                    <div style={{display:'flex', gap:10}} className="hide-on-mobile">
                        <span style={styles.tag}><Target size={14}/> ç›®æ ‡ {roomConfig.targetScore}</span>
                        <span style={styles.tag}><Layers size={14}/> {roomConfig.deckCount}å‰¯</span>
                        <span style={styles.tag}><User size={14}/> {roomConfig.maxPlayers}äºº</span>
                    </div>

                    {/* [æ–°å¢] æˆ¿ä¸»è®¾ç½®æŒ‰é’® */}
                    {amIHost && (
                        <button 
                            onClick={() => setShowSettings(true)}
                            style={{
                                background: '#f1f2f6', border: '1px solid #ccc', borderRadius: '50%', 
                                width: 36, height: 36, display: 'flex', alignItems: 'center', justifyContent: 'center',
                                cursor: 'pointer', transition: 'all 0.2s', color: '#2c3e50'
                            }}
                            title="ä¿®æ”¹æˆ¿é—´è§„åˆ™"
                        >
                            <Settings size={20} />
                        </button>
                    )}
                </div>
            </div>
            
            {/* ç§»åŠ¨ç«¯æ˜¾ç¤ºçš„é…ç½®æ¦‚è§ˆ (ä½œä¸ºè¡¥å……) */}
            <div style={{padding: '0 15px 10px 15px', display:'flex', gap:8, flexWrap:'wrap', fontSize:12, color:'#666'}} className="mobile-only-tags">
                 <span style={styles.tag}><Target size={12}/> {roomConfig.targetScore}</span>
                 <span style={styles.tag}><Layers size={12}/> {roomConfig.deckCount}å‰¯</span>
                 <span style={styles.tag}><User size={12}/> {roomConfig.maxPlayers}äºº</span>
                 {roomConfig.enableRankPenalty && <span style={{...styles.tag, color:'#e67e22', background:'#fdf2e9'}}><Award size={12}/> èµç½š</span>}
            </div>
            <style>{`@media (min-width: 769px) { .mobile-only-tags { display: none !important; } }`}</style>

            {/* ç©å®¶åˆ—è¡¨åŒºåŸŸ */}
            <div style={styles.playerGrid} className="mobile-lobby-grid">
                {players.map((p, i) => {
                    // ç»„é˜Ÿæ¨¡å¼è§†è§‰é€»è¾‘
                    let teamColor = '#eee'; 
                    let teamBg = 'white';   
                    let teamName = null;
                    
                    if (isTeamMode) {
                        const isRedTeam = i % 2 === 0; // 0, 2, 4... çº¢é˜Ÿ
                        teamColor = isRedTeam ? '#e74c3c' : '#3498db';
                        teamBg = isRedTeam ? '#fdedec' : '#eaf2f8';
                        teamName = isRedTeam ? 'çº¢é˜Ÿ' : 'è“é˜Ÿ';
                    }

                    const isMe = p.id === mySocketId;
                    if (isMe && !isTeamMode) {
                        teamBg = '#f0fbf4';
                        teamColor = '#27ae60';
                    }
                    const borderWidth = isMe ? 3 : 2;

                    return (
                        <div key={p.id} style={{
                            ...styles.lobbyPlayer, 
                            borderColor: isMe ? '#2ecc71' : teamColor, 
                            background: teamBg,
                            borderWidth: borderWidth,
                            position: 'relative'
                        }}>
                            {/* [æ–°å¢] æˆ¿ä¸»è¸¢äººæŒ‰é’® */}
                            {amIHost && !isMe && (
                                <button 
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        const confirmKick = window.confirm(`ç¡®å®šè¦è¸¢å‡º ${p.name} å—ï¼Ÿ`);
                                        if (confirmKick) handleKickPlayer(p.id);
                                    }}
                                    style={styles.kickButton}
                                    title="è¸¢å‡ºç©å®¶"
                                >
                                    <X size={14} color="white"/>
                                </button>
                            )}

                            {/* ç»„é˜Ÿè§’æ ‡ */}
                            {teamName && (
                                <div style={{
                                    position: 'absolute', top: 0, left: 0, 
                                    background: teamColor, color: 'white', 
                                    fontSize: 10, padding: '2px 8px', 
                                    borderBottomRightRadius: 8, borderTopLeftRadius: 8
                                }}>
                                    {teamName}
                                </div>
                            )}

                            {/* æˆ¿ä¸»è°ƒä½æŒ‰é’® */}
                            {amIHost && players.length > 1 && (
                                <div style={{
                                    position: 'absolute', right: 5, top: '50%', transform: 'translateY(-50%)',
                                    display:'flex', flexDirection:'column', gap:4
                                }}>
                                    {i > 0 && (
                                        <button 
                                            onClick={(e) => { e.stopPropagation(); handleSwitchSeat(i, i - 1); }}
                                            style={{
                                                padding:4, borderRadius:4, border:'1px solid #ccc', 
                                                background:'white', cursor:'pointer', lineHeight:0
                                            }}
                                            title="ä¸Šç§»"
                                        >
                                            <ArrowUp size={14} color="#666"/>
                                        </button>
                                    )}
                                    {i < players.length - 1 && (
                                        <button 
                                            onClick={(e) => { e.stopPropagation(); handleSwitchSeat(i, i + 1); }}
                                            style={{
                                                padding:4, borderRadius:4, border:'1px solid #ccc', 
                                                background:'white', cursor:'pointer', lineHeight:0
                                            }}
                                            title="ä¸‹ç§»"
                                        >
                                            <ArrowDown size={14} color="#666"/>
                                        </button>
                                    )}
                                </div>
                            )}

                            <div style={styles.avatarLarge}>
                                {p.isBot ? <Bot size={40} /> : p.name[0]}
                            </div>
                            <div style={{fontWeight: 'bold', display:'flex', alignItems:'center', gap:5}}>
                                {p.name}
                                {p.isBot && <span style={{fontSize:10, background:'#eee', padding:'2px 5px', borderRadius:4}}>AI</span>}
                            </div>
                            {p.isHost && <span style={styles.hostBadge}>æˆ¿ä¸»</span>}
                        </div>
                    );
                })}
                
                {/* è™šæ‹Ÿç©ºä½ */}
                {Array.from({length: Math.max(0, roomConfig.maxPlayers - players.length)}).map((_, i) => (
                    <div key={`empty-${i}`} style={{...styles.lobbyPlayer, borderStyle: 'dashed', opacity: 0.5}}>
                        <div style={{...styles.avatarLarge, background:'#f0f0f0', color:'#ccc'}}>?</div>
                        <div style={{color:'#999'}}>ç­‰å¾…åŠ å…¥</div>
                    </div>
                ))}
            </div>

            {/* åº•éƒ¨æŒ‰é’® */}
            <div style={styles.lobbyFooter} className="mobile-lobby-footer">
                {players.find(p=>p.id===mySocketId)?.isHost ? (
                    <div style={{display:'flex', gap: 15, justifyContent: 'center'}}>
                        <button 
                            style={{...styles.primaryButton, background: '#7f8c8d', width:'auto', padding:'0 20px', fontSize: 16, marginTop:0}} 
                            onClick={handleAddBot}
                            disabled={players.length >= roomConfig.maxPlayers}
                        >
                            <Bot size={18} style={{marginRight:5}}/> +Bot
                        </button>

                        <button style={{...styles.primaryButton, width:'auto', padding:'0 30px', marginTop:0}} onClick={handleStartGame} disabled={players.length < 2}>
                            <Play size={18} style={{marginRight:5}}/> å¼€å§‹å¯¹æˆ˜
                        </button>
                    </div>
                ) : (
                    <div style={{color:'#999', fontSize: 14, display:'flex', alignItems:'center', gap:5}}><Clock size={16}/> ç­‰å¾…æˆ¿ä¸»å¼€å§‹...</div>
                )}
            </div>
          </div>
      </div>
    </div>
    );
};

================================================================================
FILE PATH: client\src\screens\LoginScreen.jsx
================================================================================
// ç™»å½•é¡µ - é€‚é…ç§»åŠ¨ç«¯ï¼ŒåŒ…å«è‡ªåŠ¨å…¨å±é€»è¾‘ + æ‰‹åŠ¨å…¨å±æŒ‰é’® + å‰©ä½™ç‰Œæ•°é…ç½® + ç»„é˜Ÿå¼€å…³ (ç§»é™¤æŠ½å¡å¼€å…³ï¼Œæ”¹ä¸ºé»˜è®¤)
import React, { useState } from 'react'; 
import { User, Monitor, RefreshCw, Plus, LogIn, Clock, Layers, Users, Target, Wifi, WifiOff, Award, Maximize, Minimize, Eye, Shield } from 'lucide-react'; 
import { styles } from '../styles.js';
// [æ–°å¢] å¼•å…¥ useGame
import { useGame } from '../context/GameContext.jsx';

// [ä¿®æ”¹] ç§»é™¤ Props å‚æ•°
export const LoginScreen = () => {
    
    // [æ–°å¢] ä» Context è·å–æ•°æ®
    const { 
        username, setUsername, 
        roomId, setRoomId, 
        roomConfig, setRoomConfig, 
        isCreatorMode, setIsCreatorMode, 
        handleRoomAction, 
        isLoading,
        isConnected 
    } = useGame();

    // å…¨å±çŠ¶æ€ç®¡ç†
    const [isFullScreen, setIsFullScreen] = useState(false);

    // æ‰‹åŠ¨åˆ‡æ¢å…¨å±
    const toggleFullScreen = () => {
        if (!document.fullscreenElement) {
            const docEl = document.documentElement;
            const requestFull = docEl.requestFullscreen || docEl.webkitRequestFullscreen || docEl.mozRequestFullScreen || docEl.msRequestFullscreen;
            if (requestFull) {
                requestFull.call(docEl)
                    .then(() => setIsFullScreen(true))
                    .catch(err => console.log("å…¨å±è¯·æ±‚è¢«æ‹¦æˆª:", err));
            }
        } else {
            const exitFull = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen;
            if (exitFull) {
                exitFull.call(document)
                    .then(() => setIsFullScreen(false));
            }
        }
    };

    // å°è¯•è¯·æ±‚å…¨å±çš„è¾…åŠ©å‡½æ•°
    const tryEnterFullScreen = () => {
        try {
            if (!document.fullscreenElement) {
                const docEl = document.documentElement;
                const requestFull = docEl.requestFullscreen || docEl.webkitRequestFullscreen || docEl.mozRequestFullScreen || docEl.msRequestFullscreen;
                
                if (requestFull) {
                    requestFull.call(docEl)
                        .then(() => setIsFullScreen(true))
                        .catch(err => console.log("å…¨å±è‡ªåŠ¨è§¦å‘è¢«æ‹¦æˆª (æ­£å¸¸):", err));
                }
            }
        } catch (e) {
            console.log("å…¨å±é”™è¯¯:", e);
        }
    };

    const onActionClick = () => {
        tryEnterFullScreen(); 
        handleRoomAction();   
    };

    const renderConfigSlider = (icon, label, value, min, max, step, onChange, suffix = '') => (
        <div style={styles.configItem}>
            <div style={styles.configLabel}>
                <span style={{display:'flex', alignItems:'center', gap:6}}>{icon} {label}</span>
                <span style={styles.configValue}>{value}{suffix}</span>
            </div>
            <input 
                type="range" 
                style={styles.rangeInput}
                min={min} 
                max={max} 
                step={step || 1}
                value={value} 
                onChange={(e) => onChange(parseInt(e.target.value))}
            />
        </div>
    );

    return (
        <div style={styles.container}>
            <div style={styles.loginCard} className="mobile-layout-column">
                {/* å·¦ä¾§ï¼šå“ç‰Œå±•ç¤ºåŒº */}
                <div style={styles.loginLeft} className="mobile-login-left">
                    <div style={styles.logoCircle}>
                        <div style={styles.logoText}>510K</div>
                    </div>
                    <h1 style={styles.brandTitle}>æ‰‘å…‹å¯¹æˆ˜</h1>
                    <div style={styles.brandSubtitle}>å¤šäººåœ¨çº¿ Â· è‡ªç”±è§„åˆ™ Â· æé€Ÿç•…ç©</div>
                    
                    <div style={styles.featureList} className="hide-on-mobile">
                        <div style={styles.featureItem}>âœ¨ æ”¯æŒ 2-12 äººåŒå°ç«æŠ€</div>
                        <div style={styles.featureItem}>ğŸš€ åªæœ‰ 1 å‰¯ç‰Œ? ä¸ï¼Œç°åœ¨æ”¯æŒ 8 å‰¯!</div>
                        <div style={styles.featureItem}>â±ï¸ è‡ªå®šä¹‰æ€è€ƒæ—¶é—´ä¸è·èƒœç›®æ ‡</div>
                    </div>
                </div>

                {/* å³ä¾§ï¼šæ“ä½œåŒº */}
                <div style={styles.loginRight} className="mobile-login-right">
                    {/* é¡¶éƒ¨çŠ¶æ€æ  */}
                    <div style={{
                        display: 'flex', 
                        justifyContent: 'space-between', 
                        alignItems: 'center',
                        marginBottom: 20
                    }}>
                        <button 
                            onClick={toggleFullScreen}
                            style={{
                                background: '#f8f9fa', border: '1px solid #e1e4e8', borderRadius: 20, padding: '6px 12px',
                                cursor: 'pointer', color: '#7f8c8d', display: 'flex', alignItems: 'center', gap: 6,
                                fontSize: 12, fontWeight: 'bold', transition: 'all 0.2s'
                            }}
                        >
                            {isFullScreen ? <Minimize size={14}/> : <Maximize size={14}/>}
                            <span>{isFullScreen ? 'é€€å‡ºå…¨å±' : 'å…¨å±æ¨¡å¼'}</span>
                        </button>

                        <div style={{
                            display: 'flex', alignItems: 'center', gap: 6, fontSize: 12, padding: '6px 12px', borderRadius: 20,
                            background: isConnected ? '#eafaf1' : '#fdedec', color: isConnected ? '#27ae60' : '#e74c3c',
                            fontWeight: 'bold', border: `1px solid ${isConnected ? '#abebc6' : '#fadbd8'}`
                        }}>
                            {isConnected ? <Wifi size={14}/> : <WifiOff size={14}/>}
                            {isConnected ? 'å·²è¿æ¥' : 'è¿æ¥ä¸­...'}
                        </div>
                    </div>

                    {/* é¡¶éƒ¨ Tab åˆ‡æ¢ */}
                    <div style={styles.tabs}>
                        <button style={!isCreatorMode ? styles.tabBtnActive : styles.tabBtn} onClick={()=>setIsCreatorMode(false)}>åŠ å…¥æˆ¿é—´</button>
                        <button style={isCreatorMode ? styles.tabBtnActive : styles.tabBtn} onClick={()=>setIsCreatorMode(true)}>åˆ›å»ºæˆ¿é—´</button>
                    </div>

                    <div style={styles.formContent}>
                        <div style={styles.inputGroup}>
                            <User size={18} color="#7f8c8d" />
                            <input style={styles.input} value={username} onChange={e=>setUsername(e.target.value)} placeholder="è¯·è¾“å…¥ä½ çš„æ˜µç§°" maxLength={10}/>
                        </div>
                        <div style={styles.inputGroup}>
                            <Monitor size={18} color="#7f8c8d" />
                            <input style={styles.input} value={roomId} onChange={e=>setRoomId(e.target.value)} placeholder="è¯·è¾“å…¥æˆ¿é—´å· (å¦‚: 888)" maxLength={6}/>
                        </div>

                        {/* åˆ›å»ºæ¨¡å¼ä¸‹çš„é«˜çº§é…ç½®åŒº */}
                        {isCreatorMode && (
                            <div style={styles.advancedConfigPanel}>
                                <div style={styles.configGrid}>
                                    {renderConfigSlider(<Users size={14}/>, "ç©å®¶äººæ•°", roomConfig.maxPlayers, 2, 12, 1, v=>setRoomConfig({...roomConfig, maxPlayers:v}), 'äºº')}
                                    {renderConfigSlider(<Layers size={14}/>, "ç‰Œåº“æ•°é‡", roomConfig.deckCount, 1, 8, 1, v=>setRoomConfig({...roomConfig, deckCount:v}), 'å‰¯')}
                                    {renderConfigSlider(<Target size={14}/>, "è·èƒœç›®æ ‡", roomConfig.targetScore, 500, 5000, 500, v=>setRoomConfig({...roomConfig, targetScore:v}), 'åˆ†')}
                                    
                                    {/* ç»„é˜Ÿå¯¹æŠ—å¼€å…³ */}
                                    <div style={{...styles.configItem, marginTop: 10, padding: '10px', background: roomConfig.maxPlayers % 2 !== 0 ? '#f0f0f0' : '#e8f8f5', borderRadius: 8, opacity: roomConfig.maxPlayers % 2 !== 0 ? 0.6 : 1, gridColumn: '1 / -1'}}>
                                        <div style={{display:'flex', justifyContent:'space-between', alignItems:'center'}}>
                                            <div style={{display:'flex', alignItems:'center', gap:6, fontWeight:'600', color: roomConfig.maxPlayers % 2 !== 0 ? '#999' : '#27ae60'}}>
                                                <Shield size={16} /> ç»„é˜Ÿå¯¹æŠ—æ¨¡å¼ (2v2, 3v3...)
                                            </div>
                                            <label style={{position:'relative', display:'inline-block', width:40, height:20}}>
                                                <input 
                                                    type="checkbox" 
                                                    style={{opacity:0, width:0, height:0}}
                                                    checked={roomConfig.isTeamMode && roomConfig.maxPlayers % 2 === 0}
                                                    disabled={roomConfig.maxPlayers % 2 !== 0}
                                                    onChange={(e) => setRoomConfig({...roomConfig, isTeamMode: e.target.checked})}
                                                />
                                                <span style={{
                                                    position:'absolute', cursor: roomConfig.maxPlayers % 2 !== 0 ? 'not-allowed' : 'pointer', top:0, left:0, right:0, bottom:0, 
                                                    backgroundColor: (roomConfig.isTeamMode && roomConfig.maxPlayers % 2 === 0) ? '#27ae60' : '#ccc', 
                                                    transition:'.4s', borderRadius: 20
                                                }}>
                                                    <span style={{
                                                        position:'absolute', content:"", height:16, width:16, left:2, bottom:2, 
                                                        backgroundColor:'white', transition:'.4s', borderRadius:'50%',
                                                        transform: (roomConfig.isTeamMode && roomConfig.maxPlayers % 2 === 0) ? 'translateX(20px)' : 'translateX(0)'
                                                    }}></span>
                                                </span>
                                            </label>
                                        </div>
                                        <div style={{fontSize: 11, color: '#7f8c8d', marginTop: 4}}>
                                            {roomConfig.maxPlayers % 2 !== 0 ? "âš ï¸ éœ€è¦å¶æ•°äººæ•° (4, 6...) æ‰èƒ½å¼€å¯" : "å¼€å¯åï¼Œé—´éš”å…¥åº§ä¸ºé˜Ÿå‹ (1å’Œ3é˜Ÿå‹ï¼Œ2å’Œ4é˜Ÿå‹)"}
                                        </div>
                                    </div>
                                    
                                    {/* [æ³¨] æŠ½å¡å¼€å…³å·²ç§»é™¤ï¼Œç°åœ¨æ˜¯å¼ºåˆ¶é»˜è®¤æµç¨‹ */}

                                    {/* å€’è®¡æ—¶é€‰æ‹© */}
                                    <div style={styles.configItem}>
                                        <div style={styles.configLabel}>
                                            <span style={{display:'flex', alignItems:'center', gap:6}}><Clock size={14}/> å‡ºç‰Œæ—¶é™</span>
                                            <span style={styles.configValue}>{roomConfig.turnTimeout / 1000}ç§’</span>
                                        </div>
                                        <div style={styles.radioGroup}>
                                            {[30, 60, 90, 120].map(sec => (
                                                <button 
                                                    key={sec}
                                                    style={roomConfig.turnTimeout === sec * 1000 ? styles.radioBtnActive : styles.radioBtn}
                                                    onClick={() => setRoomConfig({...roomConfig, turnTimeout: sec * 1000})}
                                                >
                                                    {sec}s
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                </div>

                                {/* å‰©ä½™ç‰Œæ•°æ˜¾ç¤ºé…ç½® */}
                                <div style={{marginTop: 20, paddingTop: 15, borderTop: '1px solid #f0f0f0'}}>
                                    <div style={{display:'flex', alignItems:'center', gap:6, color:'#7f8c8d', fontSize:14, marginBottom:10, fontWeight:600}}>
                                        <Eye size={14}/> å‰©ä½™ç‰Œæ•°æ˜¾ç¤ºè§„åˆ™
                                    </div>
                                    <div style={styles.radioGroup}>
                                        <button 
                                            style={roomConfig.showCardCountMode === 0 ? styles.radioBtnActive : styles.radioBtn}
                                            onClick={() => setRoomConfig({...roomConfig, showCardCountMode: 0})}
                                        >
                                            ä¸æ˜¾ç¤º
                                        </button>
                                        <button 
                                            style={roomConfig.showCardCountMode === 1 ? styles.radioBtnActive : styles.radioBtn}
                                            onClick={() => setRoomConfig({...roomConfig, showCardCountMode: 1})}
                                        >
                                            â‰¤3å¼ æ˜¾ç¤º
                                        </button>
                                        <button 
                                            style={roomConfig.showCardCountMode === 2 ? styles.radioBtnActive : styles.radioBtn}
                                            onClick={() => setRoomConfig({...roomConfig, showCardCountMode: 2})}
                                        >
                                            ä¸€ç›´æ˜¾ç¤º
                                        </button>
                                    </div>
                                </div>

                                {/* æ’åèµç½šè®¾ç½®åŒºåŸŸ */}
                                <div style={{marginTop: 20, paddingTop: 20, borderTop: '1px solid #f0f0f0'}}>
                                    <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom: 15}}>
                                        <div style={{display:'flex', alignItems:'center', gap:8, fontWeight:'600', color:'#555', fontSize:14}}>
                                            <Award size={16} /> å¯ç”¨æ’åèµç½š (è¿›è´¡/æŠ“åˆ†)
                                        </div>
                                        <label style={{position:'relative', display:'inline-block', width:40, height:20}}>
                                            <input 
                                                type="checkbox" 
                                                style={{opacity:0, width:0, height:0}}
                                                checked={roomConfig.enableRankPenalty}
                                                onChange={(e) => setRoomConfig({...roomConfig, enableRankPenalty: e.target.checked})}
                                            />
                                            <span style={{
                                                position:'absolute', cursor:'pointer', top:0, left:0, right:0, bottom:0, 
                                                backgroundColor: roomConfig.enableRankPenalty ? '#27ae60' : '#ccc', 
                                                transition:'.4s', borderRadius: 20
                                            }}>
                                                <span style={{
                                                    position:'absolute', content:"", height:16, width:16, left:2, bottom:2, 
                                                    backgroundColor:'white', transition:'.4s', borderRadius:'50%',
                                                    transform: roomConfig.enableRankPenalty ? 'translateX(20px)' : 'translateX(0)'
                                                }}></span>
                                            </span>
                                        </label>
                                    </div>

                                    {/* å¦‚æœå¼€å¯ï¼Œæ˜¾ç¤ºè¯¦ç»†åˆ†å€¼è®¾ç½® */}
                                    {roomConfig.enableRankPenalty && (
                                        <div style={{background:'#f9f9f9', padding: 15, borderRadius: 8, display:'flex', gap: 20, fontSize: 13}}>
                                            <div style={{flex:1}}>
                                                <div style={{marginBottom:5, color:'#7f8c8d'}}>å¤´å°¾èµç½š (ç¬¬1å vs å€’1)</div>
                                                <input 
                                                    type="number" style={{...styles.input, background:'white', height: 35, padding: '0 10px'}} 
                                                    value={roomConfig.rankPenaltyScores[0]}
                                                    onChange={e => {
                                                        const val = Math.max(0, parseInt(e.target.value) || 0);
                                                        setRoomConfig({...roomConfig, rankPenaltyScores: [val, roomConfig.rankPenaltyScores[1]]});
                                                    }}
                                                />
                                            </div>
                                            <div style={{flex:1}}>
                                                <div style={{marginBottom:5, color:'#7f8c8d'}}>æ¬¡çº§èµç½š (ç¬¬2å vs å€’2)</div>
                                                <input 
                                                    type="number" style={{...styles.input, background:'white', height: 35, padding: '0 10px'}} 
                                                    value={roomConfig.rankPenaltyScores[1]}
                                                    onChange={e => {
                                                        const val = Math.max(0, parseInt(e.target.value) || 0);
                                                        setRoomConfig({...roomConfig, rankPenaltyScores: [roomConfig.rankPenaltyScores[0], val]});
                                                    }}
                                                />
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}

                        <div style={{flex: 1}}></div>

                        <button 
                            style={{
                                ...styles.primaryButton,
                                opacity: (!isConnected || isLoading) ? 0.7 : 1,
                                cursor: (!isConnected || isLoading) ? 'not-allowed' : 'pointer',
                                background: (!isConnected) ? '#95a5a6' : '#2c3e50'
                            }} 
                            onClick={onActionClick} 
                            disabled={isLoading || !isConnected}
                        >
                            {(isLoading || !isConnected) ? <RefreshCw className="spin" size={20}/> : (isCreatorMode ? <Plus size={20}/> : <LogIn size={20}/>)}
                            <span style={{marginLeft:10}}>
                                {!isConnected ? "æ­£åœ¨è¿æ¥æœåŠ¡å™¨..." : (isLoading ? "å¤„ç†ä¸­..." : (isCreatorMode ? "ç«‹å³åˆ›å»ºæˆ¿é—´" : "è¿›å…¥æ¸¸æˆæˆ¿é—´"))}
                            </span>
                        </button>
                        
                        {!isConnected && (
                            <div style={{textAlign:'center', marginTop: 15, fontSize: 13, color:'#e74c3c', background:'#fdedec', padding:'8px', borderRadius:8}}>
                                âš ï¸ é¦–æ¬¡è®¿é—®å¯èƒ½éœ€è¦ 30-50ç§’ å”¤é†’æœåŠ¡å™¨ï¼Œè¯·è€å¿ƒç­‰å¾…å³ä¸Šè§’å˜ä¸ºç»¿è‰²ã€‚
                            </div>
                        )}
                    </div>
                </div>
            </div>
            <style>{`.spin { animation: spin 1s linear infinite; } @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }`}</style>
        </div>
    );
};

================================================================================
FILE PATH: client\src\styles.js
================================================================================
// ç»Ÿä¸€æ ·å¼æ–‡ä»¶ - ç§»åŠ¨ç«¯é€‚é…ç‰ˆ
// [å®Œæ•´ç‰ˆ] åŒ…å«æ‰€æœ‰åŸæœ‰å¸ƒå±€ã€æ‹‡æŒ‡çƒ­åŒºã€ä»¥åŠæ–°å¢çš„æ»‘åŠ¨é€‰ç‰Œæ”¯æŒå’Œå‰©ä½™ç‰Œæ•°å¾½ç« 
// [æœ¬æ¬¡ä¿®å¤] ä¿®å¤å¤§å…äººå¤šæ—¶æ’‘ç ´å±å¹•çš„é—®é¢˜ï¼šç»™ lobbyCard åŠ é™é«˜ï¼Œç»™ playerGrid åŠ æ»šåŠ¨
// [æœ¬æ¬¡æ–°å¢] kickButton

export const styles = {
  // ============================
  // å…¨å±€å®¹å™¨
  // ============================
  container: { 
      height: '100dvh', // ä½¿ç”¨ 100dvh è‡ªåŠ¨é€‚é…åŠ¨æ€åœ°å€æ 
      width: '100vw', 
      display: 'flex', 
      justifyContent: 'center', 
      alignItems: 'center', 
      background: '#1e272e', 
      fontFamily: '"Segoe UI", Roboto, Helvetica, Arial, sans-serif', 
      backgroundImage: 'radial-gradient(circle at top right, #34495e 0%, #000000 100%)',
      overflow: 'hidden' 
  },
  
  // ============================
  // ç™»å½•é¡µ (Login Screen)
  // ============================
  loginCard: { 
      background: 'white', 
      borderRadius: 24, 
      width: '95%', 
      maxWidth: '1100px', 
      minHeight: '600px', 
      maxHeight: '90vh',
      display: 'flex', 
      boxShadow: '0 50px 100px -20px rgba(0,0,0,0.7)',
      overflow: 'hidden',
      animation: 'popIn 0.5s ease-out'
  },

  // å·¦ä¾§å“ç‰ŒåŒº
  loginLeft: { 
      flex: 0.8, 
      background: 'linear-gradient(135deg, #27ae60 0%, #2ecc71 100%)', 
      padding: '60px 50px', 
      display:'flex', 
      flexDirection:'column', 
      justifyContent:'center', 
      alignItems: 'flex-start',
      color: 'white',
      position: 'relative',
      overflow: 'hidden'
  },
  logoCircle: { width: 90, height: 90, background: 'rgba(255,255,255,0.2)', borderRadius: 24, display:'flex', alignItems:'center', justifyContent:'center', marginBottom: 25, backdropFilter: 'blur(10px)' },
  logoText: { fontSize: 28, fontWeight: '900', color: 'white' },
  brandTitle: { fontSize: 48, fontWeight: '800', margin: '0 0 15px 0', letterSpacing: -1.5 },
  brandSubtitle: { fontSize: 18, opacity: 0.9, marginBottom: 50, fontWeight: '500' },
  featureList: { marginTop: 'auto', display: 'flex', flexDirection: 'column', gap: 15 },
  featureItem: { fontSize: 15, opacity: 0.95, display:'flex', alignItems:'center', fontWeight: '500' },

  // å³ä¾§è¡¨å•åŒº
  loginRight: { 
      flex: 1.2, 
      padding: '50px 60px', 
      display: 'flex',
      flexDirection: 'column',
      background: '#ffffff',
      overflowY: 'auto' 
  },
  
  tabs: { display: 'flex', gap: 35, marginBottom: 35, borderBottom: '2px solid #f1f2f6' },
  tabBtn: { padding: '12px 0', fontSize: 18, fontWeight: 'bold', color: '#95a5a6', background: 'none', border: 'none', cursor: 'pointer', transition: 'all 0.3s', borderBottom: '3px solid transparent', marginBottom: -3 },
  tabBtnActive: { padding: '12px 0', fontSize: 18, fontWeight: 'bold', color: '#2c3e50', background: 'none', border: 'none', cursor: 'pointer', transition: 'all 0.3s', borderBottom: '3px solid #27ae60', marginBottom: -3 },
  
  formContent: { flex: 1, display: 'flex', flexDirection: 'column' },

  inputGroup: { display: 'flex', alignItems: 'center', background: '#f8f9fa', borderRadius: 14, padding: '0 20px', marginBottom: 20, border: '1px solid #e1e4e8', height: 60, transition: 'all 0.2s' },
  input: { padding: '10px', border: 'none', background: 'transparent', flex: 1, outline:'none', fontSize: 17, color: '#2c3e50', fontWeight: '500' },

  // é«˜çº§é…ç½®é¢æ¿
  advancedConfigPanel: { 
      marginTop: 15, 
      background: '#fff', 
      borderRadius: 12,
      animation: 'fadeIn 0.4s ease'
  },
  configGrid: {
      display: 'grid',
      gridTemplateColumns: '1fr 1fr', 
      gap: '25px 35px'
  },
  configItem: { display: 'flex', flexDirection: 'column', gap: 10 },
  configLabel: { display: 'flex', justifyContent: 'space-between', fontSize: 14, color: '#7f8c8d', fontWeight: '600' },
  configValue: { color: '#27ae60', fontWeight: 'bold' },
  
  rangeInput: { width: '100%', cursor: 'pointer', accentColor: '#27ae60', height: 6 },

  radioGroup: { display: 'flex', gap: 10 },
  radioBtn: { flex: 1, padding: '8px 0', borderRadius: 8, border: '1px solid #e1e4e8', background: 'white', color: '#7f8c8d', fontSize: 13, cursor: 'pointer', transition: 'all 0.2s' },
  radioBtnActive: { flex: 1, padding: '8px 0', borderRadius: 8, border: '1px solid #27ae60', background: '#eafaf1', color: '#27ae60', fontSize: 13, fontWeight: 'bold', cursor: 'pointer' },

  primaryButton: { 
      marginTop: 25, 
      width: '100%', 
      height: 65, 
      background: '#2c3e50', 
      color: 'white', 
      border: 'none', 
      borderRadius: 14, 
      fontWeight: 'bold', 
      cursor: 'pointer', 
      display: 'flex', 
      justifyContent: 'center', 
      alignItems: 'center', 
      fontSize: 19, 
      transition: 'all 0.2s', 
      boxShadow: '0 10px 25px rgba(44, 62, 80, 0.25)' 
  },

  // ============================
  // æ¸¸æˆç•Œé¢ (Game Screen)
  // ============================

  gameTable: { 
      height: '100dvh', // ä½¿ç”¨ 100dvh
      width: '100vw', 
      background: '#1e3c29', 
      backgroundImage: 'radial-gradient(circle at center, #2d7a54 0%, #173b25 100%)', 
      position: 'relative', 
      overflow: 'hidden', 
      display: 'flex', 
      flexDirection: 'column', 
      userSelect: 'none',
      
      // [å…³é”®] å¿…é¡»åŠ ä¸Š border-boxï¼Œé˜²æ­¢å®½åº¦æº¢å‡º
      boxSizing: 'border-box',

      paddingTop: 'env(safe-area-inset-top)',
      paddingLeft: 'max(15px, env(safe-area-inset-left))',
      paddingRight: 'max(15px, env(safe-area-inset-right))',
      paddingBottom: 'env(safe-area-inset-bottom)'
  },
  
  // å®‰å…¨åŒºåŸŸåŒ…è£…å±‚
  gameSafeArea: {
      position: 'absolute',
      top: 0, left: 0, right: 0, bottom: 0,
      width: '100%',
      height: '100%',
      boxSizing: 'border-box',
      paddingTop: 'env(safe-area-inset-top)',
      paddingLeft: 'max(15px, env(safe-area-inset-left))',
      paddingRight: 'max(15px, env(safe-area-inset-right))',
      paddingBottom: 'env(safe-area-inset-bottom)',
      display: 'flex',
      flexDirection: 'column',
      pointerEvents: 'none' 
  },

  playersArea: { 
      position: 'absolute',
      top: 0, left: 0, right: 0, bottom: 0,
      pointerEvents: 'none',
      zIndex: 10
  },
  
  playerBox: { 
      pointerEvents: 'auto',
      padding: '2px 4px',   
      borderRadius: 8, 
      textAlign: 'center', 
      minWidth: 45,           
      color:'white', 
      border: '1px solid transparent', 
      transition: 'all 0.3s', 
      position: 'relative',
      backdropFilter: 'blur(3px)',
      boxShadow: '0 2px 10px rgba(0,0,0,0.3)'
  },

  // [æ–°å¢] å‰©ä½™ç‰Œæ•°å°å¾½ç« æ ·å¼
  cardCountBadge: {
      position: 'absolute',
      top: -8,
      left: -8,
      background: '#e74c3c',
      color: 'white',
      borderRadius: '50%',
      width: 20,
      height: 20,
      fontSize: 12,
      fontWeight: 'bold',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      border: '2px solid #fff',
      boxShadow: '0 2px 5px rgba(0,0,0,0.3)',
      zIndex: 25
  },

  avatar: { 
      width: 30, 
      height: 30, 
      background: '#ecf0f1', 
      borderRadius: '50%', 
      margin: '0 auto 2px', 
      lineHeight: '30px', 
      color:'#333', 
      fontWeight:'bold', 
      fontSize: 14, 
      border: '1px solid rgba(255,255,255,0.3)', 
      boxShadow: '0 2px 5px rgba(0,0,0,0.2)' 
  },

  playerName: { 
      fontSize: 10, 
      fontWeight: 'bold', 
      marginBottom: 1, 
      whiteSpace: 'nowrap', 
      overflow: 'hidden', 
      textOverflow: 'ellipsis', 
      maxWidth: 50 
  },
  
  // [ä¿®æ”¹] å·¦ä¸Šè§’æ—¥å¿—é¢æ¿ (GameLogPanel) - æ”¯æŒæŠ˜å åŠ¨ç”»
  gameLogPanel: { 
      position: 'absolute', 
      top: 50, 
      left: 10, 
      width: 200, 
      background: 'rgba(0, 0, 0, 0.35)', 
      borderRadius: 10, 
      padding: '8px 12px', 
      border: '1px solid rgba(255,255,255,0.1)',
      backdropFilter: 'blur(5px)',
      
      display: 'flex', 
      flexDirection: 'column', 
      zIndex: 5, 
      pointerEvents: 'auto', 
      boxShadow: '0 4px 10px rgba(0,0,0,0.3)',
      
      // [å…³é”®ä¿®æ”¹] å¢åŠ è¿‡æ¸¡åŠ¨ç”»ï¼Œè®©æŠ˜å æ›´ä¸æ»‘
      transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
      overflow: 'hidden' // é˜²æ­¢æŠ˜å æ—¶å†…å®¹æº¢å‡º
  },
  
  logHeader: { 
      display: 'flex', 
      alignItems: 'center', 
      gap: 5, 
      fontSize: 12, 
      borderBottom: '1px solid rgba(255,255,255,0.2)', 
      paddingBottom: 4, 
      marginBottom: 4 
  }, 
  
  logList: { 
      flex: 1, 
      overflowY: 'auto', 
      display: 'flex', 
      flexDirection: 'column', 
      gap: 4, 
      fontSize: 12,
      // å¢åŠ é€æ˜åº¦è¿‡æ¸¡
      transition: 'opacity 0.2s ease-in-out',
      maskImage: 'linear-gradient(to bottom, transparent, black 10%)',
      WebkitMaskImage: 'linear-gradient(to bottom, transparent, black 10%)'
  },
  
  logItem: { 
      lineHeight: 1.4, 
      display: 'flex', 
      alignItems: 'flex-start', 
      color: '#ecf0f1',
      fontSize: 12,
      textShadow: '0 1px 1px rgba(0,0,0,0.8)'
  },
  
  logTime: { display: 'none' },
  
  tableHeader: { 
      padding: '4px 10px', 
      display: 'flex', 
      justifyContent: 'space-between', 
      alignItems:'flex-start', 
      zIndex: 20,
      width: '100%',
      pointerEvents: 'none',
      boxSizing: 'border-box' 
  },
  
  roomBadgeContainer: {
    display: 'flex',
    alignItems: 'center',
    gap: 8, 
    pointerEvents: 'auto'
  },

  roomBadge: { 
    background: 'rgba(0,0,0,0.3)', 
    color:'white', 
    padding: '4px 8px', 
    borderRadius: 15, 
    fontSize: 11, 
    border: '1px solid rgba(255,255,255,0.1)', 
    fontWeight: 'bold',
    whiteSpace: 'nowrap'
  },
  
  scoreBoard: { 
      position: 'absolute', 
      top: '40%', 
      left: '50%', 
      transform: 'translate(-50%, -100%) scale(0.8)', 
      background: 'rgba(0,0,0,0.6)', 
      padding: '5px 20px', 
      borderRadius: 20, 
      textAlign: 'center', 
      color: 'white', 
      border: '1px solid rgba(255,255,255,0.2)', 
      backdropFilter: 'blur(5px)', 
      boxShadow: '0 5px 15px rgba(0,0,0,0.3)',
      zIndex: 5 
  },
  
  glassButton: { pointerEvents: 'auto', background: 'rgba(255,255,255,0.1)', color: 'white', border: '1px solid rgba(255,255,255,0.2)', padding: '8px 20px', borderRadius: 20, cursor: 'pointer', display: 'flex', alignItems: 'center', fontSize: 14, transition: 'background 0.2s' },
  sortButton: { pointerEvents: 'auto', background: 'rgba(255,255,255,0.1)', color: 'white', border: '1px solid rgba(255,255,255,0.2)', padding: '8px 20px', borderRadius: 20, cursor: 'pointer', display: 'flex', alignItems: 'center', fontSize: 14, transition: 'background 0.2s' },
  
  infoMessage: { position: 'absolute', top: '25%', width: '100%', textAlign: 'center', color: '#f1c40f', fontSize: 40, fontWeight: 'bold', textShadow: '0 5px 15px rgba(0,0,0,0.5)', pointerEvents: 'none', zIndex: 50, letterSpacing: 2 },
  
  tableCenter: { 
      position: 'absolute',
      top: '50%',
      left: '50%',
      transform: 'translate(-50%, -50%)',
      display: 'flex', 
      alignItems: 'center', 
      justifyContent: 'center', 
      zIndex: 1
  },
  
  playerNameTag: { color: 'white', textAlign: 'center', marginBottom: 5, textShadow: '0 2px 4px rgba(0,0,0,0.5)', fontSize: 14, fontWeight: 'bold', background: 'rgba(0,0,0,0.3)', padding: '2px 10px', borderRadius: 20, display: 'inline-block' },
  playedRow: { display: 'flex', gap: -10, filter: 'drop-shadow(0 10px 20px rgba(0,0,0,0.3))' }, 
  miniCard: { background: 'white', padding: '10px 15px', borderRadius: 8, fontWeight: 'bold', fontSize: 24, minWidth: 40, textAlign:'center' },
  
  scoreBarBg: { width:'100%', height:4, background:'rgba(0,0,0,0.5)', borderRadius:2, marginTop:2, overflow:'hidden' },
  scoreBarFill: { height:'100%', transition:'width 0.5s' },
  playerScore: { fontSize: 9, color: '#f1c40f', fontWeight: 'bold', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 3, marginTop: 1 },
  turnProgress: { position: 'absolute', bottom: 0, left: 0, height: 4, background: '#f1c40f', width: '100%', animation: 'progress 15s linear forwards' },
  
  // HandArea
  handArea: { 
      position: 'absolute', 
      // [å…³é”®ä¿®æ”¹] æŠ¬é«˜åº•éƒ¨è·ç¦»
      bottom: 'max(25px, env(safe-area-inset-bottom))',
      
      // [å…³é”®ä¿®æ”¹] åŠ å¤§å·¦ä¾§é—´è· (65 -> 110)ï¼Œé˜²æ­¢è¢«å·¦ä¸‹è§’å¤´åƒé®æŒ¡
      left: 70,
      
      right: 10, 
      height: 160,            
      display: 'flex', 
      justifyContent:'flex-start', 
      alignItems: 'flex-end', 
      zIndex: 20,
      touchAction: 'none', 
      pointerEvents: 'auto',
      paddingBottom: 10       
  },
  
  card: { 
      background: 'white', 
      borderRadius: 6,      
      border: '1px solid #999', 
      position: 'absolute', 
      cursor: 'pointer', 
      display: 'flex', 
      flexDirection: 'column', 
      padding: 4,            
      transition: 'transform 0.1s cubic-bezier(0.2, 0.8, 0.2, 1)', 
      width: 55,         
      height: 70 
  },
  
  actionBar: { position: 'absolute', bottom: 100, width: '100%', height: 60, display: 'flex', justifyContent: 'center', alignItems: 'center', pointerEvents: 'none', zIndex: 30 }, 
  playButton: { pointerEvents: 'auto', padding: '8px 30px', background: 'linear-gradient(to bottom, #f1c40f, #f39c12)', border: 'none', borderRadius: 40, fontWeight: 'bold', cursor: 'pointer', marginLeft: 20, fontSize: 16, boxShadow: '0 8px 20px rgba(243, 156, 18, 0.4)', color: '#fff', textShadow: '0 1px 2px rgba(0,0,0,0.2)', transition: 'transform 0.1s' },
  passButton: { pointerEvents: 'auto', padding: '8px 25px', background: '#7f8c8d', border: 'none', borderRadius: 40, fontWeight: 'bold', cursor: 'pointer', fontSize: 14, color: 'white', boxShadow: '0 5px 15px rgba(0,0,0,0.3)' },
  waitingBadge: { color: 'rgba(255,255,255,0.7)', fontSize: 16, display: 'flex', alignItems: 'center', gap: 10, background: 'rgba(0,0,0,0.3)', padding: '10px 20px', borderRadius: 30 },
  
  // å¼¹çª—é®ç½©
  modalOverlay: { 
      position: 'fixed', 
      top:0, left:0, right:0, bottom:0, 
      background: 'rgba(0,0,0,0.85)', 
      display:'flex', 
      justifyContent:'center', 
      alignItems:'center', 
      zIndex: 99, 
      backdropFilter: 'blur(8px)',
      pointerEvents: 'auto' 
  },

  // å¼¹çª—å†…å®¹
  modalContent: { 
      background: 'white', 
      padding: 30, 
      borderRadius: 24, 
      textAlign: 'center', 
      boxShadow: '0 30px 80px rgba(0,0,0,0.6)', 
      animation: 'popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275)',
      width: '90%',        
      maxWidth: 500,       
      maxHeight: '85vh',   
      overflowY: 'auto',   
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center'
  },
  
  // å¤§å…é¡µ (Lobby) - [ä¿®å¤]
  lobbyCard: { 
      background: 'white', 
      padding: 40, 
      borderRadius: 20, 
      width: '1000px', 
      maxWidth: '95vw', 
      minHeight: '600px',
      // [æ ¸å¿ƒä¿®å¤] é™åˆ¶æœ€å¤§é«˜åº¦ï¼Œé˜²æ­¢åœ¨å¤§å±æˆ–äººæ•°è¿‡å¤šæ—¶æ’‘ç ´å±å¹•
      maxHeight: '85vh', 
      display: 'flex', 
      flexDirection: 'column', 
      boxShadow: '0 30px 60px rgba(0,0,0,0.5)',
      // ç¡®ä¿å†…å®¹æº¢å‡ºæ—¶ä¸ä¼šç ´ååœ†è§’æˆ–æº¢å‡º Card
      overflow: 'hidden' 
  },

  lobbyHeader: { 
      display: 'flex', 
      justifyContent: 'space-between', 
      alignItems: 'center', 
      marginBottom: 30, 
      paddingBottom: 20, 
      borderBottom: '1px solid #eee',
      // é˜²æ­¢å¤´éƒ¨è¢«å‹ç¼©
      flexShrink: 0
  },
  
  tag: { background: '#f0f9f4', color: '#27ae60', padding: '5px 10px', borderRadius: 20, fontSize: 14, display: 'flex', alignItems: 'center', gap: 5 },
  
  playerGrid: { 
      display: 'grid', 
      gridTemplateColumns: 'repeat(auto-fill, minmax(180px, 1fr))', 
      gap: 20, 
      flex: 1, 
      alignContent: 'start',
      // [æ ¸å¿ƒä¿®å¤] å…è®¸ç½‘æ ¼å†…éƒ¨æ»šåŠ¨
      overflowY: 'auto',
      minHeight: 0
  },
  
  lobbyPlayer: { border: '2px solid #eee', borderRadius: 12, padding: 25, display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 15, position: 'relative', transition: 'all 0.2s' },
  avatarLarge: { width: 80, height: 80, borderRadius: '50%', background: '#34495e', color: 'white', fontSize: 32, display: 'flex', alignItems: 'center', justifyContent: 'center', fontWeight: 'bold' },
  hostBadge: { position: 'absolute', top: 10, right: 10, background: '#f1c40f', color: '#333', fontSize: 12, padding: '4px 8px', borderRadius: 4, fontWeight: 'bold' },
  
  // [æ–°å¢] è¸¢äººæŒ‰é’®æ ·å¼
  kickButton: {
      position: 'absolute',
      top: -8,
      right: -8,
      width: 24,
      height: 24,
      borderRadius: '50%',
      background: '#e74c3c',
      border: '2px solid white',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      cursor: 'pointer',
      padding: 0,
      zIndex: 10,
      boxShadow: '0 2px 5px rgba(0,0,0,0.2)'
  },

  lobbyFooter: { 
      marginTop: 'auto', 
      borderTop: '1px solid #eee', 
      paddingTop: 20, 
      display: 'flex', 
      justifyContent: 'center',
      // é˜²æ­¢åº•éƒ¨è¢«å‹ç¼©
      flexShrink: 0 
  },
};

================================================================================
FILE PATH: client\src\utils\cardLogic.js
================================================================================
// çº¯é€»è¾‘å·¥å…·

// æ’åºæƒé‡ï¼š2(15) > A(14) > K(13)...
export const getSortValue = (cardVal) => {
    const normalized = cardVal % 54;
    if (normalized === 52) return 16;
    if (normalized === 53) return 17;
    const base = normalized % 13;
    if (base === 0) return 14; 
    if (base === 1) return 15; 
    return base + 1;
};

// èŠ±è‰²æ’åºæƒé‡
export const getSuitSortValue = (cardVal) => {
    if (cardVal >= 52) return cardVal * 100;
    const suit = Math.floor(cardVal / 13) % 4; 
    const val = cardVal % 13;
    return suit * 100 + val; 
};

// åˆ¤æ–­æ˜¯å¦ä¸ºåˆ†ç‰Œ (5, 10, K)
const isScoreCard = (cardVal) => {
    const normalized = cardVal % 54;
    if (normalized >= 52) return false; // ç‹ä¸æ˜¯åˆ†ç‰Œ
    const val = normalized % 13;
    // 0=A, 1=2, 2=3, 3=4(5), ..., 9(10), ..., 12(K)
    return val === 4 || val === 9 || val === 12;
};

// è·å–åˆ†ç‰Œçš„å†…éƒ¨æ’åºæƒé‡ (K > 10 > 5)
const getScoreCardRank = (cardVal) => {
    const val = (cardVal % 54) % 13;
    if (val === 12) return 3; // K
    if (val === 9) return 2;  // 10
    if (val === 4) return 1;  // 5
    return 0;
};

// è·å–å•å¼ ç‰Œçš„æ˜¾ç¤ºä¿¡æ¯
export const getCardDisplay = (cardVal) => {
    const normalizedValue = cardVal % 54; 
    if (normalizedValue === 52) return { suit: 'Joker', text: 'å°ç‹', color: '#000', isScore: false };
    if (normalizedValue === 53) return { suit: 'Joker', text: 'å¤§ç‹', color: '#d00', isScore: false };
    
    const suits = ['â™ ', 'â™¥', 'â™£', 'â™¦'];
    const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
    const valueIndex = normalizedValue % 13;
    const suit = suits[Math.floor(normalizedValue / 13)];
    const color = (suit === 'â™¥' || suit === 'â™¦') ? '#d00' : '#000';
    const text = values[valueIndex];
    const isScore = (text === '5' || text === '10' || text === 'K');
    
    return { suit, text, color, isScore };
};

// æ™ºèƒ½ç†ç‰Œé€»è¾‘
export const arrangeHand = (cards) => {
    const scoreCards = []; // å³ä¾§ï¼šåˆ†ç‰Œ
    const otherCards = []; // å¾…åˆ†ç±»çš„ç‰Œ

    // 1. å…ˆæŠŠæ‰€æœ‰åˆ†ç‰Œ(5, 10, K)æå–å‡ºæ¥ (ä¸åšç‰¹æ®Šä¿®æ­£ï¼Œä¸¥æ ¼åˆ†ç¦»)
    cards.forEach(c => {
        if (isScoreCard(c)) scoreCards.push(c);
        else otherCards.push(c);
    });

    // 2. å¯¹åˆ†ç‰Œè¿›è¡Œæ’åºï¼šK > 10 > 5 (KKKK 1010 5555)
    scoreCards.sort((a, b) => {
        const rA = getScoreCardRank(a);
        const rB = getScoreCardRank(b);
        if (rA !== rB) return rB - rA; // é™åº (K=3, 10=2, 5=1)
        return getSuitSortValue(b) - getSuitSortValue(a); // åŒåˆ†æŒ‰èŠ±è‰²æ’
    });

    // 3. å¯¹å‰©ä½™ç‰Œè¿›è¡Œåˆ†ç»„
    const groups = new Map();
    otherCards.forEach(c => {
        const val = getSortValue(c);
        if (!groups.has(val)) groups.set(val, []);
        groups.get(val).push(c);
    });

    const bombs = [];   // å·¦ä¾§ï¼šç‚¸å¼¹
    const triples = []; // ä¸­é—´ï¼šä¸‰å¼ 
    const pairs = [];   // ä¸­é—´ï¼šå¯¹å­
    const singles = []; // ä¸­é—´ï¼šå•å¼ 

    groups.forEach((groupCards, val) => {
        const count = groupCards.length;
        // è§„åˆ™ï¼šæ•°é‡ >= 4 è§†ä¸ºç‚¸å¼¹
        if (count >= 4) {
            bombs.push({ val, cards: groupCards, count });
        } else if (count === 3) {
            triples.push({ val, cards: groupCards });
        } else if (count === 2) {
            pairs.push({ val, cards: groupCards });
        } else {
            singles.push({ val, cards: groupCards });
        }
    });

    // 4. æ’åºç‚¸å¼¹ï¼šå¼ æ•°ä¼˜å…ˆ (10å¼  > 8å¼  > 6å¼ ...)ï¼Œå…¶æ¬¡ç‚¹æ•°
    bombs.sort((a, b) => {
        if (a.count !== b.count) return b.count - a.count; // å¼ æ•°é™åº
        return b.val - a.val; // ç‚¹æ•°é™åº
    });

    // 5. æ’åºä¸­é—´åºŸç‰Œï¼šå„è‡ªæŒ‰ç‚¹æ•°é™åº
    const sortByVal = (a, b) => b.val - a.val;
    triples.sort(sortByVal);
    pairs.sort(sortByVal);
    singles.sort(sortByVal);

    // 6. å±•å¹³æ•°ç»„
    const flatBombs = bombs.flatMap(b => b.cards);
    const flatTriples = triples.flatMap(t => t.cards);
    const flatPairs = pairs.flatMap(p => p.cards);
    const flatSingles = singles.flatMap(s => s.cards);

    // 7. æ‹¼æ¥ï¼šå·¦ç‚¸å¼¹ + ä¸­(ä¸‰+å¯¹+å•) + å³åˆ†ç‰Œ
    return [...flatBombs, ...flatTriples, ...flatPairs, ...flatSingles, ...scoreCards];
};

// æ‰‹ç‰Œæ’åºå…¥å£
export const sortHand = (cards, mode = 'POINT') => {
    // å³ä½¿UIåˆ é™¤äº† SUIT å…¥å£ï¼Œä¸ºäº†å…¼å®¹æ€§ä¿ç•™ä»£ç é€»è¾‘
    if (mode === 'SUIT') {
        return [...cards].sort((a, b) => getSuitSortValue(b) - getSuitSortValue(a));
    }
    if (mode === 'ARRANGE') {
        return arrangeHand(cards);
    }
    // é»˜è®¤ POINT
    return [...cards].sort((a, b) => getSortValue(b) - getSortValue(a));
};

// è®¡ç®—æ‰‹ç‰Œé—´è·
export const calculateCardSpacing = (count, screenWidth) => {
    if (count <= 1) return 0;
    
    // é€‚é…æ‰‹æœºé€»è¾‘ï¼šç•™å‡ºå·¦å³å®‰å…¨è·ç¦»
    const isMobile = screenWidth < 768;
    const padding = isMobile ? 20 : 100; // å‡å°‘ä¸¤ä¾§ç•™ç™½
    
    const w = Math.min(screenWidth - padding, 1200); 
    
    // å¡ç‰Œå®é™…å®½åº¦
    const cardWidth = 55; // ä¸ styles.js ä¸­çš„ card width ä¸€è‡´
    
    // æœ€å¤§é—´è·ï¼šç‰Œå°‘çš„æ—¶å€™ä¸è¦åˆ†å¤ªå¼€
    const maxGap = isMobile ? 35 : 45; 
    
    const neededWidth = (count - 1) * maxGap + cardWidth;
    
    // å¦‚æœéœ€è¦çš„å®½åº¦å°äºå±å¹•å®½ï¼Œå°±ç”¨æœ€å¤§é—´è·
    if (neededWidth <= w) return maxGap;
    
    // å¦åˆ™ï¼ŒæŒ¤å‹ç‰Œçš„é—´è·
    return (w - cardWidth) / (count - 1);
};

// [æ–°å¢] è¾…åŠ©å‡½æ•°ï¼šæ ¹æ®è§¦æ‘¸Xåæ ‡è®¡ç®—æ˜¯ç¬¬å‡ å¼ ç‰Œ
export const getCardIndexFromTouch = (touchX, containerLeft, spacing, count) => {
    // ç›¸å¯¹å®¹å™¨å·¦ä¾§çš„è·ç¦»
    const relativeX = touchX - containerLeft;
    
    // ä¼°ç®—ç´¢å¼•
    let index = Math.floor(relativeX / spacing);
    
    // è¾¹ç•Œæ£€æŸ¥
    if (index < 0) index = 0;
    if (index >= count) index = count - 1; // è§¦æ‘¸åœ¨æœ€åä¸€å¼ ç‰Œä¹‹åï¼Œä¹Ÿç®—æœ€åä¸€å¼ 
    
    return index;
};

================================================================================
FILE PATH: client\src\utils\SoundManager.js
================================================================================
/**
 * ç®€æ˜“ Web Audio API éŸ³æ•ˆç®¡ç†å™¨
 * ä¸éœ€è¦å¤–éƒ¨ MP3 æ–‡ä»¶ï¼Œç›´æ¥ç”¨ä»£ç ç”Ÿæˆå£°éŸ³
 */
const SoundManager = {
    ctx: null,

    init: () => {
        if (!SoundManager.ctx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            SoundManager.ctx = new AudioContext();
        }
    },

    // æ’­æ”¾æŒ‡å®šç±»å‹çš„éŸ³æ•ˆ
    play: (type) => {
        try {
            // æŸäº›æµè§ˆå™¨éœ€è¦ç”¨æˆ·äº¤äº’åæ‰èƒ½æ¢å¤ Context
            if (SoundManager.ctx && SoundManager.ctx.state === 'suspended') {
                SoundManager.ctx.resume();
            }
            if (!SoundManager.ctx) SoundManager.init();

            switch (type) {
                case 'deal': // å‘ç‰Œ/ç‚¹å‡»ç‰Œ (çŸ­ä¿ƒçš„é«˜é¢‘éŸ³)
                    SoundManager.beep(800, 0.05, 'sine');
                    break;
                case 'play': // å‡ºç‰Œ (æœ‰æ‰“å‡»æ„Ÿ)
                    SoundManager.noise(0.1); 
                    break;
                case 'win': // èƒœåˆ© (è¿ç»­çš„ç¶éŸ³)
                    SoundManager.arpeggio([523.25, 659.25, 783.99, 1046.50], 0.1);
                    break;
                case 'lose': // å¤±è´¥/è¢«å‹ (ä½æ²‰)
                    SoundManager.beep(150, 0.3, 'sawtooth');
                    break;
                case 'alert': // è½®åˆ°ä½ äº†
                    SoundManager.beep(880, 0.1, 'square');
                    setTimeout(() => SoundManager.beep(880, 0.1, 'square'), 150);
                    break;
                default:
                    break;
            }
        } catch (e) {
            console.warn('Audio play failed:', e);
        }
    },

    // --- åˆæˆå™¨åº•å±‚å‡½æ•° ---

    // å‘å‡ºå•éŸ³
    beep: (freq, duration, type = 'sine') => {
        const ctx = SoundManager.ctx;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();

        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        
        gain.gain.setValueAtTime(0.1, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(ctx.destination);

        osc.start();
        osc.stop(ctx.currentTime + duration);
    },

    // æ¨¡æ‹Ÿæ‰“å‡»å£° (ç™½å™ªéŸ³)
    noise: (duration) => {
        const ctx = SoundManager.ctx;
        const bufferSize = ctx.sampleRate * duration;
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }

        const noise = ctx.createBufferSource();
        noise.buffer = buffer;
        
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.2, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);

        noise.connect(gain);
        gain.connect(ctx.destination);
        noise.start();
    },

    // ç¶éŸ³ (èƒœåˆ©éŸ³æ•ˆ)
    arpeggio: (freqs, interval) => {
        freqs.forEach((f, i) => {
            setTimeout(() => SoundManager.beep(f, 0.2, 'triangle'), i * interval * 1000);
        });
    }
};

export default SoundManager;

================================================================================
FILE PATH: client\vite.config.js
================================================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})


================================================================================
FILE PATH: server\game\BotLogic.js
================================================================================
const CardRules = require('./CardRules');

const BotLogic = {
    // [å…¼å®¹æ—§æ¥å£] æœºå™¨äººå†³ç­–ä»åªå–ç¬¬ä¸€ä¸ªï¼ˆé€šå¸¸æ˜¯æœ€å°çš„ï¼‰
    decideMove: (hand, lastPlayedCards, deckCount) => {
        const solutions = BotLogic.findAllSolutions(hand, lastPlayedCards, deckCount);
        return solutions.length > 0 ? solutions[0] : null;
    },

    // [æ–°æ¥å£] æ‰¾å‡ºæ‰€æœ‰å¯è¡Œçš„å‡ºç‰Œæ–¹æ¡ˆ
    findAllSolutions: (hand, lastPlayedCards, deckCount) => {
        try {
            const solutions = [];
            
            // 1. é¢„å¤„ç†æ‰‹ç‰Œï¼šåˆ†ç»„ + æ’åº
            const grouped = {};
            const points = [];
            hand.forEach(c => {
                const p = CardRules.getPoint(c);
                if (!grouped[p]) {
                    grouped[p] = [];
                    points.push(p);
                }
                grouped[p].push(c);
            });
            // ç‚¹æ•°å»é‡å¹¶æ’åº
            points.sort((a, b) => a - b); 
            // å»é™¤é‡å¤ç‚¹æ•° (æ¯”å¦‚ points é‡Œå¯èƒ½æœ‰å¤šä¸ª 3ï¼Œå¦‚æœä¸å»é‡éå†ä¼šé‡å¤ï¼Œä½†è¿™é‡Œæˆ‘ä»¬ç”¨ Set æˆ– includes åˆ¤æ–­å»é‡)
            const uniquePoints = [...new Set(points)].sort((a,b)=>a-b);

            // --- è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾æ‰€æœ‰ç‚¸å¼¹ ---
            const findAllBombs = (minLevel = 0, minVal = 0) => {
                const bombList = [];

                // A. 510K (Level 1 & 2)
                if (minLevel <= 2) {
                    const fives = grouped[5] || [];
                    const tens = grouped[10] || [];
                    const kings = grouped[13] || []; // K
                    
                    if (fives.length > 0 && tens.length > 0 && kings.length > 0) {
                        // ç®€å•èµ·è§ï¼Œåªç»„è£…ä¸€å¥— 510K (ä¼˜å…ˆçº¯è‰²)
                        // å¦‚æœè¦ç©·ä¸¾æ‰€æœ‰ 510K ç»„åˆä¼šå¤ªå¤šï¼Œè¿™é‡Œç®€åŒ–ä¸ºï¼šæœ‰ä¸€å¥—å°±æç¤ºä¸€å¥—
                        let foundPure = false;
                        for (let f of fives) {
                            for (let t of tens) {
                                for (let k of kings) {
                                    const s1 = CardRules.getSuit(f);
                                    const s2 = CardRules.getSuit(t);
                                    const s3 = CardRules.getSuit(k);
                                    if (s1 === s2 && s2 === s3) {
                                        // çº¯è‰² 510K (Level 2)
                                        if (2 > minLevel || (2 === minLevel && 100 > minVal)) { // çº¯è‰²valueæ­¤å¤„æš‚å®š
                                            bombList.push({ cards: [f, t, k], level: 2, val: 999 }); // çº¯è‰²ä¼˜å…ˆ
                                            foundPure = true;
                                        }
                                    }
                                }
                                if(foundPure) break;
                            }
                            if(foundPure) break;
                        }
                        
                        if (!foundPure && minLevel <= 1) {
                            // æ‚è‰² 510K (Level 1)
                            bombList.push({ cards: [fives[0], tens[0], kings[0]], level: 1, val: 1 });
                        }
                    }
                }

                // B. æ™®é€šç‚¸å¼¹ (Level 3)
                // éå†æ‰€æœ‰ç‚¹æ•°ï¼Œçœ‹æ˜¯å¦æœ‰ >= 4 å¼ 
                for (let p of uniquePoints) {
                    const count = grouped[p].length;
                    if (count >= 4) {
                        // å¦‚æœè¦æ±‚ Level 3ï¼Œæ¯”è¾ƒ Valï¼›å¦‚æœ minLevel < 3ï¼Œç›´æ¥åŠ å…¥
                        if (minLevel < 3 || (minLevel === 3 && p > minVal)) {
                            bombList.push({ cards: grouped[p], level: 3, val: p });
                        }
                    }
                }

                // C. å¤©ç‹ç‚¸ (Level 4)
                const jokers = hand.filter(c => CardRules.getPoint(c) >= 16);
                if (jokers.length === deckCount * 2) {
                    if (minLevel < 4) {
                        bombList.push({ cards: jokers, level: 4, val: 999 });
                    }
                }

                return bombList;
            };

            // --- åœºæ™¯ 1: è‡ªç”±å‡ºç‰Œ (First Play) ---
            if (!lastPlayedCards || lastPlayedCards.length === 0) {
                // è‡ªç”±å‡ºç‰Œæ—¶ï¼Œå¾ªç¯æç¤ºï¼šæœ€å°å•å¼  -> æœ€å°å¯¹å­ -> æœ€å°ä¸‰å¼  -> ç‚¸å¼¹
                // 1. æœ€å°å•å¼ 
                if (uniquePoints.length > 0) solutions.push([grouped[uniquePoints[0]][0]]);
                // 2. æœ€å°å¯¹å­
                for (let p of uniquePoints) {
                    if (grouped[p].length >= 2) {
                        solutions.push(grouped[p].slice(0, 2));
                        break; 
                    }
                }
                // 3. æœ€å°ä¸‰å¼ 
                for (let p of uniquePoints) {
                    if (grouped[p].length >= 3) {
                        solutions.push(grouped[p].slice(0, 3));
                        break;
                    }
                }
                // 4. æ‰€æœ‰ç‚¸å¼¹
                const bombs = findAllBombs(-1, -1);
                bombs.forEach(b => solutions.push(b.cards));
                
                return solutions;
            }

            // --- åœºæ™¯ 2: ç®¡ç‰Œ (Beat It) ---
            const lastState = CardRules.analyze(lastPlayedCards, deckCount);
            if (lastState.type === 'INVALID') return [];

            // ç­–ç•¥ A: åŒç‰Œå‹å‹åˆ¶ (å•/å¯¹/ä¸‰)
            if (['SINGLE', 'PAIR', 'TRIPLE'].includes(lastState.type)) {
                const countNeeded = lastState.type === 'SINGLE' ? 1 : (lastState.type === 'PAIR' ? 2 : 3);
                
                for (let p of uniquePoints) {
                    // å¿…é¡»ç‚¹æ•°æ›´å¤§ï¼Œä¸”å¼ æ•°å¤Ÿ
                    if (p > lastState.val && grouped[p].length >= countNeeded) {
                        // å³ä½¿æ˜¯ç‚¸å¼¹ï¼ˆ4å¼ ï¼‰ï¼Œå¦‚æœè¢«æ‹†æˆå•/å¯¹/ä¸‰æ¥ç®¡ï¼Œä¹Ÿæ˜¯åˆè§„çš„ï¼ˆè™½ç„¶æœ‰ç‚¹äºï¼‰
                        // ä¸ºäº†æç¤ºå…¨é¢ï¼Œæˆ‘ä»¬æŠŠå®ƒåŠ è¿›å»
                        solutions.push(grouped[p].slice(0, countNeeded));
                    }
                }
            }
            
            // ç­–ç•¥ B: è¿å¯¹/é£æœº (ç®€åŒ–å¤„ç†ï¼šåªæç¤ºç‚¸å¼¹ï¼Œæˆ–è€…ç²¾å‡†åŒ¹é…)
            // å¤æ‚çš„è¿å¯¹ç©·ä¸¾æ¯”è¾ƒè€—æ—¶ï¼Œè¿™é‡Œæš‚æ—¶ç•¥è¿‡è¿å¯¹çš„åŒå‹ç®¡æ³•ï¼Œç›´æ¥æ¨èç‚¸å¼¹

            // ç­–ç•¥ C: ç‚¸å¼¹å‹åˆ¶
            const currentLevel = lastState.level || 0;
            const currentVal = lastState.val || 0;
            
            const bombs = findAllBombs(currentLevel, currentVal);
            // æ­¤æ—¶ bombs é‡Œçš„å·²ç»æ˜¯ç¬¦åˆç­‰çº§è¦æ±‚çš„äº†ï¼Œé™¤äº†åŒçº§æ¯”è¾ƒ
            // findAllBombs é‡Œå·²ç»åšäº†ç®€å•çš„ minLevel è¿‡æ»¤ï¼Œè¿™é‡Œå†ç»†è‡´æ’ä¸€ä¸‹
            
            bombs.forEach(b => {
                // ä¸¥æ ¼æ ¡éªŒèƒ½ä¸èƒ½ç®¡
                if (CardRules.canPlay(b.cards, lastPlayedCards, deckCount)) {
                    solutions.push(b.cards);
                }
            });

            return solutions;
        } catch (e) {
            console.error("BotLogic findAllSolutions error:", e);
            return [];
        }
    }
};

module.exports = BotLogic;

================================================================================
FILE PATH: server\game\CardRules.js
================================================================================
// çº¯è§„åˆ™è®¡ç®— (510K é€»è¾‘ã€æ¯”å¤§å°)

const CardRules = {
    // 1. åŸºç¡€æ˜ å°„
    // 3=3 ... K=13, A=14, 2=15, å°ç‹=16, å¤§ç‹=17
    getPoint: (cardVal) => {
        const normalized = cardVal % 54;
        if (normalized === 52) return 16;
        if (normalized === 53) return 17;
        const base = normalized % 13;
        if (base === 0) return 14; // A
        if (base === 1) return 15; // 2
        return base + 1; // 3 => 3
    },

    getSortValue: (cardVal) => {
        const normalized = cardVal % 54;
        if (normalized === 52) return 16;
        if (normalized === 53) return 17;
        const base = normalized % 13;
        if (base === 0) return 14; 
        if (base === 1) return 15; 
        return base + 1;
    },

    getSuitSortValue: (cardVal) => {
        if (cardVal >= 52) return cardVal * 100;
        const suit = Math.floor(cardVal / 13) % 4; 
        const val = cardVal % 13;
        return suit * 100 + val; 
    },
    
    getPointText: (point) => {
        if (point <= 10) return point.toString();
        if (point === 11) return 'J';
        if (point === 12) return 'Q';
        if (point === 13) return 'K';
        if (point === 14) return 'A';
        if (point === 15) return '2';
        if (point === 16) return 'å°ç‹';
        if (point === 17) return 'å¤§ç‹';
        return '?';
    },
    
    getAnalysisText: (analysisResult) => {
        if (!analysisResult || analysisResult.type === 'INVALID') return 'æœªçŸ¥ç‰Œå‹';
        
        const pt = CardRules.getPointText(analysisResult.val);
        
        switch (analysisResult.type) {
            case 'SINGLE': return `å•å¼  ${pt}`;
            case 'PAIR': return `å¯¹ ${pt}`;
            case 'TRIPLE': return `ä¸‰å¼  ${pt}`;
            case 'LIANDUI': return `${analysisResult.len/2}è¿å¯¹ (${pt}èµ·)`;
            case 'AIRPLANE': return `é£æœº (${pt}èµ·)`;
            case '510K_MIXED': return 'æ‚è‰² 510K'; // [æ–°å¢]
            case '510K_PURE': 
                const suitNames = ['é»‘æ¡ƒ', 'çº¢æ¡ƒ', 'æ¢…èŠ±', 'æ–¹ç‰‡'];
                const suitIndex = 4 - analysisResult.val; 
                const sName = suitNames[suitIndex] || 'çº¯';
                return `${sName} 510K`;
            case 'BOMB_STD': return `${analysisResult.len}ç‚¸ (${pt})`;
            case 'BOMB_MAX': return `è‡³å°Š ${analysisResult.len}ç‚¸ (${pt})`;
            case 'BOMB_KING': return 'å¤©ç‹ç‚¸!';
            default: return 'æœªçŸ¥';
        }
    },

    getCardScore: (cardVal) => {
        const p = CardRules.getPoint(cardVal);
        if (p === 5) return 5;
        if (p === 10) return 10;
        if (p === 13) return 10; // K
        return 0;
    },

    calculateTotalScore: (cards) => {
        return cards.reduce((sum, c) => sum + CardRules.getCardScore(c), 0);
    },

    getSuit: (cardVal) => {
        const normalized = cardVal % 54;
        if (normalized >= 52) return -1; 
        return Math.floor(normalized / 13);
    },

    // 2. æ ¸å¿ƒï¼šç‰Œå‹åˆ†æ
    analyze: (cards, deckCount = 1) => {
        const len = cards.length;
        if (len === 0) return { type: 'EMPTY' };

        // æ’åºï¼šç‚¹æ•°ä»å°åˆ°å¤§
        const points = cards.map(CardRules.getPoint).sort((a, b) => a - b);
        
        // ç»Ÿè®¡ç‚¹æ•°é¢‘ç‡
        const counts = {};
        points.forEach(p => { counts[p] = (counts[p] || 0) + 1; });
        const uniquePoints = Object.keys(counts).map(Number).sort((a,b)=>a-b);
        
        // --- éç‚¸å¼¹ç‰Œå‹ ---

        if (len === 1) return { type: 'SINGLE', val: points[0], level: 0 };

        if (len === 2 && points[0] === points[1]) {
            return { type: 'PAIR', val: points[0], level: 0 };
        }

        if (len === 3 && uniquePoints.length === 1) {
            return { type: 'TRIPLE', val: points[0], level: 0 };
        }

        // è¿å¯¹
        if (len >= 4 && len % 2 === 0) {
            if (!points.some(p => p >= 15)) {
                let isLiandui = true;
                if (uniquePoints.length === len / 2) {
                     for (let p of uniquePoints) {
                         if (counts[p] !== 2) isLiandui = false;
                     }
                     for(let i=0; i<uniquePoints.length-1; i++) {
                         if(uniquePoints[i+1] !== uniquePoints[i]+1) isLiandui = false;
                     }
                     if (isLiandui) return { type: 'LIANDUI', val: points[0], len: len, level: 0 };
                }
            }
        }

        // é£æœº
        if (len >= 6 && len % 3 === 0) {
            if (!points.some(p => p >= 15)) {
                let isAirplane = true;
                if (uniquePoints.length === len / 3) {
                    for (let p of uniquePoints) {
                        if (counts[p] !== 3) isAirplane = false;
                    }
                    for(let i=0; i<uniquePoints.length-1; i++) {
                        if(uniquePoints[i+1] !== uniquePoints[i]+1) isAirplane = false;
                    }
                    if (isAirplane) return { type: 'AIRPLANE', val: points[0], len: len, level: 0 };
                }
            }
        }

        // --- ç‚¸å¼¹ç‰Œå‹ (Level 1-5) ---

        // 510K æ£€æµ‹
        if (len === 3) {
            const has5 = points.includes(5);
            const has10 = points.includes(10);
            const hasK = points.includes(13);
            if (has5 && has10 && hasK) {
                // æ£€æŸ¥èŠ±è‰²
                const suits = cards.map(CardRules.getSuit);
                const isPure = (suits[0] === suits[1] && suits[1] === suits[2]);
                
                if (isPure) {
                    // çº¯510K (Level 2)
                    const suit = suits[0];
                    let suitVal = 0;
                    if (suit === 0) suitVal = 4; // é»‘
                    else if (suit === 1) suitVal = 3; // çº¢
                    else if (suit === 2) suitVal = 2; // æ¢…
                    else if (suit === 3) suitVal = 1; // æ–¹
                    return { type: '510K_PURE', val: suitVal, level: 2 }; 
                } else {
                    // [ä¿®å¤] æ¢å¤æ‚è‰² 510K (Level 1)
                    return { type: '510K_MIXED', val: 1, level: 1 };
                }
            }
        }

        // Level 3: æ™®é€šç‚¸å¼¹
        if (uniquePoints.length === 1 && len >= 4) {
            if (len === deckCount * 4) {
                 return { type: 'BOMB_MAX', val: points[0], level: 5 };
            }
            return { type: 'BOMB_STD', val: points[0], len: len, level: 3 };
        }

        // Level 4: å¤©ç‹ç‚¸
        const isAllJokers = points.every(p => p >= 16);
        if (isAllJokers && len === deckCount * 2) {
            return { type: 'BOMB_KING', val: 999, level: 4 };
        }

        return { type: 'INVALID' };
    },

    // 3. æ ¡éªŒèƒ½å¦ç®¡ç‰Œ
    canPlay: (newCards, lastCards, deckCount) => {
        const newHand = CardRules.analyze(newCards, deckCount);
        if (newHand.type === 'INVALID') return false;

        // è‡ªç”±å‡ºç‰Œ
        if (!lastCards || lastCards.length === 0) return true;

        const lastHand = CardRules.analyze(lastCards, deckCount);

        // A. ç‚¸å¼¹ vs éç‚¸å¼¹
        if (newHand.level > 0 && lastHand.level === 0) return true;
        if (newHand.level === 0 && lastHand.level > 0) return false;

        // B. ç‚¸å¼¹ä¹‹é—´ (Level æ¯”è¾ƒ)
        if (newHand.level > 0 && lastHand.level > 0) {
            if (newHand.level > lastHand.level) return true;
            if (newHand.level < lastHand.level) return false;

            // åŒçº§åˆ«æ¯”è¾ƒ (Levelç›¸ç­‰æ—¶)
            if (newHand.type === '510K_PURE') {
                return newHand.val > lastHand.val;
            }

            if (newHand.type === 'BOMB_STD') {
                if (newHand.len > lastHand.len) return true;
                if (newHand.len < lastHand.len) return false;
                return newHand.val > lastHand.val;
            }
            
            // [æ–°å¢] æ‚è‰²510K äº’ç®¡é€»è¾‘ (é€šå¸¸æ‚è‰²ä¸åˆ†å¤§å°ï¼Œæˆ–è€…ä¸èƒ½äº’ç®¡)
            // è¿™é‡Œè®¾å®šä¸ºï¼šä¸èƒ½äº’ç®¡ (è¿”å›false)
            if (newHand.type === '510K_MIXED') return false;

            if (newHand.type === 'BOMB_MAX') return newHand.val > lastHand.val;
            
            return false;
        }

        // C. éç‚¸å¼¹ä¹‹é—´ (åŒç‰Œå‹æ¯”è¾ƒ)
        if (newHand.type === lastHand.type) {
            if ((newHand.type === 'LIANDUI' || newHand.type === 'AIRPLANE') && newHand.len !== lastHand.len) return false;
            
            if (newCards.length !== lastCards.length) return false;
            
            if (newHand.type === 'LIANDUI') {
                return newHand.val === lastHand.val + 1;
            }
            
            return newHand.val > lastHand.val;
        }

        return false;
    }
};

module.exports = CardRules;

================================================================================
FILE PATH: server\game\Deck.js
================================================================================
// ç‰Œåº“ç”Ÿæˆä¸æ´—ç‰Œ


class Deck {
    constructor(deckCount = 1) {
        this.deck = [];
        // ç”Ÿæˆå¤šå‰¯ç‰Œã€‚æ¯å‰¯ç‰Œæ˜¯ 0-53ã€‚
        // æˆ‘ä»¬ä½¿ç”¨ i + d * 54 æ¥ä¿è¯æ¯å¼ ç‰Œæœ‰å”¯ä¸€IDï¼Œæ–¹ä¾¿å‰ç«¯æ¸²æŸ“ Key å€¼
        for (let d = 0; d < deckCount; d++) {
             for (let i = 0; i < 54; i++) {
                this.deck.push(i + d * 54); 
            }
        }
    }

    shuffle() {
        // Fisher-Yates æ´—ç‰Œç®—æ³•
        for (let i = this.deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
        }
    }

    deal(playerCount) {
        this.shuffle();
        const hands = {};
        const totalCards = this.deck.length;
        const cardsPerPlayer = Math.floor(totalCards / playerCount); 
        
        for (let i = 0; i < playerCount; i++) {
            hands[i] = this.deck.slice(i * cardsPerPlayer, (i + 1) * cardsPerPlayer);
            // å°†å¤šä½™çš„ç‰Œå‘ç»™æœ€åä¸€ä¸ªäººï¼ˆç®€åŒ–å¤„ç†ï¼‰
            if (i === playerCount - 1) {
                 hands[i] = this.deck.slice(i * cardsPerPlayer);
            }
        }
        return hands;
    }
}

module.exports = Deck;

================================================================================
FILE PATH: server\game\GameManager.js
================================================================================
const CardRules = require('./CardRules');
const Deck = require('./Deck');
const BotLogic = require('./BotLogic');

class GameManager {
    constructor(roomConfig, players, io, roomId) {
        this.config = roomConfig;
        this.players = players; 
        this.io = io; 
        this.roomId = roomId;

        this.grandScores = {}; // æ€»å¤§åˆ†
        this.players.forEach(p => this.grandScores[p.id] = 0);
        this.lastWinnerId = null;
        this.gameState = null; 
        
        // æ¯”èµ›å†å²è®°å½•ï¼Œç”¨äºç»“ç®—é¡µé¢å±•ç¤ºè¡¨æ ¼
        this.matchHistory = []; 
        
        this.timer = null;
        this.botTimer = null;
        this.turnStartTime = 0; 
    }

    // [ä¿®æ”¹] è·å–æç¤º - è¿”å›æ‰€æœ‰å¯è¡Œè§£
    getHint(playerId) {
        try {
            if (!this.gameState) return [];
            const hand = this.gameState.hands[playerId];
            if (!hand) return [];

            const lastPlayed = this.gameState.lastPlayedCards;
            
            // ä½¿ç”¨æ–°æ–¹æ³• findAllSolutions è·å–æ‰€æœ‰å¯è¡Œç‰Œå‹
            const results = BotLogic.findAllSolutions(hand, lastPlayed, this.config.deckCount);
            
            return results || [];
        } catch (error) {
            console.error("[GameManager] getHint error:", error);
            return [];
        }
    }

    // åˆ‡æ¢æ‰˜ç®¡çŠ¶æ€
    toggleAutoPlay(playerId) {
        const player = this.players.find(p => p.id === playerId);
        if (!player || player.isBot) return; 

        player.isAutoPlay = !player.isAutoPlay;
        
        // å¦‚æœå½“å‰æ­£å¥½æ˜¯è¯¥ç©å®¶çš„å›åˆ
        if (this.gameState && this.players[this.gameState.currentTurnIndex].id === playerId) {
            if (player.isAutoPlay) {
                // å¼€å¯æ‰˜ç®¡ï¼šç«‹å³å°è¯•è¿è¡Œ Bot
                this._checkAndRunBot();
            } else {
                // å–æ¶ˆæ‰˜ç®¡ï¼šæ¸…é™¤ Bot è®¡æ—¶å™¨ï¼Œé‡ç½®è¶…æ—¶è®¡æ—¶å™¨ç»™ç©å®¶æ€è€ƒæ—¶é—´
                if (this.botTimer) {
                    clearTimeout(this.botTimer);
                    this.botTimer = null;
                }
                this._resetTimer();
            }
        }
    }

    startRound(isNextRound = false) {
        if (!isNextRound) {
            this.players.forEach(p => this.grandScores[p.id] = 0);
            this.lastWinnerId = null;
            this.matchHistory = []; // æ–°æ¯”èµ›æ¸…ç©ºå†å²
        }

        const deck = new Deck(this.config.deckCount);
        const hands = deck.deal(this.players.length);

        let startIndex = 0;
        if (this.lastWinnerId) {
            const winnerIdx = this.players.findIndex(p => p.id === this.lastWinnerId);
            if (winnerIdx !== -1) startIndex = winnerIdx;
        }

        // ç»„é˜Ÿåˆ†é…é€»è¾‘ï¼šé—´éš”å…¥åº§ (0,2ä¸ºä¸€é˜Ÿ; 1,3ä¸ºä¸€é˜Ÿ)
        const isTeamMode = this.config.isTeamMode && (this.players.length % 2 === 0);
        this.players.forEach((p, index) => {
            if (isTeamMode) {
                p.team = index % 2; // 0 æˆ– 1
            } else {
                p.team = null; // ä¸ªäººæˆ˜
            }
        });

        this.gameState = {
            hands: {},
            currentTurnIndex: startIndex,
            lastPlayedCards: [],    
            consecutivePasses: 0,   
            roundPoints: {},        
            pendingTablePoints: 0,  
            roundWinnerId: null, 
            finishedRank: [],    
        };

        this.players.forEach((p, index) => {
            this.gameState.hands[p.id] = hands[index];
            this.gameState.roundPoints[p.id] = 0;
        });

        this._resetTimer();
        this._checkAndRunBot();

        return {
            startPlayerIndex: startIndex,
            startPlayerId: this.players[startIndex].id,
            hands: this.gameState.hands
        };
    }

    _checkAndRunBot() {
        if (!this.gameState) return;
        
        if (this.botTimer) {
            clearTimeout(this.botTimer);
            this.botTimer = null;
        }

        if (this._getActivePlayerCount() <= 1 && this.gameState.lastPlayedCards.length === 0) return;

        const currPlayer = this.players[this.gameState.currentTurnIndex];
        const isAI = currPlayer.isBot || currPlayer.isAutoPlay;

        if (isAI && this.gameState.hands[currPlayer.id].length > 0) {
            const delay = 1000 + Math.random() * 1000;
            this.botTimer = setTimeout(() => {
                this._executeBotTurn(currPlayer);
            }, delay);
        }
    }

    _executeBotTurn(botPlayer) {
        if (!this.gameState) return;
        // åŒé‡æ£€æŸ¥ï¼šç¡®ä¿å½“å‰å›åˆç¡®å®å±äºè¯¥ Botï¼Œé˜²æ­¢ Timer è§¦å‘æ—¶å›åˆå·²å˜
        if (this.players[this.gameState.currentTurnIndex].id !== botPlayer.id) return;

        try {
            const hand = this.gameState.hands[botPlayer.id];
            // æ²¡ç‰Œäº†ï¼Œç›´æ¥è·³è¿‡
            if (!hand || hand.length === 0) {
                 this._advanceTurn(); 
                 this._broadcastUpdate(); // å¹¿æ’­çŠ¶æ€
                 return;
            }

            const isNewRound = this.gameState.lastPlayedCards.length === 0;
            const cardsToBeat = isNewRound ? [] : this.gameState.lastPlayedCards;

            const sortedHand = [...hand].sort((a,b) => CardRules.getPoint(a) - CardRules.getPoint(b));
            
            // å°è¯•è·å–å‡ºç‰Œç­–ç•¥
            let cardsToPlay = null;
            try {
                // [ä¿®æ”¹] Bot ä½¿ç”¨ decideMove (å†…éƒ¨ä¼šè°ƒç”¨ findAllSolutions å–ç¬¬ä¸€ä¸ª)
                cardsToPlay = BotLogic.decideMove(sortedHand, cardsToBeat, this.config.deckCount);
            } catch (err) {
                console.error("[Bot Error] Logic crashed:", err);
            }

            if (cardsToPlay) {
                console.log(`[Bot/Auto] ${botPlayer.name} plays ${cardsToPlay.length} cards.`);
                const result = this.playCards(botPlayer.id, cardsToPlay);
                
                if (result.success) {
                    if (!botPlayer.isBot) {
                        this.io.to(botPlayer.id).emit('hand_update', this.gameState.hands[botPlayer.id]);
                    }

                    if (result.isRoundOver) {
                        this._handleWin(result, botPlayer.id);
                    } else {
                        const analysis = CardRules.analyze(cardsToPlay, this.config.deckCount);
                        const desc = CardRules.getAnalysisText(analysis);
                        this._broadcastUpdate(`${botPlayer.name}: ${desc}`);
                    }
                } else {
                    console.error(`[Bot Error] Play failed: ${result.error}`);
                    if (!isNewRound) {
                        this._forcePass(botPlayer);
                    } else {
                        this._playMinCard(botPlayer, sortedHand);
                    }
                }
            } else {
                if (isNewRound) {
                    console.warn(`[Bot Fix] AI tried to pass on new round. Forcing min card.`);
                    this._playMinCard(botPlayer, sortedHand);
                } else {
                    console.log(`[Bot/Auto] ${botPlayer.name} passes.`);
                    this._forcePass(botPlayer);
                }
            }
        } catch (error) {
            console.error(`[Bot Error] Critical Exception in _executeBotTurn:`, error);
            
            this._advanceTurn();
            this._resetTimer();
            
            const publicState = this.getPublicState();
            publicState.infoText = `${botPlayer.name} å‘ç”Ÿé”™è¯¯ï¼Œè·³è¿‡`;
            this.io.to(this.roomId).emit('game_state_update', publicState);

            this._checkAndRunBot();
        }
    }
    
    // è¾…åŠ©ï¼šå‡ºæœ€å°çš„ä¸€å¼ ç‰Œ (ç”¨äºå…œåº•)
    _playMinCard(botPlayer, sortedHand) {
        const minCard = [sortedHand[0]];
        const result = this.playCards(botPlayer.id, minCard);
        if (result.success) {
            if (!botPlayer.isBot) this.io.to(botPlayer.id).emit('hand_update', this.gameState.hands[botPlayer.id]);
            
            const analysis = CardRules.analyze(minCard, this.config.deckCount);
            const desc = CardRules.getAnalysisText(analysis);
            this._broadcastUpdate(`${botPlayer.name}: ${desc} (ç³»ç»Ÿ)`);
        } else {
             this._forcePass(botPlayer); 
        }
    }

    // ç»Ÿä¸€å¹¿æ’­å‡½æ•°
    _broadcastUpdate(infoText = null) {
        const publicState = this.getPublicState();
        if (infoText) publicState.infoText = infoText;
        this.io.to(this.roomId).emit('game_state_update', publicState);
    }
    
    // å¼ºåˆ¶è¿‡ç‰Œè¾…åŠ©å‡½æ•°
    _forcePass(botPlayer) {
        const result = this.passTurn(botPlayer.id);
        if (result.success) {
            this._broadcastUpdate(`${botPlayer.name}: ä¸è¦`);
        } else {
            console.error("[Bot Critical] Failed to pass turn:", result.error);
            this._advanceTurn();
            this._broadcastUpdate();
            this._resetTimer();
            this._checkAndRunBot();
        }
    }

    _handleWin(result, winnerId) {
        const rInfo = result.roundResult;

        // æ„é€ åŒ…å«æ‰€æœ‰ä¿¡æ¯çš„ç»“ç®—å¯¹è±¡
        const settlementData = {
            roundWinner: rInfo.roundWinnerName,
            pointsEarned: rInfo.pointsEarned,
            detail: rInfo.detail,       // æ–‡å­—ç‰ˆæ—¥å¿—
            matchHistory: this.matchHistory, // å®Œæ•´çš„å†å²è®°å½•
            grandScores: rInfo.grandScores,
            roundIndex: this.matchHistory.length
        };

        if (rInfo.isGrandOver) {
            this.io.to(this.roomId).emit('grand_game_over', { 
                grandWinner: rInfo.roundWinnerName, 
                ...settlementData
            });
            this.gameState = null; 
            this._clearTimer(); 
        } else {
            this.io.to(this.roomId).emit('round_over', settlementData);
            this._clearTimer();
        }
    }

    playCards(playerId, cards) {
        if (!this.gameState) return { success: false, error: 'æ¸¸æˆæœªå¼€å§‹' };

        const currPlayer = this.players[this.gameState.currentTurnIndex];
        if (currPlayer.id !== playerId) return { success: false, error: 'è¿˜æ²¡è½®åˆ°ä½ ' };

        const playerHand = this.gameState.hands[playerId];
        if (!this._handContainsCards(playerHand, cards)) {
            return { success: false, error: 'æ‰‹ç‰Œä¸è¶³æˆ–æ•°æ®ä¸åŒæ­¥' };
        }

        const isNewRound = this.gameState.lastPlayedCards.length === 0;
        const cardsToBeat = isNewRound ? [] : this.gameState.lastPlayedCards;

        if (!CardRules.canPlay(cards, cardsToBeat, this.config.deckCount)) {
            return { success: false, error: 'ç‰Œå‹ä¸ç¬¦æˆ–ç®¡ä¸ä¸Š' };
        }

        this._removeCardsFromHand(playerId, cards);
        this.gameState.pendingTablePoints += CardRules.calculateTotalScore(cards);
        this.gameState.lastPlayedCards = cards;
        this.gameState.consecutivePasses = 0;
        this.gameState.roundWinnerId = playerId;

        const isFinished = this.gameState.hands[playerId].length === 0;
        if (isFinished) {
            if (!this.gameState.finishedRank.includes(playerId)) {
                this.gameState.finishedRank.push(playerId);
            }
        }
        
        const analysis = CardRules.analyze(cards, this.config.deckCount);
        const cardDesc = CardRules.getAnalysisText(analysis);
        const logText = `${currPlayer.name}: ${cardDesc}`;

        const activeCount = this._getActivePlayerCount();
        
        if (activeCount <= 1) {
            this._clearTimer();
            const roundResult = this._concludeRound();
            return { 
                success: true, 
                isRoundOver: true,
                roundResult,
                cardsPlayed: cards,
                pendingPoints: this.gameState.pendingTablePoints,
                logText // è¿”å›æ—¥å¿—ç»™è°ƒç”¨è€…
            };
        }

        this._advanceTurn();
        this._resetTimer();
        this._checkAndRunBot();

        return { 
            success: true, 
            isRoundOver: false,
            cardsPlayed: cards,
            pendingPoints: this.gameState.pendingTablePoints,
            logText // è¿”å›æ—¥å¿—ç»™è°ƒç”¨è€…
        };
    }

    passTurn(playerId) {
        if (!this.gameState) return { success: false, error: 'æ¸¸æˆæœªå¼€å§‹' };

        const currPlayer = this.players[this.gameState.currentTurnIndex];
        if (currPlayer.id !== playerId) return { success: false, error: 'è¿˜æ²¡è½®åˆ°ä½ ' };

        if (this.gameState.lastPlayedCards.length === 0) {
            return { success: false, error: 'å¿…é¡»å‡ºç‰Œ' };
        }

        this.gameState.consecutivePasses++;
        this._advanceTurn(); 

        const winnerHand = this.gameState.hands[this.gameState.roundWinnerId];
        const winnerIsActive = winnerHand && winnerHand.length > 0;
        const activeCount = this._getActivePlayerCount();
        
        const passesNeeded = winnerIsActive ? (activeCount - 1) : activeCount;

        let turnCleared = false;
        let infoMessage = `${currPlayer.name}: ä¸è¦`;

        if (this.gameState.consecutivePasses >= passesNeeded) {
            const wId = this.gameState.roundWinnerId;
            if (wId) {
                this.gameState.roundPoints[wId] = (this.gameState.roundPoints[wId] || 0) + this.gameState.pendingTablePoints;
                this.gameState.pendingTablePoints = 0;
                
                // å¦‚æœèµ¢å®¶è¿˜æœ‰ç‰Œï¼Œèµ¢å®¶ç»§ç»­å‡º
                if (this.gameState.hands[wId].length > 0) {
                     const wIdx = this.players.findIndex(p => p.id === wId);
                     this.gameState.currentTurnIndex = wIdx;
                } else {
                    // èµ¢å®¶å·²å‡ºå®Œç‰Œ (é€ƒå‡º)
                    // æ£€æŸ¥æ˜¯å¦éœ€è¦è§¦å‘â€œé˜Ÿå‹æ¥é£â€é€»è¾‘
                    const winnerPlayer = this.players.find(p => p.id === wId);
                    const isTeamMode = this.config.isTeamMode && (this.players.length % 2 === 0);
                    
                    let teammateTookOver = false;

                    // åªæœ‰åœ¨ç»„é˜Ÿæ¨¡å¼ä¸‹ï¼Œæ‰å°è¯•å¯»æ‰¾é˜Ÿå‹æ¥é£
                    if (isTeamMode && winnerPlayer && winnerPlayer.team !== undefined && winnerPlayer.team !== null) {
                        const wIdx = this.players.findIndex(p => p.id === wId);
                        const pCount = this.players.length;
                        
                        // æ¥é£æœç´¢é€’å¢æ–¹å‘
                        for (let i = 1; i < pCount; i++) {
                            const tIdx = (wIdx + i) % pCount; 
                            const potentialTeammate = this.players[tIdx];
                            
                            // æ˜¯é˜Ÿå‹ ä¸” è¿˜æ˜¯æ´»è·ƒçŠ¶æ€
                            if (potentialTeammate.team === winnerPlayer.team && 
                                this.gameState.hands[potentialTeammate.id] && 
                                this.gameState.hands[potentialTeammate.id].length > 0) {
                                
                                this.gameState.currentTurnIndex = tIdx;
                                teammateTookOver = true;
                                infoMessage = `${currPlayer.name}: ä¸è¦ (é˜Ÿå‹æ¥é£)`;
                                this._broadcastUpdate(`${winnerPlayer.name} å·²é€ƒå‡ºï¼Œé˜Ÿå‹ ${potentialTeammate.name} æ¥é£`);
                                break;
                            }
                        }
                    }
                }
            }
            
            this.gameState.lastPlayedCards = [];
            this.gameState.consecutivePasses = 0;
            turnCleared = true;
        }

        this._resetTimer(); 
        this._checkAndRunBot();

        return { 
            success: true, 
            turnCleared,
            logText: infoMessage
        };
    }

    _clearTimer() {
        if (this.timer) clearTimeout(this.timer);
        if (this.botTimer) clearTimeout(this.botTimer);
        this.timer = null;
        this.botTimer = null;
    }

    _resetTimer() {
        this._clearTimer();
        if (this.gameState && this._getActivePlayerCount() > 1) {
            this.turnStartTime = Date.now();
            const timeLimit = this.config.turnTimeout || 60000;
            this.timer = setTimeout(() => {
                this._handleTimeout();
            }, timeLimit);
        }
    }

    _handleTimeout() {
        if (!this.gameState) return;
        const currIdx = this.gameState.currentTurnIndex;
        const currPlayer = this.players[currIdx];
        
        console.log(`[Timeout] Player ${currPlayer.name} (${currPlayer.id}) timed out.`);
        const isNewRound = this.gameState.lastPlayedCards.length === 0;

        if (isNewRound) {
            const hand = this.gameState.hands[currPlayer.id];
            if (!hand || hand.length === 0) { this._advanceTurn(); return; }

            const sorted = hand.map(c => ({ id: c, val: CardRules.getPoint(c) })).sort((a, b) => a.val - b.val);
            const cardToPlay = [sorted[0].id]; 
            
            const result = this.playCards(currPlayer.id, cardToPlay);
            if (result.success) {
                this.io.to(currPlayer.id).emit('hand_update', this.gameState.hands[currPlayer.id]);
                
                const logText = result.logText || `${currPlayer.name} è¶…æ—¶å‡ºç‰Œ`;
                
                if (result.isRoundOver) {
                     this._handleWin(result, currPlayer.id);
                } else {
                     this._broadcastUpdate(logText);
                }
            }
        } else {
            const result = this.passTurn(currPlayer.id);
            if (result.success) {
                this._broadcastUpdate(`${currPlayer.name}: è¶…æ—¶è¿‡ç‰Œ`);
            }
        }
    }

    _getActivePlayerCount() {
        if (!this.gameState) return 0;
        let count = 0;
        for (const p of this.players) {
            if (this.gameState.hands[p.id] && this.gameState.hands[p.id].length > 0) {
                count++;
            }
        }
        return count;
    }

    _advanceTurn() {
        const playerCount = this.players.length;
        let nextIndex = this.gameState.currentTurnIndex;
        let attempts = 0;
        
        do {
            nextIndex = (nextIndex + 1) % playerCount; // è½®è½¬æ”¹ä¸ºé€’å¢
            attempts++;
        } while (
            this.gameState.hands[this.players[nextIndex].id].length === 0 && 
            attempts < playerCount 
        );
        
        this.gameState.currentTurnIndex = nextIndex;
    }

    getPublicState() {
        if (!this.gameState) return null;
        
        const currentScoresDisplay = {};
        const roundPointsDisplay = {}; // æ¯ä¸€å°å±€çš„ç‹¬ç«‹åˆ†æ•°
        const playersInfo = {};
        const handCounts = {};

        this.players.forEach(p => {
            const grand = this.grandScores[p.id] || 0;
            const round = this.gameState.roundPoints[p.id] || 0;
            currentScoresDisplay[p.id] = grand + round;
            roundPointsDisplay[p.id] = round; 
            
            playersInfo[p.id] = { 
                isBot: p.isBot, 
                isAutoPlay: p.isAutoPlay,
                team: p.team 
            };
            handCounts[p.id] = this.gameState.hands[p.id] ? this.gameState.hands[p.id].length : 0;
        });

        const winnerObj = this.players.find(p => p.id === this.gameState.roundWinnerId);

        let remainingSeconds = 0;
        if (this.turnStartTime) {
            const timeLimit = this.config.turnTimeout || 60000;
            const elapsed = Date.now() - this.turnStartTime;
            remainingSeconds = Math.max(0, Math.ceil((timeLimit - elapsed) / 1000));
        }
        
        return {
            turnIndex: this.gameState.currentTurnIndex,
            currentTurnId: this.players[this.gameState.currentTurnIndex].id,
            turnRemaining: remainingSeconds, 
            lastPlayed: this.gameState.lastPlayedCards,
            lastPlayerName: winnerObj ? winnerObj.name : '',
            scores: currentScoresDisplay,
            roundPoints: roundPointsDisplay, 
            pendingPoints: this.gameState.pendingTablePoints,
            finishedRank: this.gameState.finishedRank,
            playersInfo: playersInfo,
            handCounts: handCounts 
        };
    }

    // å®Œæ•´çš„é‡è¿æ•°æ®æ¬è¿
    reconnectPlayer(oldId, newId) {
        console.log(`[GameManager] Moving data from ${oldId} to ${newId}`);

        // 1. æ¬è¿å…¨å±€æ€»åˆ†
        if (this.grandScores[oldId] !== undefined) {
            this.grandScores[newId] = this.grandScores[oldId];
            delete this.grandScores[oldId];
        }

        // 2. æ¬è¿ä¸Šå±€èµ¢å®¶æ ‡è®°
        if (this.lastWinnerId === oldId) this.lastWinnerId = newId;

        // 3. å¤„ç†æ‰˜ç®¡çŠ¶æ€
        const player = this.players.find(p => p.id === newId);
        if (player) {
             player.isAutoPlay = false; 
        }

        // 4. æ¬è¿å½“å‰å±€æ•°æ®
        if (this.gameState) {
            // æ‰‹ç‰Œ
            if (this.gameState.hands[oldId]) {
                this.gameState.hands[newId] = this.gameState.hands[oldId];
                delete this.gameState.hands[oldId];
            }
            // æœ¬å±€å¾—åˆ†
            if (this.gameState.roundPoints[oldId] !== undefined) {
                this.gameState.roundPoints[newId] = this.gameState.roundPoints[oldId];
                delete this.gameState.roundPoints[oldId];
            }
            // æœ¬å›åˆèµ¢å®¶
            if (this.gameState.roundWinnerId === oldId) this.gameState.roundWinnerId = newId;
            
            // å®Œèµ›æ’å (Array)
            const rankIdx = this.gameState.finishedRank.indexOf(oldId);
            if (rankIdx !== -1) {
                this.gameState.finishedRank[rankIdx] = newId;
            }
        }

        // ä¿®å¤é‡è¿æ—¶å†å²è®°å½• ID æ˜ å°„
        this.matchHistory.forEach(match => {
            if (match.scores[oldId] !== undefined) {
                match.scores[newId] = match.scores[oldId];
                delete match.scores[oldId];
            }
        });

        return true;
    }

    _handContainsCards(hand, cardsToPlay) {
        const tempHand = [...hand];
        for (let c of cardsToPlay) {
            const idx = tempHand.indexOf(c);
            if (idx === -1) return false;
            tempHand.splice(idx, 1);
        }
        return true;
    }

    _removeCardsFromHand(playerId, cards) {
        const newHand = [...this.gameState.hands[playerId]];
        for (let c of cards) {
            const idx = newHand.indexOf(c);
            if (idx !== -1) newHand.splice(idx, 1);
        }
        this.gameState.hands[playerId] = newHand;
    }

    _concludeRound() {
        const lastPlayer = this.players.find(p => this.gameState.hands[p.id].length > 0);
        if (lastPlayer) {
            this.gameState.finishedRank.push(lastPlayer.id);
        }
        
        const wId = this.gameState.roundWinnerId;
        if (wId) {
             this.gameState.roundPoints[wId] = (this.gameState.roundPoints[wId] || 0) + this.gameState.pendingTablePoints;
             this.gameState.pendingTablePoints = 0;
        }

        const fullRankIds = [...this.gameState.finishedRank];
        this.players.forEach(p => {
            if (!fullRankIds.includes(p.id)) fullRankIds.push(p.id);
        });

        const firstWinnerId = fullRankIds[0];
        this.lastWinnerId = firstWinnerId;

        let logLines = []; // [ç”¨äºå‰ç«¯æ–‡å­—æ˜¾ç¤º]
        let penaltyDetails = []; // [ç”¨äºå‰ç«¯ Table çš„æ—¥å¿—æ•°ç»„]

        let totalCardPenalty = 0;
        let currentRoundScores = {};
        this.players.forEach(p => {
            currentRoundScores[p.id] = (this.gameState.roundPoints[p.id] || 0);
        });

        this.players.forEach(p => {
            const handPts = CardRules.calculateTotalScore(this.gameState.hands[p.id]);
            if (handPts > 0) {
                totalCardPenalty += handPts;
            }
        });

        // å¤´æ¸¸æ”¶åˆ†é€»è¾‘
        if (firstWinnerId && totalCardPenalty > 0) {
            currentRoundScores[firstWinnerId] += totalCardPenalty;
            const winnerName = this.players.find(p=>p.id===firstWinnerId)?.name;
            logLines.push(`[æ‰‹ç‰Œç½šåˆ†] è¾“å®¶å…±è®¡ ${totalCardPenalty} åˆ†ï¼Œå½’ç¬¬ä¸€å ${winnerName}ã€‚`);
            penaltyDetails.push(`ç¬¬ä¸€å ${winnerName} è·å¾—å‰©ä½™æ‰‹ç‰Œåˆ† ${totalCardPenalty}`);
        }

        // æ’åèµç½š + é˜Ÿå‹ä¿æŠ¤é€»è¾‘
        if (this.config.enableRankPenalty && this.config.rankPenaltyScores && this.config.rankPenaltyScores.length > 0) {
            const penaltyConfig = this.config.rankPenaltyScores;
            const playerCount = fullRankIds.length;
            
            penaltyConfig.forEach((score, index) => {
                const winnerIndex = index; 
                const loserIndex = playerCount - 1 - index; 

                if (winnerIndex < loserIndex) {
                    const winnerId = fullRankIds[winnerIndex];
                    const loserId = fullRankIds[loserIndex];
                    
                    if (winnerId && loserId) {
                        const winner = this.players.find(p=>p.id===winnerId);
                        const loser = this.players.find(p=>p.id===loserId);
                        
                        // é˜Ÿå‹ä¿æŠ¤åˆ¤æ–­
                        if (winner.team !== null && winner.team !== undefined && winner.team === loser.team) {
                             logLines.push(`[ğŸ›¡ï¸é˜Ÿå‹ä¿æŠ¤] ç¬¬${winnerIndex+1}å(${winner.name}) ä¸ å€’æ•°ç¬¬${index+1}å(${loser.name}) æ˜¯é˜Ÿå‹ï¼Œ${score}åˆ† å…ç½šï¼`);
                             penaltyDetails.push(`[é˜Ÿå‹ä¿æŠ¤] ${winner.name} å…æ”¶ ${loser.name} ${score} åˆ†`);
                        } else {
                            // æ­£å¸¸ç½šåˆ†
                            currentRoundScores[winnerId] += score;
                            currentRoundScores[loserId] -= score;
                            logLines.push(`[æ’åèµç½š] ç¬¬${winnerIndex+1}å ${winner.name} æ”¶å– å€’æ•°ç¬¬${index+1}å ${loser.name} ${score} åˆ†ã€‚`);
                            penaltyDetails.push(`${loser.name} è¿›è´¡ ${winner.name} ${score} åˆ†`);
                        }
                    }
                }
            });
        }

        // æ›´æ–°æ€»åˆ†
        this.players.forEach(p => {
            this.grandScores[p.id] += currentRoundScores[p.id];
        });

        // å­˜å…¥ matchHistory
        this.matchHistory.push({
            roundIndex: this.matchHistory.length + 1,
            scores: {...currentRoundScores}, 
            winnerId: firstWinnerId,
            details: penaltyDetails
        });

        const firstWinnerName = this.players.find(p => p.id === firstWinnerId)?.name || 'æœªçŸ¥';
        const isGrandOver = this.grandScores[firstWinnerId] >= this.config.targetScore;
        const totalPointsEarned = currentRoundScores[firstWinnerId]; // ä½¿ç”¨åŒ…å«ç½šåˆ†åçš„æœ€ç»ˆå½“å±€å¾—åˆ†

        return {
            roundWinnerName: firstWinnerName,
            pointsEarned: totalPointsEarned, 
            detail: logLines.join('\n') || 'å®Œç¾ç»“æŸï¼Œæœªè®¾ç½®é¢å¤–ç½šåˆ†', 
            grandScores: this.grandScores,
            isGrandOver
        };
    }
    
    getPlayerHand(playerId) {
        if (!this.gameState || !this.gameState.hands) return [];
        return this.gameState.hands[playerId] || [];
    }
}

module.exports = GameManager;

================================================================================
FILE PATH: server\game\SeatManager.js
================================================================================
const CardRules = require('./CardRules');
const Deck = require('./Deck');

class SeatManager {
    // æ„é€ å‡½æ•°æ¥æ”¶ isTeamMode å‚æ•°
    constructor(io, roomId, players, isTeamMode) {
        this.io = io;
        this.roomId = roomId;
        this.players = players; 
        this.isTeamMode = isTeamMode; 

        // ç”Ÿæˆä¸€å‰¯ç‰Œï¼Œæ´—ç‰Œ
        const deck = new Deck(1);
        deck.shuffle();
        
        // [ä¿®æ”¹] ä¼˜åŒ–æŠ½ç‰Œæ± ç”Ÿæˆé€»è¾‘ï¼šä¼˜å…ˆä¿è¯ç‚¹æ•°ä¸é‡å¤
        // è¿™æ ·ç©å®¶æŠ½åˆ°çš„ç‰Œå¤§æ¦‚ç‡æ˜¯ 3, 5, K, A è¿™ç§çº¯æ•°å­—å¤§å°æ¯”è¾ƒï¼Œä¸ç”¨æ¯”èŠ±è‰²
        const distinctCards = [];
        const seenPoints = new Set();
        const leftovers = [];

        for (let card of deck.deck) {
            const p = CardRules.getPoint(card);
            if (!seenPoints.has(p)) {
                seenPoints.add(p);
                distinctCards.push(card);
            } else {
                leftovers.push(card);
            }
        }

        // ä¼˜å…ˆç”¨ä¸é‡å¤çš„ç‰Œï¼Œå¦‚æœä¸å¤Ÿï¼ˆæå°‘æƒ…å†µï¼‰å†ç”¨å‰©ä¸‹çš„è¡¥
        const pool = [...distinctCards, ...leftovers];
        
        // å–å‡ºç­‰äºç©å®¶æ•°é‡çš„ç‰Œä½œä¸ºâ€œç­¾â€
        this.availableCards = pool.slice(0, players.length);
        
        // è®°å½•è°æŠ½äº†ä»€ä¹ˆ { playerId: cardVal }
        this.drawResults = {};
        
        // è®°å½•å½“å‰è¿˜å‰©å“ªäº›ä½ç½®çš„ç‰Œæ²¡è¢«ç¿»å¼€
        this.pendingIndices = this.availableCards.map((_, i) => i);
    }

    // [æ–°å¢] ä¸“é—¨å¤„ç†ç©å®¶é‡è¿åçš„ ID å˜æ›´
    reconnectPlayer(oldId, newId) {
        if (this.drawResults[oldId] !== undefined) {
            this.drawResults[newId] = this.drawResults[oldId];
            delete this.drawResults[oldId];
            console.log(`[SeatManager] Player reconnected: ${oldId} -> ${newId}, restored draw result.`);
        }
    }

    // ç©å®¶è¯·æ±‚æŠ½ä¸€å¼ ç‰Œ
    playerDraw(playerId, cardIndex) {
        if (this.drawResults[playerId] !== undefined) return { success: false, msg: 'ä½ å·²ç»æŠ½è¿‡ç‰Œäº†' };

        const idxInPending = this.pendingIndices.indexOf(cardIndex);
        if (idxInPending === -1) return { success: false, msg: 'è¿™å¼ ç‰Œå·²ç»è¢«è¢«äººæŠ½èµ°äº†' };

        this.pendingIndices.splice(idxInPending, 1);

        const cardVal = this.availableCards[cardIndex];
        this.drawResults[playerId] = cardVal;

        const isFinished = Object.keys(this.drawResults).length === this.players.length;

        return { 
            success: true, 
            cardVal, 
            cardIndex, 
            isFinished 
        };
    }

    // æ ¸å¿ƒï¼šè®¡ç®—æœ€ç»ˆåº§æ¬¡å’Œåˆ†ç»„
    finalizeSeats() {
        // 1. åŸºç¡€ç»„è£…ä¸æ’åº
        const results = this.players.map(p => {
            const card = this.drawResults[p.id];
            
            // [å®‰å…¨ä¿æŠ¤] å¦‚æœç©å®¶æ•°æ®å¼‚å¸¸ï¼Œé˜²æ­¢æœåŠ¡å™¨å†æ¬¡å´©æºƒ
            if (card === undefined) {
                console.error(`[SeatManager] Critical Error: Player ${p.name} (${p.id}) missing draw card!`);
                return { ...p, drawCard: 0, sortVal: 0 };
            }

            return {
                ...p,
                drawCard: card,
                // è¿™é‡Œè°ƒç”¨ CardRules.getSortValue
                sortVal: CardRules.getSortValue(card) 
            };
        });

        // ä»å¤§åˆ°å°æ’ (ç‚¹æ•°å¤§çš„åœ¨å‰ -> 1å·ä½)
        results.sort((a, b) => {
            if (b.sortVal !== a.sortVal) return b.sortVal - a.sortVal;
            // å¦‚æœç‚¹æ•°å®åœ¨ä¸€æ ·ï¼ˆè™½ç„¶æˆ‘ä»¬å°½é‡é¿å…äº†ï¼‰ï¼Œå†æ¯”èŠ±è‰²
            return CardRules.getSuitSortValue(b.drawCard) - CardRules.getSuitSortValue(a.drawCard);
        });

        // 2. æ ¹æ®æ¨¡å¼å†³å®šåº§ä½é¡ºåº
        let newOrder = [];

        if (this.isTeamMode) {
            const mid = Math.ceil(results.length / 2);
            const bigTeam = results.slice(0, mid); 
            const smallTeam = results.slice(mid);  

            const maxLen = Math.max(bigTeam.length, smallTeam.length);
            for (let i = 0; i < maxLen; i++) {
                if (bigTeam[i]) newOrder.push(bigTeam[i]); 
                if (smallTeam[i]) newOrder.push(smallTeam[i]); 
            }
        } else {
            newOrder = results;
        }

        return {
            newPlayers: newOrder,
            drawDetails: this.drawResults 
        };
    }
}

module.exports = SeatManager;

================================================================================
FILE PATH: server\index.js
================================================================================
// ç¨‹åºå…¥å£ï¼Œè´Ÿè´£å¯åŠ¨æœåŠ¡ã€Socket ç›‘å¬ã€å¸¸é©»æˆ¿é—´ç®¡ç†
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const cors = require('cors');
const path = require('path');

// å¼•å…¥æ¨¡å—
const GameManager = require('./game/GameManager');
const SeatManager = require('./game/SeatManager'); 

const app = express();
app.use(cors());

const server = http.createServer(app);
const io = new Server(server, {
    cors: { origin: "*", methods: ["GET", "POST"] }
});

// å†…å­˜æ•°æ®åº“
const rooms = {}; 

// --- [æ–°å¢] å¸¸é©»æˆ¿é—´é…ç½®å®šä¹‰ ---
const PERMANENT_ROOMS = {
    '888': { 
        deckCount: 2, 
        maxPlayers: 4, 
        targetScore: 1000,
        turnTimeout: 60000,
        showCardCountMode: 1,
        isTeamMode: false,
        enableRankPenalty: false,
        rankPenaltyScores: [50, 20]
    },
    '666': { 
        deckCount: 3, 
        maxPlayers: 6, 
        targetScore: 1000,
        turnTimeout: 60000,
        showCardCountMode: 1,
        isTeamMode: true, // é»˜è®¤å¼€å¯ç»„é˜Ÿ
        enableRankPenalty: false,
        rankPenaltyScores: [50, 20]
    }
};

/**
 * è¾…åŠ©å‡½æ•°ï¼šåˆå§‹åŒ–/é‡ç½®å¸¸é©»æˆ¿é—´
 */
function initPermanentRoom(roomId) {
    const defaultConfig = PERMANENT_ROOMS[roomId];
    if (!defaultConfig) return;

    // å¦‚æœæˆ¿é—´å·²å­˜åœ¨ï¼Œä¿ç•™è¿æ¥ï¼Œåªé‡ç½®æ¸¸æˆçŠ¶æ€
    // å¦‚æœä¸å­˜åœ¨ï¼Œæ–°å»ºå¯¹è±¡
    if (!rooms[roomId]) {
        rooms[roomId] = {
            config: JSON.parse(JSON.stringify(defaultConfig)), // æ·±æ‹·è´é»˜è®¤é…ç½®
            players: [],
            gameManager: null,
            seatManager: null, 
            destroyTimer: null,
            isPermanent: true // æ ‡è®°ä¸ºå¸¸é©»
        };
        console.log(`[System] Permanent Room ${roomId} initialized.`);
    } else {
        // é‡ç½®é€»è¾‘ï¼šè¿˜åŸé…ç½®ï¼Œæ¸…ç©ºæ¸¸æˆçŠ¶æ€
        rooms[roomId].config = JSON.parse(JSON.stringify(defaultConfig));
        rooms[roomId].gameManager = null;
        rooms[roomId].seatManager = null;
        console.log(`[System] Permanent Room ${roomId} reset to default.`);
    }
}

// å¯åŠ¨æ—¶åˆå§‹åŒ–å¸¸é©»æˆ¿é—´
Object.keys(PERMANENT_ROOMS).forEach(rId => initPermanentRoom(rId));

/**
 * è¾…åŠ©å‡½æ•°ï¼šå‘æˆ¿é—´å†…æ‰€æœ‰äººå¹¿æ’­æœ€æ–°çŠ¶æ€
 */
function broadcastGameState(io, roomId, room, infoText = null) {
    if (!room.gameManager) return;
    
    const publicState = room.gameManager.getPublicState();
    if (!publicState) return;

    if (infoText) publicState.infoText = infoText;

    io.to(roomId).emit('game_state_update', publicState);
}

// è¾…åŠ©ï¼šå¹¿æ’­æˆ¿é—´åŸºç¡€ä¿¡æ¯ (ç”¨äºå¤§å…é…ç½®æ›´æ–°)
function broadcastRoomInfo(io, roomId) {
    const room = rooms[roomId];
    if (!room) return;
    
    const currentGrandScores = room.gameManager ? room.gameManager.grandScores : {};
    // å¦‚æœè¿˜æ²¡å¼€å§‹æ¸¸æˆï¼Œç»™ä¸€ä¸ªé»˜è®¤çš„åˆ†æ•°å¯¹è±¡
    if (Object.keys(currentGrandScores).length === 0) {
        room.players.forEach(p => currentGrandScores[p.id] = 0);
    }

    const data = { 
        roomId, 
        config: room.config, 
        players: room.players, 
        grandScores: currentGrandScores 
    };
    io.to(roomId).emit('room_info', data);
}


io.on('connection', (socket) => {
    console.log(`[Connect] ${socket.id}`);
    socket.emit('your_id', socket.id);

    // --- åˆ›å»ºæˆ¿é—´ ---
    socket.on('create_room', ({ roomId, username, config }) => {
        if (rooms[roomId]) {
            // å¦‚æœæ˜¯å¸¸é©»æˆ¿é—´ï¼Œå…è®¸ç›´æ¥åŠ å…¥ï¼ˆè§†ä¸º Joinï¼‰
            if (rooms[roomId].isPermanent) {
                 // è½¬å‘ç»™ join_room é€»è¾‘
                 // è¿™é‡Œç®€å•å¤„ç†ï¼šå‘Šè¯‰å®¢æˆ·ç«¯æˆ¿é—´å­˜åœ¨ï¼Œè®©å®ƒèµ° Join æµç¨‹ï¼Œæˆ–è€…ç›´æ¥æŠ¥é”™
                 return socket.emit('error_msg', 'å¸¸é©»æˆ¿é—´å·²å­˜åœ¨ï¼Œè¯·ç›´æ¥åŠ å…¥');
            }
            return socket.emit('error_msg', 'æˆ¿é—´å·²å­˜åœ¨');
        }
        
        const cleanName = String(username || '').trim();
        if (!cleanName) return socket.emit('error_msg', 'ç”¨æˆ·åä¸èƒ½ä¸ºç©º');

        const roomConfig = { 
            deckCount: 1, 
            maxPlayers: 3, 
            targetScore: 500, 
            ...config 
        };
        
        rooms[roomId] = {
            config: roomConfig,
            players: [],
            gameManager: null,
            seatManager: null, 
            destroyTimer: null 
        };
        
        socket.join(roomId);
        rooms[roomId].players.push({ id: socket.id, name: cleanName, isHost: true, online: true });
        
        broadcastRoomInfo(io, roomId);
    });

    // --- åŠ å…¥æˆ¿é—´ ---
    socket.on('join_room', ({ roomId, username }) => {
        const room = rooms[roomId];
        if (!room) return socket.emit('error_msg', 'æˆ¿é—´ä¸å­˜åœ¨');

        const cleanName = String(username || '').trim();
        if (!cleanName) return socket.emit('error_msg', 'ç”¨æˆ·åä¸èƒ½ä¸ºç©º');

        const existingPlayerIndex = room.players.findIndex(p => p.name === cleanName);
        let isReconnect = false;
        let oldSocketId = null;

        if (existingPlayerIndex !== -1) {
            const existingPlayer = room.players[existingPlayerIndex];
            
            if (existingPlayer.online) {
                return socket.emit('error_msg', `åå­— "${cleanName}" å·²è¢«ä½¿ç”¨ä¸”ç©å®¶åœ¨çº¿`);
            }

            isReconnect = true;
            oldSocketId = existingPlayer.id;
            console.log(`[Reconnect] Success! ${cleanName} (${oldSocketId} -> ${socket.id})`);

            existingPlayer.id = socket.id;
            existingPlayer.online = true; 

            if (room.destroyTimer) {
                clearTimeout(room.destroyTimer);
                room.destroyTimer = null;
                console.log(`[Room] Destruction cancelled for ${roomId} (player returned)`);
            }

            if (room.gameManager) room.gameManager.reconnectPlayer(oldSocketId, socket.id);
            if (room.seatManager) room.seatManager.reconnectPlayer(oldSocketId, socket.id);

        } else {
            if (room.players.length >= room.config.maxPlayers) {
                return socket.emit('error_msg', 'æˆ¿é—´å·²æ»¡');
            }
            
            socket.join(roomId);
            if (!room.players.find(u => u.id === socket.id)) {
                // åˆ¤æ–­æ˜¯å¦éœ€è¦æˆä¸ºæˆ¿ä¸»ï¼š
                // 1. å¦‚æœæˆ¿é—´æ²¡äººï¼Œæ–°æ¥çš„æ˜¯æˆ¿ä¸»
                // 2. å¦‚æœå¸¸é©»æˆ¿é—´å½“å‰æ²¡æœ‰åœ¨çº¿æˆ¿ä¸»ï¼Œæ–°æ¥çš„ç»§æ‰¿æˆ¿ä¸»
                const hasHost = room.players.some(p => p.isHost && p.online);
                const isHost = !hasHost;

                room.players.push({ id: socket.id, name: cleanName, isHost: isHost, online: true });
            }
        }

        socket.join(roomId);
        
        // å¹¿æ’­æœ€æ–°çš„æˆ¿é—´ä¿¡æ¯ï¼ˆåŒ…å«æˆ¿ä¸»å˜æ›´ã€äººæ•°å˜æ›´ï¼‰
        broadcastRoomInfo(io, roomId);

        // å¦‚æœæ¸¸æˆæ­£åœ¨è¿›è¡Œï¼Œå‘é€æ¸¸æˆçŠ¶æ€
        const isGameRunning = room.gameManager && room.gameManager.gameState;
        if (isGameRunning) {
            if (isReconnect) {
                const hand = room.gameManager.getPlayerHand(socket.id);
                socket.emit('game_started', { 
                    hand: hand, 
                    grandScores: room.gameManager.grandScores 
                });
            }
            broadcastGameState(io, roomId, room);
        }
        
        // é‡è¿æŠ½å¡çŠ¶æ€è¡¥å‘
        if (room.seatManager && room.seatManager.drawResults) {
             socket.emit('enter_draw_phase', { totalCards: room.players.length });
             Object.entries(room.seatManager.drawResults).forEach(([pid, val]) => {
                 const pName = room.players.find(p=>p.id===pid)?.name || 'æœªçŸ¥';
                 let cardIndex = -1;
                 room.seatManager.availableCards.forEach((c, idx) => {
                     if (c === val) cardIndex = idx;
                 });
                 socket.emit('seat_draw_update', {
                    index: cardIndex,
                    val: val,
                    playerId: pid,
                    name: pName
                });
             });
        }
    });
    
    // --- [æ–°å¢] æ›´æ–°æˆ¿é—´é…ç½® ---
    socket.on('update_room_config', ({ roomId, config }) => {
        const room = rooms[roomId];
        if (!room) return;

        // éªŒè¯æƒé™
        const player = room.players.find(p => p.id === socket.id);
        if (!player || !player.isHost) {
            return socket.emit('error_msg', 'åªæœ‰æˆ¿ä¸»å¯ä»¥ä¿®æ”¹è§„åˆ™');
        }

        // éªŒè¯æ¸¸æˆçŠ¶æ€ï¼šæ¸¸æˆä¸­ä¸èƒ½æ”¹
        if (room.gameManager || room.seatManager) {
            return socket.emit('error_msg', 'æ¸¸æˆè¿›è¡Œä¸­æ— æ³•ä¿®æ”¹è§„åˆ™');
        }

        // æ›´æ–°é…ç½®
        room.config = { ...room.config, ...config };
        
        // å¹¿æ’­æ–°çš„é…ç½®ç»™æ‰€æœ‰äºº
        broadcastRoomInfo(io, roomId);
    });

    // æ·»åŠ æœºå™¨äºº
    socket.on('add_bot', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room) return;
        
        if (room.players.length >= room.config.maxPlayers) return socket.emit('error_msg', 'æˆ¿é—´å·²æ»¡');
        
        const botId = `bot_${Date.now()}_${Math.floor(Math.random()*1000)}`;
        const botName = `Robot ${Math.floor(Math.random()*100)}`;
        
        room.players.push({ 
            id: botId, 
            name: botName, 
            isHost: false, 
            online: true,
            isBot: true 
        });
        
        broadcastRoomInfo(io, roomId);
    });

    // [æ–°å¢] è¸¢äººåŠŸèƒ½
    socket.on('kick_player', ({ roomId, targetId }) => {
        const room = rooms[roomId];
        if (!room) return;

        // 1. éªŒè¯æƒé™ï¼šåªæœ‰æˆ¿ä¸»èƒ½è¸¢äºº
        const sender = room.players.find(p => p.id === socket.id);
        if (!sender || !sender.isHost) {
            return socket.emit('error_msg', 'åªæœ‰æˆ¿ä¸»å¯ä»¥è¸¢äºº');
        }

        // 2. æ¸¸æˆä¸­ä¸¥ç¦è¸¢äººï¼Œé˜²æ­¢å´©ç›˜
        if (room.gameManager || room.seatManager) {
            return socket.emit('error_msg', 'æ¸¸æˆè¿›è¡Œä¸­æ— æ³•è¸¢äºº');
        }

        const targetIndex = room.players.findIndex(p => p.id === targetId);
        if (targetIndex === -1) return;

        const targetPlayer = room.players[targetIndex];

        // 3. ä¸èƒ½è¸¢è‡ªå·±
        if (targetPlayer.id === socket.id) return;

        // 4. ç§»é™¤ç©å®¶
        room.players.splice(targetIndex, 1);

        // 5. å¦‚æœæ˜¯çœŸäººï¼Œé€šçŸ¥ä»–è¢«è¸¢äº†
        if (!targetPlayer.isBot) {
            io.to(targetPlayer.id).emit('kicked', 'ä½ å·²è¢«æˆ¿ä¸»ç§»å‡ºæˆ¿é—´');
            // è®©è¯¥ socket ç¦»å¼€æˆ¿é—´ channel
            const targetSocket = io.sockets.sockets.get(targetPlayer.id);
            if (targetSocket) {
                targetSocket.leave(roomId);
            }
        }

        console.log(`[Room] ${sender.name} kicked ${targetPlayer.name} from ${roomId}`);
        
        // 6. å¹¿æ’­æ›´æ–°
        broadcastRoomInfo(io, roomId);
    });

    // åˆ‡æ¢æ‰˜ç®¡
    socket.on('toggle_auto_play', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room || !room.gameManager) return;

        room.gameManager.toggleAutoPlay(socket.id);
        broadcastGameState(io, roomId, room);
    });

    // åº§ä½è°ƒæ•´
    socket.on('switch_seat', ({ roomId, index1, index2 }) => {
        const room = rooms[roomId];
        if (!room) return;

        const requestPlayer = room.players.find(p => p.id === socket.id);
        if (!requestPlayer || !requestPlayer.isHost) {
            return socket.emit('error_msg', 'åªæœ‰æˆ¿ä¸»å¯ä»¥è°ƒæ•´åº§ä½');
        }

        if (index1 < 0 || index1 >= room.players.length || index2 < 0 || index2 >= room.players.length) return;
        if (room.gameManager && room.gameManager.gameState) return socket.emit('error_msg', 'æ¸¸æˆä¸­æ— æ³•è°ƒæ•´åº§ä½');

        const temp = room.players[index1];
        room.players[index1] = room.players[index2];
        room.players[index2] = temp;

        broadcastRoomInfo(io, roomId);
    });

    // æŠ½å¡äº¤äº’é€»è¾‘
    socket.on('draw_seat_card', ({ roomId, cardIndex }) => {
        const room = rooms[roomId];
        if (!room || !room.seatManager) return;

        const result = room.seatManager.playerDraw(socket.id, cardIndex);
        if (!result.success) return socket.emit('error_msg', result.msg);

        const player = room.players.find(p => p.id === socket.id);
        io.to(roomId).emit('seat_draw_update', {
            index: cardIndex,
            val: result.cardVal,
            playerId: socket.id,
            name: player ? player.name : 'æœªçŸ¥'
        });

        if (result.isFinished) {
            setTimeout(() => {
                const { newPlayers, drawDetails } = room.seatManager.finalizeSeats();
                room.players = newPlayers;
                room.seatManager = null; 

                io.to(roomId).emit('seat_draw_finished', {
                    players: newPlayers,
                    details: drawDetails
                });

                setTimeout(() => handleGameStart(roomId, false), 3000);
            }, 1000); 
        }
    });

    // æ¸¸æˆæµç¨‹
    const handleGameStart = (roomId, isNextRound) => {
        const room = rooms[roomId];
        if (!room) return;

        if (!isNextRound || !room.gameManager) {
            room.gameManager = new GameManager(room.config, room.players, io, roomId);
        }

        const startInfo = room.gameManager.startRound(isNextRound);

        room.players.forEach((p) => {
            if (!p.isBot) { 
                const hand = startInfo.hands[p.id];
                io.to(p.id).emit('game_started', { 
                    hand: hand, 
                    grandScores: room.gameManager.grandScores,
                    handCounts: room.gameManager.getPublicState().handCounts
                });
            }
        });

        const startPlayerName = room.players[startInfo.startPlayerIndex].name;
        const msg = isNextRound 
            ? `æ–°ä¸€è½®å¼€å§‹ï¼ç”± ${startPlayerName} å…ˆå‡º` 
            : `æ¸¸æˆå¼€å§‹ï¼ç›®æ ‡ ${room.config.targetScore} åˆ†`;
        
        broadcastGameState(io, roomId, room, msg);
    };

    socket.on('start_game', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room) return;
        
        // ä¿®æ­£ï¼šå¦‚æœäººæ•°ä¸ºå¥‡æ•°ï¼Œå¼ºåˆ¶å…³é—­ç»„é˜Ÿæ¨¡å¼ï¼Œé˜²æ­¢é€»è¾‘å†²çª
        if (room.config.isTeamMode && room.players.length % 2 !== 0) {
            room.config.isTeamMode = false;
            io.to(roomId).emit('error_msg', 'äººæ•°ä¸ºå¥‡æ•°ï¼Œå·²è‡ªåŠ¨å…³é—­ç»„é˜Ÿæ¨¡å¼');
            broadcastRoomInfo(io, roomId); // å¹¿æ’­é…ç½®å˜æ›´
        }

        const isTeamMode = room.config.isTeamMode && (room.players.length % 2 === 0);
        room.seatManager = new SeatManager(io, roomId, room.players, isTeamMode);
        
        io.to(roomId).emit('enter_draw_phase', { totalCards: room.players.length });
        
        const bots = room.players.filter(p => p.isBot);
        bots.forEach((bot, i) => {
            setTimeout(() => {
                if(room.seatManager) {
                    const availableIdx = room.seatManager.pendingIndices[0];
                    if (availableIdx !== undefined) {
                        const res = room.seatManager.playerDraw(bot.id, availableIdx);
                        if(res.success) {
                            io.to(roomId).emit('seat_draw_update', {
                                index: res.cardIndex,
                                val: res.cardVal,
                                playerId: bot.id,
                                name: bot.name
                            });
                            if (res.isFinished) {
                                setTimeout(() => {
                                    const { newPlayers } = room.seatManager.finalizeSeats();
                                    room.players = newPlayers;
                                    room.seatManager = null;
                                    io.to(roomId).emit('seat_draw_finished', { players: newPlayers });
                                    setTimeout(() => handleGameStart(roomId, false), 3000);
                                }, 1000);
                            }
                        }
                    }
                }
            }, 1000 + i * 1500); 
        });
    });

    socket.on('next_round', ({ roomId }) => handleGameStart(roomId, true));

    socket.on('play_cards', ({ roomId, cards }) => {
        const room = rooms[roomId];
        if (!room || !room.gameManager) return;
        
        const result = room.gameManager.playCards(socket.id, cards);

        if (!result.success) return socket.emit('play_error', result.error);

        const currentHand = room.gameManager.gameState.hands[socket.id];
        io.to(socket.id).emit('hand_update', currentHand);

        if (result.isRoundOver) { 
            const rInfo = result.roundResult;
            if (rInfo.isGrandOver) {
                io.to(roomId).emit('grand_game_over', { 
                    grandWinner: rInfo.roundWinnerName, 
                    grandScores: rInfo.grandScores 
                });
                room.gameManager = null; 
            } else {
                io.to(roomId).emit('round_over', {
                    roundWinner: rInfo.roundWinnerName,
                    pointsEarned: rInfo.pointsEarned,
                    detail: rInfo.detail,
                    grandScores: rInfo.grandScores
                });
            }
        } else {
            broadcastGameState(io, roomId, room, result.logText);
        }
    });

       socket.on('pass_turn', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room || !room.gameManager) return;

        const result = room.gameManager.passTurn(socket.id);
        if (!result.success) return socket.emit('play_error', result.error);

        broadcastGameState(io, roomId, room, result.logText || "PASS");
    });

    // [æ–°å¢] æç¤ºè¯·æ±‚ç›‘å¬
    socket.on('request_hint', ({ roomId }) => {
    const room = rooms[roomId];
    if (room && room.gameManager) {
        // è°ƒç”¨ GameManager çš„ getHint æ–¹æ³•
        const cards = room.gameManager.getHint(socket.id);
        // å‘é€å›ç»™å®¢æˆ·ç«¯
        socket.emit('hint_response', cards);
    }
});


    socket.on('disconnect', () => {
        Object.keys(rooms).forEach(rId => {
            const r = rooms[rId];
            
            const idx = r.players.findIndex(p => p.id === socket.id);
            if (idx === -1) return; 

            const player = r.players[idx];
            
            // é€»è¾‘åˆ†æ”¯ï¼šå¦‚æœåœ¨å¤§å…é˜¶æ®µ
            if (!r.gameManager && !r.seatManager) {
                r.players.splice(idx, 1);
                console.log(`[Disconnect] Lobby user ${player.name} removed from ${rId}`);
                
                // å¤„ç†æˆ¿ä¸»ç§»äº¤é€»è¾‘
                if (player.isHost && r.players.length > 0) {
                    // ä¼˜å…ˆç§»äº¤ç»™éBotï¼Œå¦‚æœéƒ½æ˜¯Botåˆ™ç»™ç¬¬ä¸€ä¸ª
                    const nextHost = r.players.find(p => !p.isBot) || r.players[0];
                    if (nextHost) nextHost.isHost = true;
                }
                
                if (r.players.length === 0) {
                    if (r.isPermanent) {
                        // å¸¸é©»æˆ¿é—´ï¼šæ— äººæ—¶é‡ç½®é…ç½®ï¼Œä½†ä¸åˆ é™¤
                        initPermanentRoom(rId);
                    } else {
                        // æ™®é€šæˆ¿é—´ï¼šåˆ é™¤
                        if (r.destroyTimer) clearTimeout(r.destroyTimer);
                        delete rooms[rId];
                        console.log(`[Room] Room ${rId} deleted (empty lobby).`);
                    }
                } else {
                    broadcastRoomInfo(io, rId);
                }
            } else {
                // æ¸¸æˆä¸­æ‰çº¿
                player.online = false;
                console.log(`[Disconnect] Game user ${player.name} (${socket.id}) dropped.`);

                const allHumansOffline = r.players.filter(p => !p.isBot).every(p => !p.online);
                
                if (allHumansOffline) {
                    if (r.destroyTimer) clearTimeout(r.destroyTimer);
                    r.destroyTimer = setTimeout(() => {
                        const currentRoom = rooms[rId];
                        // å†æ¬¡æ£€æŸ¥æ˜¯å¦çœŸçš„æ²¡äºº
                        if (currentRoom && currentRoom.players.filter(p => !p.isBot).every(p => !p.online)) {
                            if (currentRoom.isPermanent) {
                                initPermanentRoom(rId); // é‡ç½®
                            } else {
                                delete rooms[rId]; // é”€æ¯
                                console.log(`[Room] Room ${rId} destroyed due to inactivity.`);
                            }
                        }
                    }, 60000); 
                }
            }
        });
    });
});

// è¿™ä¸€æ®µçš„æ„æ€æ˜¯ï¼šå¦‚æœæ˜¯åœ¨çº¿ä¸Šç¯å¢ƒï¼Œå°±æŠŠ React æ‰“åŒ…å¥½çš„æ–‡ä»¶(build)å‘ç»™æµè§ˆå™¨
if (process.env.NODE_ENV === 'production') {
    // 1. æŒ‡å®šé™æ€æ–‡ä»¶ç›®å½•
    const buildPath = path.join(__dirname, '../client/dist');
    app.use(express.static(buildPath));
    // 2. ä»»ä½•å…¶ä»–è¯·æ±‚ï¼Œéƒ½è¿”å› index.html
    app.get(/(.*)/, (req, res) => {
        res.sendFile(path.join(__dirname, '../client/dist', 'index.html'));
    });
}

// å¯åŠ¨æœåŠ¡å™¨
const PORT = process.env.PORT || 3001;
server.listen(PORT, () => {
    console.log(`>>> Server Running on port ${PORT}`);
});

================================================================================
FILE PATH: server\package.json
================================================================================
{
  "name": "server",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^5.2.1",
    "nodemon": "^3.1.11",
    "socket.io": "^4.8.1"
  }
}


================================================================================
FILE PATH: server\utils\socketAuth.js
================================================================================
// (å¯é€‰) èº«ä»½éªŒè¯å·¥å…·
