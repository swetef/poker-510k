Project Context Generated at 2025/12/16 18:56:02


================================================================================
FILE PATH: client\eslint.config.js
================================================================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])


================================================================================
FILE PATH: client\index.html
================================================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    
    <!-- [å…³é”®ä¿®æ”¹] å¢åŠ  viewport-fit=cover è§£å†³é¡¶éƒ¨é»‘è¾¹é—®é¢˜ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    
    <link rel="manifest" href="/manifest.json">
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="510Kå¯¹æˆ˜">
    
    <title>client</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

================================================================================
FILE PATH: client\package.json
================================================================================
{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "lucide-react": "^0.559.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "socket.io-client": "^4.8.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "vite": "npm:rolldown-vite@7.2.5"
  },
  "overrides": {
    "vite": "npm:rolldown-vite@7.2.5"
  }
}


================================================================================
FILE PATH: client\src\App.css
================================================================================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}


================================================================================
FILE PATH: client\src\App.jsx
================================================================================
import React, { useState, useEffect, useRef } from 'react';
import io from 'socket.io-client';
import { Smartphone } from 'lucide-react'; // [æ–°å¢] å›¾æ ‡

import { sortHand } from './utils/cardLogic.js';
import SoundManager from './utils/SoundManager.js';
import { LoginScreen } from './screens/LoginScreen.jsx';
import { LobbyScreen } from './screens/LobbyScreen.jsx';
import { GameScreen } from './screens/GameScreen.jsx';

const getSocketUrl = () => {
    const { hostname, protocol } = window.location;
    const isLocal = hostname === 'localhost' || 
                    hostname === '127.0.0.1' || 
                    hostname.startsWith('192.168.') || 
                    hostname.startsWith('10.');
    if (isLocal) {
        return `${protocol}//${hostname}:3001`;
    }
    return '/';
};

const SOCKET_URL = getSocketUrl();

export default function App() {
  const [gameState, setGameState] = useState('LOGIN'); 
  const [username, setUsername] = useState('');
  const [roomId, setRoomId] = useState('');
  
  const [roomConfig, setRoomConfig] = useState({ 
      deckCount: 2,          
      maxPlayers: 4,         
      targetScore: 1000,     
      turnTimeout: 60000,
      enableRankPenalty: false,    
      rankPenaltyScores: [30, 15]  
  });
  
  const [isCreatorMode, setIsCreatorMode] = useState(false); 

  const [players, setPlayers] = useState([]);     
  const [myHand, setMyHand] = useState([]);       
  const [selectedCards, setSelectedCards] = useState([]); 
  const [lastPlayed, setLastPlayed] = useState([]); 
  const [currentTurnId, setCurrentTurnId] = useState(null); 
  const [lastPlayerName, setLastPlayerName] = useState(''); 
  const [infoMessage, setInfoMessage] = useState(''); 
  
  const [roundResult, setRoundResult] = useState(null); 
  const [grandResult, setGrandResult] = useState(null); 
  const [playerScores, setPlayerScores] = useState({});
  const [playersInfo, setPlayersInfo] = useState({});
  const [finishedRank, setFinishedRank] = useState([]); 
  
  const [pendingPoints, setPendingPoints] = useState(0);
  const [gameLogs, setGameLogs] = useState([]);

  const [sortMode, setSortMode] = useState('POINT'); 
  const [isConnected, setIsConnected] = useState(false); 
  const [mySocketId, setMySocketId] = useState(null);
  const [isLoading, setIsLoading] = useState(false);

  const [turnRemaining, setTurnRemaining] = useState(60); 

  const socketRef = useRef(null);
  const isDragging = useRef(false); 
  const dragStartMode = useRef(true); 
  const sortModeRef = useRef('POINT');
  const usernameRef = useRef(username); 
  const mySocketIdRef = useRef(null);   

  useEffect(() => { usernameRef.current = username; }, [username]);
  useEffect(() => { mySocketIdRef.current = mySocketId; }, [mySocketId]);

  useEffect(() => {
    console.log(`æ­£åœ¨è¿æ¥æœåŠ¡å™¨: ${SOCKET_URL}`);
    
    const socket = io(SOCKET_URL, { 
        reconnectionAttempts: 10,   
        reconnectionDelay: 1000,    
        timeout: 20000,             
        transports: ['websocket', 'polling'] 
    });
    
    socketRef.current = socket;

    const initAudio = () => {
        SoundManager.init();
        window.removeEventListener('click', initAudio);
    };
    window.addEventListener('click', initAudio);

    socket.on('connect', () => {
        console.log("Socket è¿æ¥æˆåŠŸ!");
        setIsConnected(true); 
    });
    
    socket.on('disconnect', () => {
        console.log("Socket æ–­å¼€è¿æ¥");
        setIsConnected(false); 
    });
    
    socket.on('connect_error', (err) => {
        console.warn("è¿æ¥é”™è¯¯:", err);
    });

    socket.on('your_id', (id) => {
        setMySocketId(id);
        mySocketIdRef.current = id;
    });
    socket.on('error_msg', (msg) => { setIsLoading(false); alert(msg); });

    socket.on('room_info', (data) => {
        setRoomId(data.roomId);
        setRoomConfig(data.config);
        setPlayers(data.players);
        setGameState('LOBBY'); 
        setIsLoading(false);
    });

    socket.on('game_started', (data) => {
        if (data.hand) {
            setMyHand(sortHand(data.hand, sortModeRef.current));
        }
        setLastPlayed([]);
        setRoundResult(null);
        setGrandResult(null);
        setPendingPoints(0);
        setFinishedRank([]); 
        if (data.grandScores) setPlayerScores(data.grandScores);
        setGameLogs(prev => [...prev, { time: new Date().toLocaleTimeString(), text: 'ğŸ æ–°ä¸€å±€å¼€å§‹ï¼' }]); 
        setGameState('GAME');
        setTurnRemaining(60);
        setPlayersInfo({});
        SoundManager.play('deal');
    });

    socket.on('game_state_update', (data) => {
        setCurrentTurnId(data.currentTurnId);
        
        if (data.turnRemaining !== undefined) {
             setTurnRemaining(data.turnRemaining);
        }

        if (data.lastPlayed && data.lastPlayed.length > 0) {
             SoundManager.play('play'); 
        }

        if (data.lastPlayed) setLastPlayed(sortHand(data.lastPlayed, sortModeRef.current));
        setLastPlayerName(data.lastPlayerName || '');
        
        if (data.infoText && data.infoText !== 'PASS') {
            setInfoMessage(data.infoText); setTimeout(()=>setInfoMessage(''), 2000);
            setGameLogs(prev => [...prev, { time: new Date().toLocaleTimeString(), text: data.infoText }]);
        }
        if (data.scores) setPlayerScores(data.scores);
        if (data.playersInfo) setPlayersInfo(data.playersInfo);
        
        if (data.finishedRank) setFinishedRank(data.finishedRank);

        if (data.pendingPoints !== undefined) setPendingPoints(data.pendingPoints);

        if (data.currentTurnId === mySocketIdRef.current) {
            SoundManager.play('alert');
        }
    });

    socket.on('hand_update', (newHand) => {
        setMyHand(sortHand(newHand, sortModeRef.current)); 
        setSelectedCards([]);
    });

    socket.on('play_error', (msg) => { 
        setInfoMessage(msg); 
        setTimeout(()=>setInfoMessage(''), 2000); 
        SoundManager.play('lose'); 
    }); 
    
    socket.on('round_over', (data) => {
        setRoundResult(data);
        if (data.grandScores) setPlayerScores(data.grandScores);
        const amIWinner = data.roundWinner === usernameRef.current;
        SoundManager.play(amIWinner ? 'win' : 'lose');
    });

    socket.on('grand_game_over', (data) => {
        setGrandResult(data);
        SoundManager.play('win'); 
    });

    const handleGlobalMouseUp = () => { isDragging.current = false; };
    window.addEventListener('mouseup', handleGlobalMouseUp);
    return () => { socket.disconnect(); window.removeEventListener('mouseup', handleGlobalMouseUp); };
  }, []);

  useEffect(() => {
      sortModeRef.current = sortMode;
      if (myHand.length > 0) setMyHand(prev => sortHand(prev, sortMode));
  }, [sortMode]);

  const toggleSort = () => setSortMode(prev => prev === 'POINT' ? 'SUIT' : 'POINT');
  
  const handleRoomAction = () => {
      if (!isConnected) return; 
      if (!username || !roomId) return alert("è¯·è¾“å…¥æ˜µç§°å’Œæˆ¿é—´å·");
      setIsLoading(true);
      const event = isCreatorMode ? 'create_room' : 'join_room';
      const payload = isCreatorMode ? { roomId, username, config: roomConfig } : { roomId, username };
      socketRef.current.emit(event, payload);
  };
  
  const handleStartGame = () => socketRef.current.emit('start_game', { roomId });
  const handleNextRound = () => socketRef.current.emit('next_round', { roomId });
  const handleAddBot = () => socketRef.current.emit('add_bot', { roomId });
  
  const handleToggleAutoPlay = () => socketRef.current.emit('toggle_auto_play', { roomId });

  const updateSelection = (cardVal, forceSelect = null) => {
    setSelectedCards(prev => {
        const isSelected = prev.includes(cardVal);
        if (forceSelect !== null) return forceSelect && !isSelected ? [...prev, cardVal] : (!forceSelect && isSelected ? prev.filter(c => c !== cardVal) : prev);
        return isSelected ? prev.filter(c => c !== cardVal) : [...prev, cardVal];
    });
  };

  const handleMouseDown = (cardVal) => {
    isDragging.current = true;
    dragStartMode.current = !selectedCards.includes(cardVal); 
    updateSelection(cardVal, dragStartMode.current);
    SoundManager.play('deal'); 
  };
  
  const handleMouseEnter = (cardVal) => {
    if (isDragging.current) {
        updateSelection(cardVal, dragStartMode.current);
    }
  };

  const handlePlayCards = () => {
    if (selectedCards.length === 0) return alert("è¯·å…ˆé€‰ç‰Œ");
    socketRef.current.emit('play_cards', { roomId, cards: selectedCards });
  };
  
  const handlePass = () => {
    socketRef.current.emit('pass_turn', { roomId });
    setSelectedCards([]);
  };

  // --- Render Helpers ---

  // æ¨ªå±å¼•å¯¼å±‚
  const renderLandscapeHint = () => (
      <div className="landscape-hint">
          <div className="phone-rotate-icon"></div>
          <h3 style={{marginBottom: 10, fontSize: 18}}>å»ºè®®ä½¿ç”¨æ¨ªå±æ¸¸ç©</h3>
          <p style={{fontSize: 14, opacity: 0.8, maxWidth: 250}}>
              510K éœ€è¦è¾ƒå¤§çš„å±•ç¤ºç©ºé—´ã€‚<br/>
              è¯·æ—‹è½¬æ‚¨çš„æ‰‹æœºä»¥è·å¾—æœ€ä½³ä½“éªŒã€‚
          </p>
          <button 
            style={{marginTop: 20, padding: '8px 20px', background: 'rgba(255,255,255,0.2)', color:'white', border:'1px solid white'}}
            onClick={(e) => { e.currentTarget.parentElement.style.display = 'none'; }}
          >
              æˆ‘éè¦ç«–å±ç©
          </button>
      </div>
  );

  return (
    <>
      {renderLandscapeHint()}
      
      {gameState === 'LOGIN' && <LoginScreen {...{
          username, setUsername, 
          roomId, setRoomId, 
          roomConfig, setRoomConfig, 
          isCreatorMode, setIsCreatorMode, 
          handleRoomAction, 
          isLoading,
          isConnected 
      }} />}
      
      {gameState === 'LOBBY' && <LobbyScreen {...{
          roomId, roomConfig, players, mySocketId, 
          handleStartGame, 
          handleAddBot 
      }} />}
      
      {gameState === 'GAME' && <GameScreen {...{
          roomId, players, myHand, selectedCards, lastPlayed, lastPlayerName, currentTurnId, 
          infoMessage, winner: null, playerScores, playersInfo, pendingPoints, gameLogs, sortMode, 
          mySocketId, roundResult, grandResult, roomConfig,
          turnRemaining, finishedRank,
          toggleSort, handleMouseDown, handleMouseEnter, handlePlayCards, handlePass, handleNextRound, handleStartGame,
          handleToggleAutoPlay 
      }} />}
    </>
  );
}

================================================================================
FILE PATH: client\src\components\BaseUI.jsx
================================================================================
// åŸºç¡€UIç»„ä»¶ - ä¿®å¤ç§»åŠ¨ç«¯ç‚¹å‡»æ— æ•ˆã€åŒé‡è§¦å‘é—®é¢˜
import React, { useEffect, useRef } from 'react';
import { Coins, History, Trophy, Flag } from 'lucide-react'; 
import { getCardDisplay } from '../utils/cardLogic';
import { styles } from '../styles';
import CountDownTimer from './CountDownTimer'; 

export const Card = ({ cardVal, index, isSelected, onClick, onMouseEnter, spacing }) => {
    const { suit, text, color, isScore } = getCardDisplay(cardVal);
    
    // [å…³é”®ä¿®å¤] ä½¿ç”¨ Pointer Events ä»£æ›¿ Touch/Mouse äº‹ä»¶
    // PointerDown èƒ½åŒæ—¶å“åº”é¼ æ ‡æŒ‰ä¸‹å’Œæ‰‹æŒ‡æŒ‰ä¸‹ï¼Œä¸”å“åº”é€Ÿåº¦å¿«ï¼Œæ—  300ms å»¶è¿Ÿ
    const handlePointerDown = (e) => {
        // åªæœ‰å·¦é”®ç‚¹å‡»(0)æˆ–è§¦æ‘¸æ—¶è§¦å‘
        if (e.button !== 0 && e.pointerType === 'mouse') return;
        
        // é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œé˜²æ­¢è§¦å‘åç»­çš„å…¼å®¹æ€§é¼ æ ‡äº‹ä»¶
        // ä½†æ³¨æ„ï¼šåœ¨æŸäº›æµè§ˆå™¨ä¸­è¿™å¯èƒ½é˜»æ­¢æ»šåŠ¨ï¼Œæ‰€ä»¥ CSS çš„ touch-action: none é…åˆå¾ˆé‡è¦
        // e.preventDefault(); 
        e.stopPropagation();
        
        // å¦‚æœæ˜¯è§¦æ‘¸è®¾å¤‡ï¼Œç›´æ¥ç”±è¿™é‡Œè§¦å‘ç‚¹å‡»é€»è¾‘
        onClick(cardVal);
    };

    return (
        <div 
            // ç§»é™¤ onTouchStart å’Œ onMouseDownï¼Œç»Ÿä¸€ä½¿ç”¨ onPointerDown
            onPointerDown={handlePointerDown}
            
            // ä¿ç•™ MouseEnter ç”¨äº PC ç«¯æ‹–æ‹½æ»‘é€‰ï¼ˆç§»åŠ¨ç«¯ä¸æ”¯æŒ hover æ‰€ä»¥ä¸ä¼šè§¦å‘ï¼‰
            onMouseEnter={(e) => {
                if (e.pointerType === 'mouse') {
                     onMouseEnter(cardVal);
                }
            }}
            
            style={{
                ...styles.card, 
                color, 
                left: index * spacing, 
                zIndex: index,
                // [ä¼˜åŒ–] é€‰ä¸­æ—¶ä¸Šæµ®é«˜åº¦å¢åŠ ï¼Œæ‰‹æœºä¸Šæ›´å®¹æ˜“çœ‹æ¸…
                transform: isSelected ? 'translateY(-45px)' : 'translateY(0)',
                borderColor: isSelected ? '#3498db' : (isScore ? '#f1c40f' : '#bdc3c7'),
                boxShadow: isSelected ? '0 0 15px rgba(52, 152, 219, 0.6)' : (isScore ? '0 0 8px rgba(241, 196, 15, 0.4)' : '0 -2px 5px rgba(0,0,0,0.1)'),
                // ç¡®ä¿ç§»åŠ¨ç«¯å¯ä»¥æ¥æ”¶ Pointer äº‹ä»¶
                touchAction: 'none' 
            }}
        >
            <div style={{fontSize: 18, fontWeight: 'bold'}}>{text}</div>
            <div style={{fontSize: 36, alignSelf: 'center', marginTop: 5}}>{suit}</div>
            {isScore && <div style={{position:'absolute', bottom:2, right:2, fontSize:14, color:'#f1c40f'}}>â˜…</div>}
        </div>
    );
};

export const MiniCard = ({ cardVal, index }) => {
    const { text, suit, color, isScore } = getCardDisplay(cardVal);
    return (
        <div style={{
            ...styles.miniCard, color,
            border: isScore ? '2px solid #f1c40f' : '1px solid #ccc',
            transform: isScore ? 'scale(1.1) translateY(-10px)' : 'scale(1)',
            zIndex: index
        }}>
            {suit}{text}
        </div>
    );
};

export const PlayerAvatar = ({ player, isTurn, score, targetScore, isMySocket, remainingSeconds, rank }) => {
    const progress = Math.min((score / targetScore) * 100, 100);
    const containerOpacity = rank ? 0.75 : 1; 

    return (
        <div style={{
            ...styles.playerBox,
            borderColor: isTurn ? '#f1c40f' : 'rgba(255,255,255,0.1)',
            transform: isTurn ? 'scale(1.1)' : 'scale(1)',
            boxShadow: isTurn ? '0 0 25px rgba(241, 196, 15, 0.5)' : 'none',
            background: isTurn ? 'rgba(44, 62, 80, 0.9)' : 'rgba(44, 62, 80, 0.6)',
            position: 'relative',
            opacity: containerOpacity
        }}>
            {rank && (
                <div style={{
                    position: 'absolute',
                    top: -15,
                    left: '50%',
                    transform: 'translateX(-50%)',
                    background: rank === 1 ? '#f1c40f' : (rank === 2 ? '#bdc3c7' : '#e67e22'), 
                    color: '#fff',
                    padding: '3px 12px',
                    borderRadius: 20,
                    fontSize: 13,
                    fontWeight: 'bold',
                    boxShadow: '0 4px 10px rgba(0,0,0,0.4)',
                    zIndex: 20,
                    display: 'flex',
                    alignItems: 'center',
                    gap: 4,
                    whiteSpace: 'nowrap',
                    border: '2px solid white'
                }}>
                    {rank === 1 ? <Trophy size={14} fill="white" /> : <Flag size={14} fill="white"/>}
                    {rank === 1 ? 'NO.1' : `NO.${rank}`}
                </div>
            )}

            <div style={styles.avatar}>{player.name[0]}</div>
            <div style={styles.playerName}>{player.name} {isMySocket && '(æˆ‘)'}</div>
            <div style={styles.scoreBarBg}>
                <div style={{...styles.scoreBarFill, width:`${progress}%`, background: progress>=100?'#e74c3c':'#2ecc71'}}></div>
            </div>
            <div style={styles.playerScore}><Coins size={12} color="#f1c40f"/> {score} / {targetScore}</div>
            
            {isTurn && !rank && (
                <CountDownTimer 
                    initialSeconds={remainingSeconds} 
                    totalSeconds={60} 
                />
            )}
        </div>
    );
};

export const GameLogPanel = ({ logs }) => {
    const endRef = useRef(null);
    useEffect(() => { endRef.current?.scrollIntoView({ behavior: 'smooth' }); }, [logs]);

    return (
        <div style={styles.gameLogPanel}>
            <div style={styles.logHeader}>
                <History size={16} color="#f1c40f"/> <span style={{color:'#fff', fontWeight:'bold'}}>å¯¹å±€è®°å½•</span>
            </div>
            <div style={styles.logList}>
                {logs.map((log, i) => (
                    <div key={i} style={styles.logItem}>
                        <span style={styles.logTime}>[{log.time.split(' ')[0]}]</span>
                        <span style={{color: '#eee'}}>{log.text}</span>
                    </div>
                ))}
                <div ref={endRef} />
            </div>
        </div>
    );
};


================================================================================
FILE PATH: client\src\components\CountDownTimer.jsx
================================================================================
import React, { useState, useEffect } from 'react';
import { Clock } from 'lucide-react';

const CountDownTimer = ({ initialSeconds, totalSeconds = 60 }) => {
    const [seconds, setSeconds] = useState(initialSeconds);

    useEffect(() => {
        setSeconds(initialSeconds);
    }, [initialSeconds]);

    useEffect(() => {
        if (seconds <= 0) return;
        const timerId = setInterval(() => {
            setSeconds((prev) => Math.max(0, prev - 1));
        }, 1000);
        return () => clearInterval(timerId);
    }, [seconds]);

    const isUrgent = seconds <= 10;
    const color = isUrgent ? '#ff4d4d' : '#ffffff';
    const bgColor = isUrgent ? 'rgba(231, 76, 60, 0.9)' : 'rgba(0, 0, 0, 0.7)';

    return (
        <div style={{
            position: 'absolute',
            // [ä¿®æ”¹] æ˜¾ç¤ºåœ¨å¤´é¡¶ä¸Šæ–¹ï¼Œé¿å¼€ä¸‹æ–¹å†…å®¹
            top: -60, 
            left: '50%',
            transform: 'translateX(-50%)',
            
            // æ ·å¼è°ƒæ•´ï¼šæ°”æ³¡é£æ ¼
            background: bgColor,
            padding: '4px 12px',
            borderRadius: 20,
            display: 'flex',
            alignItems: 'center',
            gap: 5,
            whiteSpace: 'nowrap',
            boxShadow: '0 4px 10px rgba(0,0,0,0.3)',
            border: '1px solid rgba(255,255,255,0.2)',
            zIndex: 30,
            transition: 'all 0.3s'
        }}>
            <Clock size={14} color={color} className={isUrgent ? 'spin' : ''} />
            <span style={{ 
                color: color, 
                fontWeight: 'bold', 
                fontSize: 16,
                fontFamily: 'monospace'
            }}>
                {seconds}s
            </span>
            
            <style>{`
                .spin { animation: spin 1s linear infinite; }
            `}</style>
        </div>
    );
};

export default CountDownTimer;

================================================================================
FILE PATH: client\src\index.css
================================================================================
/* =========================================
   å…¨å±€åŸºç¡€æ ·å¼ (Base & Reset)
   ========================================= */
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  /* é…è‰²æ–¹æ¡ˆ */
  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  /* å­—ä½“æ¸²æŸ“ä¼˜åŒ– */
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  
  /* [ä¼˜åŒ–] ç¦æ­¢ç§»åŠ¨ç«¯ç‚¹å‡»é«˜äº® */
  -webkit-tap-highlight-color: transparent; 
}

/* é“¾æ¥æ ·å¼ */
a { font-weight: 500; color: #646cff; text-decoration: inherit; }
a:hover { color: #535bf2; }

/* Body åŸºç¡€è®¾ç½® */
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  /* [å…³é”®ä¿®å¤] å½»åº•ç¦æ­¢æµè§ˆå™¨çš„ä¸‹æ‹‰åˆ·æ–°å’Œå›å¼¹æ•ˆæœ */
  overscroll-behavior: none;
  overflow: hidden; /* é”æ­» Body æ»šåŠ¨ï¼Œåªå…è®¸å†…éƒ¨å…ƒç´ æ»šåŠ¨ */
  position: fixed;  /* å¼ºåˆ¶å›ºå®šï¼Œé˜²æ­¢ iOS Safari åœ°å€æ å› ä¸ºé¡µé¢æ»šåŠ¨è€Œå¿½éšå¿½ç° */
}

body {
  display: flex;
  place-items: center;
  min-width: 320px;
}

/* [ä¼˜åŒ–] é’ˆå¯¹æ ¹å®¹å™¨ä¼˜åŒ–è§¦æ‘¸ä½“éªŒ */
#root, .App {
  width: 100%;
  height: 100%;
  overflow-x: hidden;
  /* å…è®¸å†…éƒ¨æ­£å¸¸çš„ç‚¹å‡»å’Œæ»šåŠ¨ */
  touch-action: manipulation;
}

h1 { font-size: 3.2em; line-height: 1.1; }

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover { border-color: #646cff; }
button:focus, button:focus-visible { outline: 4px auto -webkit-focus-ring-color; }

@media (prefers-color-scheme: light) {
  :root { color: #213547; background-color: #ffffff; }
  a:hover { color: #747bff; }
  button { background-color: #f9f9f9; }
}


/* =========================================
   ç§»åŠ¨ç«¯é€‚é…æ ¸å¿ƒåŒº (Mobile Overrides)
   ========================================= */

/* --- 1. æ¨ªå±å¼•å¯¼é®ç½© --- */
.landscape-hint {
    display: none; 
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(30, 39, 46, 0.95);
    z-index: 9999; 
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
    text-align: center;
    backdrop-filter: blur(10px);
    touch-action: none; 
}

.phone-rotate-icon {
    width: 60px; height: 100px; 
    border: 3px solid white; border-radius: 10px; margin-bottom: 20px;
    animation: rotate-phone 2s infinite ease-in-out;
}
@keyframes rotate-phone {
    0% { transform: rotate(0deg); }
    50% { transform: rotate(90deg); }
    100% { transform: rotate(0deg); }
}


/* --- 2. ç§»åŠ¨ç«¯ç«–å±å¸ƒå±€ä¼˜åŒ– (Portrait Core) --- */

@media (max-width: 768px) {
  
  ::-webkit-scrollbar { width: 0px; background: transparent; }

  /* é€šç”¨åˆ—å®¹å™¨ */
  .mobile-layout-column {
    display: flex !important;
    flex-direction: column !important;
    width: 95% !important;     
    max-width: none !important; 
    height: auto !important;
    
    /* ä½¿ç”¨ dvh é€‚é…åŠ¨æ€åœ°å€æ  */
    min-height: 85vh !important; 
    min-height: 85dvh !important; 
    
    max-height: 95dvh !important; 
    margin: 10px auto !important; 
    overflow: hidden !important; 
    padding: 0 !important;      
  }

  /* --- 2.1 ç™»å½•é¡µ (Login) --- */
  .mobile-login-left {
    flex: 0 0 auto !important; 
    width: 100% !important;
    padding: 30px 20px !important; 
    border-radius: 0 0 24px 24px !important; 
    background-color: #242424; 
    min-height: auto !important;
    align-items: center !important; 
    text-align: center !important;
    padding-top: max(30px, env(safe-area-inset-top)) !important;
  }
  
  .mobile-login-left h1 { font-size: 2.5em !important; margin-bottom: 10px !important; }
  .mobile-login-left .logoCircle { width: 70px !important; height: 70px !important; margin-bottom: 15px !important; }
  .mobile-login-left .logoText { font-size: 22px !important; }

  .mobile-login-right {
    flex: 1 !important; 
    width: 100% !important;
    padding: 30px 20px !important;
    background: white;
    border-radius: 24px 24px 0 0 !important; 
    margin-top: -20px; 
    position: relative;
    z-index: 2;
    overflow-y: auto !important;
    display: flex !important;
    flex-direction: column !important;
    padding-bottom: max(30px, env(safe-area-inset-bottom)) !important;
  }
  
  .hide-on-mobile { display: none !important; }


  /* --- 2.2 å¤§å…é¡µ (Lobby) --- */
  .lobbyCard.mobile-layout-column {
      height: 92dvh !important; 
      position: relative;
      background: white !important;
  }

  .mobile-lobby-content {
      display: flex !important;
      flex-direction: column !important;
      height: 100% !important;
      width: 100%;
      overflow: hidden !important;
  }
  
  .lobbyHeader { 
      flex: 0 0 auto;
      padding: 15px !important;
      padding-top: calc(15px + env(safe-area-inset-top)) !important; 
      background: #f8f9fa; 
  }
  .lobbyHeader h2 { font-size: 20px !important; margin: 0 !important; }

  .mobile-lobby-grid {
      flex: 1 !important; 
      overflow-y: auto !important; 
      padding: 10px !important;
      display: grid !important;
      grid-template-columns: repeat(2, 1fr) !important; 
      align-content: start !important;
      gap: 10px !important;
      -webkit-overflow-scrolling: touch; 
      padding-bottom: 100px !important; 
  }
  
  .mobile-lobby-grid > div { padding: 15px !important; gap: 10px !important; }
  .mobile-lobby-grid .avatar-large { width: 50px !important; height: 50px !important; font-size: 20px !important; }

  .mobile-lobby-footer {
      flex: 0 0 auto !important;
      padding: 12px !important;
      background: white;
      border-top: 1px solid #eee;
      z-index: 10;
      padding-bottom: calc(12px + env(safe-area-inset-bottom)) !important; 
      position: absolute; 
      bottom: 0; left: 0; right: 0;
      display: flex !important;
      justify-content: space-around !important;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
  }
  
  .mobile-lobby-footer button {
      width: 45% !important;
      padding: 0 !important;
      height: 44px !important; 
      font-size: 14px !important;
      margin: 0 !important;
  }


  /* --- 2.3 æ¸¸æˆé¡µ (Game Table) --- */
  
  /* å¼¹çª—é€‚é… */
  .modal-content-wrapper {
      padding: 24px !important; 
      width: 85% !important;    
      max-width: 340px !important;
      border-radius: 20px !important;
      z-index: 1000 !important; 
  }
  .modal-content-wrapper h2 { font-size: 22px !important; }
  .modal-content-wrapper div { font-size: 15px !important; line-height: 1.6 !important; }
  
  .gameLogPanel { display: none !important; }
  
  /* é¡¶éƒ¨ä¿¡æ¯æ  */
  .tableHeader { 
      padding: 10px !important; 
      padding-top: calc(10px + env(safe-area-inset-top)) !important; 
      z-index: 50;
      /* ç¡®ä¿é¡¶éƒ¨æ ä¸è¢«é®æŒ¡ */
      position: absolute;
      top: 0; width: 100%;
  }
  .tableHeader .roomBadge { padding: 4px 10px !important; font-size: 12px !important; }
  .tableHeader .scoreBoard { padding: 5px 15px !important; top: 60px !important; } 
  .tableHeader .scoreBoard div:first-child { display: none; } 
  
  /* [ä¼˜åŒ–] ç©å®¶åŒºåŸŸä½ç½®è°ƒæ•´ */
  .mobile-players-area {
    /* å‡å°‘ padding-topï¼Œç»™ä¸­é—´è…¾å‡ºç©ºé—´ */
    padding-top: 65px !important; 
    margin-bottom: 0 !important;
    gap: 8px !important;
    width: 100% !important;
    justify-content: center !important;
    z-index: 40;
    /* ç¡®ä¿ç©å®¶å¤´åƒåœ¨å‡ºç‰Œä¸‹æ–¹ï¼ˆå¦‚æœä¸å°å¿ƒé‡å ï¼‰ï¼Œä½†åœ¨èƒŒæ™¯ä¸Šæ–¹ */
    position: relative;
  }
  
  /* ç©å®¶å¤´åƒå¾®è°ƒ */
  .mobile-avatar-scale .playerBox { 
      padding: 5px !important; min-width: 60px !important; background: rgba(0,0,0,0.5) !important;
  }
  .mobile-avatar-scale .avatar { 
      width: 40px !important; height: 40px !important; line-height: 40px !important; font-size: 14px !important; 
  }
  
  /* [æ ¸å¿ƒä¿®å¤] æ¡Œé¢å‡ºç‰ŒåŒºåŸŸä½ç½®è°ƒæ•´ */
  .mobile-table-center {
    display: flex !important;
    align-items: center !important; 
    justify-content: center !important;
    width: 100% !important;
    position: absolute !important;
    /* [ä¿®æ”¹] ä» 42% ä¸Šç§»åˆ° 38%ï¼Œé˜²æ­¢è¢«åº•éƒ¨æ‰‹ç‰Œé®æŒ¡ */
    top: 38% !important; 
    transform: translateY(-50%);
    padding: 0 !important; 
    margin: 0 !important;
    /* [ä¿®æ”¹] æé«˜å±‚çº§ï¼Œç¡®ä¿ä¸è¢«ä¾§è¾¹ç©å®¶é®æŒ¡ */
    z-index: 30 !important; 
    pointer-events: none; 
  }
  .mobile-table-center > * {
      pointer-events: auto; 
  }
  
  .mobile-table-center .mini-card {
      padding: 8px 12px !important;
      font-size: 20px !important;
      min-width: 36px !important;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  }

  /* [æ ¸å¿ƒ] æ‰‹ç‰ŒåŒºåŸŸ */
  .mobile-hand-area {
    width: 100% !important;
    position: fixed !important; 
    bottom: 0 !important;
    padding-bottom: calc(10px + env(safe-area-inset-bottom)) !important;
    /* [ä¿®æ”¹] é«˜åº¦ç¨å¾®å‡å°ä¸€ç‚¹ç‚¹ï¼Œç•™ç»™æ¡Œé¢æ›´å¤šç©ºé—´ */
    height: 145px !important; 
    background: linear-gradient(to top, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.6) 60%, transparent 100%) !important;
    z-index: 100 !important;
    touch-action: none;
    display: flex;
    justify-content: center;
    align-items: flex-end;
  }
  
  /* æ“ä½œæ  */
  .action-bar-container {
      position: fixed !important;
      bottom: calc(150px + env(safe-area-inset-bottom)) !important;
      left: 0; right: 0;
      height: 60px !important;
      background: none !important;
      z-index: 110 !important; 
      display: flex;
      justify-content: center;
      gap: 20px;
      pointer-events: none; 
  }
  .action-bar-container button {
      pointer-events: auto; 
      padding: 0 32px !important;
      font-size: 16px !important;
      height: 48px !important;
      border-radius: 24px !important; 
      box-shadow: 0 4px 12px rgba(0,0,0,0.4) !important;
      background-color: #646cff !important; 
      color: white !important;
      border: 2px solid rgba(255,255,255,0.2) !important;
  }
  .action-bar-container button:disabled {
      background-color: #555 !important;
      opacity: 0.6;
  }
}


/* --- 3. ç§»åŠ¨ç«¯æ¨ªå±é€‚é… (Landscape Overrides) --- */
@media (max-width: 896px) and (orientation: landscape) {
    
    .mobile-layout-column {
        flex-direction: row !important;
        height: 100dvh !important; 
        max-height: none !important;
        width: 100% !important;
        margin: 0 !important;
        padding-left: max(15px, env(safe-area-inset-left)) !important; 
        padding-right: max(15px, env(safe-area-inset-right)) !important; 
    }

    .mobile-login-left { 
        width: 240px !important; flex: 0 0 240px !important; 
        height: 100% !important; border-radius: 0 !important; 
        justify-content: center !important;
        padding-top: 0 !important;
    }
    .mobile-login-right { 
        border-radius: 0 !important; margin-top: 0 !important; 
        justify-content: center !important; 
        padding-bottom: 20px !important;
    }

    .mobile-players-area {
      padding-top: 10px !important;
      flex-wrap: nowrap !important;
      justify-content: flex-start !important;
      overflow-x: auto !important;
      gap: 15px !important;
      scrollbar-width: none; 
    }
    
    .mobile-table-center {
        top: 50% !important;
    }
    
    .mobile-hand-area {
        height: 100px !important;
        padding-bottom: 5px !important;
    }
    
    .action-bar-container {
        bottom: 110px !important;
    }
}


================================================================================
FILE PATH: client\src\main.jsx
================================================================================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)


================================================================================
FILE PATH: client\src\screens\GameScreen.jsx
================================================================================
// æ¸¸æˆä¸»ç•Œé¢ - æ·±åº¦é€‚é…ç§»åŠ¨ç«¯å¸ƒå±€ï¼Œå¢åŠ äº†å…¨å±æŒ‰é’®
import React, { useState } from 'react';
import { Coins, Layers, Crown, Clock, Bot, Zap, Maximize, Minimize } from 'lucide-react';
import { styles } from '../styles.js'; 
import { Card, MiniCard, PlayerAvatar, GameLogPanel } from '../components/BaseUI.jsx';
import { calculateCardSpacing } from '../utils/cardLogic.js';

export const GameScreen = ({ 
    roomId, players, myHand, selectedCards, lastPlayed, lastPlayerName, currentTurnId, 
    infoMessage, winner, playerScores, playersInfo, pendingPoints, gameLogs, sortMode,
    mySocketId, roundResult, grandResult, roomConfig,
    turnRemaining, finishedRank = [], 
    toggleSort, handleMouseDown, handleMouseEnter, handlePlayCards, handlePass, handleNextRound, handleStartGame,
    handleToggleAutoPlay 
}) => {
    const isMyTurn = currentTurnId === mySocketId;
    const amIHost = players.find(p => p.id === mySocketId)?.isHost;
    const cardSpacing = calculateCardSpacing(myHand.length, window.innerWidth);
    
    const myInfo = (playersInfo && playersInfo[mySocketId]) || {};
    const amIAutoPlay = myInfo.isAutoPlay;

    const isCrowded = players.length > 6;
    const avatarScale = isCrowded ? 0.85 : 1;
    const avatarStyleOverride = isCrowded ? { transform: `scale(${avatarScale})`, margin: -5 } : {};

    // [æ–°å¢] å…¨å±çŠ¶æ€æ§åˆ¶
    const [isFullScreen, setIsFullScreen] = useState(false);

    // [æ–°å¢] åˆ‡æ¢å…¨å±é€»è¾‘
    const toggleFullScreen = () => {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen()
                .then(() => setIsFullScreen(true))
                .catch(err => {
                    console.error("å…¨å±å¯ç”¨å¤±è´¥:", err);
                    // å¾ˆå¤š iPhone ä¸æ”¯æŒ requestFullscreenï¼Œè¿™é‡Œå¯ä»¥ç»™ä¸ªæç¤ºæˆ–è€…é™é»˜å¤±è´¥
                    // ä½†æœ‰äº† PWA æ–¹æ¡ˆä½œä¸ºåå¤‡ï¼Œè¿™é‡Œé™é»˜å³å¯
                });
        } else {
            document.exitFullscreen()
                .then(() => setIsFullScreen(false))
                .catch(err => console.error(err));
        }
    };

    return (
        <div style={styles.gameTable} onMouseUp={() => { /* Global Mouse Up Handled in App */ }}>
            <div className="gameLogPanel">
                 <GameLogPanel logs={gameLogs} />
            </div>

            <div style={styles.tableHeader}>
                <div style={styles.roomBadge}>Room {roomId}</div>
                <div style={styles.scoreBoard}>
                    <div style={{fontSize: 12, opacity: 0.8, textTransform:'uppercase'}}>Table Points</div>
                    <div style={{fontSize: 32, fontWeight: 'bold', color: '#f1c40f', display:'flex', alignItems:'center', gap:8}}><Coins size={28} /> {pendingPoints}</div>
                </div>
                
                {/* [ä¿®æ”¹] å³ä¸Šè§’æŒ‰é’®ç»„ */}
                <div style={{display:'flex', gap: 10}}>
                    {/* [æ–°å¢] å…¨å±æŒ‰é’® */}
                    <button 
                        style={{...styles.glassButton, padding: '8px 12px'}} 
                        onClick={toggleFullScreen}
                        title={isFullScreen ? "é€€å‡ºå…¨å±" : "è¿›å…¥å…¨å±"}
                    >
                        {isFullScreen ? <Minimize size={18}/> : <Maximize size={18}/>}
                    </button>

                    <button style={styles.sortButton} onClick={toggleSort}>
                        <Layers size={16} style={{marginRight:5}}/> {sortMode === 'POINT' ? 'ç‚¹æ•°' : 'èŠ±è‰²'}
                    </button>
                </div>
            </div>

            <div style={styles.infoMessage}>{infoMessage}</div>

            {/* å¼¹çª—åŒºåŸŸ */}
            {(winner || roundResult || grandResult) && (
                <div style={styles.modalOverlay}>
                    {className="modal-content-wrapper"}    
                    <div style={styles.modalContent}>
                        {grandResult ? (
                            <>
                                <Crown size={80} color="#e74c3c" style={{marginBottom: 20}} />
                                <h2 style={{fontSize: 32, marginBottom: 10, color:'#2c3e50'}}>æœ€ç»ˆå† å†›: {grandResult.grandWinner}</h2>
                                <button style={{...styles.primaryButton, fontSize: 18}} onClick={handleStartGame}>é‡æ–°å¼€å§‹</button>
                            </>
                        ) : roundResult ? (
                            <>
                                <Coins size={60} color="#f1c40f" style={{marginBottom: 20}} />
                                <h2 style={{fontSize: 28}}>å°å±€ç»“æŸ</h2>
                                <div style={{fontSize: 20}}>èƒœè€…: <span style={{color:'#27ae60'}}>{roundResult.roundWinner}</span></div>
                                <div style={{fontSize: 32, fontWeight:'bold', color:'#f1c40f', margin:'10px 0'}}>+{roundResult.pointsEarned} åˆ†</div>
                                
                                <div style={{
                                    color:'#666', fontSize:14, marginBottom:30, 
                                    whiteSpace: 'pre-wrap', lineHeight: '1.6', 
                                    maxHeight: 200, overflowY: 'auto', textAlign: 'left',
                                    background: '#f8f9fa', padding: 15, borderRadius: 8
                                }}>
                                    {roundResult.detail}
                                </div>

                                {amIHost ? <button style={styles.primaryButton} onClick={handleNextRound}>ä¸‹ä¸€å±€</button> : <div style={{color:'#999'}}>ç­‰å¾…æˆ¿ä¸»...</div>}
                            </>
                        ) : null}
                    </div>
                </div>
            )}

            <div style={styles.tableCenter} className="mobile-table-center">
                {lastPlayed.length > 0 && (
                    <div style={{animation: 'popIn 0.3s'}}>
                        <div style={styles.playerNameTag}>{lastPlayerName}</div>
                        <div style={styles.playedRow} className="mini-card-container"> 
                            {lastPlayed.map((c, i) => <MiniCard key={i} cardVal={c} index={i} />)}
                        </div>
                    </div>
                )}
            </div>

            <div style={styles.playersArea} className="mobile-players-area">
                {players.map((p, i) => {
                    const info = (playersInfo && playersInfo[p.id]) || {};
                    const isBot = info.isBot || p.isBot;
                    const isAuto = info.isAutoPlay;
                    const rankIndex = finishedRank ? finishedRank.indexOf(p.id) : -1;
                    const finishedRankVal = rankIndex !== -1 ? rankIndex + 1 : null;

                    return (
                        <div key={i} style={{...avatarStyleOverride, position:'relative'}} className="mobile-avatar-scale"> 
                            <PlayerAvatar 
                                player={p} 
                                isTurn={p.id === currentTurnId} 
                                score={playerScores[p.id] || 0} 
                                targetScore={roomConfig.targetScore} 
                                isMySocket={p.id === mySocketId}
                                remainingSeconds={turnRemaining}
                                rank={finishedRankVal}
                            />
                            <div style={{position: 'absolute', top: -10, right: -10, display: 'flex', gap: 5}}>
                                {isBot && <div style={styles.statusBadgeBot}><Bot size={12}/> AI</div>}
                                {isAuto && <div style={styles.statusBadgeAuto}><Zap size={12}/> æ‰˜ç®¡</div>}
                            </div>
                        </div>
                    );
                })}
            </div>

            <div 
                style={{
                    ...styles.handArea, 
                    opacity: amIAutoPlay ? 0.6 : 1, 
                    filter: amIAutoPlay ? 'grayscale(0.6)' : 'none',
                    pointerEvents: amIAutoPlay ? 'none' : 'auto' 
                }}
                className="mobile-hand-area"
            >
                {amIAutoPlay && (
                    <div style={{
                        position: 'absolute', top: -50, left: '50%', transform: 'translateX(-50%)',
                        background: 'rgba(230, 126, 34, 0.9)', color: 'white', padding: '5px 15px', 
                        borderRadius: 20, fontSize: 14, fontWeight: 'bold', display: 'flex', alignItems: 'center', gap: 5,
                        boxShadow: '0 4px 10px rgba(0,0,0,0.3)', zIndex: 50
                    }}>
                        <Bot size={16} /> ç³»ç»Ÿä»£æ‰“ä¸­...
                    </div>
                )}
                
                {myHand.map((c, i) => (
                    <Card key={`${c}-${i}`} cardVal={c} index={i} isSelected={selectedCards.includes(c)} onClick={handleMouseDown} onMouseEnter={handleMouseEnter} spacing={cardSpacing} />
                ))}
            </div>

            <div style={styles.actionBar} className="action-bar-container">
                {!winner && !roundResult && !grandResult && (
                    <div style={{display:'flex', alignItems: 'center', gap: 20}}>
                        {amIAutoPlay ? (
                            <button 
                                style={{
                                    ...styles.playButton, 
                                    background: '#e74c3c', 
                                    width: 220,
                                    display: 'flex', justifyContent: 'center', alignItems: 'center'
                                }} 
                                onClick={handleToggleAutoPlay}
                            >
                                <Zap size={22} style={{marginRight:8}}/> å–æ¶ˆæ‰˜ç®¡
                            </button>
                        ) : (
                            <>
                                {isMyTurn ? (
                                    <>
                                        <button style={styles.passButton} onClick={handlePass}>ä¸è¦</button>
                                        <button style={styles.playButton} onClick={handlePlayCards}>å‡ºç‰Œ</button>
                                    </>
                                ) : (
                                    <div style={styles.waitingBadge}><Clock size={20} className="spin" /> ç­‰å¾…å¯¹æ–¹...</div>
                                )}
                                
                                <button 
                                    style={{
                                        pointerEvents: 'auto', 
                                        background: 'rgba(255,255,255,0.1)', 
                                        border: '1px solid rgba(255,255,255,0.3)',
                                        color: '#ecf0f1',
                                        borderRadius: 30, 
                                        padding: '0 20px',
                                        height: 50,
                                        display: 'flex', alignItems: 'center', justifyContent: 'center',
                                        cursor: 'pointer',
                                        marginLeft: 20,
                                        fontSize: 16,
                                        fontWeight: 'bold',
                                        transition: 'all 0.2s'
                                    }}
                                    onClick={handleToggleAutoPlay}
                                    title="ç‚¹å‡»å¼€å¯ç³»ç»Ÿæ‰˜ç®¡"
                                >
                                    <Zap size={20} style={{marginRight: 6}} />
                                    æ‰˜ç®¡
                                </button>
                            </>
                        )}
                    </div>
                )}
            </div>
            
            <style>{`
                .statusBadgeBot { background: #34495e; color: white; padding: 2px 6px; borderRadius: 10px; fontSize: 10px; display: flex; align-items: center; gap: 2px; border: 1px solid rgba(255,255,255,0.3); }
                .statusBadgeAuto { background: #e67e22; color: white; padding: 2px 6px; borderRadius: 10px; fontSize: 10px; display: flex; align-items: center; gap: 2px; border: 1px solid rgba(255,255,255,0.3); animation: pulse 2s infinite; }
                @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
            `}</style>
        </div>
    );
};

================================================================================
FILE PATH: client\src\screens\LobbyScreen.jsx
================================================================================
// å¤§å…é¡µ - ä¿®å¤ç§»åŠ¨ç«¯æº¢å‡ºé—®é¢˜

import React from 'react';
import { Target, Layers, User, Play, Clock, Bot } from 'lucide-react';
import { styles } from '../styles';

export const LobbyScreen = ({ roomId, roomConfig, players, mySocketId, handleStartGame, handleAddBot }) => (
    <div style={styles.container}>
      {/* [ä¿®æ”¹] å¢åŠ  mobile-layout-column ç±»åï¼Œå¹¶é‡æ„å†…éƒ¨ç»“æ„ä»¥æ”¯æŒ flex æ»šåŠ¨ */}
      <div style={styles.lobbyCard} className="mobile-layout-column">
          
          <div className="mobile-lobby-content" style={{display:'flex', flexDirection:'column', height:'100%', overflow:'hidden', borderRadius: 20}}>
            
            {/* å¤´éƒ¨ï¼šä¿æŒä¸å˜ï¼Œå›ºå®šåœ¨é¡¶éƒ¨ */}
            <div style={styles.lobbyHeader}>
                <h2 style={{margin:0, fontSize: 24}}>æˆ¿é—´: <span style={{fontFamily:'monospace', color:'#27ae60'}}>{roomId}</span></h2>
                <div style={{display:'flex', gap:15}}>
                    <span style={styles.tag}><Target size={14}/> ç›®æ ‡ {roomConfig.targetScore}</span>
                    <span style={styles.tag}><Layers size={14}/> {roomConfig.deckCount}å‰¯ç‰Œ</span>
                    <span style={styles.tag}><User size={14}/> {roomConfig.maxPlayers}äºº</span>
                </div>
            </div>

            {/* ä¸­é—´ï¼šç©å®¶åˆ—è¡¨ - [ä¿®æ”¹] å¢åŠ  mobile-lobby-grid ç±»åï¼Œæ”¯æŒæ»šåŠ¨ */}
            <div style={styles.playerGrid} className="mobile-lobby-grid">
                {players.map((p,i)=>(
                    <div key={i} style={{...styles.lobbyPlayer, borderColor: p.id===mySocketId ? '#27ae60' : '#eee', background: p.id===mySocketId ? '#f0fbf4' : 'white'}}>
                        <div style={styles.avatarLarge}>
                            {p.isBot ? <Bot size={40} /> : p.name[0]}
                        </div>
                        <div style={{fontWeight: 'bold', display:'flex', alignItems:'center', gap:5}}>
                            {p.name}
                            {p.isBot && <span style={{fontSize:10, background:'#eee', padding:'2px 5px', borderRadius:4}}>AI</span>}
                        </div>
                        {p.isHost && <span style={styles.hostBadge}>æˆ¿ä¸»</span>}
                    </div>
                ))}
                {Array.from({length: roomConfig.maxPlayers - players.length}).map((_, i) => (
                    <div key={`empty-${i}`} style={{...styles.lobbyPlayer, borderStyle: 'dashed', opacity: 0.5}}>
                        <div style={{...styles.avatarLarge, background:'#f0f0f0', color:'#ccc'}}>?</div>
                        <div style={{color:'#999'}}>ç­‰å¾…åŠ å…¥</div>
                    </div>
                ))}
            </div>

            {/* åº•éƒ¨ï¼šæŒ‰é’®åŒº - [ä¿®æ”¹] å¢åŠ  mobile-lobby-footer ç±»åï¼Œå›ºå®šåœ¨åº•éƒ¨ */}
            <div style={styles.lobbyFooter} className="mobile-lobby-footer">
                {players.find(p=>p.id===mySocketId)?.isHost ? (
                    <div style={{display:'flex', gap: 15, justifyContent: 'center'}}>
                        <button 
                            style={{...styles.primaryButton, background: '#7f8c8d', width:'auto', padding:'0 20px', fontSize: 16, marginTop:0}} 
                            onClick={handleAddBot}
                            disabled={players.length >= roomConfig.maxPlayers}
                        >
                            <Bot size={18} style={{marginRight:5}}/> +Bot
                        </button>

                        <button style={{...styles.primaryButton, width:'auto', padding:'0 30px', marginTop:0}} onClick={handleStartGame} disabled={players.length < 2}>
                            <Play size={18} style={{marginRight:5}}/> å¼€å§‹å¯¹æˆ˜
                        </button>
                    </div>
                ) : (
                    <div style={{color:'#999', fontSize: 14, display:'flex', alignItems:'center', gap:5}}><Clock size={16}/> ç­‰å¾…æˆ¿ä¸»å¼€å§‹...</div>
                )}
            </div>
          
          </div>
      </div>
    </div>
);

================================================================================
FILE PATH: client\src\screens\LoginScreen.jsx
================================================================================
// ç™»å½•é¡µ - é€‚é…ç§»åŠ¨ç«¯ï¼ŒåŒ…å«è‡ªåŠ¨å…¨å±é€»è¾‘ + æ‰‹åŠ¨å…¨å±æŒ‰é’®
import React, { useState } from 'react'; // [ä¿®æ”¹] å¼•å…¥ useState
import { User, Monitor, RefreshCw, Plus, LogIn, Settings, Clock, Layers, Users, Target, Wifi, WifiOff, Award, Maximize, Minimize } from 'lucide-react'; // [ä¿®æ”¹] å¼•å…¥ Maximize, Minimize å›¾æ ‡
import { styles } from '../styles.js';

export const LoginScreen = ({ 
    username, setUsername, 
    roomId, setRoomId, 
    roomConfig, setRoomConfig, 
    isCreatorMode, setIsCreatorMode, 
    handleRoomAction, 
    isLoading,
    isConnected 
}) => {
    
    // [æ–°å¢] å…¨å±çŠ¶æ€ç®¡ç†
    const [isFullScreen, setIsFullScreen] = useState(false);

    // [æ–°å¢] æ‰‹åŠ¨åˆ‡æ¢å…¨å±
    const toggleFullScreen = () => {
        if (!document.fullscreenElement) {
            const docEl = document.documentElement;
            const requestFull = docEl.requestFullscreen || docEl.webkitRequestFullscreen || docEl.mozRequestFullScreen || docEl.msRequestFullscreen;
            if (requestFull) {
                requestFull.call(docEl)
                    .then(() => setIsFullScreen(true))
                    .catch(err => console.log("å…¨å±è¯·æ±‚è¢«æ‹¦æˆª:", err));
            }
        } else {
            const exitFull = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen;
            if (exitFull) {
                exitFull.call(document)
                    .then(() => setIsFullScreen(false));
            }
        }
    };

    // å°è¯•è¯·æ±‚å…¨å±çš„è¾…åŠ©å‡½æ•° (ç”¨äºç‚¹å‡»è¿›å…¥æˆ¿é—´æ—¶è‡ªåŠ¨è§¦å‘)
    const tryEnterFullScreen = () => {
        try {
            if (!document.fullscreenElement) {
                const docEl = document.documentElement;
                const requestFull = docEl.requestFullscreen || docEl.webkitRequestFullscreen || docEl.mozRequestFullScreen || docEl.msRequestFullscreen;
                
                if (requestFull) {
                    requestFull.call(docEl)
                        .then(() => setIsFullScreen(true))
                        .catch(err => console.log("å…¨å±è‡ªåŠ¨è§¦å‘è¢«æ‹¦æˆª (æ­£å¸¸):", err));
                }
            }
        } catch (e) {
            console.log("å…¨å±é”™è¯¯:", e);
        }
    };

    // åŒ…è£…åŸæœ¬çš„ handleRoomAction
    const onActionClick = () => {
        tryEnterFullScreen(); 
        handleRoomAction();   
    };

    // æ¸²æŸ“é…ç½®é¡¹çš„è¾…åŠ©å‡½æ•°
    const renderConfigSlider = (icon, label, value, min, max, step, onChange, suffix = '') => (
        <div style={styles.configItem}>
            <div style={styles.configLabel}>
                <span style={{display:'flex', alignItems:'center', gap:6}}>{icon} {label}</span>
                <span style={styles.configValue}>{value}{suffix}</span>
            </div>
            <input 
                type="range" 
                style={styles.rangeInput}
                min={min} 
                max={max} 
                step={step || 1}
                value={value} 
                onChange={(e) => onChange(parseInt(e.target.value))}
            />
        </div>
    );

    return (
        <div style={styles.container}>
            <div style={styles.loginCard} className="mobile-layout-column">
                {/* å·¦ä¾§ï¼šå“ç‰Œå±•ç¤ºåŒº */}
                <div style={styles.loginLeft} className="mobile-login-left">
                    <div style={styles.logoCircle}>
                        <div style={styles.logoText}>510K</div>
                    </div>
                    <h1 style={styles.brandTitle}>æ‰‘å…‹å¯¹æˆ˜</h1>
                    <div style={styles.brandSubtitle}>å¤šäººåœ¨çº¿ Â· è‡ªç”±è§„åˆ™ Â· æé€Ÿç•…ç©</div>
                    
                    <div style={styles.featureList} className="hide-on-mobile">
                        <div style={styles.featureItem}>âœ¨ æ”¯æŒ 2-12 äººåŒå°ç«æŠ€</div>
                        <div style={styles.featureItem}>ğŸš€ åªæœ‰ 1 å‰¯ç‰Œ? ä¸ï¼Œç°åœ¨æ”¯æŒ 8 å‰¯!</div>
                        <div style={styles.featureItem}>â±ï¸ è‡ªå®šä¹‰æ€è€ƒæ—¶é—´ä¸è·èƒœç›®æ ‡</div>
                    </div>
                </div>

                {/* å³ä¾§ï¼šæ“ä½œåŒº */}
                <div style={styles.loginRight} className="mobile-login-right">
                    {/* é¡¶éƒ¨çŠ¶æ€æ  */}
                    <div style={{
                        display: 'flex', 
                        justifyContent: 'space-between', 
                        alignItems: 'center',
                        marginBottom: 20
                    }}>
                        {/* [æ–°å¢] å·¦ä¾§ï¼šå…¨å±åˆ‡æ¢æŒ‰é’® */}
                        <button 
                            onClick={toggleFullScreen}
                            style={{
                                background: '#f8f9fa', 
                                border: '1px solid #e1e4e8', 
                                borderRadius: 20,
                                padding: '6px 12px',
                                cursor: 'pointer', 
                                color: '#7f8c8d', 
                                display: 'flex', 
                                alignItems: 'center', 
                                gap: 6,
                                fontSize: 12, 
                                fontWeight: 'bold',
                                transition: 'all 0.2s'
                            }}
                        >
                            {isFullScreen ? <Minimize size={14}/> : <Maximize size={14}/>}
                            <span>{isFullScreen ? 'é€€å‡ºå…¨å±' : 'å…¨å±æ¨¡å¼'}</span>
                        </button>

                        {/* å³ä¾§ï¼šè¿æ¥çŠ¶æ€æŒ‡ç¤ºå™¨ */}
                        <div style={{
                            display: 'flex', 
                            alignItems: 'center', 
                            gap: 6, 
                            fontSize: 12,
                            padding: '6px 12px',
                            borderRadius: 20,
                            background: isConnected ? '#eafaf1' : '#fdedec',
                            color: isConnected ? '#27ae60' : '#e74c3c',
                            fontWeight: 'bold',
                            border: `1px solid ${isConnected ? '#abebc6' : '#fadbd8'}`
                        }}>
                            {isConnected ? <Wifi size={14}/> : <WifiOff size={14}/>}
                            {isConnected ? 'å·²è¿æ¥' : 'è¿æ¥ä¸­...'}
                        </div>
                    </div>

                    {/* é¡¶éƒ¨ Tab åˆ‡æ¢ */}
                    <div style={styles.tabs}>
                        <button 
                            style={!isCreatorMode ? styles.tabBtnActive : styles.tabBtn} 
                            onClick={()=>setIsCreatorMode(false)}
                        >
                            åŠ å…¥æˆ¿é—´
                        </button>
                        <button 
                            style={isCreatorMode ? styles.tabBtnActive : styles.tabBtn} 
                            onClick={()=>setIsCreatorMode(true)}
                        >
                            åˆ›å»ºæˆ¿é—´
                        </button>
                    </div>

                    <div style={styles.formContent}>
                        {/* åŸºç¡€ä¿¡æ¯è¾“å…¥ (æ˜µç§°/æˆ¿å·) */}
                        <div style={styles.inputGroup}>
                            <User size={18} color="#7f8c8d" />
                            <input 
                                style={styles.input} 
                                value={username} 
                                onChange={e=>setUsername(e.target.value)} 
                                placeholder="è¯·è¾“å…¥ä½ çš„æ˜µç§°" 
                                maxLength={10}
                            />
                        </div>
                        <div style={styles.inputGroup}>
                            <Monitor size={18} color="#7f8c8d" />
                            <input 
                                style={styles.input} 
                                value={roomId} 
                                onChange={e=>setRoomId(e.target.value)} 
                                placeholder="è¯·è¾“å…¥æˆ¿é—´å· (å¦‚: 888)" 
                                maxLength={6}
                            />
                        </div>

                        {/* åˆ›å»ºæ¨¡å¼ä¸‹çš„é«˜çº§é…ç½®åŒº */}
                        {isCreatorMode && (
                            <div style={styles.advancedConfigPanel}>
                                <div style={styles.configGrid}>
                                    {renderConfigSlider(<Users size={14}/>, "ç©å®¶äººæ•°", roomConfig.maxPlayers, 2, 12, 1, v=>setRoomConfig({...roomConfig, maxPlayers:v}), 'äºº')}
                                    {renderConfigSlider(<Layers size={14}/>, "ç‰Œåº“æ•°é‡", roomConfig.deckCount, 1, 8, 1, v=>setRoomConfig({...roomConfig, deckCount:v}), 'å‰¯')}
                                    {renderConfigSlider(<Target size={14}/>, "è·èƒœç›®æ ‡", roomConfig.targetScore, 500, 5000, 500, v=>setRoomConfig({...roomConfig, targetScore:v}), 'åˆ†')}
                                    
                                    {/* å€’è®¡æ—¶é€‰æ‹© */}
                                    <div style={styles.configItem}>
                                        <div style={styles.configLabel}>
                                            <span style={{display:'flex', alignItems:'center', gap:6}}><Clock size={14}/> å‡ºç‰Œæ—¶é™</span>
                                            <span style={styles.configValue}>{roomConfig.turnTimeout / 1000}ç§’</span>
                                        </div>
                                        <div style={styles.radioGroup}>
                                            {[30, 60, 90, 120].map(sec => (
                                                <button 
                                                    key={sec}
                                                    style={roomConfig.turnTimeout === sec * 1000 ? styles.radioBtnActive : styles.radioBtn}
                                                    onClick={() => setRoomConfig({...roomConfig, turnTimeout: sec * 1000})}
                                                >
                                                    {sec}s
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                </div>

                                {/* æ’åèµç½šè®¾ç½®åŒºåŸŸ */}
                                <div style={{marginTop: 20, paddingTop: 20, borderTop: '1px solid #f0f0f0'}}>
                                    <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom: 15}}>
                                        <div style={{display:'flex', alignItems:'center', gap:8, fontWeight:'600', color:'#555', fontSize:14}}>
                                            <Award size={16} /> å¯ç”¨æ’åèµç½š (è¿›è´¡/æŠ“åˆ†)
                                        </div>
                                        <label style={{position:'relative', display:'inline-block', width:40, height:20}}>
                                            <input 
                                                type="checkbox" 
                                                style={{opacity:0, width:0, height:0}}
                                                checked={roomConfig.enableRankPenalty}
                                                onChange={(e) => setRoomConfig({...roomConfig, enableRankPenalty: e.target.checked})}
                                            />
                                            <span style={{
                                                position:'absolute', cursor:'pointer', top:0, left:0, right:0, bottom:0, 
                                                backgroundColor: roomConfig.enableRankPenalty ? '#27ae60' : '#ccc', 
                                                transition:'.4s', borderRadius: 20
                                            }}>
                                                <span style={{
                                                    position:'absolute', content:"", height:16, width:16, left:2, bottom:2, 
                                                    backgroundColor:'white', transition:'.4s', borderRadius:'50%',
                                                    transform: roomConfig.enableRankPenalty ? 'translateX(20px)' : 'translateX(0)'
                                                }}></span>
                                            </span>
                                        </label>
                                    </div>

                                    {/* å¦‚æœå¼€å¯ï¼Œæ˜¾ç¤ºè¯¦ç»†åˆ†å€¼è®¾ç½® */}
                                    {roomConfig.enableRankPenalty && (
                                        <div style={{background:'#f9f9f9', padding: 15, borderRadius: 8, display:'flex', gap: 20, fontSize: 13}}>
                                            <div style={{flex:1}}>
                                                <div style={{marginBottom:5, color:'#7f8c8d'}}>å¤´å°¾èµç½š (ç¬¬1å vs å€’1)</div>
                                                <input 
                                                    type="number" style={{...styles.input, background:'white', height: 35, padding: '0 10px'}} 
                                                    value={roomConfig.rankPenaltyScores[0]}
                                                    onChange={e => {
                                                        const val = Math.max(0, parseInt(e.target.value) || 0);
                                                        setRoomConfig({...roomConfig, rankPenaltyScores: [val, roomConfig.rankPenaltyScores[1]]});
                                                    }}
                                                />
                                            </div>
                                            <div style={{flex:1}}>
                                                <div style={{marginBottom:5, color:'#7f8c8d'}}>æ¬¡çº§èµç½š (ç¬¬2å vs å€’2)</div>
                                                <input 
                                                    type="number" style={{...styles.input, background:'white', height: 35, padding: '0 10px'}} 
                                                    value={roomConfig.rankPenaltyScores[1]}
                                                    onChange={e => {
                                                        const val = Math.max(0, parseInt(e.target.value) || 0);
                                                        setRoomConfig({...roomConfig, rankPenaltyScores: [roomConfig.rankPenaltyScores[0], val]});
                                                    }}
                                                />
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}

                        <div style={{flex: 1}}></div> {/* å¼¹ç°§å¡«å…… */}

                        <button 
                            style={{
                                ...styles.primaryButton,
                                opacity: (!isConnected || isLoading) ? 0.7 : 1,
                                cursor: (!isConnected || isLoading) ? 'not-allowed' : 'pointer',
                                background: (!isConnected) ? '#95a5a6' : '#2c3e50'
                            }} 
                            onClick={onActionClick} 
                            disabled={isLoading || !isConnected}
                        >
                            {(isLoading || !isConnected) ? <RefreshCw className="spin" size={20}/> : (isCreatorMode ? <Plus size={20}/> : <LogIn size={20}/>)}
                            <span style={{marginLeft:10}}>
                                {!isConnected ? "æ­£åœ¨è¿æ¥æœåŠ¡å™¨..." : (isLoading ? "å¤„ç†ä¸­..." : (isCreatorMode ? "ç«‹å³åˆ›å»ºæˆ¿é—´" : "è¿›å…¥æ¸¸æˆæˆ¿é—´"))}
                            </span>
                        </button>
                        
                        {!isConnected && (
                            <div style={{textAlign:'center', marginTop: 15, fontSize: 13, color:'#e74c3c', background:'#fdedec', padding:'8px', borderRadius:8}}>
                                âš ï¸ é¦–æ¬¡è®¿é—®å¯èƒ½éœ€è¦ 30-50ç§’ å”¤é†’æœåŠ¡å™¨ï¼Œè¯·è€å¿ƒç­‰å¾…å³ä¸Šè§’å˜ä¸ºç»¿è‰²ã€‚
                            </div>
                        )}
                    </div>
                </div>
            </div>
            <style>{`.spin { animation: spin 1s linear infinite; } @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }`}</style>
        </div>
    );
};


================================================================================
FILE PATH: client\src\styles.js
================================================================================
// ç»Ÿä¸€æ ·å¼æ–‡ä»¶ - ç§»åŠ¨ç«¯é€‚é…ç‰ˆ
// å¢åŠ äº† viewport å®‰å…¨åŒºæ”¯æŒï¼Œé˜²æ­¢åˆ˜æµ·é®æŒ¡
export const styles = {
  // å…¨å±€å®¹å™¨
  container: { 
      height: '100dvh', // ä½¿ç”¨ 100dvh è‡ªåŠ¨é€‚é…åŠ¨æ€åœ°å€æ 
      width: '100vw', 
      display: 'flex', 
      justifyContent: 'center', 
      alignItems: 'center', 
      background: '#1e272e', 
      fontFamily: '"Segoe UI", Roboto, Helvetica, Arial, sans-serif', 
      backgroundImage: 'radial-gradient(circle at top right, #34495e 0%, #000000 100%)',
      overflow: 'hidden' 
  },
  
  // --- Login Card ---
  loginCard: { 
      background: 'white', 
      borderRadius: 24, 
      width: '95%', 
      maxWidth: '1100px', 
      minHeight: '600px', 
      maxHeight: '90vh',
      display: 'flex', 
      boxShadow: '0 50px 100px -20px rgba(0,0,0,0.7)',
      overflow: 'hidden',
      animation: 'popIn 0.5s ease-out'
  },

  // å·¦ä¾§å“ç‰ŒåŒº
  loginLeft: { 
      flex: 0.8, 
      background: 'linear-gradient(135deg, #27ae60 0%, #2ecc71 100%)', 
      padding: '60px 50px', 
      display:'flex', 
      flexDirection:'column', 
      justifyContent:'center', 
      alignItems: 'flex-start',
      color: 'white',
      position: 'relative',
      overflow: 'hidden'
  },
  logoCircle: { width: 90, height: 90, background: 'rgba(255,255,255,0.2)', borderRadius: 24, display:'flex', alignItems:'center', justifyContent:'center', marginBottom: 25, backdropFilter: 'blur(10px)' },
  logoText: { fontSize: 28, fontWeight: '900', color: 'white' },
  brandTitle: { fontSize: 48, fontWeight: '800', margin: '0 0 15px 0', letterSpacing: -1.5 },
  brandSubtitle: { fontSize: 18, opacity: 0.9, marginBottom: 50, fontWeight: '500' },
  featureList: { marginTop: 'auto', display: 'flex', flexDirection: 'column', gap: 15 },
  featureItem: { fontSize: 15, opacity: 0.95, display:'flex', alignItems:'center', fontWeight: '500' },

  // å³ä¾§è¡¨å•åŒº
  loginRight: { 
      flex: 1.2, 
      padding: '50px 60px', 
      display: 'flex',
      flexDirection: 'column',
      background: '#ffffff',
      overflowY: 'auto' 
  },
  
  tabs: { display: 'flex', gap: 35, marginBottom: 35, borderBottom: '2px solid #f1f2f6' },
  tabBtn: { padding: '12px 0', fontSize: 18, fontWeight: 'bold', color: '#95a5a6', background: 'none', border: 'none', cursor: 'pointer', transition: 'all 0.3s', borderBottom: '3px solid transparent', marginBottom: -3 },
  tabBtnActive: { padding: '12px 0', fontSize: 18, fontWeight: 'bold', color: '#2c3e50', background: 'none', border: 'none', cursor: 'pointer', transition: 'all 0.3s', borderBottom: '3px solid #27ae60', marginBottom: -3 },
  
  formContent: { flex: 1, display: 'flex', flexDirection: 'column' },

  inputGroup: { display: 'flex', alignItems: 'center', background: '#f8f9fa', borderRadius: 14, padding: '0 20px', marginBottom: 20, border: '1px solid #e1e4e8', height: 60, transition: 'all 0.2s' },
  input: { padding: '10px', border: 'none', background: 'transparent', flex: 1, outline:'none', fontSize: 17, color: '#2c3e50', fontWeight: '500' },

  // é«˜çº§é…ç½®é¢æ¿
  advancedConfigPanel: { 
      marginTop: 15, 
      background: '#fff', 
      borderRadius: 12,
      animation: 'fadeIn 0.4s ease'
  },
  configGrid: {
      display: 'grid',
      gridTemplateColumns: '1fr 1fr', 
      gap: '25px 35px'
  },
  configItem: { display: 'flex', flexDirection: 'column', gap: 10 },
  configLabel: { display: 'flex', justifyContent: 'space-between', fontSize: 14, color: '#7f8c8d', fontWeight: '600' },
  configValue: { color: '#27ae60', fontWeight: 'bold' },
  
  rangeInput: { width: '100%', cursor: 'pointer', accentColor: '#27ae60', height: 6 },

  radioGroup: { display: 'flex', gap: 10 },
  radioBtn: { flex: 1, padding: '8px 0', borderRadius: 8, border: '1px solid #e1e4e8', background: 'white', color: '#7f8c8d', fontSize: 13, cursor: 'pointer', transition: 'all 0.2s' },
  radioBtnActive: { flex: 1, padding: '8px 0', borderRadius: 8, border: '1px solid #27ae60', background: '#eafaf1', color: '#27ae60', fontSize: 13, fontWeight: 'bold', cursor: 'pointer' },

  primaryButton: { 
      marginTop: 25, 
      width: '100%', 
      height: 65, 
      background: '#2c3e50', 
      color: 'white', 
      border: 'none', 
      borderRadius: 14, 
      fontWeight: 'bold', 
      cursor: 'pointer', 
      display: 'flex', 
      justifyContent: 'center', 
      alignItems: 'center', 
      fontSize: 19, 
      transition: 'all 0.2s', 
      boxShadow: '0 10px 25px rgba(44, 62, 80, 0.25)' 
  },

  // --- Game Screen Styles ---

  gameTable: { 
      height: '100dvh', // ä½¿ç”¨ 100dvh
      width: '100vw', 
      background: '#1e3c29', 
      backgroundImage: 'radial-gradient(circle at center, #2d7a54 0%, #173b25 100%)', 
      position: 'relative', 
      overflow: 'hidden', 
      display: 'flex', 
      flexDirection: 'column', 
      userSelect: 'none',
      // [å…³é”®ä¿®æ”¹] å¢åŠ  safe-area-inset é€‚é…åˆ˜æµ·å±
      paddingTop: 'env(safe-area-inset-top)',
      paddingLeft: 'env(safe-area-inset-left)',
      paddingRight: 'env(safe-area-inset-right)',
      paddingBottom: 'env(safe-area-inset-bottom)'
  },
  
  // Players Area: è°ƒæ•´ä½ç½®ï¼Œé¿å…è¢«é¡¶éƒ¨ Header é®æŒ¡
  playersArea: { 
      display: 'flex', 
      justifyContent: 'center', 
      alignContent: 'center', 
      flexWrap: 'wrap',       
      gap: '10px',            
      // [ä¿®æ”¹] å¢åŠ é¡¶éƒ¨ paddingï¼Œç»™ Header ç•™å‡ºç©ºé—´
      paddingTop: 80,         
      marginBottom: 200,      
      width: '98%',           
      maxWidth: 1600,         
      margin: '0 auto 200px', 
      pointerEvents: 'none',  
      zIndex: 10
  },
  
  playerBox: { 
      pointerEvents: 'auto',
      padding: '10px 15px',   
      borderRadius: 16, 
      textAlign: 'center', 
      minWidth: 90,           
      color:'white', 
      border: '2px solid transparent', 
      transition: 'all 0.3s', 
      position: 'relative' 
  },

  avatar: { width: 70, height: 70, background: '#ecf0f1', borderRadius: '50%', margin: '0 auto 8px', lineHeight: '70px', color:'#333', fontWeight:'bold', fontSize: 24, border: '2px solid rgba(255,255,255,0.2)', boxShadow: '0 4px 10px rgba(0,0,0,0.2)' },
  playerName: { fontSize: 14, fontWeight: 'bold', marginBottom: 4, whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', maxWidth: 90 },
  
  gameLogPanel: { position: 'absolute', top: 20, left: 20, width: 250, bottom: 280, background: 'rgba(0,0,0,0.2)', borderRadius: 12, padding: 20, display: 'flex', flexDirection: 'column', zIndex: 5, backdropFilter: 'blur(10px)', border: '1px solid rgba(255,255,255,0.1)' },
  logHeader: { display: 'flex', alignItems: 'center', gap: 8, paddingBottom: 10, borderBottom: '1px solid rgba(255,255,255,0.1)', marginBottom: 10 },
  logList: { flex: 1, overflowY: 'auto', display: 'flex', flexDirection: 'column', gap: 10, fontSize: 13, scrollbarWidth: 'thin' },
  logItem: { lineHeight: 1.5, display: 'flex', alignItems: 'flex-start' },
  logTime: { opacity: 0.5, fontSize: 10, marginRight: 8, width: 45, display: 'inline-block', color: '#ccc' },
  
  tableHeader: { 
      // [ä¿®æ”¹] é¡¶éƒ¨æ ä½¿ç”¨ padding + safe-areaï¼Œä¸”ä½¿ç”¨ç»å¯¹å®šä½ç¡®ä¿ä¸è¢«æµå¼å¸ƒå±€æŒ¤èµ°
      padding: '10px 40px', 
      paddingTop: 'calc(10px + env(safe-area-inset-top))', 
      display: 'flex', 
      justifyContent: 'space-between', 
      alignItems:'flex-start', 
      zIndex: 20,
      position: 'absolute',
      top: 0,
      width: '100%',
      boxSizing: 'border-box'
  },
  roomBadge: { background: 'rgba(0,0,0,0.3)', color:'white', padding: '8px 20px', borderRadius: 20, fontSize: 16, border: '1px solid rgba(255,255,255,0.1)', fontWeight: 'bold' },
  
  scoreBoard: { position: 'absolute', top: 20, left: '50%', transform: 'translateX(-50%)', background: 'rgba(0,0,0,0.5)', padding: '10px 50px', borderRadius: 20, textAlign: 'center', color: 'white', border: '1px solid rgba(255,255,255,0.1)', backdropFilter: 'blur(10px)', boxShadow: '0 10px 30px rgba(0,0,0,0.2)' },
  
  glassButton: { background: 'rgba(255,255,255,0.1)', color: 'white', border: '1px solid rgba(255,255,255,0.2)', padding: '8px 20px', borderRadius: 20, cursor: 'pointer', display: 'flex', alignItems: 'center', fontSize: 14, transition: 'background 0.2s' },
  sortButton: { background: 'rgba(255,255,255,0.1)', color: 'white', border: '1px solid rgba(255,255,255,0.2)', padding: '8px 20px', borderRadius: 20, cursor: 'pointer', display: 'flex', alignItems: 'center', fontSize: 14, transition: 'background 0.2s' },
  
  infoMessage: { position: 'absolute', top: '25%', width: '100%', textAlign: 'center', color: '#f1c40f', fontSize: 40, fontWeight: 'bold', textShadow: '0 5px 15px rgba(0,0,0,0.5)', pointerEvents: 'none', zIndex: 50, letterSpacing: 2 },
  
  tableCenter: { flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', paddingBottom: 100 },
  playerNameTag: { color: 'white', textAlign: 'center', marginBottom: 15, textShadow: '0 2px 4px rgba(0,0,0,0.5)', fontSize: 18, fontWeight: 'bold', background: 'rgba(0,0,0,0.3)', padding: '5px 20px', borderRadius: 20, display: 'inline-block' },
  playedRow: { display: 'flex', gap: -10, filter: 'drop-shadow(0 10px 20px rgba(0,0,0,0.3))' }, 
  miniCard: { background: 'white', padding: '15px 20px', borderRadius: 10, fontWeight: 'bold', fontSize: 28, minWidth: 50, textAlign:'center' },
  
  scoreBarBg: { width:'100%', height:6, background:'rgba(0,0,0,0.5)', borderRadius:3, marginTop:5, overflow:'hidden' },
  scoreBarFill: { height:'100%', transition:'width 0.5s' },
  playerScore: { fontSize: 13, color: '#f1c40f', fontWeight: 'bold', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 5, marginTop: 5 },
  turnProgress: { position: 'absolute', bottom: 0, left: 0, height: 4, background: '#f1c40f', width: '100%', animation: 'progress 15s linear forwards' },
  
  handArea: { 
      position: 'absolute', 
      bottom: 20,             
      left: '50%', 
      transform: 'translateX(-50%)', 
      height: 140, 
      width: '100%',          
      maxWidth: 1600, 
      display: 'flex', 
      justifyContent:'center', 
      zIndex: 20 
  },
  
  card: { 
      background: 'white', 
      borderRadius: 8,       
      border: '1px solid #999', 
      position: 'absolute', 
      cursor: 'pointer', 
      display: 'flex', 
      flexDirection: 'column', 
      padding: 5,            
      transition: 'transform 0.1s cubic-bezier(0.2, 0.8, 0.2, 1)', 
      width: 80,             
      height: 110            
  },
  
  actionBar: { position: 'absolute', bottom: 0, width: '100%', height: 120, background: 'linear-gradient(to top, rgba(0,0,0,0.9), transparent)', display: 'flex', justifyContent: 'center', alignItems: 'center', pointerEvents: 'none', zIndex: 30 }, 
  playButton: { pointerEvents: 'auto', padding: '15px 60px', background: 'linear-gradient(to bottom, #f1c40f, #f39c12)', border: 'none', borderRadius: 40, fontWeight: 'bold', cursor: 'pointer', marginLeft: 20, fontSize: 20, boxShadow: '0 8px 20px rgba(243, 156, 18, 0.4)', color: '#fff', textShadow: '0 1px 2px rgba(0,0,0,0.2)', transition: 'transform 0.1s' },
  passButton: { pointerEvents: 'auto', padding: '15px 40px', background: '#7f8c8d', border: 'none', borderRadius: 40, fontWeight: 'bold', cursor: 'pointer', fontSize: 18, color: 'white', boxShadow: '0 5px 15px rgba(0,0,0,0.3)' },
  waitingBadge: { color: 'rgba(255,255,255,0.7)', fontSize: 16, display: 'flex', alignItems: 'center', gap: 10, background: 'rgba(0,0,0,0.3)', padding: '10px 20px', borderRadius: 30 },
  modalOverlay: { position: 'fixed', top:0, left:0, right:0, bottom:0, background: 'rgba(0,0,0,0.85)', display:'flex', justifyContent:'center', alignItems:'center', zIndex: 99, backdropFilter: 'blur(8px)' },
  modalContent: { background: 'white', padding: 60, borderRadius: 30, textAlign: 'center', boxShadow: '0 30px 80px rgba(0,0,0,0.6)', animation: 'popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275)' },
  
  lobbyCard: { background: 'white', padding: 40, borderRadius: 20, width: '1000px', maxWidth: '95vw', minHeight: '600px', display: 'flex', flexDirection: 'column', boxShadow: '0 30px 60px rgba(0,0,0,0.5)' },
  lobbyHeader: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 30, paddingBottom: 20, borderBottom: '1px solid #eee' },
  tag: { background: '#f0f9f4', color: '#27ae60', padding: '5px 10px', borderRadius: 20, fontSize: 14, display: 'flex', alignItems: 'center', gap: 5 },
  playerGrid: { display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(180px, 1fr))', gap: 20, flex: 1, alignContent: 'start' },
  lobbyPlayer: { border: '2px solid #eee', borderRadius: 12, padding: 25, display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 15, position: 'relative', transition: 'all 0.2s' },
  avatarLarge: { width: 80, height: 80, borderRadius: '50%', background: '#34495e', color: 'white', fontSize: 32, display: 'flex', alignItems: 'center', justifyContent: 'center', fontWeight: 'bold' },
  hostBadge: { position: 'absolute', top: 10, right: 10, background: '#f1c40f', color: '#333', fontSize: 12, padding: '4px 8px', borderRadius: 4, fontWeight: 'bold' },
  lobbyFooter: { marginTop: 'auto', borderTop: '1px solid #eee', paddingTop: 20, display: 'flex', justifyContent: 'center' },
};

================================================================================
FILE PATH: client\src\utils\cardLogic.js
================================================================================
// çº¯é€»è¾‘å·¥å…·

// æ’åºæƒé‡ï¼š2(15) > A(14) > K(13)...
export const getSortValue = (cardVal) => {
    const normalized = cardVal % 54;
    if (normalized === 52) return 16;
    if (normalized === 53) return 17;
    const base = normalized % 13;
    if (base === 0) return 14; 
    if (base === 1) return 15; 
    return base + 1;
};

// èŠ±è‰²æ’åºæƒé‡
export const getSuitSortValue = (cardVal) => {
    if (cardVal >= 52) return cardVal * 100;
    const suit = Math.floor(cardVal / 13) % 4; 
    const val = cardVal % 13;
    return suit * 100 + val; 
};

// è·å–å•å¼ ç‰Œçš„æ˜¾ç¤ºä¿¡æ¯
export const getCardDisplay = (cardVal) => {
    const normalizedValue = cardVal % 54; 
    if (normalizedValue === 52) return { suit: 'Joker', text: 'å°ç‹', color: '#000', isScore: false };
    if (normalizedValue === 53) return { suit: 'Joker', text: 'å¤§ç‹', color: '#d00', isScore: false };
    
    const suits = ['â™ ', 'â™¥', 'â™£', 'â™¦'];
    const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
    const valueIndex = normalizedValue % 13;
    const suit = suits[Math.floor(normalizedValue / 13)];
    const color = (suit === 'â™¥' || suit === 'â™¦') ? '#d00' : '#000';
    const text = values[valueIndex];
    const isScore = (text === '5' || text === '10' || text === 'K');
    
    return { suit, text, color, isScore };
};

// æ‰‹ç‰Œæ’åº
export const sortHand = (cards, mode = 'POINT') => {
    if (mode === 'SUIT') {
        return [...cards].sort((a, b) => getSuitSortValue(b) - getSuitSortValue(a));
    }
    return [...cards].sort((a, b) => getSortValue(b) - getSortValue(a));
};

// è®¡ç®—æ‰‹ç‰Œé—´è· - [ä¿®æ”¹] é€‚é…ç§»åŠ¨ç«¯
export const calculateCardSpacing = (count, screenWidth) => {
    if (count <= 1) return 0;
    
    // [ä¿®æ”¹] é€‚é…æ‰‹æœºï¼šå¦‚æœå±å¹•å¾ˆçª„ï¼Œå¢åŠ å¯ç”¨å®½åº¦çš„æ¯”ä¾‹
    const isMobile = screenWidth < 768;
    const padding = isMobile ? 10 : 80; // è¿›ä¸€æ­¥å‡å°‘ç•™ç™½
    
    const w = Math.min(screenWidth - padding, 1400); 
    
    // [ä¿®æ”¹] å¡ç‰Œå®é™…æ¸²æŸ“å®½åº¦ (å¯¹åº” styles.js é‡Œçš„ card.width)
    // ä» 80 è°ƒæ•´ä¸º 68 ä»¥åŒ¹é…æ–°æ ·å¼
    const cardWidth = 68; 
    
    // æœ€å¤§é—´è·ï¼šç‰Œå°‘çš„æ—¶å€™ä¸è¦åˆ†å¤ªå¼€
    const maxGap = isMobile ? 40 : 50; 
    
    const neededWidth = (count - 1) * maxGap + cardWidth;
    
    // å¦‚æœéœ€è¦çš„å®½åº¦å°äºå±å¹•å®½ï¼Œå°±ç”¨æœ€å¤§é—´è·
    if (neededWidth <= w) return maxGap;
    
    // å¦åˆ™ï¼ŒæŒ¤å‹ç‰Œçš„é—´è·
    return (w - cardWidth) / (count - 1);
};

================================================================================
FILE PATH: client\src\utils\SoundManager.js
================================================================================
/**
 * ç®€æ˜“ Web Audio API éŸ³æ•ˆç®¡ç†å™¨
 * ä¸éœ€è¦å¤–éƒ¨ MP3 æ–‡ä»¶ï¼Œç›´æ¥ç”¨ä»£ç ç”Ÿæˆå£°éŸ³
 */
const SoundManager = {
    ctx: null,

    init: () => {
        if (!SoundManager.ctx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            SoundManager.ctx = new AudioContext();
        }
    },

    // æ’­æ”¾æŒ‡å®šç±»å‹çš„éŸ³æ•ˆ
    play: (type) => {
        try {
            // æŸäº›æµè§ˆå™¨éœ€è¦ç”¨æˆ·äº¤äº’åæ‰èƒ½æ¢å¤ Context
            if (SoundManager.ctx && SoundManager.ctx.state === 'suspended') {
                SoundManager.ctx.resume();
            }
            if (!SoundManager.ctx) SoundManager.init();

            switch (type) {
                case 'deal': // å‘ç‰Œ/ç‚¹å‡»ç‰Œ (çŸ­ä¿ƒçš„é«˜é¢‘éŸ³)
                    SoundManager.beep(800, 0.05, 'sine');
                    break;
                case 'play': // å‡ºç‰Œ (æœ‰æ‰“å‡»æ„Ÿ)
                    SoundManager.noise(0.1); 
                    break;
                case 'win': // èƒœåˆ© (è¿ç»­çš„ç¶éŸ³)
                    SoundManager.arpeggio([523.25, 659.25, 783.99, 1046.50], 0.1);
                    break;
                case 'lose': // å¤±è´¥/è¢«å‹ (ä½æ²‰)
                    SoundManager.beep(150, 0.3, 'sawtooth');
                    break;
                case 'alert': // è½®åˆ°ä½ äº†
                    SoundManager.beep(880, 0.1, 'square');
                    setTimeout(() => SoundManager.beep(880, 0.1, 'square'), 150);
                    break;
                default:
                    break;
            }
        } catch (e) {
            console.warn('Audio play failed:', e);
        }
    },

    // --- åˆæˆå™¨åº•å±‚å‡½æ•° ---

    // å‘å‡ºå•éŸ³
    beep: (freq, duration, type = 'sine') => {
        const ctx = SoundManager.ctx;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();

        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        
        gain.gain.setValueAtTime(0.1, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(ctx.destination);

        osc.start();
        osc.stop(ctx.currentTime + duration);
    },

    // æ¨¡æ‹Ÿæ‰“å‡»å£° (ç™½å™ªéŸ³)
    noise: (duration) => {
        const ctx = SoundManager.ctx;
        const bufferSize = ctx.sampleRate * duration;
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }

        const noise = ctx.createBufferSource();
        noise.buffer = buffer;
        
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.2, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);

        noise.connect(gain);
        gain.connect(ctx.destination);
        noise.start();
    },

    // ç¶éŸ³ (èƒœåˆ©éŸ³æ•ˆ)
    arpeggio: (freqs, interval) => {
        freqs.forEach((f, i) => {
            setTimeout(() => SoundManager.beep(f, 0.2, 'triangle'), i * interval * 1000);
        });
    }
};

export default SoundManager;

================================================================================
FILE PATH: client\vite.config.js
================================================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})


================================================================================
FILE PATH: server\game\BotLogic.js
================================================================================
const CardRules = require('./CardRules');

const BotLogic = {
    // ç®€å•çš„å†³ç­–å‡½æ•°
    decideMove: (hand, lastPlayedCards, deckCount) => {
        try {
            // 1. å¦‚æœå½“å‰æ²¡æœ‰è¢«å‹ç‰Œï¼ˆè‡ªå·±é¢†å‡ºï¼‰ï¼Œå‡ºæœ€å°çš„ä¸€å¼ ç‰Œ
            if (!lastPlayedCards || lastPlayedCards.length === 0) {
                if (hand.length === 0) return null;
                // ç®€å•ç­–ç•¥ï¼šæ€»æ˜¯å‡ºæ‰‹ä¸­æœ€å°çš„ä¸€å¼ ç‰Œ
                return [hand[0]]; 
            }

            // 2. å¦‚æœæœ‰äººå‡ºç‰Œäº†ï¼Œå°è¯•ç®¡ä¸Š
            const lastHandState = CardRules.analyze(lastPlayedCards, deckCount);
            if (lastHandState.type === 'INVALID') return null; 

            // æ•´ç†æ‰‹ç‰Œï¼šæŒ‰ç‚¹æ•°åˆ†ç»„
            const grouped = {};
            hand.forEach(c => {
                const p = CardRules.getPoint(c);
                if (!grouped[p]) grouped[p] = [];
                grouped[p].push(c);
            });
            
            const uniquePoints = Object.keys(grouped).map(Number).sort((a,b) => a-b);

            // ç­–ç•¥ Aï¼šå°è¯•ç”¨åŒç±»å‹çš„ç‰Œç®¡ï¼ˆä¸å«ç‚¸å¼¹ï¼‰
            if (['SINGLE', 'PAIR', 'TRIPLE'].includes(lastHandState.type)) {
                const countNeeded = lastHandState.type === 'SINGLE' ? 1 : 
                                    lastHandState.type === 'PAIR' ? 2 : 3;
                
                for (let p of uniquePoints) {
                    if (p > lastHandState.val && grouped[p].length >= countNeeded) {
                        return grouped[p].slice(0, countNeeded);
                    }
                }
            }
            
            // ç®€å•çš„è¿å¯¹/é£æœºç®¡ç‰Œå°è¯• (åªç®¡é•¿åº¦ä¸€è‡´çš„)
            if (lastHandState.type === 'LIANDUI' || lastHandState.type === 'AIRPLANE') {
                 // è¿™æ˜¯ä¸€ä¸ªå¤æ‚çš„æœç´¢ï¼Œè¿™é‡Œç®€åŒ–ï¼šBotæš‚ä¸å¤„ç†å¤æ‚ç‰Œå‹çš„è·Ÿç‰Œï¼Œç›´æ¥å°è¯•ç”¨ç‚¸å¼¹ç‚¸
            }

            // ç­–ç•¥ Bï¼šå°è¯•ç”¨ç‚¸å¼¹ç‚¸
            const currentLevel = lastHandState.level || 0;
            
            // æ‰¾æ™®é€šç‚¸å¼¹ (4å¼ åŠä»¥ä¸Š)
            for (let p of uniquePoints) {
                if (grouped[p].length >= 4) {
                    const bombCards = grouped[p];
                    const bombState = CardRules.analyze(bombCards, deckCount);
                    
                    // çº§åˆ«é«˜ï¼Œæˆ–åŒçº§åˆ«ç‚¹æ•°å¤§
                    if (bombState.level > currentLevel) return bombCards;
                    if (bombState.level === currentLevel && bombState.val > lastHandState.val) return bombCards;
                }
            }

            // 3. å®åœ¨ç®¡ä¸ä¸Šï¼Œè¿‡
            return null;
        } catch (e) {
            console.error("BotLogic error:", e);
            return null; // æŠ¥é”™æ—¶é»˜è®¤è¿‡ç‰Œ
        }
    }
};

module.exports = BotLogic;

================================================================================
FILE PATH: server\game\CardRules.js
================================================================================
// çº¯è§„åˆ™è®¡ç®— (510K é€»è¾‘ã€æ¯”å¤§å°)

const CardRules = {
    // 1. åŸºç¡€æ˜ å°„
    // 3=3 ... K=13, A=14, 2=15, å°ç‹=16, å¤§ç‹=17
    getPoint: (cardVal) => {
        const normalized = cardVal % 54;
        if (normalized === 52) return 16;
        if (normalized === 53) return 17;
        const base = normalized % 13;
        if (base === 0) return 14; // A
        if (base === 1) return 15; // 2
        return base + 1; // 3 => 3
    },

    // è·å–ç‰Œçš„åˆ†æ•° (5=5, 10=10, K=10)
    getCardScore: (cardVal) => {
        const p = CardRules.getPoint(cardVal);
        if (p === 5) return 5;
        if (p === 10) return 10;
        if (p === 13) return 10; // K
        return 0;
    },

    // è®¡ç®—ä¸€ç»„ç‰Œçš„æ€»åˆ†
    calculateTotalScore: (cards) => {
        return cards.reduce((sum, c) => sum + CardRules.getCardScore(c), 0);
    },

    // è·å–ç‰Œçš„èŠ±è‰² (0-3)
    getSuit: (cardVal) => {
        const normalized = cardVal % 54;
        if (normalized >= 52) return -1; // ç‹æ²¡æœ‰èŠ±è‰²
        return Math.floor(normalized / 13);
    },

    // 2. æ ¸å¿ƒï¼šç‰Œå‹åˆ†æ
    analyze: (cards, deckCount = 1) => {
        const len = cards.length;
        if (len === 0) return { type: 'EMPTY' };

        // æ’åºï¼šç‚¹æ•°ä»å°åˆ°å¤§
        const points = cards.map(CardRules.getPoint).sort((a, b) => a - b);
        
        // ç»Ÿè®¡ç‚¹æ•°é¢‘ç‡ { point: count }
        const counts = {};
        points.forEach(p => { counts[p] = (counts[p] || 0) + 1; });
        const uniquePoints = Object.keys(counts).map(Number).sort((a,b)=>a-b);
        
        // --- éç‚¸å¼¹ç‰Œå‹ ---

        // å•å¼ 
        if (len === 1) return { type: 'SINGLE', val: points[0], level: 0 };

        // å¯¹å­
        if (len === 2 && points[0] === points[1]) {
            return { type: 'PAIR', val: points[0], level: 0 };
        }

        // ä¸‰å¼  (ä¸å¸¦) - ä¹Ÿå¯ä»¥çœ‹ä½œæ˜¯é•¿åº¦ä¸º3çš„é£æœºï¼Œä½†ä¸ºäº†å…¼å®¹æ€§ä¿ç•™ä¸º TRIPLE
        if (len === 3 && uniquePoints.length === 1) {
            return { type: 'TRIPLE', val: points[0], level: 0 };
        }

        // è¿å¯¹ (Liandui)
        if (len >= 4 && len % 2 === 0) {
            // ç®€å•æ ¡éªŒï¼šä¸å«2å’Œç‹
            if (!points.some(p => p >= 15)) {
                let isLiandui = true;
                // æ£€æŸ¥æ˜¯å¦æ˜¯è¿ç»­çš„å¯¹å­ (3344, 334455)
                // æ¡ä»¶1: å»é‡åçš„æ•°é‡è¦æ˜¯æ€»å¼ æ•°çš„ä¸€åŠ (è¯´æ˜å…¨æ˜¯æˆå¯¹çš„)
                if (uniquePoints.length === len / 2) {
                     // æ¡ä»¶2: æ¯å¼ ç‰Œå¿…é¡»å‡ºç°2æ¬¡ (é¿å… 3333 è¿™ç§è¢«è¯¯åˆ¤ä¸ºè¿å¯¹ï¼Œè™½ç„¶3333æ˜¯ç‚¸å¼¹é€»è¾‘ä¼šä¼˜å…ˆï¼Œä½†ä»¥é˜²ä¸‡ä¸€)
                     for (let p of uniquePoints) {
                         if (counts[p] !== 2) isLiandui = false;
                     }

                     // æ¡ä»¶3: æ£€æŸ¥ uniquePoints æ˜¯å¦è¿ç»­
                     for(let i=0; i<uniquePoints.length-1; i++) {
                         if(uniquePoints[i+1] !== uniquePoints[i]+1) isLiandui = false;
                     }
                     
                     if (isLiandui) return { type: 'LIANDUI', val: points[0], len: len, level: 0 };
                }
            }
        }

        // [æ–°å¢] é£æœº (Airplane) - è¿ç»­çš„ä¸‰ä¸å¸¦
        // è§„åˆ™ï¼šè‡³å°‘2ä¸ªè¿ç»­çš„ä¸‰å¼  (len >= 6)ï¼Œä¸”æ˜¯3çš„å€æ•°
        if (len >= 6 && len % 3 === 0) {
            // ç®€å•æ ¡éªŒï¼šä¸å«2å’Œç‹ (é€šå¸¸é¡ºå­ç±»ç‰Œå‹ä¸åˆ°2)
            if (!points.some(p => p >= 15)) {
                let isAirplane = true;
                
                // æ¡ä»¶1: å»é‡åçš„æ•°é‡åº”è¯¥æ˜¯æ€»å¼ æ•°çš„ 1/3 (ä¾‹å¦‚ 333444ï¼Œ6å¼ ç‰Œï¼Œå»é‡æ˜¯3,4 ä¸¤ä¸ªæ•°)
                if (uniquePoints.length === len / 3) {
                    // æ¡ä»¶2: æ¯ä¸ªç‚¹æ•°å¿…é¡»å‡ºç°æ­£å¥½3æ¬¡
                    for (let p of uniquePoints) {
                        if (counts[p] !== 3) isAirplane = false;
                    }

                    // æ¡ä»¶3: è¿ç»­æ€§æ£€æŸ¥
                    for(let i=0; i<uniquePoints.length-1; i++) {
                        if(uniquePoints[i+1] !== uniquePoints[i]+1) isAirplane = false;
                    }

                    if (isAirplane) return { type: 'AIRPLANE', val: points[0], len: len, level: 0 };
                }
            }
        }

        // --- ç‚¸å¼¹ç‰Œå‹ (Level 1-5) ---

        // Level 1 & 2: 510K
        if (len === 3) {
            const has5 = points.includes(5);
            const has10 = points.includes(10);
            const hasK = points.includes(13);
            if (has5 && has10 && hasK) {
                // æ£€æŸ¥èŠ±è‰²
                const suits = cards.map(CardRules.getSuit);
                const isPure = (suits[0] === suits[1] && suits[1] === suits[2]);
                if (isPure) {
                    return { type: '510K_PURE', val: suits[0], level: 2 }; // çº¯510K (Level 2)
                } else {
                    return { type: '510K_MIXED', val: 0, level: 1 }; // æ‚510K (Level 1)
                }
            }
        }

        // Level 3: æ™®é€šç‚¸å¼¹ (>=4å¼ )
        if (uniquePoints.length === 1 && len >= 4) {
            // Level 5: è‡³å°Šæ»¡ç‚¸ (Rankæ•°é‡ == DECK_COUNT * 4)
            if (len === deckCount * 4) {
                 return { type: 'BOMB_MAX', val: points[0], level: 5 };
            }
            // æ™®é€šç‚¸å¼¹
            return { type: 'BOMB_STD', val: points[0], len: len, level: 3 };
        }

        // Level 4: å¤©ç‹ç‚¸ (æ‰€æœ‰ç‹)
        const isAllJokers = points.every(p => p >= 16);
        if (isAllJokers && len === deckCount * 2) {
            return { type: 'BOMB_KING', val: 999, level: 4 };
        }

        return { type: 'INVALID' };
    },

    // 3. æ ¡éªŒèƒ½å¦ç®¡ç‰Œ
    canPlay: (newCards, lastCards, deckCount) => {
        const newHand = CardRules.analyze(newCards, deckCount);
        if (newHand.type === 'INVALID') return false;

        // è‡ªç”±å‡ºç‰Œ
        if (!lastCards || lastCards.length === 0) return true;

        const lastHand = CardRules.analyze(lastCards, deckCount);

        // A. ç‚¸å¼¹ vs éç‚¸å¼¹
        if (newHand.level > 0 && lastHand.level === 0) return true;
        if (newHand.level === 0 && lastHand.level > 0) return false;

        // B. ç‚¸å¼¹ä¹‹é—´ (Level æ¯”è¾ƒ)
        if (newHand.level > 0 && lastHand.level > 0) {
            if (newHand.level > lastHand.level) return true;
            if (newHand.level < lastHand.level) return false;

            // åŒçº§åˆ«æ¯”è¾ƒ
            if (newHand.type === '510K_MIXED') return false; // äº’ä¸ç®¡
            if (newHand.type === '510K_PURE') return false; 

            if (newHand.type === 'BOMB_STD') {
                if (newHand.len > lastHand.len) return true;
                if (newHand.len < lastHand.len) return false;
                return newHand.val > lastHand.val;
            }
            
            if (newHand.type === 'BOMB_MAX') return newHand.val > lastHand.val;
            return false;
        }

        // C. éç‚¸å¼¹ä¹‹é—´ (åŒç‰Œå‹æ¯”è¾ƒ)
        if (newHand.type === lastHand.type) {
            // è¿å¯¹å’Œé£æœºå¿…é¡»å¼ æ•°ä¸€è‡´æ‰èƒ½æ¯”è¾ƒ
            if ((newHand.type === 'LIANDUI' || newHand.type === 'AIRPLANE') && newHand.len !== lastHand.len) return false;
            
            // å¿…é¡»å¼ æ•°ä¸€è‡´
            if (newCards.length !== lastCards.length) return false;
            
            // æ¯”è¾ƒæœ€å°çš„é‚£ä¸ªç‚¹æ•° (val)
            return newHand.val > lastHand.val;
        }

        return false;
    }
};

module.exports = CardRules;

================================================================================
FILE PATH: server\game\Deck.js
================================================================================
// ç‰Œåº“ç”Ÿæˆä¸æ´—ç‰Œ


class Deck {
    constructor(deckCount = 1) {
        this.deck = [];
        // ç”Ÿæˆå¤šå‰¯ç‰Œã€‚æ¯å‰¯ç‰Œæ˜¯ 0-53ã€‚
        // æˆ‘ä»¬ä½¿ç”¨ i + d * 54 æ¥ä¿è¯æ¯å¼ ç‰Œæœ‰å”¯ä¸€IDï¼Œæ–¹ä¾¿å‰ç«¯æ¸²æŸ“ Key å€¼
        for (let d = 0; d < deckCount; d++) {
             for (let i = 0; i < 54; i++) {
                this.deck.push(i + d * 54); 
            }
        }
    }

    shuffle() {
        // Fisher-Yates æ´—ç‰Œç®—æ³•
        for (let i = this.deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
        }
    }

    deal(playerCount) {
        this.shuffle();
        const hands = {};
        const totalCards = this.deck.length;
        const cardsPerPlayer = Math.floor(totalCards / playerCount); 
        
        for (let i = 0; i < playerCount; i++) {
            hands[i] = this.deck.slice(i * cardsPerPlayer, (i + 1) * cardsPerPlayer);
            // å°†å¤šä½™çš„ç‰Œå‘ç»™æœ€åä¸€ä¸ªäººï¼ˆç®€åŒ–å¤„ç†ï¼‰
            if (i === playerCount - 1) {
                 hands[i] = this.deck.slice(i * cardsPerPlayer);
            }
        }
        return hands;
    }
}

module.exports = Deck;

================================================================================
FILE PATH: server\game\GameManager.js
================================================================================
const CardRules = require('./CardRules');
const Deck = require('./Deck');
const BotLogic = require('./BotLogic');

class GameManager {
    constructor(roomConfig, players, io, roomId) {
        this.config = roomConfig;
        this.players = players; 
        this.io = io; 
        this.roomId = roomId;

        this.grandScores = {};
        this.players.forEach(p => this.grandScores[p.id] = 0);
        this.lastWinnerId = null;
        this.gameState = null; 
        
        this.timer = null;
        this.botTimer = null;
        this.turnStartTime = 0; 
    }

    // [æ–°å¢] åˆ‡æ¢æ‰˜ç®¡çŠ¶æ€
    toggleAutoPlay(playerId) {
        const player = this.players.find(p => p.id === playerId);
        if (!player || player.isBot) return; 

        player.isAutoPlay = !player.isAutoPlay;
        
        if (this.gameState && this.players[this.gameState.currentTurnIndex].id === playerId) {
            if (player.isAutoPlay) {
                this._checkAndRunBot();
            } else {
                if (this.botTimer) {
                    clearTimeout(this.botTimer);
                    this.botTimer = null;
                }
                this._resetTimer();
            }
        }
    }

    startRound(isNextRound = false) {
        if (!isNextRound) {
            this.players.forEach(p => this.grandScores[p.id] = 0);
            this.lastWinnerId = null;
        }

        const deck = new Deck(this.config.deckCount);
        const hands = deck.deal(this.players.length);

        let startIndex = 0;
        if (this.lastWinnerId) {
            const winnerIdx = this.players.findIndex(p => p.id === this.lastWinnerId);
            if (winnerIdx !== -1) startIndex = winnerIdx;
        }

        this.gameState = {
            hands: {},
            currentTurnIndex: startIndex,
            lastPlayedCards: [],    
            consecutivePasses: 0,   
            roundPoints: {},        
            pendingTablePoints: 0,  
            roundWinnerId: null, 
            finishedRank: [],    
        };

        this.players.forEach((p, index) => {
            this.gameState.hands[p.id] = hands[index];
            this.gameState.roundPoints[p.id] = 0;
        });

        this._resetTimer();
        this._checkAndRunBot();

        return {
            startPlayerIndex: startIndex,
            startPlayerId: this.players[startIndex].id,
            hands: this.gameState.hands
        };
    }

    _checkAndRunBot() {
        if (!this.gameState) return;
        
        if (this.botTimer) {
            clearTimeout(this.botTimer);
            this.botTimer = null;
        }

        if (this._getActivePlayerCount() <= 1 && this.gameState.lastPlayedCards.length === 0) return;

        const currPlayer = this.players[this.gameState.currentTurnIndex];
        const isAI = currPlayer.isBot || currPlayer.isAutoPlay;

        if (isAI && this.gameState.hands[currPlayer.id].length > 0) {
            const delay = 1000 + Math.random() * 1000;
            this.botTimer = setTimeout(() => {
                this._executeBotTurn(currPlayer);
            }, delay);
        }
    }

    _executeBotTurn(botPlayer) {
        if (!this.gameState) return;
        if (this.players[this.gameState.currentTurnIndex].id !== botPlayer.id) return;

        try {
            const hand = this.gameState.hands[botPlayer.id];
            if (!hand || hand.length === 0) {
                 this._advanceTurn(); 
                 return;
            }

            const isNewRound = this.gameState.lastPlayedCards.length === 0;
            const cardsToBeat = isNewRound ? [] : this.gameState.lastPlayedCards;

            const sortedHand = [...hand].sort((a,b) => CardRules.getPoint(a) - CardRules.getPoint(b));
            
            const cardsToPlay = BotLogic.decideMove(sortedHand, cardsToBeat, this.config.deckCount);

            if (cardsToPlay) {
                console.log(`[Bot/Auto] ${botPlayer.name} plays ${cardsToPlay.length} cards.`);
                const result = this.playCards(botPlayer.id, cardsToPlay);
                
                if (result.success) {
                    // [ä¿®å¤] å…³é”®ä¿®å¤ï¼šå¦‚æœæ˜¯çœŸå®ç©å®¶æ‰˜ç®¡ï¼Œå¿…é¡»å‘é€æ‰‹ç‰Œæ›´æ–°äº‹ä»¶ï¼Œå¦åˆ™å®¢æˆ·ç«¯çœ‹ä¸åˆ°ç‰Œå°‘äº†
                    if (!botPlayer.isBot) {
                        this.io.to(botPlayer.id).emit('hand_update', this.gameState.hands[botPlayer.id]);
                    }

                    if (result.isRoundOver) {
                        this._handleWin(result, botPlayer.id);
                    } else {
                        const publicState = this.getPublicState();
                        this.io.to(this.roomId).emit('game_state_update', publicState);
                    }
                } else {
                    console.error(`[Bot Error] Play failed: ${result.error}`);
                    if (!isNewRound) this.passTurn(botPlayer.id);
                }
            } else {
                console.log(`[Bot/Auto] ${botPlayer.name} passes.`);
                const result = this.passTurn(botPlayer.id);
                if (result.success) {
                    const publicState = this.getPublicState();
                    publicState.infoText = isNewRound ? '' : 'PASS';
                    this.io.to(this.roomId).emit('game_state_update', publicState);
                }
            }
        } catch (error) {
            console.error(`[Bot Error] Exception in _executeBotTurn:`, error);
        }
    }

    _handleWin(result, winnerId) {
        const rInfo = result.roundResult;
        if (rInfo.isGrandOver) {
            this.io.to(this.roomId).emit('grand_game_over', { 
                grandWinner: rInfo.roundWinnerName, 
                grandScores: rInfo.grandScores 
            });
            this.gameState = null; 
            this._clearTimer(); 
        } else {
            this.io.to(this.roomId).emit('round_over', {
                roundWinner: rInfo.roundWinnerName,
                pointsEarned: rInfo.pointsEarned,
                detail: rInfo.detail,
                grandScores: rInfo.grandScores
            });
            this._clearTimer();
        }
    }

    playCards(playerId, cards) {
        if (!this.gameState) return { success: false, error: 'æ¸¸æˆæœªå¼€å§‹' };

        const currPlayer = this.players[this.gameState.currentTurnIndex];
        if (currPlayer.id !== playerId) return { success: false, error: 'è¿˜æ²¡è½®åˆ°ä½ ' };

        const playerHand = this.gameState.hands[playerId];
        if (!this._handContainsCards(playerHand, cards)) {
            return { success: false, error: 'æ‰‹ç‰Œä¸è¶³æˆ–æ•°æ®ä¸åŒæ­¥' };
        }

        const isNewRound = this.gameState.lastPlayedCards.length === 0;
        const cardsToBeat = isNewRound ? [] : this.gameState.lastPlayedCards;

        if (!CardRules.canPlay(cards, cardsToBeat, this.config.deckCount)) {
            return { success: false, error: 'ç‰Œå‹ä¸ç¬¦æˆ–ç®¡ä¸ä¸Š' };
        }

        this._removeCardsFromHand(playerId, cards);
        this.gameState.pendingTablePoints += CardRules.calculateTotalScore(cards);
        this.gameState.lastPlayedCards = cards;
        this.gameState.consecutivePasses = 0;
        this.gameState.roundWinnerId = playerId;

        const isFinished = this.gameState.hands[playerId].length === 0;
        if (isFinished) {
            if (!this.gameState.finishedRank.includes(playerId)) {
                this.gameState.finishedRank.push(playerId);
            }
        }

        const activeCount = this._getActivePlayerCount();
        
        if (activeCount <= 1) {
            this._clearTimer();
            const roundResult = this._concludeRound();
            return { 
                success: true, 
                isRoundOver: true,
                roundResult,
                cardsPlayed: cards,
                pendingPoints: this.gameState.pendingTablePoints
            };
        }

        this._advanceTurn();
        this._resetTimer();
        this._checkAndRunBot();

        return { 
            success: true, 
            isRoundOver: false,
            cardsPlayed: cards,
            pendingPoints: this.gameState.pendingTablePoints
        };
    }

    passTurn(playerId) {
        if (!this.gameState) return { success: false, error: 'æ¸¸æˆæœªå¼€å§‹' };

        const currPlayer = this.players[this.gameState.currentTurnIndex];
        if (currPlayer.id !== playerId) return { success: false, error: 'è¿˜æ²¡è½®åˆ°ä½ ' };

        if (this.gameState.lastPlayedCards.length === 0) {
            return { success: false, error: 'å¿…é¡»å‡ºç‰Œ' };
        }

        this.gameState.consecutivePasses++;
        this._advanceTurn(); 

        const winnerHand = this.gameState.hands[this.gameState.roundWinnerId];
        const winnerIsActive = winnerHand && winnerHand.length > 0;
        const activeCount = this._getActivePlayerCount();
        
        const passesNeeded = winnerIsActive ? (activeCount - 1) : activeCount;

        let turnCleared = false;
        if (this.gameState.consecutivePasses >= passesNeeded) {
            const wId = this.gameState.roundWinnerId;
            if (wId) {
                this.gameState.roundPoints[wId] = (this.gameState.roundPoints[wId] || 0) + this.gameState.pendingTablePoints;
                this.gameState.pendingTablePoints = 0;
                
                if (this.gameState.hands[wId].length > 0) {
                     const wIdx = this.players.findIndex(p => p.id === wId);
                     this.gameState.currentTurnIndex = wIdx;
                }
            }
            
            this.gameState.lastPlayedCards = [];
            this.gameState.consecutivePasses = 0;
            turnCleared = true;
        }

        this._resetTimer(); 
        this._checkAndRunBot();

        return { success: true, turnCleared };
    }

    _clearTimer() {
        if (this.timer) clearTimeout(this.timer);
        if (this.botTimer) clearTimeout(this.botTimer);
        this.timer = null;
        this.botTimer = null;
    }

    _resetTimer() {
        this._clearTimer();
        if (this.gameState && this._getActivePlayerCount() > 1) {
            this.turnStartTime = Date.now();
            const timeLimit = this.config.turnTimeout || 60000;
            this.timer = setTimeout(() => {
                this._handleTimeout();
            }, timeLimit);
        }
    }

    _handleTimeout() {
        if (!this.gameState) return;
        const currIdx = this.gameState.currentTurnIndex;
        const currPlayer = this.players[currIdx];
        
        console.log(`[Timeout] Player ${currPlayer.name} (${currPlayer.id}) timed out.`);
        const isNewRound = this.gameState.lastPlayedCards.length === 0;

        if (isNewRound) {
            const hand = this.gameState.hands[currPlayer.id];
            if (!hand || hand.length === 0) { this._advanceTurn(); return; }

            const sorted = hand.map(c => ({ id: c, val: CardRules.getPoint(c) })).sort((a, b) => a.val - b.val);
            const cardToPlay = [sorted[0].id]; 
            
            const result = this.playCards(currPlayer.id, cardToPlay);
            if (result.success) {
                this.io.to(currPlayer.id).emit('hand_update', this.gameState.hands[currPlayer.id]);
                
                if (result.isRoundOver) {
                     this._handleWin(result, currPlayer.id);
                } else {
                     const publicState = this.getPublicState();
                     publicState.infoText = `${currPlayer.name} è¶…æ—¶ï¼Œç³»ç»Ÿä»£æ‰“`;
                     this.io.to(this.roomId).emit('game_state_update', publicState);
                }
            }
        } else {
            const result = this.passTurn(currPlayer.id);
            if (result.success) {
                const publicState = this.getPublicState();
                publicState.infoText = `${currPlayer.name} è¶…æ—¶ï¼Œè‡ªåŠ¨è¿‡ç‰Œ`;
                this.io.to(this.roomId).emit('game_state_update', publicState);
            }
        }
    }

    _getActivePlayerCount() {
        if (!this.gameState) return 0;
        let count = 0;
        for (const p of this.players) {
            if (this.gameState.hands[p.id] && this.gameState.hands[p.id].length > 0) {
                count++;
            }
        }
        return count;
    }

    _advanceTurn() {
        const playerCount = this.players.length;
        let nextIndex = this.gameState.currentTurnIndex;
        let attempts = 0;
        do {
            nextIndex = (nextIndex + 1) % playerCount;
            attempts++;
        } while (
            this.gameState.hands[this.players[nextIndex].id].length === 0 && 
            attempts < playerCount 
        );
        this.gameState.currentTurnIndex = nextIndex;
    }

    getPublicState() {
        if (!this.gameState) return null;
        
        const currentScoresDisplay = {};
        const playersInfo = {};
        
        this.players.forEach(p => {
            currentScoresDisplay[p.id] = (this.grandScores[p.id] || 0) + (this.gameState.roundPoints[p.id] || 0);
            playersInfo[p.id] = { isBot: p.isBot, isAutoPlay: p.isAutoPlay };
        });

        const winnerObj = this.players.find(p => p.id === this.gameState.roundWinnerId);

        let remainingSeconds = 0;
        if (this.turnStartTime) {
            const timeLimit = this.config.turnTimeout || 60000;
            const elapsed = Date.now() - this.turnStartTime;
            remainingSeconds = Math.max(0, Math.ceil((timeLimit - elapsed) / 1000));
        }
        
        return {
            turnIndex: this.gameState.currentTurnIndex,
            currentTurnId: this.players[this.gameState.currentTurnIndex].id,
            turnRemaining: remainingSeconds, 
            lastPlayed: this.gameState.lastPlayedCards,
            lastPlayerName: winnerObj ? winnerObj.name : '',
            scores: currentScoresDisplay,
            pendingPoints: this.gameState.pendingTablePoints,
            finishedRank: this.gameState.finishedRank,
            playersInfo: playersInfo 
        };
    }

    reconnectPlayer(oldId, newId) {
        if (this.grandScores[oldId] !== undefined) {
            this.grandScores[newId] = this.grandScores[oldId];
            delete this.grandScores[oldId];
        }
        if (this.lastWinnerId === oldId) this.lastWinnerId = newId;

        const player = this.players.find(p => p.id === newId);
        if (player) player.isAutoPlay = false;

        if (this.gameState) {
            if (this.gameState.hands[oldId]) {
                this.gameState.hands[newId] = this.gameState.hands[oldId];
                delete this.gameState.hands[oldId];
            }
            if (this.gameState.roundPoints[oldId] !== undefined) {
                this.gameState.roundPoints[newId] = this.gameState.roundPoints[oldId];
                delete this.gameState.roundPoints[oldId];
            }
            if (this.gameState.roundWinnerId === oldId) this.gameState.roundWinnerId = newId;
            
            const rankIdx = this.gameState.finishedRank.indexOf(oldId);
            if (rankIdx !== -1) {
                this.gameState.finishedRank[rankIdx] = newId;
            }
        }
        return true;
    }

    _handContainsCards(hand, cardsToPlay) {
        const tempHand = [...hand];
        for (let c of cardsToPlay) {
            const idx = tempHand.indexOf(c);
            if (idx === -1) return false;
            tempHand.splice(idx, 1);
        }
        return true;
    }

    _removeCardsFromHand(playerId, cards) {
        const newHand = [...this.gameState.hands[playerId]];
        for (let c of cards) {
            const idx = newHand.indexOf(c);
            if (idx !== -1) newHand.splice(idx, 1);
        }
        this.gameState.hands[playerId] = newHand;
    }

    // [æ ¸å¿ƒä¿®æ”¹] ç»“ç®—é€»è¾‘ï¼šå¢åŠ æ’åèµç½š
    _concludeRound() {
        const lastPlayer = this.players.find(p => this.gameState.hands[p.id].length > 0);
        if (lastPlayer) {
            this.gameState.finishedRank.push(lastPlayer.id);
        }
        
        // 1. å¤„ç†æœ€åä¸€è½®çš„æ¡Œé¢åˆ†
        const wId = this.gameState.roundWinnerId;
        if (wId) {
             this.gameState.roundPoints[wId] = (this.gameState.roundPoints[wId] || 0) + this.gameState.pendingTablePoints;
             this.gameState.pendingTablePoints = 0;
        }

        // 2. æ„é€ å®Œæ•´æ’å (å·²è·‘å®Œ + å‰©ä½™ç©å®¶)
        // å®é™…ä¸Šåœ¨ activeCount <= 1 æ—¶ï¼Œå‰©ä¸‹çš„é‚£ä¸ªç©å®¶ä¹Ÿå·²ç»è¢« push åˆ° finishedRank é‡Œäº†(é€šè¿‡ä¸Šé¢çš„ lastPlayer é€»è¾‘)
        // ä½†ä¸ºäº†ä¿é™©ï¼Œæˆ‘ä»¬ç”¨ Set å»é‡ç¡®ä¿å®Œæ•´æ€§
        const fullRankIds = [...this.gameState.finishedRank];
        this.players.forEach(p => {
            if (!fullRankIds.includes(p.id)) fullRankIds.push(p.id);
        });

        const firstWinnerId = fullRankIds[0];
        this.lastWinnerId = firstWinnerId;

        let logLines = [];

        // 3. è§„åˆ™ä¸€ï¼šå‰©ä½™æ‰‹ç‰Œç½šåˆ† (åŸæœ‰é€»è¾‘)
        let totalCardPenalty = 0;
        let cardPenaltyDetail = "";

        this.players.forEach(p => {
            const handPts = CardRules.calculateTotalScore(this.gameState.hands[p.id]);
            if (handPts > 0) {
                totalCardPenalty += handPts;
                cardPenaltyDetail += `${p.name}-${handPts} `;
            }
            // å…ˆç´¯åŠ æ¡Œé¢åˆ†
            this.grandScores[p.id] += (this.gameState.roundPoints[p.id] || 0);
        });

        if (firstWinnerId && totalCardPenalty > 0) {
            this.grandScores[firstWinnerId] += totalCardPenalty;
            logLines.push(`[æ‰‹ç‰Œç½šåˆ†] è¾“å®¶å…±è®¡ ${totalCardPenalty} åˆ†ï¼Œå½’ç¬¬ä¸€å ${this.players.find(p=>p.id===firstWinnerId)?.name}ã€‚`);
        }

        // 4. [æ–°å¢] è§„åˆ™äºŒï¼šæ’åèµç½š (Rank Penalty)
        if (this.config.enableRankPenalty && this.config.rankPenaltyScores && this.config.rankPenaltyScores.length > 0) {
            const penaltyConfig = this.config.rankPenaltyScores;
            const playerCount = fullRankIds.length;
            
            // éå†é…ç½®ï¼š[30, 15] å¯¹åº” (ç¬¬ä¸€vså€’ä¸€), (ç¬¬äºŒvså€’äºŒ)
            penaltyConfig.forEach((score, index) => {
                const winnerIndex = index; // 0, 1
                const loserIndex = playerCount - 1 - index; // N-1, N-2

                // åªæœ‰å½“èµ¢å®¶ç´¢å¼•å°äºè¾“å®¶ç´¢å¼•æ—¶æ‰æ‰§è¡Œ (é¿å…å¥‡æ•°äººæ•°ä¸­é—´æ’è½¦)
                if (winnerIndex < loserIndex) {
                    const winnerId = fullRankIds[winnerIndex];
                    const loserId = fullRankIds[loserIndex];
                    
                    if (winnerId && loserId) {
                        this.grandScores[winnerId] += score;
                        this.grandScores[loserId] -= score;

                        const wName = this.players.find(p=>p.id===winnerId)?.name;
                        const lName = this.players.find(p=>p.id===loserId)?.name;
                        logLines.push(`[æ’åèµç½š] ç¬¬${winnerIndex+1}å ${wName} æ”¶å– å€’æ•°ç¬¬${index+1}å ${lName} ${score} åˆ†ã€‚`);
                    }
                }
            });
        }

        const firstWinnerName = this.players.find(p => p.id === firstWinnerId)?.name || 'æœªçŸ¥';
        const isGrandOver = this.grandScores[firstWinnerId] >= this.config.targetScore;
        const totalPointsEarned = (this.gameState.roundPoints[firstWinnerId] || 0) + totalCardPenalty;

        return {
            roundWinnerName: firstWinnerName,
            pointsEarned: totalPointsEarned, 
            detail: logLines.join('\n') || 'å®Œç¾ç»“æŸï¼Œæ— é¢å¤–ç½šåˆ†', // ç”¨æ¢è¡Œç¬¦è¿æ¥
            grandScores: this.grandScores,
            isGrandOver
        };
    }
    
    getPlayerHand(playerId) {
        if (!this.gameState || !this.gameState.hands) return [];
        return this.gameState.hands[playerId] || [];
    }
}

module.exports = GameManager;

================================================================================
FILE PATH: server\index.js
================================================================================
// ç¨‹åºå…¥å£ï¼Œåªè´Ÿè´£å¯åŠ¨æœåŠ¡å’Œ Socket ç›‘å¬
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const cors = require('cors');
const path = require('path');

// å¼•å…¥æ¨¡å—
const GameManager = require('./game/GameManager');

const app = express();
app.use(cors());

const server = http.createServer(app);
const io = new Server(server, {
    cors: { origin: "*", methods: ["GET", "POST"] }
});

// å†…å­˜æ•°æ®åº“
const rooms = {}; 

/**
 * è¾…åŠ©å‡½æ•°ï¼šå‘æˆ¿é—´å†…æ‰€æœ‰äººå¹¿æ’­æœ€æ–°çŠ¶æ€
 */
function broadcastGameState(io, roomId, room, infoText = null) {
    if (!room.gameManager) return;
    
    // ä» GameManager è·å–çº¯å‡€çš„ UI å±•ç¤ºæ•°æ®
    const publicState = room.gameManager.getPublicState();
    if (!publicState) return;

    if (infoText) publicState.infoText = infoText;

    io.to(roomId).emit('game_state_update', publicState);
}

io.on('connection', (socket) => {
    console.log(`[Connect] ${socket.id}`);
    socket.emit('your_id', socket.id);

    // --- åˆ›å»ºæˆ¿é—´ ---
    socket.on('create_room', ({ roomId, username, config }) => {
        if (rooms[roomId]) return socket.emit('error_msg', 'æˆ¿é—´å·²å­˜åœ¨');
        
        const cleanName = String(username || '').trim();
        if (!cleanName) return socket.emit('error_msg', 'ç”¨æˆ·åä¸èƒ½ä¸ºç©º');

        const roomConfig = { deckCount: 1, maxPlayers: 3, targetScore: 500, ...config };
        
        rooms[roomId] = {
            config: roomConfig,
            players: [],
            gameManager: null,
            destroyTimer: null 
        };
        
        socket.join(roomId);
        rooms[roomId].players.push({ id: socket.id, name: cleanName, isHost: true, online: true });
        
        const initialScores = {};
        rooms[roomId].players.forEach(p => initialScores[p.id] = 0);

        const data = { roomId, config: roomConfig, players: rooms[roomId].players, grandScores: initialScores };
        socket.emit('room_info', data); 
        io.to(roomId).emit('room_info', data);
    });

    // --- åŠ å…¥æˆ¿é—´ ---
    socket.on('join_room', ({ roomId, username }) => {
        const room = rooms[roomId];
        if (!room) return socket.emit('error_msg', 'æˆ¿é—´ä¸å­˜åœ¨');

        const cleanName = String(username || '').trim();
        if (!cleanName) return socket.emit('error_msg', 'ç”¨æˆ·åä¸èƒ½ä¸ºç©º');

        const existingPlayerIndex = room.players.findIndex(p => p.name === cleanName);
        let isReconnect = false;
        let oldSocketId = null;

        if (existingPlayerIndex !== -1) {
            const existingPlayer = room.players[existingPlayerIndex];
            
            if (existingPlayer.online) {
                return socket.emit('error_msg', `åå­— "${cleanName}" å·²è¢«ä½¿ç”¨ä¸”ç©å®¶åœ¨çº¿`);
            }

            isReconnect = true;
            oldSocketId = existingPlayer.id;
            console.log(`[Reconnect] Success! ${cleanName} (${oldSocketId} -> ${socket.id})`);

            existingPlayer.id = socket.id;
            existingPlayer.online = true; 

            if (room.destroyTimer) {
                clearTimeout(room.destroyTimer);
                room.destroyTimer = null;
                console.log(`[Room] Destruction cancelled for ${roomId} (player returned)`);
            }

            if (room.gameManager) {
                room.gameManager.reconnectPlayer(oldSocketId, socket.id);
            }
        } else {
            if (room.players.length >= room.config.maxPlayers) {
                return socket.emit('error_msg', 'æˆ¿é—´å·²æ»¡');
            }
            
            socket.join(roomId);
            if (!room.players.find(u => u.id === socket.id)) {
                room.players.push({ id: socket.id, name: cleanName, isHost: false, online: true });
            }
        }

        socket.join(roomId);
        
        let currentGrandScores = {};
        if (room.gameManager) {
            currentGrandScores = room.gameManager.grandScores;
        } else {
            room.players.forEach(p => currentGrandScores[p.id] = 0);
        }
        
        const data = { roomId, config: room.config, players: room.players, grandScores: currentGrandScores };
        
        socket.emit('room_info', data);

        const isGameRunning = room.gameManager && room.gameManager.gameState;
        if (!isGameRunning) {
            socket.to(roomId).emit('room_info', data);
        }

        if (isGameRunning) {
            if (isReconnect) {
                const hand = room.gameManager.getPlayerHand(socket.id);
                socket.emit('game_started', { 
                    hand: hand, 
                    grandScores: room.gameManager.grandScores 
                });
            }
            broadcastGameState(io, roomId, room);
        }
    });
    
    // æ·»åŠ æœºå™¨äºº
    socket.on('add_bot', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room) return;
        
        if (room.players.length >= room.config.maxPlayers) return socket.emit('error_msg', 'æˆ¿é—´å·²æ»¡');
        
        const botId = `bot_${Date.now()}_${Math.floor(Math.random()*1000)}`;
        const botName = `Robot ${Math.floor(Math.random()*100)}`;
        
        room.players.push({ 
            id: botId, 
            name: botName, 
            isHost: false, 
            online: true,
            isBot: true 
        });
        
        const currentGrandScores = room.gameManager ? room.gameManager.grandScores : {};
        currentGrandScores[botId] = 0;

        const data = { roomId, config: room.config, players: room.players, grandScores: currentGrandScores };
        io.to(roomId).emit('room_info', data);
    });

    // [æ–°å¢] åˆ‡æ¢æ‰˜ç®¡
    socket.on('toggle_auto_play', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room || !room.gameManager) return;

        room.gameManager.toggleAutoPlay(socket.id);
        broadcastGameState(io, roomId, room);
    });

    // --- æ¸¸æˆæµç¨‹ ---
    const handleGameStart = (roomId, isNextRound) => {
        const room = rooms[roomId];
        if (!room) return;

        if (!isNextRound || !room.gameManager) {
            room.gameManager = new GameManager(room.config, room.players, io, roomId);
        }

        const startInfo = room.gameManager.startRound(isNextRound);

        room.players.forEach((p) => {
            if (!p.isBot) { 
                const hand = startInfo.hands[p.id];
                io.to(p.id).emit('game_started', { 
                    hand: hand, 
                    grandScores: room.gameManager.grandScores 
                });
            }
        });

        const startPlayerName = room.players[startInfo.startPlayerIndex].name;
        const msg = isNextRound 
            ? `æ–°ä¸€è½®å¼€å§‹ï¼ç”± ${startPlayerName} å…ˆå‡º` 
            : `æ¸¸æˆå¼€å§‹ï¼ç›®æ ‡ ${room.config.targetScore} åˆ†`;
        
        broadcastGameState(io, roomId, room, msg);
    };

    socket.on('start_game', ({ roomId }) => handleGameStart(roomId, false));
    socket.on('next_round', ({ roomId }) => handleGameStart(roomId, true));

    // --- å‡ºç‰Œ ---
    socket.on('play_cards', ({ roomId, cards }) => {
        const room = rooms[roomId];
        if (!room || !room.gameManager) return;
        
        const result = room.gameManager.playCards(socket.id, cards);

        if (!result.success) {
            return socket.emit('play_error', result.error);
        }

        const currentHand = room.gameManager.gameState.hands[socket.id];
        io.to(socket.id).emit('hand_update', currentHand);

        if (result.isWin) {
            const rInfo = result.roundResult;
            if (rInfo.isGrandOver) {
                io.to(roomId).emit('grand_game_over', { 
                    grandWinner: rInfo.roundWinnerName, 
                    grandScores: rInfo.grandScores 
                });
                room.gameManager = null; 
            } else {
                io.to(roomId).emit('round_over', {
                    roundWinner: rInfo.roundWinnerName,
                    pointsEarned: rInfo.pointsEarned,
                    detail: rInfo.detail,
                    grandScores: rInfo.grandScores
                });
            }
        } else {
            broadcastGameState(io, roomId, room);
        }
    });

    // --- è¿‡ç‰Œ ---
    socket.on('pass_turn', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room || !room.gameManager) return;

        const result = room.gameManager.passTurn(socket.id);
        
        if (!result.success) return socket.emit('play_error', result.error);

        broadcastGameState(io, roomId, room, "PASS");
    });

    // --- æ–­å¼€è¿æ¥ ---
    socket.on('disconnect', () => {
        Object.keys(rooms).forEach(rId => {
            const r = rooms[rId];
            
            const idx = r.players.findIndex(p => p.id === socket.id);
            if (idx === -1) return; 

            const player = r.players[idx];
            const isGameRunning = r.gameManager && r.gameManager.gameState;

            if (!isGameRunning) {
                r.players.splice(idx, 1);
                console.log(`[Disconnect] Lobby user ${player.name} removed from ${rId}`);
                
                if (r.players.length === 0) {
                    if (r.destroyTimer) clearTimeout(r.destroyTimer);
                    delete rooms[rId];
                    console.log(`[Room] Room ${rId} deleted (empty lobby).`);
                } else {
                    io.to(rId).emit('room_info', { 
                        roomId: rId, 
                        config: r.config, 
                        players: r.players, 
                        grandScores: r.gameManager ? r.gameManager.grandScores : {} 
                    });
                }
            } else {
                player.online = false;
                console.log(`[Disconnect] Game user ${player.name} (${socket.id}) dropped.`);

                const allHumansOffline = r.players.filter(p => !p.isBot).every(p => !p.online);
                
                if (allHumansOffline) {
                    console.log(`[Room] Room ${rId} is empty. Scheduling destruction in 60s...`);
                    
                    if (r.destroyTimer) clearTimeout(r.destroyTimer);
                    
                    r.destroyTimer = setTimeout(() => {
                        if (rooms[rId] && rooms[rId].players.filter(p => !p.isBot).every(p => !p.online)) {
                            delete rooms[rId];
                            console.log(`[Room] Room ${rId} destroyed due to inactivity (game running).`);
                        }
                    }, 60000); 
                }
            }
        });
    });
});



// è¿™ä¸€æ®µçš„æ„æ€æ˜¯ï¼šå¦‚æœæ˜¯åœ¨çº¿ä¸Šç¯å¢ƒï¼Œå°±æŠŠ React æ‰“åŒ…å¥½çš„æ–‡ä»¶(build)å‘ç»™æµè§ˆå™¨
if (process.env.NODE_ENV === 'production') {
    // 1. æŒ‡å®šé™æ€æ–‡ä»¶ç›®å½•
    const buildPath = path.join(__dirname, '../client/dist');
    app.use(express.static(buildPath));
    // 2. ä»»ä½•å…¶ä»–è¯·æ±‚ï¼Œéƒ½è¿”å› index.html
    app.get(/(.*)/, (req, res) => {
        res.sendFile(path.join(__dirname, '../client/dist', 'index.html'));
    });
}

// å¯åŠ¨æœåŠ¡å™¨
const PORT = process.env.PORT || 3001;
server.listen(PORT, () => {
    console.log(`>>> Server Running on port ${PORT}`);
});





================================================================================
FILE PATH: server\package.json
================================================================================
{
  "name": "server",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^5.2.1",
    "nodemon": "^3.1.11",
    "socket.io": "^4.8.1"
  }
}


================================================================================
FILE PATH: server\utils\socketAuth.js
================================================================================
// (å¯é€‰) èº«ä»½éªŒè¯å·¥å…·
