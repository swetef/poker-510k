Project Context Generated at 2025/12/16 14:41:28


================================================================================
FILE PATH: client\eslint.config.js
================================================================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])


================================================================================
FILE PATH: client\index.html
================================================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>client</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>


================================================================================
FILE PATH: client\package.json
================================================================================
{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "lucide-react": "^0.559.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "socket.io-client": "^4.8.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "vite": "npm:rolldown-vite@7.2.5"
  },
  "overrides": {
    "vite": "npm:rolldown-vite@7.2.5"
  }
}


================================================================================
FILE PATH: client\src\App.css
================================================================================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}


================================================================================
FILE PATH: client\src\App.jsx
================================================================================
import React from 'react';
import { GameProvider, useGame } from './context/GameContext.jsx';
import { LoginScreen } from './screens/LoginScreen';
import { LobbyScreen } from './screens/LobbyScreen';
import { GameScreen } from './screens/GameScreen';
import './index.css'; // å…¨å±€æ ·å¼

// å†…å®¹ç»„ä»¶ï¼Œæ¶ˆè´¹ Context
const GameContent = () => {
    const { gameState } = useGame();

    const renderLandscapeHint = () => (
        <div className="landscape-hint">
            <div className="phone-rotate-icon"></div>
            <h3>å»ºè®®ä½¿ç”¨æ¨ªå±æ¸¸ç©</h3>
            <button onClick={(e) => { e.currentTarget.parentElement.style.display = 'none'; }}>
                æˆ‘éè¦ç«–å±ç©
            </button>
        </div>
    );

    return (
        <>
            {renderLandscapeHint()}
            {gameState === 'LOGIN' && <LoginScreen />}
            {gameState === 'LOBBY' && <LobbyScreen />}
            {gameState === 'GAME' && <GameScreen />}
        </>
    );
};

export default function App() {
    return (
        <GameProvider>
            <GameContent />
        </GameProvider>
    );
}

================================================================================
FILE PATH: client\src\components\BaseUI.jsx
================================================================================
// åŸºç¡€UIç»„ä»¶ - ä¿®å¤ç§»åŠ¨ç«¯ç‚¹å‡»æ— æ•ˆã€åŒé‡è§¦å‘é—®é¢˜
import React, { useEffect, useRef } from 'react';
import { Coins, History, Trophy, Flag } from 'lucide-react'; 
import { getCardDisplay } from '../utils/cardLogic';
import { styles } from '../styles';
import CountDownTimer from './CountDownTimer'; 

export const Card = ({ cardVal, index, isSelected, onClick, onMouseEnter, spacing }) => {
    const { suit, text, color, isScore } = getCardDisplay(cardVal);
    
    // [å…³é”®ä¿®å¤] ä½¿ç”¨ Pointer Events ä»£æ›¿ Touch/Mouse äº‹ä»¶
    // PointerDown èƒ½åŒæ—¶å“åº”é¼ æ ‡æŒ‰ä¸‹å’Œæ‰‹æŒ‡æŒ‰ä¸‹ï¼Œä¸”å“åº”é€Ÿåº¦å¿«ï¼Œæ—  300ms å»¶è¿Ÿ
    const handlePointerDown = (e) => {
        // åªæœ‰å·¦é”®ç‚¹å‡»(0)æˆ–è§¦æ‘¸æ—¶è§¦å‘
        if (e.button !== 0 && e.pointerType === 'mouse') return;
        
        // é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œé˜²æ­¢è§¦å‘åç»­çš„å…¼å®¹æ€§é¼ æ ‡äº‹ä»¶
        // ä½†æ³¨æ„ï¼šåœ¨æŸäº›æµè§ˆå™¨ä¸­è¿™å¯èƒ½é˜»æ­¢æ»šåŠ¨ï¼Œæ‰€ä»¥ CSS çš„ touch-action: none é…åˆå¾ˆé‡è¦
        // e.preventDefault(); 
        e.stopPropagation();
        
        // å¦‚æœæ˜¯è§¦æ‘¸è®¾å¤‡ï¼Œç›´æ¥ç”±è¿™é‡Œè§¦å‘ç‚¹å‡»é€»è¾‘
        onClick(cardVal);
    };

    return (
        <div 
            // ç§»é™¤ onTouchStart å’Œ onMouseDownï¼Œç»Ÿä¸€ä½¿ç”¨ onPointerDown
            onPointerDown={handlePointerDown}
            
            // ä¿ç•™ MouseEnter ç”¨äº PC ç«¯æ‹–æ‹½æ»‘é€‰ï¼ˆç§»åŠ¨ç«¯ä¸æ”¯æŒ hover æ‰€ä»¥ä¸ä¼šè§¦å‘ï¼‰
            onMouseEnter={(e) => {
                if (e.pointerType === 'mouse') {
                     onMouseEnter(cardVal);
                }
            }}
            
            style={{
                ...styles.card, 
                color, 
                left: index * spacing, 
                zIndex: index,
                // [ä¼˜åŒ–] é€‰ä¸­æ—¶ä¸Šæµ®é«˜åº¦å¢åŠ ï¼Œæ‰‹æœºä¸Šæ›´å®¹æ˜“çœ‹æ¸…
                transform: isSelected ? 'translateY(-45px)' : 'translateY(0)',
                borderColor: isSelected ? '#3498db' : (isScore ? '#f1c40f' : '#bdc3c7'),
                boxShadow: isSelected ? '0 0 15px rgba(52, 152, 219, 0.6)' : (isScore ? '0 0 8px rgba(241, 196, 15, 0.4)' : '0 -2px 5px rgba(0,0,0,0.1)'),
                // ç¡®ä¿ç§»åŠ¨ç«¯å¯ä»¥æ¥æ”¶ Pointer äº‹ä»¶
                touchAction: 'none' 
            }}
        >
            <div style={{fontSize: 18, fontWeight: 'bold'}}>{text}</div>
            <div style={{fontSize: 36, alignSelf: 'center', marginTop: 5}}>{suit}</div>
            {isScore && <div style={{position:'absolute', bottom:2, right:2, fontSize:14, color:'#f1c40f'}}>â˜…</div>}
        </div>
    );
};

export const MiniCard = ({ cardVal, index }) => {
    const { text, suit, color, isScore } = getCardDisplay(cardVal);
    return (
        <div style={{
            ...styles.miniCard, color,
            border: isScore ? '2px solid #f1c40f' : '1px solid #ccc',
            transform: isScore ? 'scale(1.1) translateY(-10px)' : 'scale(1)',
            zIndex: index
        }}>
            {suit}{text}
        </div>
    );
};

export const PlayerAvatar = ({ player, isTurn, score, targetScore, isMySocket, remainingSeconds, rank }) => {
    const progress = Math.min((score / targetScore) * 100, 100);
    const containerOpacity = rank ? 0.75 : 1; 

    return (
        <div style={{
            ...styles.playerBox,
            borderColor: isTurn ? '#f1c40f' : 'rgba(255,255,255,0.1)',
            transform: isTurn ? 'scale(1.1)' : 'scale(1)',
            boxShadow: isTurn ? '0 0 25px rgba(241, 196, 15, 0.5)' : 'none',
            background: isTurn ? 'rgba(44, 62, 80, 0.9)' : 'rgba(44, 62, 80, 0.6)',
            position: 'relative',
            opacity: containerOpacity
        }}>
            {rank && (
                <div style={{
                    position: 'absolute',
                    top: -15,
                    left: '50%',
                    transform: 'translateX(-50%)',
                    background: rank === 1 ? '#f1c40f' : (rank === 2 ? '#bdc3c7' : '#e67e22'), 
                    color: '#fff',
                    padding: '3px 12px',
                    borderRadius: 20,
                    fontSize: 13,
                    fontWeight: 'bold',
                    boxShadow: '0 4px 10px rgba(0,0,0,0.4)',
                    zIndex: 20,
                    display: 'flex',
                    alignItems: 'center',
                    gap: 4,
                    whiteSpace: 'nowrap',
                    border: '2px solid white'
                }}>
                    {rank === 1 ? <Trophy size={14} fill="white" /> : <Flag size={14} fill="white"/>}
                    {rank === 1 ? 'NO.1' : `NO.${rank}`}
                </div>
            )}

            <div style={styles.avatar}>{player.name[0]}</div>
            <div style={styles.playerName}>{player.name} {isMySocket && '(æˆ‘)'}</div>
            <div style={styles.scoreBarBg}>
                <div style={{...styles.scoreBarFill, width:`${progress}%`, background: progress>=100?'#e74c3c':'#2ecc71'}}></div>
            </div>
            <div style={styles.playerScore}><Coins size={12} color="#f1c40f"/> {score} / {targetScore}</div>
            
            {isTurn && !rank && (
                <CountDownTimer 
                    initialSeconds={remainingSeconds} 
                    totalSeconds={60} 
                />
            )}
        </div>
    );
};

export const GameLogPanel = ({ logs }) => {
    const endRef = useRef(null);
    useEffect(() => { endRef.current?.scrollIntoView({ behavior: 'smooth' }); }, [logs]);

    return (
        <div style={styles.gameLogPanel}>
            <div style={styles.logHeader}>
                <History size={16} color="#f1c40f"/> <span style={{color:'#fff', fontWeight:'bold'}}>å¯¹å±€è®°å½•</span>
            </div>
            <div style={styles.logList}>
                {logs.map((log, i) => (
                    <div key={i} style={styles.logItem}>
                        <span style={styles.logTime}>[{log.time.split(' ')[0]}]</span>
                        <span style={{color: '#eee'}}>{log.text}</span>
                    </div>
                ))}
                <div ref={endRef} />
            </div>
        </div>
    );
};

================================================================================
FILE PATH: client\src\components\CountDownTimer.jsx
================================================================================
import React, { useState, useEffect } from 'react';
import { Clock } from 'lucide-react';

const CountDownTimer = ({ initialSeconds, totalSeconds = 60 }) => {
    const [seconds, setSeconds] = useState(initialSeconds);

    useEffect(() => {
        setSeconds(initialSeconds);
    }, [initialSeconds]);

    useEffect(() => {
        if (seconds <= 0) return;
        const timerId = setInterval(() => {
            setSeconds((prev) => Math.max(0, prev - 1));
        }, 1000);
        return () => clearInterval(timerId);
    }, [seconds]);

    const isUrgent = seconds <= 10;
    const color = isUrgent ? '#ff4d4d' : '#ffffff';
    const bgColor = isUrgent ? 'rgba(231, 76, 60, 0.9)' : 'rgba(0, 0, 0, 0.7)';

    return (
        <div style={{
            position: 'absolute',
            // [ä¿®æ”¹] æ˜¾ç¤ºåœ¨å¤´é¡¶ä¸Šæ–¹ï¼Œé¿å¼€ä¸‹æ–¹å†…å®¹
            top: -60, 
            left: '50%',
            transform: 'translateX(-50%)',
            
            // æ ·å¼è°ƒæ•´ï¼šæ°”æ³¡é£æ ¼
            background: bgColor,
            padding: '4px 12px',
            borderRadius: 20,
            display: 'flex',
            alignItems: 'center',
            gap: 5,
            whiteSpace: 'nowrap',
            boxShadow: '0 4px 10px rgba(0,0,0,0.3)',
            border: '1px solid rgba(255,255,255,0.2)',
            zIndex: 30,
            transition: 'all 0.3s'
        }}>
            <Clock size={14} color={color} className={isUrgent ? 'spin' : ''} />
            <span style={{ 
                color: color, 
                fontWeight: 'bold', 
                fontSize: 16,
                fontFamily: 'monospace'
            }}>
                {seconds}s
            </span>
            
            <style>{`
                .spin { animation: spin 1s linear infinite; }
            `}</style>
        </div>
    );
};

export default CountDownTimer;

================================================================================
FILE PATH: client\src\context\GameContext.jsx
================================================================================
import React, { createContext, useContext, useState, useEffect, useRef } from 'react';
import io from 'socket.io-client';
import SoundManager from '../utils/SoundManager.js';
import { sortHand } from '../utils/cardLogic.js';

const GameContext = createContext(null);

export const GameProvider = ({ children }) => {
    // --- 1. çŠ¶æ€å®šä¹‰ ---
    const [socket, setSocket] = useState(null);
    const [isConnected, setIsConnected] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [mySocketId, setMySocketId] = useState(null);

    // æ¸¸æˆæ ¸å¿ƒæ•°æ®
    const [gameState, setGameState] = useState('LOGIN'); // LOGIN, LOBBY, GAME
    const [roomId, setRoomId] = useState('');
    const [roomConfig, setRoomConfig] = useState({ 
        deckCount: 2, maxPlayers: 4, targetScore: 1000, turnTimeout: 60000, 
        enableRankPenalty: false, rankPenaltyScores: [30, 15] 
    });
    const [players, setPlayers] = useState([]);
    const [playerScores, setPlayerScores] = useState({});
    const [playersInfo, setPlayersInfo] = useState({});

    // ç©å®¶ä¸ªäººæ•°æ®
    const [username, setUsername] = useState('');
    const [myHand, setMyHand] = useState([]);
    const [selectedCards, setSelectedCards] = useState([]);
    const [sortMode, setSortMode] = useState('POINT');

    // æ¸¸æˆè¿›ç¨‹æ•°æ®
    const [currentTurnId, setCurrentTurnId] = useState(null);
    const [lastPlayed, setLastPlayed] = useState([]);
    const [lastPlayerName, setLastPlayerName] = useState('');
    const [pendingPoints, setPendingPoints] = useState(0);
    const [turnRemaining, setTurnRemaining] = useState(60);
    const [roundResult, setRoundResult] = useState(null);
    const [grandResult, setGrandResult] = useState(null);
    const [finishedRank, setFinishedRank] = useState([]);

    // UI äº¤äº’æ•°æ®
    const [infoMessage, setInfoMessage] = useState('');
    const [gameLogs, setGameLogs] = useState([]);

    // Refs ç”¨äºè§£å†³é—­åŒ…é—®é¢˜
    const socketRef = useRef(null);
    const sortModeRef = useRef('POINT');
    const usernameRef = useRef('');

    useEffect(() => { usernameRef.current = username; }, [username]);
    useEffect(() => { sortModeRef.current = sortMode; }, [sortMode]);

    // --- 2. Socket åˆå§‹åŒ– ---
    useEffect(() => {
        const getSocketUrl = () => {
            const { hostname, protocol } = window.location;
            const isLocal = hostname === 'localhost' || hostname === '127.0.0.1' || hostname.startsWith('192.168.');
            return isLocal ? `${protocol}//${hostname}:3001` : '/';
        };

        const newSocket = io(getSocketUrl(), {
            reconnectionAttempts: 10,
            reconnectionDelay: 1000,
            timeout: 20000,
            transports: ['websocket', 'polling']
        });

        socketRef.current = newSocket;
        setSocket(newSocket);

        // åˆå§‹åŒ–éŸ³æ•ˆ
        const initAudio = () => {
            SoundManager.init();
            window.removeEventListener('click', initAudio);
        };
        window.addEventListener('click', initAudio);

        // --- ç»‘å®šäº‹ä»¶ç›‘å¬ ---
        newSocket.on('connect', () => setIsConnected(true));
        newSocket.on('disconnect', () => setIsConnected(false));
        newSocket.on('your_id', (id) => setMySocketId(id));
        newSocket.on('error_msg', (msg) => { setIsLoading(false); alert(msg); });

        newSocket.on('room_info', (data) => {
            setRoomId(data.roomId);
            setRoomConfig(data.config);
            setPlayers(data.players);
            if(data.grandScores) setPlayerScores(data.grandScores);
            setGameState('LOBBY');
            setIsLoading(false);
        });

        newSocket.on('game_started', (data) => {
            if (data.hand) setMyHand(sortHand(data.hand, sortModeRef.current));
            setLastPlayed([]);
            setRoundResult(null);
            setGrandResult(null);
            setPendingPoints(0);
            setFinishedRank([]);
            if (data.grandScores) setPlayerScores(data.grandScores);
            setGameLogs(prev => [...prev, { time: new Date().toLocaleTimeString(), text: 'ğŸ æ–°ä¸€å±€å¼€å§‹ï¼' }]);
            setGameState('GAME');
            setTurnRemaining(60);
            setPlayersInfo({});
            SoundManager.play('deal');
        });

        newSocket.on('game_state_update', (data) => {
            setCurrentTurnId(data.currentTurnId);
            if (data.turnRemaining !== undefined) setTurnRemaining(data.turnRemaining);
            
            if (data.lastPlayed && data.lastPlayed.length > 0) {
                setLastPlayed(sortHand(data.lastPlayed, sortModeRef.current));
                SoundManager.play('play');
            } else {
                setLastPlayed([]);
            }
            
            setLastPlayerName(data.lastPlayerName || '');
            if (data.scores) setPlayerScores(data.scores);
            if (data.playersInfo) setPlayersInfo(data.playersInfo);
            if (data.finishedRank) setFinishedRank(data.finishedRank);
            if (data.pendingPoints !== undefined) setPendingPoints(data.pendingPoints);

            if (data.infoText && data.infoText !== 'PASS') {
                showInfo(data.infoText);
                setGameLogs(prev => [...prev, { time: new Date().toLocaleTimeString(), text: data.infoText }]);
            }

            if (data.currentTurnId === socketRef.current.id) {
                SoundManager.play('alert');
            }
        });

        newSocket.on('hand_update', (newHand) => {
            setMyHand(sortHand(newHand, sortModeRef.current));
            setSelectedCards([]);
        });

        newSocket.on('play_error', (msg) => {
            showInfo(msg);
            SoundManager.play('lose');
        });

        newSocket.on('round_over', (data) => {
            setRoundResult(data);
            if (data.grandScores) setPlayerScores(data.grandScores);
            SoundManager.play(data.roundWinner === usernameRef.current ? 'win' : 'lose');
        });

        newSocket.on('grand_game_over', (data) => {
            setGrandResult(data);
            SoundManager.play('win');
        });

        return () => newSocket.disconnect();
    }, []);

    // --- 3. è¾…åŠ© Effect ---
    useEffect(() => {
        if (myHand.length > 0) setMyHand(prev => sortHand(prev, sortMode));
    }, [sortMode]);

    // --- 4. åŠ¨ä½œ Actions ---
    const showInfo = (msg) => {
        setInfoMessage(msg);
        setTimeout(() => setInfoMessage(''), 2000);
    };

    const handleRoomAction = (isCreatorMode) => {
        if (!username || !roomId) return alert("è¯·è¾“å…¥æ˜µç§°å’Œæˆ¿é—´å·");
        setIsLoading(true);
        const event = isCreatorMode ? 'create_room' : 'join_room';
        const payload = isCreatorMode ? { roomId, username, config: roomConfig } : { roomId, username };
        socket.emit(event, payload);
    };

    const toggleSort = () => setSortMode(prev => prev === 'POINT' ? 'SUIT' : 'POINT');
    
    // é€‰ç‰Œé€»è¾‘
    const toggleSelectCard = (cardVal, forceSelect = null) => {
        setSelectedCards(prev => {
            const isSelected = prev.includes(cardVal);
            if (forceSelect !== null) {
                return forceSelect && !isSelected ? [...prev, cardVal] : (!forceSelect && isSelected ? prev.filter(c => c !== cardVal) : prev);
            }
            return isSelected ? prev.filter(c => c !== cardVal) : [...prev, cardVal];
        });
    };

    // æ¸¸æˆæ“ä½œ
    const actions = {
        playCards: () => {
            if (selectedCards.length === 0) return alert("è¯·å…ˆé€‰ç‰Œ");
            socket.emit('play_cards', { roomId, cards: selectedCards });
        },
        passTurn: () => {
            socket.emit('pass_turn', { roomId });
            setSelectedCards([]);
        },
        startGame: () => socket.emit('start_game', { roomId }),
        nextRound: () => socket.emit('next_round', { roomId }),
        addBot: () => socket.emit('add_bot', { roomId }),
        toggleAutoPlay: () => socket.emit('toggle_auto_play', { roomId }),
        handleRoomAction,
        toggleSort,
        toggleSelectCard,
        setUsername,
        setRoomId,
        setRoomConfig
    };

    const value = {
        // State
        socket, isConnected, isLoading, mySocketId,
        gameState, roomId, roomConfig, players, playerScores, playersInfo,
        username, myHand, selectedCards, sortMode,
        currentTurnId, lastPlayed, lastPlayerName, pendingPoints, turnRemaining, roundResult, grandResult, finishedRank,
        infoMessage, gameLogs,
        // Actions
        ...actions
    };

    return <GameContext.Provider value={value}>{children}</GameContext.Provider>;
};

export const useGame = () => {
    const context = useContext(GameContext);
    if (!context) throw new Error("useGame must be used within a GameProvider");
    return context;
};

================================================================================
FILE PATH: client\src\index.css
================================================================================
/* =========================================
   å…¨å±€åŸºç¡€æ ·å¼ (Base & Reset)
   ========================================= */
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  /* é…è‰²æ–¹æ¡ˆ */
  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  /* å­—ä½“æ¸²æŸ“ä¼˜åŒ– */
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  
  /* [ä¼˜åŒ–] ç¦æ­¢ç§»åŠ¨ç«¯ç‚¹å‡»é«˜äº® */
  -webkit-tap-highlight-color: transparent; 
}

/* é“¾æ¥æ ·å¼ */
a { font-weight: 500; color: #646cff; text-decoration: inherit; }
a:hover { color: #535bf2; }

/* Body åŸºç¡€è®¾ç½® */
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  /* [å…³é”®ä¿®å¤] å½»åº•ç¦æ­¢æµè§ˆå™¨çš„ä¸‹æ‹‰åˆ·æ–°å’Œå›å¼¹æ•ˆæœ */
  overscroll-behavior: none;
  overflow: hidden; /* é”æ­» Body æ»šåŠ¨ï¼Œåªå…è®¸å†…éƒ¨å…ƒç´ æ»šåŠ¨ */
  position: fixed;  /* å¼ºåˆ¶å›ºå®šï¼Œé˜²æ­¢ iOS Safari åœ°å€æ å› ä¸ºé¡µé¢æ»šåŠ¨è€Œå¿½éšå¿½ç° */
}

body {
  display: flex;
  place-items: center;
  min-width: 320px;
}

/* [ä¼˜åŒ–] é’ˆå¯¹æ ¹å®¹å™¨ä¼˜åŒ–è§¦æ‘¸ä½“éªŒ */
#root, .App {
  width: 100%;
  height: 100%;
  overflow-x: hidden;
  /* å…è®¸å†…éƒ¨æ­£å¸¸çš„ç‚¹å‡»å’Œæ»šåŠ¨ */
  touch-action: manipulation;
}

h1 { font-size: 3.2em; line-height: 1.1; }

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover { border-color: #646cff; }
button:focus, button:focus-visible { outline: 4px auto -webkit-focus-ring-color; }

@media (prefers-color-scheme: light) {
  :root { color: #213547; background-color: #ffffff; }
  a:hover { color: #747bff; }
  button { background-color: #f9f9f9; }
}


/* =========================================
   ç§»åŠ¨ç«¯é€‚é…æ ¸å¿ƒåŒº (Mobile Overrides)
   ========================================= */

/* --- 1. æ¨ªå±å¼•å¯¼é®ç½© --- */
.landscape-hint {
    display: none; 
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(30, 39, 46, 0.95);
    z-index: 9999; 
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
    text-align: center;
    backdrop-filter: blur(10px);
    touch-action: none; 
}

.phone-rotate-icon {
    width: 60px; height: 100px; 
    border: 3px solid white; border-radius: 10px; margin-bottom: 20px;
    animation: rotate-phone 2s infinite ease-in-out;
}
@keyframes rotate-phone {
    0% { transform: rotate(0deg); }
    50% { transform: rotate(90deg); }
    100% { transform: rotate(0deg); }
}


/* --- 2. ç§»åŠ¨ç«¯ç«–å±å¸ƒå±€ä¼˜åŒ– (Portrait Core) --- */

@media (max-width: 768px) {
  
  ::-webkit-scrollbar { width: 0px; background: transparent; }

  /* é€šç”¨åˆ—å®¹å™¨ */
  .mobile-layout-column {
    display: flex !important;
    flex-direction: column !important;
    width: 95% !important;     
    max-width: none !important; 
    height: auto !important;
    
    /* ä½¿ç”¨ dvh é€‚é…åŠ¨æ€åœ°å€æ  */
    min-height: 85vh !important; 
    min-height: 85dvh !important; 
    
    max-height: 95dvh !important; 
    margin: 10px auto !important; 
    overflow: hidden !important; 
    padding: 0 !important;      
  }

  /* --- 2.1 ç™»å½•é¡µ (Login) --- */
  .mobile-login-left {
    flex: 0 0 auto !important; 
    width: 100% !important;
    padding: 30px 20px !important; 
    border-radius: 0 0 24px 24px !important; 
    background-color: #242424; 
    min-height: auto !important;
    align-items: center !important; 
    text-align: center !important;
    padding-top: max(30px, env(safe-area-inset-top)) !important;
  }
  
  .mobile-login-left h1 { font-size: 2.5em !important; margin-bottom: 10px !important; }
  .mobile-login-left .logoCircle { width: 70px !important; height: 70px !important; margin-bottom: 15px !important; }
  .mobile-login-left .logoText { font-size: 22px !important; }

  .mobile-login-right {
    flex: 1 !important; 
    width: 100% !important;
    padding: 30px 20px !important;
    background: white;
    border-radius: 24px 24px 0 0 !important; 
    margin-top: -20px; 
    position: relative;
    z-index: 2;
    overflow-y: auto !important;
    display: flex !important;
    flex-direction: column !important;
    padding-bottom: max(30px, env(safe-area-inset-bottom)) !important;
  }
  
  .hide-on-mobile { display: none !important; }


  /* --- 2.2 å¤§å…é¡µ (Lobby) --- */
  .lobbyCard.mobile-layout-column {
      height: 92dvh !important; 
      position: relative;
      background: white !important;
  }

  .mobile-lobby-content {
      display: flex !important;
      flex-direction: column !important;
      height: 100% !important;
      width: 100%;
      overflow: hidden !important;
  }
  
  .lobbyHeader { 
      flex: 0 0 auto;
      padding: 15px !important;
      padding-top: calc(15px + env(safe-area-inset-top)) !important; 
      background: #f8f9fa; 
  }
  .lobbyHeader h2 { font-size: 20px !important; margin: 0 !important; }

  .mobile-lobby-grid {
      flex: 1 !important; 
      overflow-y: auto !important; 
      padding: 10px !important;
      display: grid !important;
      grid-template-columns: repeat(2, 1fr) !important; 
      align-content: start !important;
      gap: 10px !important;
      -webkit-overflow-scrolling: touch; 
      padding-bottom: 100px !important; 
  }
  
  .mobile-lobby-grid > div { padding: 15px !important; gap: 10px !important; }
  .mobile-lobby-grid .avatar-large { width: 50px !important; height: 50px !important; font-size: 20px !important; }

  .mobile-lobby-footer {
      flex: 0 0 auto !important;
      padding: 12px !important;
      background: white;
      border-top: 1px solid #eee;
      z-index: 10;
      padding-bottom: calc(12px + env(safe-area-inset-bottom)) !important; 
      position: absolute; 
      bottom: 0; left: 0; right: 0;
      display: flex !important;
      justify-content: space-around !important;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
  }
  
  .mobile-lobby-footer button {
      width: 45% !important;
      padding: 0 !important;
      height: 44px !important; 
      font-size: 14px !important;
      margin: 0 !important;
  }


  /* --- 2.3 æ¸¸æˆé¡µ (Game Table) --- */
  
  /* å¼¹çª—é€‚é… */
  .modal-content-wrapper {
      padding: 24px !important; 
      width: 85% !important;    
      max-width: 340px !important;
      border-radius: 20px !important;
      z-index: 1000 !important; 
  }
  .modal-content-wrapper h2 { font-size: 22px !important; }
  .modal-content-wrapper div { font-size: 15px !important; line-height: 1.6 !important; }
  
  .gameLogPanel { display: none !important; }
  
  /* é¡¶éƒ¨ä¿¡æ¯æ  */
  .tableHeader { 
      padding: 10px !important; 
      padding-top: calc(10px + env(safe-area-inset-top)) !important; 
      z-index: 50;
      /* ç¡®ä¿é¡¶éƒ¨æ ä¸è¢«é®æŒ¡ */
      position: absolute;
      top: 0; width: 100%;
  }
  .tableHeader .roomBadge { padding: 4px 10px !important; font-size: 12px !important; }
  .tableHeader .scoreBoard { padding: 5px 15px !important; top: 60px !important; } 
  .tableHeader .scoreBoard div:first-child { display: none; } 
  
  /* [ä¼˜åŒ–] ç©å®¶åŒºåŸŸä½ç½®è°ƒæ•´ */
  .mobile-players-area {
    /* å‡å°‘ padding-topï¼Œç»™ä¸­é—´è…¾å‡ºç©ºé—´ */
    padding-top: 65px !important; 
    margin-bottom: 0 !important;
    gap: 8px !important;
    width: 100% !important;
    justify-content: center !important;
    z-index: 40;
    /* ç¡®ä¿ç©å®¶å¤´åƒåœ¨å‡ºç‰Œä¸‹æ–¹ï¼ˆå¦‚æœä¸å°å¿ƒé‡å ï¼‰ï¼Œä½†åœ¨èƒŒæ™¯ä¸Šæ–¹ */
    position: relative;
  }
  
  /* ç©å®¶å¤´åƒå¾®è°ƒ */
  .mobile-avatar-scale .playerBox { 
      padding: 5px !important; min-width: 60px !important; background: rgba(0,0,0,0.5) !important;
  }
  .mobile-avatar-scale .avatar { 
      width: 40px !important; height: 40px !important; line-height: 40px !important; font-size: 14px !important; 
  }
  
  /* [æ ¸å¿ƒä¿®å¤] æ¡Œé¢å‡ºç‰ŒåŒºåŸŸä½ç½®è°ƒæ•´ */
  .mobile-table-center {
    display: flex !important;
    align-items: center !important; 
    justify-content: center !important;
    width: 100% !important;
    position: absolute !important;
    /* [ä¿®æ”¹] ä» 42% ä¸Šç§»åˆ° 38%ï¼Œé˜²æ­¢è¢«åº•éƒ¨æ‰‹ç‰Œé®æŒ¡ */
    top: 38% !important; 
    transform: translateY(-50%);
    padding: 0 !important; 
    margin: 0 !important;
    /* [ä¿®æ”¹] æé«˜å±‚çº§ï¼Œç¡®ä¿ä¸è¢«ä¾§è¾¹ç©å®¶é®æŒ¡ */
    z-index: 30 !important; 
    pointer-events: none; 
  }
  .mobile-table-center > * {
      pointer-events: auto; 
  }
  
  .mobile-table-center .mini-card {
      padding: 8px 12px !important;
      font-size: 20px !important;
      min-width: 36px !important;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  }

  /* [æ ¸å¿ƒ] æ‰‹ç‰ŒåŒºåŸŸ */
  .mobile-hand-area {
    width: 100% !important;
    position: fixed !important; 
    bottom: 0 !important;
    padding-bottom: calc(10px + env(safe-area-inset-bottom)) !important;
    /* [ä¿®æ”¹] é«˜åº¦ç¨å¾®å‡å°ä¸€ç‚¹ç‚¹ï¼Œç•™ç»™æ¡Œé¢æ›´å¤šç©ºé—´ */
    height: 145px !important; 
    background: linear-gradient(to top, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.6) 60%, transparent 100%) !important;
    z-index: 100 !important;
    touch-action: none;
    display: flex;
    justify-content: center;
    align-items: flex-end;
  }
  
  /* æ“ä½œæ  */
  .action-bar-container {
      position: fixed !important;
      bottom: calc(150px + env(safe-area-inset-bottom)) !important;
      left: 0; right: 0;
      height: 60px !important;
      background: none !important;
      z-index: 110 !important; 
      display: flex;
      justify-content: center;
      gap: 20px;
      pointer-events: none; 
  }
  .action-bar-container button {
      pointer-events: auto; 
      padding: 0 32px !important;
      font-size: 16px !important;
      height: 48px !important;
      border-radius: 24px !important; 
      box-shadow: 0 4px 12px rgba(0,0,0,0.4) !important;
      background-color: #646cff !important; 
      color: white !important;
      border: 2px solid rgba(255,255,255,0.2) !important;
  }
  .action-bar-container button:disabled {
      background-color: #555 !important;
      opacity: 0.6;
  }
}


/* --- 3. ç§»åŠ¨ç«¯æ¨ªå±é€‚é… (Landscape Overrides) --- */
@media (max-width: 896px) and (orientation: landscape) {
    
    .mobile-layout-column {
        flex-direction: row !important;
        height: 100dvh !important; 
        max-height: none !important;
        width: 100% !important;
        margin: 0 !important;
        padding-left: max(15px, env(safe-area-inset-left)) !important; 
        padding-right: max(15px, env(safe-area-inset-right)) !important; 
    }

    .mobile-login-left { 
        width: 240px !important; flex: 0 0 240px !important; 
        height: 100% !important; border-radius: 0 !important; 
        justify-content: center !important;
        padding-top: 0 !important;
    }
    .mobile-login-right { 
        border-radius: 0 !important; margin-top: 0 !important; 
        justify-content: center !important; 
        padding-bottom: 20px !important;
    }

    .mobile-players-area {
      padding-top: 10px !important;
      flex-wrap: nowrap !important;
      justify-content: flex-start !important;
      overflow-x: auto !important;
      gap: 15px !important;
      scrollbar-width: none; 
    }
    
    .mobile-table-center {
        top: 50% !important;
    }
    
    .mobile-hand-area {
        height: 100px !important;
        padding-bottom: 5px !important;
    }
    
    .action-bar-container {
        bottom: 110px !important;
    }
}

================================================================================
FILE PATH: client\src\main.jsx
================================================================================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)


================================================================================
FILE PATH: client\src\screens\GameScreen.jsx
================================================================================
// æ¸¸æˆä¸»ç•Œé¢ - æ·±åº¦é€‚é…ç§»åŠ¨ç«¯å¸ƒå±€
import React from 'react';
import { Coins, Layers, Crown, Clock, Bot, Zap } from 'lucide-react';
import { styles } from '../styles.js'; 
import { Card, MiniCard, PlayerAvatar, GameLogPanel } from '../components/BaseUI.jsx';
import { calculateCardSpacing } from '../utils/cardLogic.js';

export const GameScreen = ({ 
    roomId, players, myHand, selectedCards, lastPlayed, lastPlayerName, currentTurnId, 
    infoMessage, winner, playerScores, playersInfo, pendingPoints, gameLogs, sortMode,
    mySocketId, roundResult, grandResult, roomConfig,
    turnRemaining, finishedRank = [], 
    toggleSort, handleMouseDown, handleMouseEnter, handlePlayCards, handlePass, handleNextRound, handleStartGame,
    handleToggleAutoPlay 
}) => {
    const isMyTurn = currentTurnId === mySocketId;
    const amIHost = players.find(p => p.id === mySocketId)?.isHost;
    const cardSpacing = calculateCardSpacing(myHand.length, window.innerWidth);
    
    const myInfo = (playersInfo && playersInfo[mySocketId]) || {};
    const amIAutoPlay = myInfo.isAutoPlay;

    const isCrowded = players.length > 6;
    const avatarScale = isCrowded ? 0.85 : 1;
    const avatarStyleOverride = isCrowded ? { transform: `scale(${avatarScale})`, margin: -5 } : {};

    return (
        <div style={styles.gameTable} onMouseUp={() => { /* Global Mouse Up Handled in App */ }}>
            {/* å¢åŠ ç±»å gameLogPanel ä»¥ä¾¿åœ¨æ‰‹æœºä¸Šéšè— */}
            <div className="gameLogPanel">
                 <GameLogPanel logs={gameLogs} />
            </div>

            <div style={styles.tableHeader}>
                <div style={styles.roomBadge}>Room {roomId}</div>
                <div style={styles.scoreBoard}>
                    <div style={{fontSize: 12, opacity: 0.8, textTransform:'uppercase'}}>Table Points</div>
                    <div style={{fontSize: 32, fontWeight: 'bold', color: '#f1c40f', display:'flex', alignItems:'center', gap:8}}><Coins size={28} /> {pendingPoints}</div>
                </div>
                <button style={styles.sortButton} onClick={toggleSort}><Layers size={16} style={{marginRight:5}}/> {sortMode === 'POINT' ? 'ç‚¹æ•°' : 'èŠ±è‰²'}</button>
            </div>

            <div style={styles.infoMessage}>{infoMessage}</div>

            {/* å¼¹çª—åŒºåŸŸ */}
            {(winner || roundResult || grandResult) && (
                <div style={styles.modalOverlay}>
                    {className="modal-content-wrapper"}    
                    <div style={styles.modalContent}>
                        {grandResult ? (
                            <>
                                <Crown size={80} color="#e74c3c" style={{marginBottom: 20}} />
                                <h2 style={{fontSize: 32, marginBottom: 10, color:'#2c3e50'}}>æœ€ç»ˆå† å†›: {grandResult.grandWinner}</h2>
                                <button style={{...styles.primaryButton, fontSize: 18}} onClick={handleStartGame}>é‡æ–°å¼€å§‹</button>
                            </>
                        ) : roundResult ? (
                            <>
                                <Coins size={60} color="#f1c40f" style={{marginBottom: 20}} />
                                <h2 style={{fontSize: 28}}>å°å±€ç»“æŸ</h2>
                                <div style={{fontSize: 20}}>èƒœè€…: <span style={{color:'#27ae60'}}>{roundResult.roundWinner}</span></div>
                                <div style={{fontSize: 32, fontWeight:'bold', color:'#f1c40f', margin:'10px 0'}}>+{roundResult.pointsEarned} åˆ†</div>
                                
                                <div style={{
                                    color:'#666', fontSize:14, marginBottom:30, 
                                    whiteSpace: 'pre-wrap', lineHeight: '1.6', 
                                    maxHeight: 200, overflowY: 'auto', textAlign: 'left',
                                    background: '#f8f9fa', padding: 15, borderRadius: 8
                                }}>
                                    {roundResult.detail}
                                </div>

                                {amIHost ? <button style={styles.primaryButton} onClick={handleNextRound}>ä¸‹ä¸€å±€</button> : <div style={{color:'#999'}}>ç­‰å¾…æˆ¿ä¸»...</div>}
                            </>
                        ) : null}
                    </div>
                </div>
            )}

            {/* æ¡Œé¢åŒºåŸŸ (å‡ºç‰Œå±•ç¤º) */}
            {/* [ä¿®æ”¹] å¢åŠ  mobile-table-center ç±»å */}
            <div style={styles.tableCenter} className="mobile-table-center">
                {lastPlayed.length > 0 && (
                    <div style={{animation: 'popIn 0.3s'}}>
                        <div style={styles.playerNameTag}>{lastPlayerName}</div>
                        <div style={styles.playedRow} className="mini-card-container"> 
                            {/* ç»™ MiniCard åŠ ä¸ªçˆ¶å®¹å™¨ç±»åä»¥ä¾¿ CSS æ§åˆ¶ */}
                            {lastPlayed.map((c, i) => <MiniCard key={i} cardVal={c} index={i} />)}
                        </div>
                    </div>
                )}
            </div>

            {/* ç©å®¶åŒºåŸŸ */}
            {/* [ä¿®æ”¹] å¢åŠ  mobile-players-area ç±»å */}
            <div style={styles.playersArea} className="mobile-players-area">
                {players.map((p, i) => {
                    const info = (playersInfo && playersInfo[p.id]) || {};
                    const isBot = info.isBot || p.isBot;
                    const isAuto = info.isAutoPlay;
                    const rankIndex = finishedRank ? finishedRank.indexOf(p.id) : -1;
                    const finishedRankVal = rankIndex !== -1 ? rankIndex + 1 : null;

                    return (
                        <div key={i} style={{...avatarStyleOverride, position:'relative'}} className="mobile-avatar-scale"> 
                            <PlayerAvatar 
                                player={p} 
                                isTurn={p.id === currentTurnId} 
                                score={playerScores[p.id] || 0} 
                                targetScore={roomConfig.targetScore} 
                                isMySocket={p.id === mySocketId}
                                remainingSeconds={turnRemaining}
                                rank={finishedRankVal}
                            />
                            <div style={{position: 'absolute', top: -10, right: -10, display: 'flex', gap: 5}}>
                                {isBot && <div style={styles.statusBadgeBot}><Bot size={12}/> AI</div>}
                                {isAuto && <div style={styles.statusBadgeAuto}><Zap size={12}/> æ‰˜ç®¡</div>}
                            </div>
                        </div>
                    );
                })}
            </div>

            {/* æ‰‹ç‰ŒåŒºåŸŸ */}
            <div 
                style={{
                    ...styles.handArea, 
                    opacity: amIAutoPlay ? 0.6 : 1, 
                    filter: amIAutoPlay ? 'grayscale(0.6)' : 'none',
                    pointerEvents: amIAutoPlay ? 'none' : 'auto' 
                }}
                className="mobile-hand-area"
            >
                {amIAutoPlay && (
                    <div style={{
                        position: 'absolute', top: -50, left: '50%', transform: 'translateX(-50%)',
                        background: 'rgba(230, 126, 34, 0.9)', color: 'white', padding: '5px 15px', 
                        borderRadius: 20, fontSize: 14, fontWeight: 'bold', display: 'flex', alignItems: 'center', gap: 5,
                        boxShadow: '0 4px 10px rgba(0,0,0,0.3)', zIndex: 50
                    }}>
                        <Bot size={16} /> ç³»ç»Ÿä»£æ‰“ä¸­...
                    </div>
                )}
                
                {myHand.map((c, i) => (
                    <Card key={`${c}-${i}`} cardVal={c} index={i} isSelected={selectedCards.includes(c)} onClick={handleMouseDown} onMouseEnter={handleMouseEnter} spacing={cardSpacing} />
                ))}
            </div>

            {/* æ“ä½œæ  */}
            {/* [ä¿®æ”¹] å¢åŠ  action-bar-container ç±»å */}
            <div style={styles.actionBar} className="action-bar-container">
                {!winner && !roundResult && !grandResult && (
                    <div style={{display:'flex', alignItems: 'center', gap: 20}}>
                        {amIAutoPlay ? (
                            <button 
                                style={{
                                    ...styles.playButton, 
                                    background: '#e74c3c', 
                                    width: 220,
                                    display: 'flex', justifyContent: 'center', alignItems: 'center'
                                }} 
                                onClick={handleToggleAutoPlay}
                            >
                                <Zap size={22} style={{marginRight:8}}/> å–æ¶ˆæ‰˜ç®¡
                            </button>
                        ) : (
                            <>
                                {isMyTurn ? (
                                    <>
                                        <button style={styles.passButton} onClick={handlePass}>ä¸è¦</button>
                                        <button style={styles.playButton} onClick={handlePlayCards}>å‡ºç‰Œ</button>
                                    </>
                                ) : (
                                    <div style={styles.waitingBadge}><Clock size={20} className="spin" /> ç­‰å¾…å¯¹æ–¹...</div>
                                )}
                                
                                <button 
                                    style={{
                                        pointerEvents: 'auto', 
                                        background: 'rgba(255,255,255,0.1)', 
                                        border: '1px solid rgba(255,255,255,0.3)',
                                        color: '#ecf0f1',
                                        borderRadius: 30, 
                                        padding: '0 20px',
                                        height: 50,
                                        display: 'flex', alignItems: 'center', justifyContent: 'center',
                                        cursor: 'pointer',
                                        marginLeft: 20,
                                        fontSize: 16,
                                        fontWeight: 'bold',
                                        transition: 'all 0.2s'
                                    }}
                                    onClick={handleToggleAutoPlay}
                                    title="ç‚¹å‡»å¼€å¯ç³»ç»Ÿæ‰˜ç®¡"
                                >
                                    <Zap size={20} style={{marginRight: 6}} />
                                    æ‰˜ç®¡
                                </button>
                            </>
                        )}
                    </div>
                )}
            </div>
            
            <style>{`
                .statusBadgeBot { background: #34495e; color: white; padding: 2px 6px; borderRadius: 10px; fontSize: 10px; display: flex; align-items: center; gap: 2px; border: 1px solid rgba(255,255,255,0.3); }
                .statusBadgeAuto { background: #e67e22; color: white; padding: 2px 6px; borderRadius: 10px; fontSize: 10px; display: flex; align-items: center; gap: 2px; border: 1px solid rgba(255,255,255,0.3); animation: pulse 2s infinite; }
                @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
            `}</style>
        </div>
    );
};

================================================================================
FILE PATH: client\src\screens\LobbyScreen.jsx
================================================================================
import React from 'react';
import { useGame } from '../context/GameContext.jsx';
import styles from '../styles/LobbyScreen.module.css';

export const LobbyScreen = () => {
    const { roomId, players, roomConfig, startGame, addBot, mySocketId } = useGame();
    const isHost = players.find(p => p.id === mySocketId)?.isHost;

    return (
        <div className={styles.container}>
            <div className={styles.card}>
                <h2>æˆ¿é—´: {roomId} <span style={{fontSize:14, color:'#666'}}>({players.length}/{roomConfig.maxPlayers}äºº)</span></h2>
                
                <div className={styles.playerList}>
                    {players.map(p => (
                        <div key={p.id} className={styles.playerItem} style={{borderColor: p.id===mySocketId ? '#27ae60' : '#eee'}}>
                            <div style={{width:40, height:40, background:'#eee', borderRadius:'50%', display:'flex', alignItems:'center', justifyContent:'center'}}>
                                {p.name[0]}
                            </div>
                            <div>
                                <div style={{fontWeight:'bold'}}>{p.name}</div>
                                {p.isHost && <div style={{fontSize:12, color:'#f39c12'}}>æˆ¿ä¸»</div>}
                            </div>
                        </div>
                    ))}
                </div>

                {isHost ? (
                    <div style={{display:'flex', gap:10}}>
                        <button className={styles.startBtn} style={{background:'#95a5a6', flex:1}} onClick={addBot}>+ æœºå™¨äºº</button>
                        <button className={styles.startBtn} style={{flex:2}} onClick={startGame} disabled={players.length < 2}>å¼€å§‹æ¸¸æˆ</button>
                    </div>
                ) : (
                    <div style={{textAlign:'center', color:'#999'}}>ç­‰å¾…æˆ¿ä¸»å¼€å§‹...</div>
                )}
            </div>
        </div>
    );
};

================================================================================
FILE PATH: client\src\screens\LoginScreen.jsx
================================================================================
import React, { useState } from 'react';
import { User, Monitor, LogIn, Plus, RefreshCw, Wifi, WifiOff } from 'lucide-react';
import { useGame } from '../context/GameContext.jsx';
import styles from '../styles/LoginScreen.module.css';

export const LoginScreen = () => {
    // ç›´æ¥ä» Context è·å–çŠ¶æ€å’Œæ–¹æ³•
    const { 
        username, setUsername, roomId, setRoomId, roomConfig, setRoomConfig,
        handleRoomAction, isLoading, isConnected 
    } = useGame();

    const [isCreatorMode, setIsCreatorMode] = useState(false);

    return (
        <div className={styles.container}>
            <div className={styles.card}>
                {/* å·¦ä¾§ */}
                <div className={styles.leftPanel}>
                    <h1 className={styles.brandTitle}>510K</h1>
                    <div style={{opacity:0.9}}>å¤šäººåœ¨çº¿æ‰‘å…‹å¯¹æˆ˜</div>
                </div>

                {/* å³ä¾§ */}
                <div className={styles.rightPanel}>
                    {/* çŠ¶æ€æ  */}
                    <div style={{display:'flex', justifyContent:'flex-end', marginBottom:20}}>
                        <div style={{
                            display: 'flex', alignItems: 'center', gap: 6, fontSize: 12, padding: '6px 12px', borderRadius: 20,
                            background: isConnected ? '#eafaf1' : '#fdedec', color: isConnected ? '#27ae60' : '#e74c3c'
                        }}>
                            {isConnected ? <Wifi size={14}/> : <WifiOff size={14}/>}
                            {isConnected ? 'å·²è¿æ¥' : 'è¿æ¥ä¸­...'}
                        </div>
                    </div>

                    {/* Tabs */}
                    <div className={styles.tabs}>
                        <button className={!isCreatorMode ? styles.tabBtnActive : styles.tabBtn} onClick={()=>setIsCreatorMode(false)}>åŠ å…¥æˆ¿é—´</button>
                        <button className={isCreatorMode ? styles.tabBtnActive : styles.tabBtn} onClick={()=>setIsCreatorMode(true)}>åˆ›å»ºæˆ¿é—´</button>
                    </div>

                    {/* è¡¨å• */}
                    <div className={styles.inputGroup}>
                        <User size={18} color="#7f8c8d" />
                        <input className={styles.input} value={username} onChange={e=>setUsername(e.target.value)} placeholder="ä½ çš„æ˜µç§°" maxLength={10} />
                    </div>
                    <div className={styles.inputGroup}>
                        <Monitor size={18} color="#7f8c8d" />
                        <input className={styles.input} value={roomId} onChange={e=>setRoomId(e.target.value)} placeholder="æˆ¿é—´å· (å¦‚: 888)" maxLength={6} />
                    </div>

                    {/* é…ç½®åŒºåŸŸ (ç®€åŒ–ç‰ˆï¼Œå¤ç”¨ inputGroup æˆ–æ–°å¢æ ·å¼) */}
                    {isCreatorMode && (
                        <div style={{background:'#f8f9fa', padding:15, borderRadius:12, marginBottom:20}}>
                            <div style={{fontSize:14, color:'#666', marginBottom:10}}>è·èƒœç›®æ ‡: {roomConfig.targetScore}åˆ†</div>
                            <input type="range" min="500" max="2000" step="100" style={{width:'100%'}} 
                                value={roomConfig.targetScore} onChange={e=>setRoomConfig({...roomConfig, targetScore: parseInt(e.target.value)})} 
                            />
                        </div>
                    )}

                    <button className={styles.primaryBtn} onClick={() => handleRoomAction(isCreatorMode)} disabled={isLoading || !isConnected}>
                        {isLoading ? <RefreshCw className="spin" size={20}/> : (isCreatorMode ? <Plus size={20}/> : <LogIn size={20}/>)}
                        <span>{isCreatorMode ? "åˆ›å»ºæˆ¿é—´" : "è¿›å…¥æ¸¸æˆ"}</span>
                    </button>
                </div>
            </div>
            <style>{`.spin { animation: spin 1s linear infinite; } @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }`}</style>
        </div>
    );
};

================================================================================
FILE PATH: client\src\styles\GameScreen.css
================================================================================
/* æ¸¸æˆæ¡Œå¸ƒèƒŒæ™¯ */
.gameTable {
    height: 100vh;
    width: 100vw;
    background-color: #1e3c29;
    background-image: radial-gradient(circle at center, #2d7a54 0%, #173b25 100%);
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    user-select: none;
}

/* é¡¶éƒ¨ä¿¡æ¯æ  */
.header {
    padding: 20px 40px;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    z-index: 20;
}

.roomBadge {
    background: rgba(0,0,0,0.3);
    color: white;
    padding: 8px 20px;
    border-radius: 20px;
    font-weight: bold;
    border: 1px solid rgba(255,255,255,0.1);
}

.pendingScore {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.5);
    padding: 10px 40px;
    border-radius: 20px;
    color: #f1c40f;
    font-size: 24px;
    font-weight: bold;
    backdrop-filter: blur(5px);
    border: 1px solid rgba(255,255,255,0.1);
}

/* æ¡Œé¢ä¸­å¿ƒå‡ºç‰ŒåŒº */
.tableCenter {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding-bottom: 120px; /* ç»™æ‰‹ç‰Œç•™ç©ºé—´ */
    z-index: 10;
}

.lastPlayerName {
    color: white;
    background: rgba(0,0,0,0.4);
    padding: 4px 15px;
    border-radius: 12px;
    margin-bottom: 10px;
    font-size: 14px;
}

.cardsRow {
    display: flex;
    gap: 5px; /* é»˜è®¤é—´è· */
}

/* ç©å®¶å¤´åƒåŒºåŸŸ */
.playersArea {
    display: flex;
    justify-content: center;
    gap: 20px;
    flex-wrap: wrap;
    width: 90%;
    margin: 0 auto;
    /* æ”¾åœ¨ä¸­é—´åä¸Šä½ç½® */
    position: absolute;
    top: 100px;
    left: 0; right: 0;
    pointer-events: none;
}

/* æ‰‹ç‰ŒåŒºåŸŸ */
.handArea {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    height: 140px;
    width: 100%;
    max-width: 1400px;
    display: flex;
    justify-content: center;
    z-index: 30;
}

/* æ“ä½œæ  */
.actionBar {
    position: absolute;
    bottom: 30px;
    left: 0; right: 0;
    display: flex;
    justify-content: center;
    gap: 20px;
    z-index: 40;
    pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€åˆ°æ‰‹ç‰Œ */
}

.actionBtn {
    pointer-events: auto;
    padding: 12px 40px;
    border-radius: 30px;
    border: none;
    font-weight: bold;
    font-size: 18px;
    cursor: pointer;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    transition: transform 0.1s;
}

.playBtn {
    background: linear-gradient(to bottom, #f1c40f, #f39c12);
    color: white;
}

.passBtn {
    background: #7f8c8d;
    color: white;
}

/* --- ç§»åŠ¨ç«¯é€‚é… (Media Queries) --- */
@media (max-width: 768px) {
    .header {
        padding: 10px;
    }
    
    .roomBadge { font-size: 12px; padding: 5px 10px; }
    
    .pendingScore {
        top: 60px; /* é¿å¼€æˆ¿å· */
        padding: 5px 20px;
        font-size: 18px;
    }

    .playersArea {
        top: 110px;
        gap: 8px;
        width: 100%;
        overflow-x: auto;
        justify-content: flex-start; /* å…è®¸æ¨ªå‘æ»šåŠ¨ */
        padding: 0 10px;
    }

    .tableCenter {
        /* ä¸Šç§»ä»¥é¿å¼€æ‰‹ç‰Œ */
        position: absolute;
        top: 40%;
        left: 0; right: 0;
        padding: 0;
    }

    .cardsRow {
        gap: -5px; /* ç‰Œå å¾—ç´§ä¸€ç‚¹ */
        transform: scale(0.8);
    }

    .handArea {
        bottom: 0;
        height: 120px;
        /* èƒŒæ™¯æ¸å˜ï¼Œé˜²æ­¢çœ‹ä¸æ¸…ç‰Œ */
        background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
    }

    .actionBar {
        bottom: 130px; /* æåˆ°æ‰‹ç‰Œä¸Šé¢ */
    }
    
    .actionBtn {
        padding: 8px 30px;
        font-size: 16px;
    }
}

================================================================================
FILE PATH: client\src\styles\LobbyScreen.module.css
================================================================================
.container {
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #f0f2f5;
}
.card {
    background: white;
    padding: 30px;
    border-radius: 20px;
    width: 600px;
    max-width: 90%;
    box-shadow: 0 10px 30px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
    gap: 20px;
}
.playerList {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 15px;
}
.playerItem {
    padding: 15px;
    border: 1px solid #eee;
    border-radius: 10px;
    display: flex;
    align-items: center;
    gap: 10px;
}
.startBtn {
    background: #27ae60;
    color: white;
    border: none;
    padding: 15px;
    border-radius: 10px;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
}
.startBtn:disabled { background: #ccc; }

================================================================================
FILE PATH: client\src\styles\LoginScreen.module.css
================================================================================
/* å®¹å™¨ */
.container {
    height: 100vh;
    width: 100vw;
    display: flex;
    justify-content: center;
    align-items: center;
    background-image: radial-gradient(circle at top right, #34495e 0%, #000000 100%);
    overflow: hidden;
}

.card {
    background: white;
    border-radius: 24px;
    width: 95%;
    max-width: 1100px;
    min-height: 600px;
    max-height: 90vh;
    display: flex;
    box-shadow: 0 50px 100px -20px rgba(0,0,0,0.7);
    overflow: hidden;
    animation: popIn 0.5s ease-out;
}

/* å·¦ä¾§å“ç‰Œ */
.leftPanel {
    flex: 0.8;
    background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
    padding: 60px 50px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    color: white;
    position: relative;
}

.brandTitle {
    font-size: 48px;
    font-weight: 800;
    margin-bottom: 15px;
    letter-spacing: -1.5px;
}

/* å³ä¾§è¡¨å• */
.rightPanel {
    flex: 1.2;
    padding: 50px 60px;
    background: white;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
}

/* Tabs */
.tabs {
    display: flex;
    gap: 35px;
    margin-bottom: 35px;
    border-bottom: 2px solid #f1f2f6;
}

.tabBtn {
    padding: 12px 0;
    font-size: 18px;
    font-weight: bold;
    color: #95a5a6;
    background: none;
    border: none;
    cursor: pointer;
    border-bottom: 3px solid transparent;
    transition: all 0.3s;
}

.tabBtnActive {
    composes: tabBtn;
    color: #2c3e50;
    border-bottom: 3px solid #27ae60;
}

/* è¾“å…¥æ¡† */
.inputGroup {
    display: flex;
    align-items: center;
    background: #f8f9fa;
    border-radius: 14px;
    padding: 0 20px;
    margin-bottom: 20px;
    border: 1px solid #e1e4e8;
    height: 60px;
}

.input {
    border: none;
    background: transparent;
    flex: 1;
    outline: none;
    font-size: 17px;
    margin-left: 10px;
    font-weight: 500;
}

/* æŒ‰é’® */
.primaryBtn {
    margin-top: 25px;
    width: 100%;
    height: 65px;
    background: #2c3e50;
    color: white;
    border: none;
    border-radius: 14px;
    font-weight: bold;
    font-size: 19px;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 10px;
    transition: all 0.2s;
}

.primaryBtn:disabled {
    background: #95a5a6;
    cursor: not-allowed;
}

/* ç§»åŠ¨ç«¯é€‚é… */
@media (max-width: 768px) {
    .card {
        flex-direction: column;
        min-height: auto;
        border-radius: 0;
        width: 100%;
        height: 100%;
    }
    .leftPanel {
        flex: 0 0 auto;
        padding: 40px 20px;
        border-radius: 0 0 20px 20px;
        align-items: center;
        text-align: center;
    }
    .rightPanel {
        border-radius: 20px 20px 0 0;
        margin-top: -20px;
        padding: 30px 20px;
    }
    .brandTitle { font-size: 32px; }
}

@keyframes popIn { from { transform: scale(0.95); opacity: 0; } to { transform: scale(1); opacity: 1; } }

================================================================================
FILE PATH: client\src\styles.js
================================================================================
// ç»Ÿä¸€æ ·å¼æ–‡ä»¶ - ç§»åŠ¨ç«¯é€‚é…ç‰ˆ
export const styles = {
  // å…¨å±€å®¹å™¨
  container: { 
      height: '100vh', 
      width: '100vw', 
      display: 'flex', 
      justifyContent: 'center', 
      alignItems: 'center', 
      background: '#1e272e', 
      fontFamily: '"Segoe UI", Roboto, Helvetica, Arial, sans-serif', 
      backgroundImage: 'radial-gradient(circle at top right, #34495e 0%, #000000 100%)',
      overflow: 'hidden' // æ³¨æ„ï¼šå¦‚æœé¡µé¢å†…å®¹è¿‡å¤šï¼Œè¿™é‡Œå¯èƒ½ä¼šå¯¼è‡´æ— æ³•æ»šåŠ¨ï¼Œä½†åœ¨ index.css ä¸­ mobile ç±»å¤„ç†äº†æ»šåŠ¨
  },
  
  // --- Login Card ---
  loginCard: { 
      background: 'white', 
      borderRadius: 24, 
      // [ä¿®æ”¹] å®½åº¦æ”¹ä¸ºç™¾åˆ†æ¯” + æœ€å¤§å®½åº¦é™åˆ¶ï¼Œé€‚åº”æ‰‹æœº
      width: '95%', 
      maxWidth: '1100px', 
      // [ä¿®æ”¹] å»æ‰å›ºå®šé«˜åº¦ï¼Œä½¿ç”¨ minHeight
      minHeight: '600px', 
      // [æ–°å¢] é™åˆ¶æœ€å¤§é«˜åº¦ï¼Œé˜²æ­¢åœ¨å¤§å±ä¸Šä¹Ÿé“ºå¤ªæ»¡
      maxHeight: '90vh',
      display: 'flex', 
      boxShadow: '0 50px 100px -20px rgba(0,0,0,0.7)',
      overflow: 'hidden',
      animation: 'popIn 0.5s ease-out'
  },

  // å·¦ä¾§å“ç‰ŒåŒº
  loginLeft: { 
      flex: 0.8, 
      background: 'linear-gradient(135deg, #27ae60 0%, #2ecc71 100%)', 
      padding: '60px 50px', 
      display:'flex', 
      flexDirection:'column', 
      justifyContent:'center', 
      alignItems: 'flex-start',
      color: 'white',
      position: 'relative',
      overflow: 'hidden'
  },
  logoCircle: { width: 90, height: 90, background: 'rgba(255,255,255,0.2)', borderRadius: 24, display:'flex', alignItems:'center', justifyContent:'center', marginBottom: 25, backdropFilter: 'blur(10px)' },
  logoText: { fontSize: 28, fontWeight: '900', color: 'white' },
  brandTitle: { fontSize: 48, fontWeight: '800', margin: '0 0 15px 0', letterSpacing: -1.5 },
  brandSubtitle: { fontSize: 18, opacity: 0.9, marginBottom: 50, fontWeight: '500' },
  featureList: { marginTop: 'auto', display: 'flex', flexDirection: 'column', gap: 15 },
  featureItem: { fontSize: 15, opacity: 0.95, display:'flex', alignItems:'center', fontWeight: '500' },

  // å³ä¾§è¡¨å•åŒº
  loginRight: { 
      flex: 1.2, 
      padding: '50px 60px', 
      display: 'flex',
      flexDirection: 'column',
      background: '#ffffff',
      overflowY: 'auto' // é˜²æ­¢å†…å®¹è¿‡å¤šæ—¶æ— æ³•æ»šåŠ¨
  },
  
  tabs: { display: 'flex', gap: 35, marginBottom: 35, borderBottom: '2px solid #f1f2f6' },
  tabBtn: { padding: '12px 0', fontSize: 18, fontWeight: 'bold', color: '#95a5a6', background: 'none', border: 'none', cursor: 'pointer', transition: 'all 0.3s', borderBottom: '3px solid transparent', marginBottom: -3 },
  tabBtnActive: { padding: '12px 0', fontSize: 18, fontWeight: 'bold', color: '#2c3e50', background: 'none', border: 'none', cursor: 'pointer', transition: 'all 0.3s', borderBottom: '3px solid #27ae60', marginBottom: -3 },
  
  formContent: { flex: 1, display: 'flex', flexDirection: 'column' },

  inputGroup: { display: 'flex', alignItems: 'center', background: '#f8f9fa', borderRadius: 14, padding: '0 20px', marginBottom: 20, border: '1px solid #e1e4e8', height: 60, transition: 'all 0.2s' },
  input: { padding: '10px', border: 'none', background: 'transparent', flex: 1, outline:'none', fontSize: 17, color: '#2c3e50', fontWeight: '500' },

  // é«˜çº§é…ç½®é¢æ¿
  advancedConfigPanel: { 
      marginTop: 15, 
      background: '#fff', 
      borderRadius: 12,
      animation: 'fadeIn 0.4s ease'
  },
  configGrid: {
      display: 'grid',
      gridTemplateColumns: '1fr 1fr', 
      gap: '25px 35px'
  },
  configItem: { display: 'flex', flexDirection: 'column', gap: 10 },
  configLabel: { display: 'flex', justifyContent: 'space-between', fontSize: 14, color: '#7f8c8d', fontWeight: '600' },
  configValue: { color: '#27ae60', fontWeight: 'bold' },
  
  rangeInput: { width: '100%', cursor: 'pointer', accentColor: '#27ae60', height: 6 },

  radioGroup: { display: 'flex', gap: 10 },
  radioBtn: { flex: 1, padding: '8px 0', borderRadius: 8, border: '1px solid #e1e4e8', background: 'white', color: '#7f8c8d', fontSize: 13, cursor: 'pointer', transition: 'all 0.2s' },
  radioBtnActive: { flex: 1, padding: '8px 0', borderRadius: 8, border: '1px solid #27ae60', background: '#eafaf1', color: '#27ae60', fontSize: 13, fontWeight: 'bold', cursor: 'pointer' },

  primaryButton: { 
      marginTop: 25, 
      width: '100%', 
      height: 65, 
      background: '#2c3e50', 
      color: 'white', 
      border: 'none', 
      borderRadius: 14, 
      fontWeight: 'bold', 
      cursor: 'pointer', 
      display: 'flex', 
      justifyContent: 'center', 
      alignItems: 'center', 
      fontSize: 19, 
      transition: 'all 0.2s', 
      boxShadow: '0 10px 25px rgba(44, 62, 80, 0.25)' 
  },

  // --- Game Screen Styles ---

  gameTable: { height: '100vh', width: '100vw', background: '#1e3c29', backgroundImage: 'radial-gradient(circle at center, #2d7a54 0%, #173b25 100%)', position: 'relative', overflow: 'hidden', display: 'flex', flexDirection: 'column', userSelect: 'none' },
  
  // Players Area: è°ƒæ•´é—´è·å’Œä½ç½®ä»¥é€‚åº”ç§»åŠ¨ç«¯
  playersArea: { 
      display: 'flex', 
      justifyContent: 'center', 
      alignContent: 'center', 
      flexWrap: 'wrap',       
      gap: '10px',            // [ä¿®æ”¹] å‡å°é—´è·ï¼Œæ‰‹æœºä¸€è¡Œèƒ½æ’æ›´å¤š
      paddingTop: 60,         // [æ–°å¢] é¿å¼€é¡¶éƒ¨çš„ scoreBoard
      marginBottom: 200,      // [ä¿®æ”¹] å‡å°åº•éƒ¨ç•™ç™½
      width: '98%',           // [ä¿®æ”¹] å æ»¡å®½åº¦
      maxWidth: 1600,         
      margin: '0 auto 200px', 
      pointerEvents: 'none',  
      zIndex: 10
  },
  
  playerBox: { 
      pointerEvents: 'auto',
      padding: '10px 15px',   
      borderRadius: 16, 
      textAlign: 'center', 
      minWidth: 90,           
      color:'white', 
      border: '2px solid transparent', 
      transition: 'all 0.3s', 
      position: 'relative' 
  },

  avatar: { width: 70, height: 70, background: '#ecf0f1', borderRadius: '50%', margin: '0 auto 8px', lineHeight: '70px', color:'#333', fontWeight:'bold', fontSize: 24, border: '2px solid rgba(255,255,255,0.2)', boxShadow: '0 4px 10px rgba(0,0,0,0.2)' },
  playerName: { fontSize: 14, fontWeight: 'bold', marginBottom: 4, whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', maxWidth: 90 },
  
  gameLogPanel: { position: 'absolute', top: 20, left: 20, width: 250, bottom: 280, background: 'rgba(0,0,0,0.2)', borderRadius: 12, padding: 20, display: 'flex', flexDirection: 'column', zIndex: 5, backdropFilter: 'blur(10px)', border: '1px solid rgba(255,255,255,0.1)' },
  logHeader: { display: 'flex', alignItems: 'center', gap: 8, paddingBottom: 10, borderBottom: '1px solid rgba(255,255,255,0.1)', marginBottom: 10 },
  logList: { flex: 1, overflowY: 'auto', display: 'flex', flexDirection: 'column', gap: 10, fontSize: 13, scrollbarWidth: 'thin' },
  logItem: { lineHeight: 1.5, display: 'flex', alignItems: 'flex-start' },
  logTime: { opacity: 0.5, fontSize: 10, marginRight: 8, width: 45, display: 'inline-block', color: '#ccc' },
  
  tableHeader: { padding: '20px 40px', display: 'flex', justifyContent: 'space-between', alignItems:'flex-start', zIndex: 20 },
  roomBadge: { background: 'rgba(0,0,0,0.3)', color:'white', padding: '8px 20px', borderRadius: 20, fontSize: 16, border: '1px solid rgba(255,255,255,0.1)', fontWeight: 'bold' },
  
  scoreBoard: { position: 'absolute', top: 20, left: '50%', transform: 'translateX(-50%)', background: 'rgba(0,0,0,0.5)', padding: '10px 50px', borderRadius: 20, textAlign: 'center', color: 'white', border: '1px solid rgba(255,255,255,0.1)', backdropFilter: 'blur(10px)', boxShadow: '0 10px 30px rgba(0,0,0,0.2)' },
  sortButton: { background: 'rgba(255,255,255,0.1)', color: 'white', border: '1px solid rgba(255,255,255,0.2)', padding: '8px 20px', borderRadius: 20, cursor: 'pointer', display: 'flex', alignItems: 'center', fontSize: 14, transition: 'background 0.2s' },
  
  infoMessage: { position: 'absolute', top: '25%', width: '100%', textAlign: 'center', color: '#f1c40f', fontSize: 40, fontWeight: 'bold', textShadow: '0 5px 15px rgba(0,0,0,0.5)', pointerEvents: 'none', zIndex: 50, letterSpacing: 2 },
  
  tableCenter: { flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', paddingBottom: 100 },
  playerNameTag: { color: 'white', textAlign: 'center', marginBottom: 15, textShadow: '0 2px 4px rgba(0,0,0,0.5)', fontSize: 18, fontWeight: 'bold', background: 'rgba(0,0,0,0.3)', padding: '5px 20px', borderRadius: 20, display: 'inline-block' },
  playedRow: { display: 'flex', gap: -10, filter: 'drop-shadow(0 10px 20px rgba(0,0,0,0.3))' }, 
  miniCard: { background: 'white', padding: '15px 20px', borderRadius: 10, fontWeight: 'bold', fontSize: 28, minWidth: 50, textAlign:'center' },
  
  scoreBarBg: { width:'100%', height:6, background:'rgba(0,0,0,0.5)', borderRadius:3, marginTop:5, overflow:'hidden' },
  scoreBarFill: { height:'100%', transition:'width 0.5s' },
  playerScore: { fontSize: 13, color: '#f1c40f', fontWeight: 'bold', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 5, marginTop: 5 },
  turnProgress: { position: 'absolute', bottom: 0, left: 0, height: 4, background: '#f1c40f', width: '100%', animation: 'progress 15s linear forwards' },
  
  // [ä¿®æ”¹] æ‰‹ç‰ŒåŒºåŸŸï¼šè°ƒæ•´é«˜åº¦å’Œå®½åº¦å æ¯”
  handArea: { 
      position: 'absolute', 
      bottom: 20,             // [ä¿®æ”¹] ç¨å¾®é ä¸‹
      left: '50%', 
      transform: 'translateX(-50%)', 
      height: 140, 
      width: '100%',          // [ä¿®æ”¹] å®½åº¦å æ»¡ï¼Œé˜²æ­¢æœ€å·¦æœ€å³çš„ç‰Œç‚¹ä¸åˆ°
      maxWidth: 1600, 
      display: 'flex', 
      justifyContent:'center', 
      zIndex: 20 
  },
  
  // [ä¿®æ”¹] å¡ç‰Œï¼šé€‚é…ç§»åŠ¨ç«¯å°ºå¯¸
  card: { 
      background: 'white', 
      borderRadius: 8,       // [ä¿®æ”¹] åœ†è§’æ”¹å°
      border: '1px solid #999', 
      position: 'absolute', 
      cursor: 'pointer', 
      display: 'flex', 
      flexDirection: 'column', 
      padding: 5,            // [ä¿®æ”¹] å†…è¾¹è·å‡å°
      transition: 'transform 0.1s cubic-bezier(0.2, 0.8, 0.2, 1)', 
      width: 80,             // [ä¿®æ”¹] å®½åº¦ç¼©å°åˆ° 80
      height: 110            // [ä¿®æ”¹] é«˜åº¦ç¼©å°åˆ° 110
  },
  
  actionBar: { position: 'absolute', bottom: 0, width: '100%', height: 120, background: 'linear-gradient(to top, rgba(0,0,0,0.9), transparent)', display: 'flex', justifyContent: 'center', alignItems: 'center', pointerEvents: 'none', zIndex: 30 }, 
  playButton: { pointerEvents: 'auto', padding: '15px 60px', background: 'linear-gradient(to bottom, #f1c40f, #f39c12)', border: 'none', borderRadius: 40, fontWeight: 'bold', cursor: 'pointer', marginLeft: 20, fontSize: 20, boxShadow: '0 8px 20px rgba(243, 156, 18, 0.4)', color: '#fff', textShadow: '0 1px 2px rgba(0,0,0,0.2)', transition: 'transform 0.1s' },
  passButton: { pointerEvents: 'auto', padding: '15px 40px', background: '#7f8c8d', border: 'none', borderRadius: 40, fontWeight: 'bold', cursor: 'pointer', fontSize: 18, color: 'white', boxShadow: '0 5px 15px rgba(0,0,0,0.3)' },
  waitingBadge: { color: 'rgba(255,255,255,0.7)', fontSize: 16, display: 'flex', alignItems: 'center', gap: 10, background: 'rgba(0,0,0,0.3)', padding: '10px 20px', borderRadius: 30 },
  modalOverlay: { position: 'fixed', top:0, left:0, right:0, bottom:0, background: 'rgba(0,0,0,0.85)', display:'flex', justifyContent:'center', alignItems:'center', zIndex: 99, backdropFilter: 'blur(8px)' },
  modalContent: { background: 'white', padding: 60, borderRadius: 30, textAlign: 'center', boxShadow: '0 30px 80px rgba(0,0,0,0.6)', animation: 'popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275)' },
  
  // Lobby æ ·å¼
  lobbyCard: { background: 'white', padding: 40, borderRadius: 20, width: '1000px', maxWidth: '95vw', minHeight: '600px', display: 'flex', flexDirection: 'column', boxShadow: '0 30px 60px rgba(0,0,0,0.5)' },
  lobbyHeader: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 30, paddingBottom: 20, borderBottom: '1px solid #eee' },
  tag: { background: '#f0f9f4', color: '#27ae60', padding: '5px 10px', borderRadius: 20, fontSize: 14, display: 'flex', alignItems: 'center', gap: 5 },
  playerGrid: { display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(180px, 1fr))', gap: 20, flex: 1, alignContent: 'start' },
  lobbyPlayer: { border: '2px solid #eee', borderRadius: 12, padding: 25, display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 15, position: 'relative', transition: 'all 0.2s' },
  avatarLarge: { width: 80, height: 80, borderRadius: '50%', background: '#34495e', color: 'white', fontSize: 32, display: 'flex', alignItems: 'center', justifyContent: 'center', fontWeight: 'bold' },
  hostBadge: { position: 'absolute', top: 10, right: 10, background: '#f1c40f', color: '#333', fontSize: 12, padding: '4px 8px', borderRadius: 4, fontWeight: 'bold' },
  lobbyFooter: { marginTop: 'auto', borderTop: '1px solid #eee', paddingTop: 20, display: 'flex', justifyContent: 'center' },
};

================================================================================
FILE PATH: client\src\utils\cardLogic.js
================================================================================
// çº¯é€»è¾‘å·¥å…·

// æ’åºæƒé‡ï¼š2(15) > A(14) > K(13)...
export const getSortValue = (cardVal) => {
    const normalized = cardVal % 54;
    if (normalized === 52) return 16;
    if (normalized === 53) return 17;
    const base = normalized % 13;
    if (base === 0) return 14; 
    if (base === 1) return 15; 
    return base + 1;
};

// èŠ±è‰²æ’åºæƒé‡
export const getSuitSortValue = (cardVal) => {
    if (cardVal >= 52) return cardVal * 100;
    const suit = Math.floor(cardVal / 13) % 4; 
    const val = cardVal % 13;
    return suit * 100 + val; 
};

// è·å–å•å¼ ç‰Œçš„æ˜¾ç¤ºä¿¡æ¯
export const getCardDisplay = (cardVal) => {
    const normalizedValue = cardVal % 54; 
    if (normalizedValue === 52) return { suit: 'Joker', text: 'å°ç‹', color: '#000', isScore: false };
    if (normalizedValue === 53) return { suit: 'Joker', text: 'å¤§ç‹', color: '#d00', isScore: false };
    
    const suits = ['â™ ', 'â™¥', 'â™£', 'â™¦'];
    const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
    const valueIndex = normalizedValue % 13;
    const suit = suits[Math.floor(normalizedValue / 13)];
    const color = (suit === 'â™¥' || suit === 'â™¦') ? '#d00' : '#000';
    const text = values[valueIndex];
    const isScore = (text === '5' || text === '10' || text === 'K');
    
    return { suit, text, color, isScore };
};

// æ‰‹ç‰Œæ’åº
export const sortHand = (cards, mode = 'POINT') => {
    if (mode === 'SUIT') {
        return [...cards].sort((a, b) => getSuitSortValue(b) - getSuitSortValue(a));
    }
    return [...cards].sort((a, b) => getSortValue(b) - getSortValue(a));
};

// è®¡ç®—æ‰‹ç‰Œé—´è· - [ä¿®æ”¹] é€‚é…ç§»åŠ¨ç«¯
export const calculateCardSpacing = (count, screenWidth) => {
    if (count <= 1) return 0;
    
    // [ä¿®æ”¹] é€‚é…æ‰‹æœºï¼šå¦‚æœå±å¹•å¾ˆçª„ï¼Œå¢åŠ å¯ç”¨å®½åº¦çš„æ¯”ä¾‹
    const isMobile = screenWidth < 768;
    const padding = isMobile ? 20 : 100; // æ‰‹æœºç«¯ç•™ç™½å°‘ä¸€ç‚¹
    
    const w = Math.min(screenWidth - padding, 1400); 
    
    // [ä¿®æ”¹] å¡ç‰Œå®é™…æ¸²æŸ“å®½åº¦ (å¯¹åº” styles.js é‡Œçš„ card.width)
    // ä¹‹å‰æ˜¯100ï¼Œæ”¹æˆäº†80æ¥é€‚é…
    const cardWidth = 80; 
    
    // æœ€å¤§é—´è·ï¼šç‰Œå°‘çš„æ—¶å€™ä¸è¦åˆ†å¤ªå¼€
    const maxGap = 50; 
    
    const neededWidth = (count - 1) * maxGap + cardWidth;
    
    // å¦‚æœéœ€è¦çš„å®½åº¦å°äºå±å¹•å®½ï¼Œå°±ç”¨æœ€å¤§é—´è·
    if (neededWidth <= w) return maxGap;
    
    // å¦åˆ™ï¼ŒæŒ¤å‹ç‰Œçš„é—´è·
    return (w - cardWidth) / (count - 1);
};

================================================================================
FILE PATH: client\src\utils\SoundManager.js
================================================================================
/**
 * ç®€æ˜“ Web Audio API éŸ³æ•ˆç®¡ç†å™¨
 * ä¸éœ€è¦å¤–éƒ¨ MP3 æ–‡ä»¶ï¼Œç›´æ¥ç”¨ä»£ç ç”Ÿæˆå£°éŸ³
 */
const SoundManager = {
    ctx: null,

    init: () => {
        if (!SoundManager.ctx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            SoundManager.ctx = new AudioContext();
        }
    },

    // æ’­æ”¾æŒ‡å®šç±»å‹çš„éŸ³æ•ˆ
    play: (type) => {
        try {
            // æŸäº›æµè§ˆå™¨éœ€è¦ç”¨æˆ·äº¤äº’åæ‰èƒ½æ¢å¤ Context
            if (SoundManager.ctx && SoundManager.ctx.state === 'suspended') {
                SoundManager.ctx.resume();
            }
            if (!SoundManager.ctx) SoundManager.init();

            switch (type) {
                case 'deal': // å‘ç‰Œ/ç‚¹å‡»ç‰Œ (çŸ­ä¿ƒçš„é«˜é¢‘éŸ³)
                    SoundManager.beep(800, 0.05, 'sine');
                    break;
                case 'play': // å‡ºç‰Œ (æœ‰æ‰“å‡»æ„Ÿ)
                    SoundManager.noise(0.1); 
                    break;
                case 'win': // èƒœåˆ© (è¿ç»­çš„ç¶éŸ³)
                    SoundManager.arpeggio([523.25, 659.25, 783.99, 1046.50], 0.1);
                    break;
                case 'lose': // å¤±è´¥/è¢«å‹ (ä½æ²‰)
                    SoundManager.beep(150, 0.3, 'sawtooth');
                    break;
                case 'alert': // è½®åˆ°ä½ äº†
                    SoundManager.beep(880, 0.1, 'square');
                    setTimeout(() => SoundManager.beep(880, 0.1, 'square'), 150);
                    break;
                default:
                    break;
            }
        } catch (e) {
            console.warn('Audio play failed:', e);
        }
    },

    // --- åˆæˆå™¨åº•å±‚å‡½æ•° ---

    // å‘å‡ºå•éŸ³
    beep: (freq, duration, type = 'sine') => {
        const ctx = SoundManager.ctx;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();

        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        
        gain.gain.setValueAtTime(0.1, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(ctx.destination);

        osc.start();
        osc.stop(ctx.currentTime + duration);
    },

    // æ¨¡æ‹Ÿæ‰“å‡»å£° (ç™½å™ªéŸ³)
    noise: (duration) => {
        const ctx = SoundManager.ctx;
        const bufferSize = ctx.sampleRate * duration;
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }

        const noise = ctx.createBufferSource();
        noise.buffer = buffer;
        
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.2, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);

        noise.connect(gain);
        gain.connect(ctx.destination);
        noise.start();
    },

    // ç¶éŸ³ (èƒœåˆ©éŸ³æ•ˆ)
    arpeggio: (freqs, interval) => {
        freqs.forEach((f, i) => {
            setTimeout(() => SoundManager.beep(f, 0.2, 'triangle'), i * interval * 1000);
        });
    }
};

export default SoundManager;

================================================================================
FILE PATH: client\vite.config.js
================================================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})


================================================================================
FILE PATH: server\game\BotLogic.js
================================================================================
const CardRules = require('./CardRules');

const BotLogic = {
    // ç®€å•çš„å†³ç­–å‡½æ•°
    decideMove: (hand, lastPlayedCards, deckCount) => {
        try {
            // 1. å¦‚æœå½“å‰æ²¡æœ‰è¢«å‹ç‰Œï¼ˆè‡ªå·±é¢†å‡ºï¼‰ï¼Œå‡ºæœ€å°çš„ä¸€å¼ ç‰Œ
            if (!lastPlayedCards || lastPlayedCards.length === 0) {
                if (hand.length === 0) return null;
                // ç®€å•ç­–ç•¥ï¼šæ€»æ˜¯å‡ºæ‰‹ä¸­æœ€å°çš„ä¸€å¼ ç‰Œ
                return [hand[0]]; 
            }

            // 2. å¦‚æœæœ‰äººå‡ºç‰Œäº†ï¼Œå°è¯•ç®¡ä¸Š
            const lastHandState = CardRules.analyze(lastPlayedCards, deckCount);
            if (lastHandState.type === 'INVALID') return null; 

            // æ•´ç†æ‰‹ç‰Œï¼šæŒ‰ç‚¹æ•°åˆ†ç»„
            const grouped = {};
            hand.forEach(c => {
                const p = CardRules.getPoint(c);
                if (!grouped[p]) grouped[p] = [];
                grouped[p].push(c);
            });
            
            const uniquePoints = Object.keys(grouped).map(Number).sort((a,b) => a-b);

            // ç­–ç•¥ Aï¼šå°è¯•ç”¨åŒç±»å‹çš„ç‰Œç®¡ï¼ˆä¸å«ç‚¸å¼¹ï¼‰
            if (['SINGLE', 'PAIR', 'TRIPLE'].includes(lastHandState.type)) {
                const countNeeded = lastHandState.type === 'SINGLE' ? 1 : 
                                    lastHandState.type === 'PAIR' ? 2 : 3;
                
                for (let p of uniquePoints) {
                    if (p > lastHandState.val && grouped[p].length >= countNeeded) {
                        return grouped[p].slice(0, countNeeded);
                    }
                }
            }
            
            // ç®€å•çš„è¿å¯¹/é£æœºç®¡ç‰Œå°è¯• (åªç®¡é•¿åº¦ä¸€è‡´çš„)
            if (lastHandState.type === 'LIANDUI' || lastHandState.type === 'AIRPLANE') {
                 // è¿™æ˜¯ä¸€ä¸ªå¤æ‚çš„æœç´¢ï¼Œè¿™é‡Œç®€åŒ–ï¼šBotæš‚ä¸å¤„ç†å¤æ‚ç‰Œå‹çš„è·Ÿç‰Œï¼Œç›´æ¥å°è¯•ç”¨ç‚¸å¼¹ç‚¸
            }

            // ç­–ç•¥ Bï¼šå°è¯•ç”¨ç‚¸å¼¹ç‚¸
            const currentLevel = lastHandState.level || 0;
            
            // æ‰¾æ™®é€šç‚¸å¼¹ (4å¼ åŠä»¥ä¸Š)
            for (let p of uniquePoints) {
                if (grouped[p].length >= 4) {
                    const bombCards = grouped[p];
                    const bombState = CardRules.analyze(bombCards, deckCount);
                    
                    // çº§åˆ«é«˜ï¼Œæˆ–åŒçº§åˆ«ç‚¹æ•°å¤§
                    if (bombState.level > currentLevel) return bombCards;
                    if (bombState.level === currentLevel && bombState.val > lastHandState.val) return bombCards;
                }
            }

            // 3. å®åœ¨ç®¡ä¸ä¸Šï¼Œè¿‡
            return null;
        } catch (e) {
            console.error("BotLogic error:", e);
            return null; // æŠ¥é”™æ—¶é»˜è®¤è¿‡ç‰Œ
        }
    }
};

module.exports = BotLogic;

================================================================================
FILE PATH: server\game\CardRules.js
================================================================================
// çº¯è§„åˆ™è®¡ç®— (510K é€»è¾‘ã€æ¯”å¤§å°)

const CardRules = {
    // 1. åŸºç¡€æ˜ å°„
    // 3=3 ... K=13, A=14, 2=15, å°ç‹=16, å¤§ç‹=17
    getPoint: (cardVal) => {
        const normalized = cardVal % 54;
        if (normalized === 52) return 16;
        if (normalized === 53) return 17;
        const base = normalized % 13;
        if (base === 0) return 14; // A
        if (base === 1) return 15; // 2
        return base + 1; // 3 => 3
    },

    // è·å–ç‰Œçš„åˆ†æ•° (5=5, 10=10, K=10)
    getCardScore: (cardVal) => {
        const p = CardRules.getPoint(cardVal);
        if (p === 5) return 5;
        if (p === 10) return 10;
        if (p === 13) return 10; // K
        return 0;
    },

    // è®¡ç®—ä¸€ç»„ç‰Œçš„æ€»åˆ†
    calculateTotalScore: (cards) => {
        return cards.reduce((sum, c) => sum + CardRules.getCardScore(c), 0);
    },

    // è·å–ç‰Œçš„èŠ±è‰² (0-3)
    getSuit: (cardVal) => {
        const normalized = cardVal % 54;
        if (normalized >= 52) return -1; // ç‹æ²¡æœ‰èŠ±è‰²
        return Math.floor(normalized / 13);
    },

    // 2. æ ¸å¿ƒï¼šç‰Œå‹åˆ†æ
    analyze: (cards, deckCount = 1) => {
        const len = cards.length;
        if (len === 0) return { type: 'EMPTY' };

        // æ’åºï¼šç‚¹æ•°ä»å°åˆ°å¤§
        const points = cards.map(CardRules.getPoint).sort((a, b) => a - b);
        
        // ç»Ÿè®¡ç‚¹æ•°é¢‘ç‡ { point: count }
        const counts = {};
        points.forEach(p => { counts[p] = (counts[p] || 0) + 1; });
        const uniquePoints = Object.keys(counts).map(Number).sort((a,b)=>a-b);
        
        // --- éç‚¸å¼¹ç‰Œå‹ ---

        // å•å¼ 
        if (len === 1) return { type: 'SINGLE', val: points[0], level: 0 };

        // å¯¹å­
        if (len === 2 && points[0] === points[1]) {
            return { type: 'PAIR', val: points[0], level: 0 };
        }

        // ä¸‰å¼  (ä¸å¸¦) - ä¹Ÿå¯ä»¥çœ‹ä½œæ˜¯é•¿åº¦ä¸º3çš„é£æœºï¼Œä½†ä¸ºäº†å…¼å®¹æ€§ä¿ç•™ä¸º TRIPLE
        if (len === 3 && uniquePoints.length === 1) {
            return { type: 'TRIPLE', val: points[0], level: 0 };
        }

        // è¿å¯¹ (Liandui)
        if (len >= 4 && len % 2 === 0) {
            // ç®€å•æ ¡éªŒï¼šä¸å«2å’Œç‹
            if (!points.some(p => p >= 15)) {
                let isLiandui = true;
                // æ£€æŸ¥æ˜¯å¦æ˜¯è¿ç»­çš„å¯¹å­ (3344, 334455)
                // æ¡ä»¶1: å»é‡åçš„æ•°é‡è¦æ˜¯æ€»å¼ æ•°çš„ä¸€åŠ (è¯´æ˜å…¨æ˜¯æˆå¯¹çš„)
                if (uniquePoints.length === len / 2) {
                     // æ¡ä»¶2: æ¯å¼ ç‰Œå¿…é¡»å‡ºç°2æ¬¡ (é¿å… 3333 è¿™ç§è¢«è¯¯åˆ¤ä¸ºè¿å¯¹ï¼Œè™½ç„¶3333æ˜¯ç‚¸å¼¹é€»è¾‘ä¼šä¼˜å…ˆï¼Œä½†ä»¥é˜²ä¸‡ä¸€)
                     for (let p of uniquePoints) {
                         if (counts[p] !== 2) isLiandui = false;
                     }

                     // æ¡ä»¶3: æ£€æŸ¥ uniquePoints æ˜¯å¦è¿ç»­
                     for(let i=0; i<uniquePoints.length-1; i++) {
                         if(uniquePoints[i+1] !== uniquePoints[i]+1) isLiandui = false;
                     }
                     
                     if (isLiandui) return { type: 'LIANDUI', val: points[0], len: len, level: 0 };
                }
            }
        }

        // [æ–°å¢] é£æœº (Airplane) - è¿ç»­çš„ä¸‰ä¸å¸¦
        // è§„åˆ™ï¼šè‡³å°‘2ä¸ªè¿ç»­çš„ä¸‰å¼  (len >= 6)ï¼Œä¸”æ˜¯3çš„å€æ•°
        if (len >= 6 && len % 3 === 0) {
            // ç®€å•æ ¡éªŒï¼šä¸å«2å’Œç‹ (é€šå¸¸é¡ºå­ç±»ç‰Œå‹ä¸åˆ°2)
            if (!points.some(p => p >= 15)) {
                let isAirplane = true;
                
                // æ¡ä»¶1: å»é‡åçš„æ•°é‡åº”è¯¥æ˜¯æ€»å¼ æ•°çš„ 1/3 (ä¾‹å¦‚ 333444ï¼Œ6å¼ ç‰Œï¼Œå»é‡æ˜¯3,4 ä¸¤ä¸ªæ•°)
                if (uniquePoints.length === len / 3) {
                    // æ¡ä»¶2: æ¯ä¸ªç‚¹æ•°å¿…é¡»å‡ºç°æ­£å¥½3æ¬¡
                    for (let p of uniquePoints) {
                        if (counts[p] !== 3) isAirplane = false;
                    }

                    // æ¡ä»¶3: è¿ç»­æ€§æ£€æŸ¥
                    for(let i=0; i<uniquePoints.length-1; i++) {
                        if(uniquePoints[i+1] !== uniquePoints[i]+1) isAirplane = false;
                    }

                    if (isAirplane) return { type: 'AIRPLANE', val: points[0], len: len, level: 0 };
                }
            }
        }

        // --- ç‚¸å¼¹ç‰Œå‹ (Level 1-5) ---

        // Level 1 & 2: 510K
        if (len === 3) {
            const has5 = points.includes(5);
            const has10 = points.includes(10);
            const hasK = points.includes(13);
            if (has5 && has10 && hasK) {
                // æ£€æŸ¥èŠ±è‰²
                const suits = cards.map(CardRules.getSuit);
                const isPure = (suits[0] === suits[1] && suits[1] === suits[2]);
                if (isPure) {
                    return { type: '510K_PURE', val: suits[0], level: 2 }; // çº¯510K (Level 2)
                } else {
                    return { type: '510K_MIXED', val: 0, level: 1 }; // æ‚510K (Level 1)
                }
            }
        }

        // Level 3: æ™®é€šç‚¸å¼¹ (>=4å¼ )
        if (uniquePoints.length === 1 && len >= 4) {
            // Level 5: è‡³å°Šæ»¡ç‚¸ (Rankæ•°é‡ == DECK_COUNT * 4)
            if (len === deckCount * 4) {
                 return { type: 'BOMB_MAX', val: points[0], level: 5 };
            }
            // æ™®é€šç‚¸å¼¹
            return { type: 'BOMB_STD', val: points[0], len: len, level: 3 };
        }

        // Level 4: å¤©ç‹ç‚¸ (æ‰€æœ‰ç‹)
        const isAllJokers = points.every(p => p >= 16);
        if (isAllJokers && len === deckCount * 2) {
            return { type: 'BOMB_KING', val: 999, level: 4 };
        }

        return { type: 'INVALID' };
    },

    // 3. æ ¡éªŒèƒ½å¦ç®¡ç‰Œ
    canPlay: (newCards, lastCards, deckCount) => {
        const newHand = CardRules.analyze(newCards, deckCount);
        if (newHand.type === 'INVALID') return false;

        // è‡ªç”±å‡ºç‰Œ
        if (!lastCards || lastCards.length === 0) return true;

        const lastHand = CardRules.analyze(lastCards, deckCount);

        // A. ç‚¸å¼¹ vs éç‚¸å¼¹
        if (newHand.level > 0 && lastHand.level === 0) return true;
        if (newHand.level === 0 && lastHand.level > 0) return false;

        // B. ç‚¸å¼¹ä¹‹é—´ (Level æ¯”è¾ƒ)
        if (newHand.level > 0 && lastHand.level > 0) {
            if (newHand.level > lastHand.level) return true;
            if (newHand.level < lastHand.level) return false;

            // åŒçº§åˆ«æ¯”è¾ƒ
            if (newHand.type === '510K_MIXED') return false; // äº’ä¸ç®¡
            if (newHand.type === '510K_PURE') return false; 

            if (newHand.type === 'BOMB_STD') {
                if (newHand.len > lastHand.len) return true;
                if (newHand.len < lastHand.len) return false;
                return newHand.val > lastHand.val;
            }
            
            if (newHand.type === 'BOMB_MAX') return newHand.val > lastHand.val;
            return false;
        }

        // C. éç‚¸å¼¹ä¹‹é—´ (åŒç‰Œå‹æ¯”è¾ƒ)
        if (newHand.type === lastHand.type) {
            // è¿å¯¹å’Œé£æœºå¿…é¡»å¼ æ•°ä¸€è‡´æ‰èƒ½æ¯”è¾ƒ
            if ((newHand.type === 'LIANDUI' || newHand.type === 'AIRPLANE') && newHand.len !== lastHand.len) return false;
            
            // å¿…é¡»å¼ æ•°ä¸€è‡´
            if (newCards.length !== lastCards.length) return false;
            
            // æ¯”è¾ƒæœ€å°çš„é‚£ä¸ªç‚¹æ•° (val)
            return newHand.val > lastHand.val;
        }

        return false;
    }
};

module.exports = CardRules;

================================================================================
FILE PATH: server\game\Deck.js
================================================================================
// ç‰Œåº“ç”Ÿæˆä¸æ´—ç‰Œ


class Deck {
    constructor(deckCount = 1) {
        this.deck = [];
        // ç”Ÿæˆå¤šå‰¯ç‰Œã€‚æ¯å‰¯ç‰Œæ˜¯ 0-53ã€‚
        // æˆ‘ä»¬ä½¿ç”¨ i + d * 54 æ¥ä¿è¯æ¯å¼ ç‰Œæœ‰å”¯ä¸€IDï¼Œæ–¹ä¾¿å‰ç«¯æ¸²æŸ“ Key å€¼
        for (let d = 0; d < deckCount; d++) {
             for (let i = 0; i < 54; i++) {
                this.deck.push(i + d * 54); 
            }
        }
    }

    shuffle() {
        // Fisher-Yates æ´—ç‰Œç®—æ³•
        for (let i = this.deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
        }
    }

    deal(playerCount) {
        this.shuffle();
        const hands = {};
        const totalCards = this.deck.length;
        const cardsPerPlayer = Math.floor(totalCards / playerCount); 
        
        for (let i = 0; i < playerCount; i++) {
            hands[i] = this.deck.slice(i * cardsPerPlayer, (i + 1) * cardsPerPlayer);
            // å°†å¤šä½™çš„ç‰Œå‘ç»™æœ€åä¸€ä¸ªäººï¼ˆç®€åŒ–å¤„ç†ï¼‰
            if (i === playerCount - 1) {
                 hands[i] = this.deck.slice(i * cardsPerPlayer);
            }
        }
        return hands;
    }
}

module.exports = Deck;

================================================================================
FILE PATH: server\game\GameManager.js
================================================================================
const CardRules = require('./CardRules');
const Deck = require('./Deck');
const BotLogic = require('./BotLogic');

class GameManager {
    constructor(roomConfig, players, io, roomId) {
        this.config = roomConfig;
        this.players = players; 
        this.io = io; 
        this.roomId = roomId;

        this.grandScores = {};
        this.players.forEach(p => this.grandScores[p.id] = 0);
        this.lastWinnerId = null;
        this.gameState = null; 
        
        this.timer = null;
        this.botTimer = null;
        this.turnStartTime = 0; 
    }

    // [æ–°å¢] åˆ‡æ¢æ‰˜ç®¡çŠ¶æ€
    toggleAutoPlay(playerId) {
        const player = this.players.find(p => p.id === playerId);
        if (!player || player.isBot) return; 

        player.isAutoPlay = !player.isAutoPlay;
        
        if (this.gameState && this.players[this.gameState.currentTurnIndex].id === playerId) {
            if (player.isAutoPlay) {
                this._checkAndRunBot();
            } else {
                if (this.botTimer) {
                    clearTimeout(this.botTimer);
                    this.botTimer = null;
                }
                this._resetTimer();
            }
        }
    }

    startRound(isNextRound = false) {
        if (!isNextRound) {
            this.players.forEach(p => this.grandScores[p.id] = 0);
            this.lastWinnerId = null;
        }

        const deck = new Deck(this.config.deckCount);
        const hands = deck.deal(this.players.length);

        let startIndex = 0;
        if (this.lastWinnerId) {
            const winnerIdx = this.players.findIndex(p => p.id === this.lastWinnerId);
            if (winnerIdx !== -1) startIndex = winnerIdx;
        }

        this.gameState = {
            hands: {},
            currentTurnIndex: startIndex,
            lastPlayedCards: [],    
            consecutivePasses: 0,   
            roundPoints: {},        
            pendingTablePoints: 0,  
            roundWinnerId: null, 
            finishedRank: [],    
        };

        this.players.forEach((p, index) => {
            this.gameState.hands[p.id] = hands[index];
            this.gameState.roundPoints[p.id] = 0;
        });

        this._resetTimer();
        this._checkAndRunBot();

        return {
            startPlayerIndex: startIndex,
            startPlayerId: this.players[startIndex].id,
            hands: this.gameState.hands
        };
    }

    _checkAndRunBot() {
        if (!this.gameState) return;
        
        if (this.botTimer) {
            clearTimeout(this.botTimer);
            this.botTimer = null;
        }

        if (this._getActivePlayerCount() <= 1 && this.gameState.lastPlayedCards.length === 0) return;

        const currPlayer = this.players[this.gameState.currentTurnIndex];
        const isAI = currPlayer.isBot || currPlayer.isAutoPlay;

        if (isAI && this.gameState.hands[currPlayer.id].length > 0) {
            const delay = 1000 + Math.random() * 1000;
            this.botTimer = setTimeout(() => {
                this._executeBotTurn(currPlayer);
            }, delay);
        }
    }

    _executeBotTurn(botPlayer) {
        if (!this.gameState) return;
        if (this.players[this.gameState.currentTurnIndex].id !== botPlayer.id) return;

        try {
            const hand = this.gameState.hands[botPlayer.id];
            if (!hand || hand.length === 0) {
                 this._advanceTurn(); 
                 return;
            }

            const isNewRound = this.gameState.lastPlayedCards.length === 0;
            const cardsToBeat = isNewRound ? [] : this.gameState.lastPlayedCards;

            const sortedHand = [...hand].sort((a,b) => CardRules.getPoint(a) - CardRules.getPoint(b));
            
            const cardsToPlay = BotLogic.decideMove(sortedHand, cardsToBeat, this.config.deckCount);

            if (cardsToPlay) {
                console.log(`[Bot/Auto] ${botPlayer.name} plays ${cardsToPlay.length} cards.`);
                const result = this.playCards(botPlayer.id, cardsToPlay);
                
                if (result.success) {
                    // [ä¿®å¤] å…³é”®ä¿®å¤ï¼šå¦‚æœæ˜¯çœŸå®ç©å®¶æ‰˜ç®¡ï¼Œå¿…é¡»å‘é€æ‰‹ç‰Œæ›´æ–°äº‹ä»¶ï¼Œå¦åˆ™å®¢æˆ·ç«¯çœ‹ä¸åˆ°ç‰Œå°‘äº†
                    if (!botPlayer.isBot) {
                        this.io.to(botPlayer.id).emit('hand_update', this.gameState.hands[botPlayer.id]);
                    }

                    if (result.isRoundOver) {
                        this._handleWin(result, botPlayer.id);
                    } else {
                        const publicState = this.getPublicState();
                        this.io.to(this.roomId).emit('game_state_update', publicState);
                    }
                } else {
                    console.error(`[Bot Error] Play failed: ${result.error}`);
                    if (!isNewRound) this.passTurn(botPlayer.id);
                }
            } else {
                console.log(`[Bot/Auto] ${botPlayer.name} passes.`);
                const result = this.passTurn(botPlayer.id);
                if (result.success) {
                    const publicState = this.getPublicState();
                    publicState.infoText = isNewRound ? '' : 'PASS';
                    this.io.to(this.roomId).emit('game_state_update', publicState);
                }
            }
        } catch (error) {
            console.error(`[Bot Error] Exception in _executeBotTurn:`, error);
        }
    }

    _handleWin(result, winnerId) {
        const rInfo = result.roundResult;
        if (rInfo.isGrandOver) {
            this.io.to(this.roomId).emit('grand_game_over', { 
                grandWinner: rInfo.roundWinnerName, 
                grandScores: rInfo.grandScores 
            });
            this.gameState = null; 
            this._clearTimer(); 
        } else {
            this.io.to(this.roomId).emit('round_over', {
                roundWinner: rInfo.roundWinnerName,
                pointsEarned: rInfo.pointsEarned,
                detail: rInfo.detail,
                grandScores: rInfo.grandScores
            });
            this._clearTimer();
        }
    }

    playCards(playerId, cards) {
        if (!this.gameState) return { success: false, error: 'æ¸¸æˆæœªå¼€å§‹' };

        const currPlayer = this.players[this.gameState.currentTurnIndex];
        if (currPlayer.id !== playerId) return { success: false, error: 'è¿˜æ²¡è½®åˆ°ä½ ' };

        const playerHand = this.gameState.hands[playerId];
        if (!this._handContainsCards(playerHand, cards)) {
            return { success: false, error: 'æ‰‹ç‰Œä¸è¶³æˆ–æ•°æ®ä¸åŒæ­¥' };
        }

        const isNewRound = this.gameState.lastPlayedCards.length === 0;
        const cardsToBeat = isNewRound ? [] : this.gameState.lastPlayedCards;

        if (!CardRules.canPlay(cards, cardsToBeat, this.config.deckCount)) {
            return { success: false, error: 'ç‰Œå‹ä¸ç¬¦æˆ–ç®¡ä¸ä¸Š' };
        }

        this._removeCardsFromHand(playerId, cards);
        this.gameState.pendingTablePoints += CardRules.calculateTotalScore(cards);
        this.gameState.lastPlayedCards = cards;
        this.gameState.consecutivePasses = 0;
        this.gameState.roundWinnerId = playerId;

        const isFinished = this.gameState.hands[playerId].length === 0;
        if (isFinished) {
            if (!this.gameState.finishedRank.includes(playerId)) {
                this.gameState.finishedRank.push(playerId);
            }
        }

        const activeCount = this._getActivePlayerCount();
        
        if (activeCount <= 1) {
            this._clearTimer();
            const roundResult = this._concludeRound();
            return { 
                success: true, 
                isRoundOver: true,
                roundResult,
                cardsPlayed: cards,
                pendingPoints: this.gameState.pendingTablePoints
            };
        }

        this._advanceTurn();
        this._resetTimer();
        this._checkAndRunBot();

        return { 
            success: true, 
            isRoundOver: false,
            cardsPlayed: cards,
            pendingPoints: this.gameState.pendingTablePoints
        };
    }

    passTurn(playerId) {
        if (!this.gameState) return { success: false, error: 'æ¸¸æˆæœªå¼€å§‹' };

        const currPlayer = this.players[this.gameState.currentTurnIndex];
        if (currPlayer.id !== playerId) return { success: false, error: 'è¿˜æ²¡è½®åˆ°ä½ ' };

        if (this.gameState.lastPlayedCards.length === 0) {
            return { success: false, error: 'å¿…é¡»å‡ºç‰Œ' };
        }

        this.gameState.consecutivePasses++;
        this._advanceTurn(); 

        const winnerHand = this.gameState.hands[this.gameState.roundWinnerId];
        const winnerIsActive = winnerHand && winnerHand.length > 0;
        const activeCount = this._getActivePlayerCount();
        
        const passesNeeded = winnerIsActive ? (activeCount - 1) : activeCount;

        let turnCleared = false;
        if (this.gameState.consecutivePasses >= passesNeeded) {
            const wId = this.gameState.roundWinnerId;
            if (wId) {
                this.gameState.roundPoints[wId] = (this.gameState.roundPoints[wId] || 0) + this.gameState.pendingTablePoints;
                this.gameState.pendingTablePoints = 0;
                
                if (this.gameState.hands[wId].length > 0) {
                     const wIdx = this.players.findIndex(p => p.id === wId);
                     this.gameState.currentTurnIndex = wIdx;
                }
            }
            
            this.gameState.lastPlayedCards = [];
            this.gameState.consecutivePasses = 0;
            turnCleared = true;
        }

        this._resetTimer(); 
        this._checkAndRunBot();

        return { success: true, turnCleared };
    }

    _clearTimer() {
        if (this.timer) clearTimeout(this.timer);
        if (this.botTimer) clearTimeout(this.botTimer);
        this.timer = null;
        this.botTimer = null;
    }

    _resetTimer() {
        this._clearTimer();
        if (this.gameState && this._getActivePlayerCount() > 1) {
            this.turnStartTime = Date.now();
            const timeLimit = this.config.turnTimeout || 60000;
            this.timer = setTimeout(() => {
                this._handleTimeout();
            }, timeLimit);
        }
    }

    _handleTimeout() {
        if (!this.gameState) return;
        const currIdx = this.gameState.currentTurnIndex;
        const currPlayer = this.players[currIdx];
        
        console.log(`[Timeout] Player ${currPlayer.name} (${currPlayer.id}) timed out.`);
        const isNewRound = this.gameState.lastPlayedCards.length === 0;

        if (isNewRound) {
            const hand = this.gameState.hands[currPlayer.id];
            if (!hand || hand.length === 0) { this._advanceTurn(); return; }

            const sorted = hand.map(c => ({ id: c, val: CardRules.getPoint(c) })).sort((a, b) => a.val - b.val);
            const cardToPlay = [sorted[0].id]; 
            
            const result = this.playCards(currPlayer.id, cardToPlay);
            if (result.success) {
                this.io.to(currPlayer.id).emit('hand_update', this.gameState.hands[currPlayer.id]);
                
                if (result.isRoundOver) {
                     this._handleWin(result, currPlayer.id);
                } else {
                     const publicState = this.getPublicState();
                     publicState.infoText = `${currPlayer.name} è¶…æ—¶ï¼Œç³»ç»Ÿä»£æ‰“`;
                     this.io.to(this.roomId).emit('game_state_update', publicState);
                }
            }
        } else {
            const result = this.passTurn(currPlayer.id);
            if (result.success) {
                const publicState = this.getPublicState();
                publicState.infoText = `${currPlayer.name} è¶…æ—¶ï¼Œè‡ªåŠ¨è¿‡ç‰Œ`;
                this.io.to(this.roomId).emit('game_state_update', publicState);
            }
        }
    }

    _getActivePlayerCount() {
        if (!this.gameState) return 0;
        let count = 0;
        for (const p of this.players) {
            if (this.gameState.hands[p.id] && this.gameState.hands[p.id].length > 0) {
                count++;
            }
        }
        return count;
    }

    _advanceTurn() {
        const playerCount = this.players.length;
        let nextIndex = this.gameState.currentTurnIndex;
        let attempts = 0;
        do {
            nextIndex = (nextIndex + 1) % playerCount;
            attempts++;
        } while (
            this.gameState.hands[this.players[nextIndex].id].length === 0 && 
            attempts < playerCount 
        );
        this.gameState.currentTurnIndex = nextIndex;
    }

    getPublicState() {
        if (!this.gameState) return null;
        
        const currentScoresDisplay = {};
        const playersInfo = {};
        
        this.players.forEach(p => {
            currentScoresDisplay[p.id] = (this.grandScores[p.id] || 0) + (this.gameState.roundPoints[p.id] || 0);
            playersInfo[p.id] = { isBot: p.isBot, isAutoPlay: p.isAutoPlay };
        });

        const winnerObj = this.players.find(p => p.id === this.gameState.roundWinnerId);

        let remainingSeconds = 0;
        if (this.turnStartTime) {
            const timeLimit = this.config.turnTimeout || 60000;
            const elapsed = Date.now() - this.turnStartTime;
            remainingSeconds = Math.max(0, Math.ceil((timeLimit - elapsed) / 1000));
        }
        
        return {
            turnIndex: this.gameState.currentTurnIndex,
            currentTurnId: this.players[this.gameState.currentTurnIndex].id,
            turnRemaining: remainingSeconds, 
            lastPlayed: this.gameState.lastPlayedCards,
            lastPlayerName: winnerObj ? winnerObj.name : '',
            scores: currentScoresDisplay,
            pendingPoints: this.gameState.pendingTablePoints,
            finishedRank: this.gameState.finishedRank,
            playersInfo: playersInfo 
        };
    }

    reconnectPlayer(oldId, newId) {
        if (this.grandScores[oldId] !== undefined) {
            this.grandScores[newId] = this.grandScores[oldId];
            delete this.grandScores[oldId];
        }
        if (this.lastWinnerId === oldId) this.lastWinnerId = newId;

        const player = this.players.find(p => p.id === newId);
        if (player) player.isAutoPlay = false;

        if (this.gameState) {
            if (this.gameState.hands[oldId]) {
                this.gameState.hands[newId] = this.gameState.hands[oldId];
                delete this.gameState.hands[oldId];
            }
            if (this.gameState.roundPoints[oldId] !== undefined) {
                this.gameState.roundPoints[newId] = this.gameState.roundPoints[oldId];
                delete this.gameState.roundPoints[oldId];
            }
            if (this.gameState.roundWinnerId === oldId) this.gameState.roundWinnerId = newId;
            
            const rankIdx = this.gameState.finishedRank.indexOf(oldId);
            if (rankIdx !== -1) {
                this.gameState.finishedRank[rankIdx] = newId;
            }
        }
        return true;
    }

    _handContainsCards(hand, cardsToPlay) {
        const tempHand = [...hand];
        for (let c of cardsToPlay) {
            const idx = tempHand.indexOf(c);
            if (idx === -1) return false;
            tempHand.splice(idx, 1);
        }
        return true;
    }

    _removeCardsFromHand(playerId, cards) {
        const newHand = [...this.gameState.hands[playerId]];
        for (let c of cards) {
            const idx = newHand.indexOf(c);
            if (idx !== -1) newHand.splice(idx, 1);
        }
        this.gameState.hands[playerId] = newHand;
    }

    // [æ ¸å¿ƒä¿®æ”¹] ç»“ç®—é€»è¾‘ï¼šå¢åŠ æ’åèµç½š
    _concludeRound() {
        const lastPlayer = this.players.find(p => this.gameState.hands[p.id].length > 0);
        if (lastPlayer) {
            this.gameState.finishedRank.push(lastPlayer.id);
        }
        
        // 1. å¤„ç†æœ€åä¸€è½®çš„æ¡Œé¢åˆ†
        const wId = this.gameState.roundWinnerId;
        if (wId) {
             this.gameState.roundPoints[wId] = (this.gameState.roundPoints[wId] || 0) + this.gameState.pendingTablePoints;
             this.gameState.pendingTablePoints = 0;
        }

        // 2. æ„é€ å®Œæ•´æ’å (å·²è·‘å®Œ + å‰©ä½™ç©å®¶)
        // å®é™…ä¸Šåœ¨ activeCount <= 1 æ—¶ï¼Œå‰©ä¸‹çš„é‚£ä¸ªç©å®¶ä¹Ÿå·²ç»è¢« push åˆ° finishedRank é‡Œäº†(é€šè¿‡ä¸Šé¢çš„ lastPlayer é€»è¾‘)
        // ä½†ä¸ºäº†ä¿é™©ï¼Œæˆ‘ä»¬ç”¨ Set å»é‡ç¡®ä¿å®Œæ•´æ€§
        const fullRankIds = [...this.gameState.finishedRank];
        this.players.forEach(p => {
            if (!fullRankIds.includes(p.id)) fullRankIds.push(p.id);
        });

        const firstWinnerId = fullRankIds[0];
        this.lastWinnerId = firstWinnerId;

        let logLines = [];

        // 3. è§„åˆ™ä¸€ï¼šå‰©ä½™æ‰‹ç‰Œç½šåˆ† (åŸæœ‰é€»è¾‘)
        let totalCardPenalty = 0;
        let cardPenaltyDetail = "";

        this.players.forEach(p => {
            const handPts = CardRules.calculateTotalScore(this.gameState.hands[p.id]);
            if (handPts > 0) {
                totalCardPenalty += handPts;
                cardPenaltyDetail += `${p.name}-${handPts} `;
            }
            // å…ˆç´¯åŠ æ¡Œé¢åˆ†
            this.grandScores[p.id] += (this.gameState.roundPoints[p.id] || 0);
        });

        if (firstWinnerId && totalCardPenalty > 0) {
            this.grandScores[firstWinnerId] += totalCardPenalty;
            logLines.push(`[æ‰‹ç‰Œç½šåˆ†] è¾“å®¶å…±è®¡ ${totalCardPenalty} åˆ†ï¼Œå½’ç¬¬ä¸€å ${this.players.find(p=>p.id===firstWinnerId)?.name}ã€‚`);
        }

        // 4. [æ–°å¢] è§„åˆ™äºŒï¼šæ’åèµç½š (Rank Penalty)
        if (this.config.enableRankPenalty && this.config.rankPenaltyScores && this.config.rankPenaltyScores.length > 0) {
            const penaltyConfig = this.config.rankPenaltyScores;
            const playerCount = fullRankIds.length;
            
            // éå†é…ç½®ï¼š[30, 15] å¯¹åº” (ç¬¬ä¸€vså€’ä¸€), (ç¬¬äºŒvså€’äºŒ)
            penaltyConfig.forEach((score, index) => {
                const winnerIndex = index; // 0, 1
                const loserIndex = playerCount - 1 - index; // N-1, N-2

                // åªæœ‰å½“èµ¢å®¶ç´¢å¼•å°äºè¾“å®¶ç´¢å¼•æ—¶æ‰æ‰§è¡Œ (é¿å…å¥‡æ•°äººæ•°ä¸­é—´æ’è½¦)
                if (winnerIndex < loserIndex) {
                    const winnerId = fullRankIds[winnerIndex];
                    const loserId = fullRankIds[loserIndex];
                    
                    if (winnerId && loserId) {
                        this.grandScores[winnerId] += score;
                        this.grandScores[loserId] -= score;

                        const wName = this.players.find(p=>p.id===winnerId)?.name;
                        const lName = this.players.find(p=>p.id===loserId)?.name;
                        logLines.push(`[æ’åèµç½š] ç¬¬${winnerIndex+1}å ${wName} æ”¶å– å€’æ•°ç¬¬${index+1}å ${lName} ${score} åˆ†ã€‚`);
                    }
                }
            });
        }

        const firstWinnerName = this.players.find(p => p.id === firstWinnerId)?.name || 'æœªçŸ¥';
        const isGrandOver = this.grandScores[firstWinnerId] >= this.config.targetScore;
        const totalPointsEarned = (this.gameState.roundPoints[firstWinnerId] || 0) + totalCardPenalty;

        return {
            roundWinnerName: firstWinnerName,
            pointsEarned: totalPointsEarned, 
            detail: logLines.join('\n') || 'å®Œç¾ç»“æŸï¼Œæ— é¢å¤–ç½šåˆ†', // ç”¨æ¢è¡Œç¬¦è¿æ¥
            grandScores: this.grandScores,
            isGrandOver
        };
    }
    
    getPlayerHand(playerId) {
        if (!this.gameState || !this.gameState.hands) return [];
        return this.gameState.hands[playerId] || [];
    }
}

module.exports = GameManager;

================================================================================
FILE PATH: server\index.js
================================================================================
// ç¨‹åºå…¥å£ï¼Œåªè´Ÿè´£å¯åŠ¨æœåŠ¡å’Œ Socket ç›‘å¬
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const cors = require('cors');
const path = require('path');

// å¼•å…¥æ¨¡å—
const GameManager = require('./game/GameManager');

const app = express();
app.use(cors());

const server = http.createServer(app);
const io = new Server(server, {
    cors: { origin: "*", methods: ["GET", "POST"] }
});

// å†…å­˜æ•°æ®åº“
const rooms = {}; 

/**
 * è¾…åŠ©å‡½æ•°ï¼šå‘æˆ¿é—´å†…æ‰€æœ‰äººå¹¿æ’­æœ€æ–°çŠ¶æ€
 */
function broadcastGameState(io, roomId, room, infoText = null) {
    if (!room.gameManager) return;
    
    // ä» GameManager è·å–çº¯å‡€çš„ UI å±•ç¤ºæ•°æ®
    const publicState = room.gameManager.getPublicState();
    if (!publicState) return;

    if (infoText) publicState.infoText = infoText;

    io.to(roomId).emit('game_state_update', publicState);
}

io.on('connection', (socket) => {
    console.log(`[Connect] ${socket.id}`);
    socket.emit('your_id', socket.id);

    // --- åˆ›å»ºæˆ¿é—´ ---
    socket.on('create_room', ({ roomId, username, config }) => {
        if (rooms[roomId]) return socket.emit('error_msg', 'æˆ¿é—´å·²å­˜åœ¨');
        
        const cleanName = String(username || '').trim();
        if (!cleanName) return socket.emit('error_msg', 'ç”¨æˆ·åä¸èƒ½ä¸ºç©º');

        const roomConfig = { deckCount: 1, maxPlayers: 3, targetScore: 500, ...config };
        
        rooms[roomId] = {
            config: roomConfig,
            players: [],
            gameManager: null,
            destroyTimer: null 
        };
        
        socket.join(roomId);
        rooms[roomId].players.push({ id: socket.id, name: cleanName, isHost: true, online: true });
        
        const initialScores = {};
        rooms[roomId].players.forEach(p => initialScores[p.id] = 0);

        const data = { roomId, config: roomConfig, players: rooms[roomId].players, grandScores: initialScores };
        socket.emit('room_info', data); 
        io.to(roomId).emit('room_info', data);
    });

    // --- åŠ å…¥æˆ¿é—´ ---
    socket.on('join_room', ({ roomId, username }) => {
        const room = rooms[roomId];
        if (!room) return socket.emit('error_msg', 'æˆ¿é—´ä¸å­˜åœ¨');

        const cleanName = String(username || '').trim();
        if (!cleanName) return socket.emit('error_msg', 'ç”¨æˆ·åä¸èƒ½ä¸ºç©º');

        const existingPlayerIndex = room.players.findIndex(p => p.name === cleanName);
        let isReconnect = false;
        let oldSocketId = null;

        if (existingPlayerIndex !== -1) {
            const existingPlayer = room.players[existingPlayerIndex];
            
            if (existingPlayer.online) {
                return socket.emit('error_msg', `åå­— "${cleanName}" å·²è¢«ä½¿ç”¨ä¸”ç©å®¶åœ¨çº¿`);
            }

            isReconnect = true;
            oldSocketId = existingPlayer.id;
            console.log(`[Reconnect] Success! ${cleanName} (${oldSocketId} -> ${socket.id})`);

            existingPlayer.id = socket.id;
            existingPlayer.online = true; 

            if (room.destroyTimer) {
                clearTimeout(room.destroyTimer);
                room.destroyTimer = null;
                console.log(`[Room] Destruction cancelled for ${roomId} (player returned)`);
            }

            if (room.gameManager) {
                room.gameManager.reconnectPlayer(oldSocketId, socket.id);
            }
        } else {
            if (room.players.length >= room.config.maxPlayers) {
                return socket.emit('error_msg', 'æˆ¿é—´å·²æ»¡');
            }
            
            socket.join(roomId);
            if (!room.players.find(u => u.id === socket.id)) {
                room.players.push({ id: socket.id, name: cleanName, isHost: false, online: true });
            }
        }

        socket.join(roomId);
        
        let currentGrandScores = {};
        if (room.gameManager) {
            currentGrandScores = room.gameManager.grandScores;
        } else {
            room.players.forEach(p => currentGrandScores[p.id] = 0);
        }
        
        const data = { roomId, config: room.config, players: room.players, grandScores: currentGrandScores };
        
        socket.emit('room_info', data);

        const isGameRunning = room.gameManager && room.gameManager.gameState;
        if (!isGameRunning) {
            socket.to(roomId).emit('room_info', data);
        }

        if (isGameRunning) {
            if (isReconnect) {
                const hand = room.gameManager.getPlayerHand(socket.id);
                socket.emit('game_started', { 
                    hand: hand, 
                    grandScores: room.gameManager.grandScores 
                });
            }
            broadcastGameState(io, roomId, room);
        }
    });
    
    // æ·»åŠ æœºå™¨äºº
    socket.on('add_bot', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room) return;
        
        if (room.players.length >= room.config.maxPlayers) return socket.emit('error_msg', 'æˆ¿é—´å·²æ»¡');
        
        const botId = `bot_${Date.now()}_${Math.floor(Math.random()*1000)}`;
        const botName = `Robot ${Math.floor(Math.random()*100)}`;
        
        room.players.push({ 
            id: botId, 
            name: botName, 
            isHost: false, 
            online: true,
            isBot: true 
        });
        
        const currentGrandScores = room.gameManager ? room.gameManager.grandScores : {};
        currentGrandScores[botId] = 0;

        const data = { roomId, config: room.config, players: room.players, grandScores: currentGrandScores };
        io.to(roomId).emit('room_info', data);
    });

    // [æ–°å¢] åˆ‡æ¢æ‰˜ç®¡
    socket.on('toggle_auto_play', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room || !room.gameManager) return;

        room.gameManager.toggleAutoPlay(socket.id);
        broadcastGameState(io, roomId, room);
    });

    // --- æ¸¸æˆæµç¨‹ ---
    const handleGameStart = (roomId, isNextRound) => {
        const room = rooms[roomId];
        if (!room) return;

        if (!isNextRound || !room.gameManager) {
            room.gameManager = new GameManager(room.config, room.players, io, roomId);
        }

        const startInfo = room.gameManager.startRound(isNextRound);

        room.players.forEach((p) => {
            if (!p.isBot) { 
                const hand = startInfo.hands[p.id];
                io.to(p.id).emit('game_started', { 
                    hand: hand, 
                    grandScores: room.gameManager.grandScores 
                });
            }
        });

        const startPlayerName = room.players[startInfo.startPlayerIndex].name;
        const msg = isNextRound 
            ? `æ–°ä¸€è½®å¼€å§‹ï¼ç”± ${startPlayerName} å…ˆå‡º` 
            : `æ¸¸æˆå¼€å§‹ï¼ç›®æ ‡ ${room.config.targetScore} åˆ†`;
        
        broadcastGameState(io, roomId, room, msg);
    };

    socket.on('start_game', ({ roomId }) => handleGameStart(roomId, false));
    socket.on('next_round', ({ roomId }) => handleGameStart(roomId, true));

    // --- å‡ºç‰Œ ---
    socket.on('play_cards', ({ roomId, cards }) => {
        const room = rooms[roomId];
        if (!room || !room.gameManager) return;
        
        const result = room.gameManager.playCards(socket.id, cards);

        if (!result.success) {
            return socket.emit('play_error', result.error);
        }

        const currentHand = room.gameManager.gameState.hands[socket.id];
        io.to(socket.id).emit('hand_update', currentHand);

        if (result.isWin) {
            const rInfo = result.roundResult;
            if (rInfo.isGrandOver) {
                io.to(roomId).emit('grand_game_over', { 
                    grandWinner: rInfo.roundWinnerName, 
                    grandScores: rInfo.grandScores 
                });
                room.gameManager = null; 
            } else {
                io.to(roomId).emit('round_over', {
                    roundWinner: rInfo.roundWinnerName,
                    pointsEarned: rInfo.pointsEarned,
                    detail: rInfo.detail,
                    grandScores: rInfo.grandScores
                });
            }
        } else {
            broadcastGameState(io, roomId, room);
        }
    });

    // --- è¿‡ç‰Œ ---
    socket.on('pass_turn', ({ roomId }) => {
        const room = rooms[roomId];
        if (!room || !room.gameManager) return;

        const result = room.gameManager.passTurn(socket.id);
        
        if (!result.success) return socket.emit('play_error', result.error);

        broadcastGameState(io, roomId, room, "PASS");
    });

    // --- æ–­å¼€è¿æ¥ ---
    socket.on('disconnect', () => {
        Object.keys(rooms).forEach(rId => {
            const r = rooms[rId];
            
            const idx = r.players.findIndex(p => p.id === socket.id);
            if (idx === -1) return; 

            const player = r.players[idx];
            const isGameRunning = r.gameManager && r.gameManager.gameState;

            if (!isGameRunning) {
                r.players.splice(idx, 1);
                console.log(`[Disconnect] Lobby user ${player.name} removed from ${rId}`);
                
                if (r.players.length === 0) {
                    if (r.destroyTimer) clearTimeout(r.destroyTimer);
                    delete rooms[rId];
                    console.log(`[Room] Room ${rId} deleted (empty lobby).`);
                } else {
                    io.to(rId).emit('room_info', { 
                        roomId: rId, 
                        config: r.config, 
                        players: r.players, 
                        grandScores: r.gameManager ? r.gameManager.grandScores : {} 
                    });
                }
            } else {
                player.online = false;
                console.log(`[Disconnect] Game user ${player.name} (${socket.id}) dropped.`);

                const allHumansOffline = r.players.filter(p => !p.isBot).every(p => !p.online);
                
                if (allHumansOffline) {
                    console.log(`[Room] Room ${rId} is empty. Scheduling destruction in 60s...`);
                    
                    if (r.destroyTimer) clearTimeout(r.destroyTimer);
                    
                    r.destroyTimer = setTimeout(() => {
                        if (rooms[rId] && rooms[rId].players.filter(p => !p.isBot).every(p => !p.online)) {
                            delete rooms[rId];
                            console.log(`[Room] Room ${rId} destroyed due to inactivity (game running).`);
                        }
                    }, 60000); 
                }
            }
        });
    });
});



// è¿™ä¸€æ®µçš„æ„æ€æ˜¯ï¼šå¦‚æœæ˜¯åœ¨çº¿ä¸Šç¯å¢ƒï¼Œå°±æŠŠ React æ‰“åŒ…å¥½çš„æ–‡ä»¶(build)å‘ç»™æµè§ˆå™¨
if (process.env.NODE_ENV === 'production') {
    // 1. æŒ‡å®šé™æ€æ–‡ä»¶ç›®å½•
    const buildPath = path.join(__dirname, '../client/dist');
    app.use(express.static(buildPath));
    // 2. ä»»ä½•å…¶ä»–è¯·æ±‚ï¼Œéƒ½è¿”å› index.html
    app.get(/(.*)/, (req, res) => {
        res.sendFile(path.join(__dirname, '../client/dist', 'index.html'));
    });
}

// å¯åŠ¨æœåŠ¡å™¨
const PORT = process.env.PORT || 3001;
server.listen(PORT, () => {
    console.log(`>>> Server Running on port ${PORT}`);
});





================================================================================
FILE PATH: server\package.json
================================================================================
{
  "name": "server",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^5.2.1",
    "nodemon": "^3.1.11",
    "socket.io": "^4.8.1"
  }
}


================================================================================
FILE PATH: server\utils\socketAuth.js
================================================================================
// (å¯é€‰) èº«ä»½éªŒè¯å·¥å…·
